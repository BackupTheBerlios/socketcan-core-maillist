<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH net-next-2.6 v2 1/2] can: add driver for Softing card
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2011-January/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20net-next-2.6%20v2%201/2%5D%20can%3A%20add%20driver%20for%20Softing%20card&In-Reply-To=%3C4D24DB2C.9040104%40grandegger.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005287.html">
   <LINK REL="Next"  HREF="005305.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH net-next-2.6 v2 1/2] can: add driver for Softing card</H1>
    <B>Wolfgang Grandegger</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20net-next-2.6%20v2%201/2%5D%20can%3A%20add%20driver%20for%20Softing%20card&In-Reply-To=%3C4D24DB2C.9040104%40grandegger.com%3E"
       TITLE="[PATCH net-next-2.6 v2 1/2] can: add driver for Softing card">wg at grandegger.com
       </A><BR>
    <I>Wed Jan  5 21:57:16 CET 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="005287.html">[PATCH net-next-2.6 v2 1/2] can: add driver for Softing card
</A></li>
        <LI>Next message: <A HREF="005305.html">[PATCH net-next-2.6 v2 1/2] can: add driver for Softing card
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5294">[ date ]</a>
              <a href="thread.html#5294">[ thread ]</a>
              <a href="subject.html#5294">[ subject ]</a>
              <a href="author.html#5294">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Kurt,

here comes my review... First some general remarks. As Mark already
pointed out, there are still some coding style issues:

- Please use the following style for multi line comments:

  /*
   * Comment
   */

- Please separate the function header from the body by one empty line.

- Please avoid alignment of expressions and structure members.

- Please use a consistent style for function declaration and
  continuation lines.

More comments inline...

On 12/23/2010 10:43 On 01/04/2011 04:07 PM, Kurt Van Dijck wrote:
&gt;<i> This patch adds a driver for the platform:softing device.
</I>&gt;<i> This will create (up to) 2 CAN network devices from 1
</I>&gt;<i> platform:softing device
</I>&gt;<i> 
</I>&gt;<i> Signed-off-by: Kurt Van Dijck &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kurt.van.dijck at eia.be</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> ---
</I>&gt;<i>  drivers/net/can/Kconfig                    |    2 +
</I>&gt;<i>  drivers/net/can/Makefile                   |    1 +
</I>&gt;<i>  drivers/net/can/softing/Kconfig            |   16 +
</I>&gt;<i>  drivers/net/can/softing/Makefile           |    5 +
</I>&gt;<i>  drivers/net/can/softing/softing.h          |  193 ++++++
</I>&gt;<i>  drivers/net/can/softing/softing_fw.c       |  648 ++++++++++++++++++++
</I>&gt;<i>  drivers/net/can/softing/softing_main.c     |  903 ++++++++++++++++++++++++++++
</I>&gt;<i>  drivers/net/can/softing/softing_platform.h |   38 ++
</I>&gt;<i>  8 files changed, 1806 insertions(+), 0 deletions(-)
</I>&gt;<i> 
</I>&gt;<i> diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
</I>&gt;<i> index d5a9db6..986195e 100644
</I>&gt;<i> --- a/drivers/net/can/Kconfig
</I>&gt;<i> +++ b/drivers/net/can/Kconfig
</I>&gt;<i> @@ -117,6 +117,8 @@ source &quot;drivers/net/can/sja1000/Kconfig&quot;
</I>&gt;<i>  
</I>&gt;<i>  source &quot;drivers/net/can/usb/Kconfig&quot;
</I>&gt;<i>  
</I>&gt;<i> +source &quot;drivers/net/can/softing/Kconfig&quot;
</I>&gt;<i> +
</I>&gt;<i>  config CAN_DEBUG_DEVICES
</I>&gt;<i>  	bool &quot;CAN devices debugging messages&quot;
</I>&gt;<i>  	depends on CAN
</I>&gt;<i> diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
</I>&gt;<i> index 07ca159..53c82a7 100644
</I>&gt;<i> --- a/drivers/net/can/Makefile
</I>&gt;<i> +++ b/drivers/net/can/Makefile
</I>&gt;<i> @@ -9,6 +9,7 @@ obj-$(CONFIG_CAN_DEV)		+= can-dev.o
</I>&gt;<i>  can-dev-y			:= dev.o
</I>&gt;<i>  
</I>&gt;<i>  obj-y				+= usb/
</I>&gt;<i> +obj-y				+= softing/
</I>
Please use &quot;obj-$(CONFIG_CAN_SOFTING)&quot; here.

&gt;<i>  obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
</I>&gt;<i>  obj-$(CONFIG_CAN_MSCAN)		+= mscan/
</I>&gt;<i> diff --git a/drivers/net/can/softing/Kconfig b/drivers/net/can/softing/Kconfig
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..072f337
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/softing/Kconfig
</I>&gt;<i> @@ -0,0 +1,16 @@
</I>&gt;<i> +config CAN_SOFTING
</I>&gt;<i> +	tristate &quot;Softing Gmbh CAN generic support&quot;
</I>&gt;<i> +	depends on CAN_DEV
</I>&gt;<i> +	---help---
</I>&gt;<i> +	  Support for CAN cards from Softing Gmbh &amp; some cards
</I>&gt;<i> +	  from Vector Gmbh.
</I>&gt;<i> +	  Softing Gmbh CAN cards come with 1 or 2 physical busses.
</I>&gt;<i> +	  Those cards typically use Dual Port RAM to communicate
</I>&gt;<i> +	  with the host CPU. The interface is then identical for PCI
</I>&gt;<i> +	  and PCMCIA cards. This driver operates on a platform device,
</I>&gt;<i> +	  which has been created by softing_cs or softing_pci driver.
</I>&gt;<i> +	  Warning:
</I>&gt;<i> +	  The API of the card does not allow fine control per bus, but
</I>&gt;<i> +	  controls the 2 busses on the card together.
</I>&gt;<i> +	  As such, some actions (start/stop/busoff recovery) on 1 bus
</I>&gt;<i> +	  must bring down the other bus too temporarily.
</I>&gt;<i> diff --git a/drivers/net/can/softing/Makefile b/drivers/net/can/softing/Makefile
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..7878b7b
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/softing/Makefile
</I>&gt;<i> @@ -0,0 +1,5 @@
</I>&gt;<i> +
</I>&gt;<i> +softing-y := softing_main.o softing_fw.o
</I>&gt;<i> +obj-$(CONFIG_CAN_SOFTING)        += softing.o
</I>&gt;<i> +
</I>&gt;<i> +ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
</I>&gt;<i> diff --git a/drivers/net/can/softing/softing.h b/drivers/net/can/softing/softing.h
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..72d3adb
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/softing/softing.h
</I>&gt;<i> @@ -0,0 +1,193 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * softing common interfaces
</I>&gt;<i> + *
</I>&gt;<i> + * by Kurt Van Dijck, 06-2008
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/atomic.h&gt;
</I>&gt;<i> +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> +#include &lt;linux/ktime.h&gt;
</I>&gt;<i> +#include &lt;linux/mutex.h&gt;
</I>&gt;<i> +#include &lt;linux/spinlock.h&gt;
</I>&gt;<i> +#include &lt;linux/can.h&gt;
</I>&gt;<i> +#include &lt;linux/can/dev.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#include &quot;softing_platform.h&quot;
</I>&gt;<i> +
</I>&gt;<i> +#ifndef CAN_CTRLMODE_BERR_REPORTING
</I>&gt;<i> +#define CAN_CTRLMODE_BERR_REPORTING 0
</I>&gt;<i> +#endif
</I>
Hm, do you really need that definition?

&gt;<i> +struct softing;
</I>&gt;<i> +
</I>&gt;<i> +struct softing_priv {
</I>&gt;<i> +	struct can_priv can;	/* must be the first member! */
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	struct softing *card;
</I>&gt;<i> +	struct {
</I>&gt;<i> +		int pending;
</I>&gt;<i> +		/* variables wich hold the circular buffer */
</I>&gt;<i> +		int echo_put;
</I>&gt;<i> +		int echo_get;
</I>&gt;<i> +	} tx;
</I>&gt;<i> +	struct can_bittiming_const btr_const;
</I>&gt;<i> +	int index;
</I>&gt;<i> +	u8 output;
</I>&gt;<i> +	u16 chip;
</I>&gt;<i> +};
</I>&gt;<i> +#define netdev2softing(netdev)	((struct softing_priv *)netdev_priv(netdev))
</I>&gt;<i> +
</I>&gt;<i> +struct softing {
</I>&gt;<i> +	const struct softing_platform_data *pdat;
</I>&gt;<i> +	struct platform_device *pdev;
</I>&gt;<i> +	struct net_device *net[2];
</I>&gt;<i> +	spinlock_t spin; /* protect this structure &amp; DPRAM access */
</I>&gt;<i> +	ktime_t ts_ref;
</I>&gt;<i> +	ktime_t ts_overflow; /* timestamp overflow value, in ktime */
</I>&gt;<i> +
</I>&gt;<i> +	struct {
</I>&gt;<i> +		/* indication of firmware status */
</I>&gt;<i> +		int up;
</I>&gt;<i> +		/* protection of the 'up' variable */
</I>&gt;<i> +		struct mutex lock;
</I>&gt;<i> +	} fw;
</I>&gt;<i> +	struct {
</I>&gt;<i> +		int nr;
</I>&gt;<i> +		int requested;
</I>&gt;<i> +		int svc_count;
</I>&gt;<i> +		unsigned int dpram_position;
</I>&gt;<i> +	} irq;
</I>&gt;<i> +	struct {
</I>&gt;<i> +		int pending;
</I>&gt;<i> +		int last_bus;
</I>&gt;<i> +		/*
</I>&gt;<i> +		 * keep the bus that last tx'd a message,
</I>&gt;<i> +		 * in order to let every netdev queue resume
</I>&gt;<i> +		 */
</I>&gt;<i> +	} tx;
</I>&gt;<i> +	__iomem uint8_t *dpram;
</I>&gt;<i> +	unsigned long dpram_phys;
</I>&gt;<i> +	unsigned long dpram_size;
</I>&gt;<i> +	struct {
</I>&gt;<i> +		u32  serial, fw, hw, lic;
</I>&gt;<i> +		u16  chip[2];
</I>&gt;<i> +		u32  freq;
</I>&gt;<i> +	} id;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +extern int softing_default_output(struct net_device *netdev);
</I>&gt;<i> +
</I>&gt;<i> +extern ktime_t softing_raw2ktime(struct softing *card, u32 raw);
</I>&gt;<i> +
</I>&gt;<i> +extern int softing_fct_cmd(struct softing *card, int16_t cmd, uint16_t vector,
</I>&gt;<i> +		const char *msg);
</I>&gt;<i> +
</I>&gt;<i> +extern int softing_bootloader_command(struct softing *card, int16_t cmd,
</I>&gt;<i> +		const char *msg);
</I>&gt;<i> +
</I>&gt;<i> +/* Load firmware after reset */
</I>&gt;<i> +extern int softing_load_fw(const char *file, struct softing *card,
</I>&gt;<i> +			__iomem uint8_t *virt, unsigned int size, int offset);
</I>&gt;<i> +
</I>&gt;<i> +/* Load final application firmware after bootloader */
</I>&gt;<i> +extern int softing_load_app_fw(const char *file, struct softing *card);
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * enable or disable irq
</I>&gt;<i> + * only called with fw.lock locked
</I>&gt;<i> + */
</I>&gt;<i> +extern int softing_enable_irq(struct softing *card, int enable);
</I>&gt;<i> +
</I>&gt;<i> +/* start/stop 1 bus on card */
</I>&gt;<i> +extern int softing_startstop(struct net_device *netdev, int up);
</I>&gt;<i> +
</I>&gt;<i> +/* netif_rx() */
</I>&gt;<i> +extern int softing_netdev_rx(struct net_device *netdev,
</I>&gt;<i> +		const struct can_frame *msg, ktime_t ktime);
</I>&gt;<i> +
</I>&gt;<i> +/* SOFTING DPRAM mappings */
</I>&gt;<i> +#define DPRAM_RX		0x0000
</I>&gt;<i> +	#define DPRAM_RX_SIZE	32
</I>&gt;<i> +	#define DPRAM_RX_CNT	16
</I>&gt;<i> +#define DPRAM_RX_RD		0x0201	/* uint8_t */
</I>&gt;<i> +#define DPRAM_RX_WR		0x0205	/* uint8_t */
</I>&gt;<i> +#define DPRAM_RX_LOST		0x0207	/* uint8_t */
</I>&gt;<i> +
</I>&gt;<i> +#define DPRAM_FCT_PARAM		0x0300	/* int16_t [20] */
</I>&gt;<i> +#define DPRAM_FCT_RESULT	0x0328	/* int16_t */
</I>&gt;<i> +#define DPRAM_FCT_HOST		0x032b	/* uint16_t */
</I>&gt;<i> +
</I>&gt;<i> +#define DPRAM_INFO_BUSSTATE	0x0331	/* uint16_t */
</I>&gt;<i> +#define DPRAM_INFO_BUSSTATE2	0x0335	/* uint16_t */
</I>&gt;<i> +#define DPRAM_INFO_ERRSTATE	0x0339	/* uint16_t */
</I>&gt;<i> +#define DPRAM_INFO_ERRSTATE2	0x033d	/* uint16_t */
</I>&gt;<i> +#define DPRAM_RESET		0x0341	/* uint16_t */
</I>&gt;<i> +#define DPRAM_CLR_RECV_FIFO	0x0345	/* uint16_t */
</I>&gt;<i> +#define DPRAM_RESET_TIME	0x034d	/* uint16_t */
</I>&gt;<i> +#define DPRAM_TIME		0x0350	/* uint64_t */
</I>&gt;<i> +#define DPRAM_WR_START		0x0358	/* uint8_t */
</I>&gt;<i> +#define DPRAM_WR_END		0x0359	/* uint8_t */
</I>&gt;<i> +#define DPRAM_RESET_RX_FIFO	0x0361	/* uint16_t */
</I>&gt;<i> +#define DPRAM_RESET_TX_FIFO	0x0364	/* uint8_t */
</I>&gt;<i> +#define DPRAM_READ_FIFO_LEVEL	0x0365	/* uint8_t */
</I>&gt;<i> +#define DPRAM_RX_FIFO_LEVEL	0x0366	/* uint16_t */
</I>&gt;<i> +#define DPRAM_TX_FIFO_LEVEL	0x0366	/* uint16_t */
</I>&gt;<i> +
</I>&gt;<i> +#define DPRAM_TX		0x0400	/* uint16_t */
</I>&gt;<i> +	#define DPRAM_TX_SIZE	16
</I>&gt;<i> +	#define DPRAM_TX_CNT	32
</I>&gt;<i> +#define DPRAM_TX_RD		0x0601	/* uint8_t */
</I>&gt;<i> +#define DPRAM_TX_WR		0x0605	/* uint8_t */
</I>&gt;<i> +
</I>&gt;<i> +#define DPRAM_COMMAND		0x07e0	/* uint16_t */
</I>&gt;<i> +#define DPRAM_RECEIPT		0x07f0	/* uint16_t */
</I>&gt;<i> +#define DPRAM_IRQ_TOHOST	0x07fe	/* uint8_t */
</I>&gt;<i> +#define DPRAM_IRQ_TOCARD	0x07ff	/* uint8_t */
</I>&gt;<i> +
</I>&gt;<i> +#define DPRAM_V2_RESET		0x0e00	/* uint8_t */
</I>&gt;<i> +#define DPRAM_V2_IRQ_TOHOST	0x0e02	/* uint8_t */
</I>&gt;<i> +
</I>&gt;<i> +#define TXMAX	(DPRAM_TX_CNT - 1)
</I>&gt;<i> +
</I>&gt;<i> +/* DPRAM return codes */
</I>&gt;<i> +#define RES_NONE	0
</I>&gt;<i> +#define RES_OK		1
</I>&gt;<i> +#define RES_NOK		2
</I>&gt;<i> +#define RES_UNKNOWN	3
</I>&gt;<i> +/* DPRAM flags */
</I>&gt;<i> +#define CMD_TX		0x01
</I>&gt;<i> +#define CMD_ACK		0x02
</I>&gt;<i> +#define CMD_XTD		0x04
</I>&gt;<i> +#define CMD_RTR		0x08
</I>&gt;<i> +#define CMD_ERR		0x10
</I>&gt;<i> +#define CMD_BUS2	0x80
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * some inline DPRAM acces function
</I>&gt;<i> + * to prevent extra dependency between softing &amp; softingcs
</I>&gt;<i> + */
</I>&gt;<i> +/* reset DPRAM */
</I>&gt;<i> +static inline void softing_set_reset_dpram(struct softing *card)
</I>&gt;<i> +{
</I>&gt;<i> +	if (card-&gt;pdat-&gt;generation &gt;= 2) {
</I>&gt;<i> +		uint8_t tmp;
</I>&gt;<i> +		spin_lock_bh(&amp;card-&gt;spin);
</I>&gt;<i> +		tmp = ioread8(&amp;card-&gt;dpram[DPRAM_V2_RESET]);
</I>&gt;<i> +		tmp &amp;= ~1;
</I>&gt;<i> +		iowrite8(tmp, &amp;card-&gt;dpram[DPRAM_V2_RESET]);
</I>&gt;<i> +		spin_unlock_bh(&amp;card-&gt;spin);
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline void softing_clr_reset_dpram(struct softing *card)
</I>&gt;<i> +{
</I>&gt;<i> +	if (card-&gt;pdat-&gt;generation &gt;= 2) {
</I>&gt;<i> +		uint8_t tmp;
</I>
Empty line please.

&gt;<i> +		spin_lock_bh(&amp;card-&gt;spin);
</I>&gt;<i> +		tmp = ioread8(&amp;card-&gt;dpram[DPRAM_V2_RESET]);
</I>&gt;<i> +		tmp |= 1;
</I>
Could be done in one line or even without tmp.

&gt;<i> +		iowrite8(tmp, &amp;card-&gt;dpram[DPRAM_V2_RESET]);
</I>&gt;<i> +		spin_unlock_bh(&amp;card-&gt;spin);
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> diff --git a/drivers/net/can/softing/softing_fw.c b/drivers/net/can/softing/softing_fw.c
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..03ed853
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/softing/softing_fw.c
</I>&gt;<i> @@ -0,0 +1,648 @@
</I>&gt;<i> +/*
</I>&gt;<i> +* drivers/net/can/softing/softing_fw.c
</I>&gt;<i> +*
</I>&gt;<i> +* Copyright (C) 2008-2010
</I>&gt;<i> +*
</I>&gt;<i> +* - Kurt Van Dijck, EIA Electronics
</I>&gt;<i> +*
</I>&gt;<i> +* This program is free software; you can redistribute it and/or modify
</I>&gt;<i> +* it under the terms of the version 2 of the GNU General Public License
</I>&gt;<i> +* as published by the Free Software Foundation
</I>&gt;<i> +*
</I>&gt;<i> +* This program is distributed in the hope that it will be useful,
</I>&gt;<i> +* but WITHOUT ANY WARRANTY; without even the implied warranty of
</I>&gt;<i> +* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
</I>&gt;<i> +* GNU General Public License for more details.
</I>&gt;<i> +*
</I>&gt;<i> +* You should have received a copy of the GNU General Public License
</I>&gt;<i> +* along with this program; if not, write to the Free Software
</I>&gt;<i> +* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
</I>&gt;<i> +*/
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/firmware.h&gt;
</I>&gt;<i> +#include &lt;linux/sched.h&gt;
</I>&gt;<i> +#include &lt;asm/div64.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#include &quot;softing.h&quot;
</I>&gt;<i> +
</I>&gt;<i> +int softing_fct_cmd(struct softing *card, int16_t cmd, uint16_t vector,
</I>&gt;<i> +		const char *msg)
</I>&gt;<i> +{
</I>&gt;<i> +	int ret;
</I>&gt;<i> +	unsigned long stamp;
</I>&gt;<i> +
</I>&gt;<i> +	if (vector == RES_OK)
</I>&gt;<i> +		vector = RES_NONE;
</I>&gt;<i> +	iowrite16(cmd, &amp;card-&gt;dpram[DPRAM_FCT_PARAM]);
</I>&gt;<i> +	iowrite8(vector &gt;&gt; 8, &amp;card-&gt;dpram[DPRAM_FCT_HOST + 1]);
</I>&gt;<i> +	iowrite8(vector, &amp;card-&gt;dpram[DPRAM_FCT_HOST]);
</I>&gt;<i> +
</I>&gt;<i> +	/* be sure to flush this to the card */
</I>&gt;<i> +	wmb();
</I>&gt;<i> +	stamp = jiffies + 1 * HZ;
</I>&gt;<i> +	/* wait for card */
</I>&gt;<i> +	do {
</I>&gt;<i> +		/* DPRAM_FCT_HOST is _not_ aligned */
</I>&gt;<i> +		ret = ioread8(&amp;card-&gt;dpram[DPRAM_FCT_HOST]) +
</I>&gt;<i> +			(ioread8(&amp;card-&gt;dpram[DPRAM_FCT_HOST + 1]) &lt;&lt; 8);
</I>&gt;<i> +		/* don't have any cached variables */
</I>&gt;<i> +		rmb();
</I>&gt;<i> +		if (ret == RES_OK) {
</I>&gt;<i> +			/* don't read return-value now */
</I>&gt;<i> +			ret = ioread16(&amp;card-&gt;dpram[DPRAM_FCT_RESULT]);
</I>&gt;<i> +			if (ret)
</I>&gt;<i> +				dev_alert(&amp;card-&gt;pdev-&gt;dev,
</I>&gt;<i> +					&quot;%s returned %u\n&quot;, msg, ret);
</I>&gt;<i> +			return 0;
</I>
Why do you not return an error here?

&gt;<i> +		}
</I>&gt;<i> +		if (time_after(jiffies, stamp))
</I>&gt;<i> +			break;
</I>&gt;<i> +		/* process context =&gt; relax */
</I>&gt;<i> +		usleep_range(500, 10000);
</I>&gt;<i> +	} while (!signal_pending(current));
</I>&gt;<i> +
</I>&gt;<i> +	if (ret == RES_NONE) {
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev,
</I>&gt;<i> +			&quot;%s, no response from card on %u/0x%02x\n&quot;,
</I>&gt;<i> +			msg, cmd, vector);
</I>&gt;<i> +		return 1;
</I>&gt;<i> +	} else {
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev,
</I>&gt;<i> +			&quot;%s, bad response from card on %u/0x%02x, 0x%04x\n&quot;,
</I>&gt;<i> +			msg, cmd, vector, ret);
</I>&gt;<i> +		/* make sure to return something not 0 */
</I>&gt;<i> +		return ret ?: 1;
</I>
What does it return if ret &gt; 0?

&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +int softing_bootloader_command(struct softing *card, int16_t cmd,
</I>&gt;<i> +		const char *msg)
</I>&gt;<i> +{
</I>&gt;<i> +	int ret;
</I>&gt;<i> +	unsigned long stamp;
</I>
Empty line please.

&gt;<i> +	iowrite16(RES_NONE, &amp;card-&gt;dpram[DPRAM_RECEIPT]);
</I>&gt;<i> +	iowrite16(cmd, &amp;card-&gt;dpram[DPRAM_COMMAND]);
</I>&gt;<i> +	/* be sure to flush this to the card */
</I>&gt;<i> +	wmb();
</I>&gt;<i> +	stamp = jiffies + 3 * HZ;
</I>&gt;<i> +	/* wait for card */
</I>&gt;<i> +	do {
</I>&gt;<i> +		ret = ioread16(&amp;card-&gt;dpram[DPRAM_RECEIPT]);
</I>&gt;<i> +		/* don't have any cached variables */
</I>&gt;<i> +		rmb();
</I>&gt;<i> +		if (ret == RES_OK)
</I>&gt;<i> +			return 0;
</I>&gt;<i> +		if (time_after(jiffies, stamp))
</I>&gt;<i> +			break;
</I>&gt;<i> +		/* process context =&gt; relax */
</I>&gt;<i> +		usleep_range(500, 10000);
</I>&gt;<i> +	} while (!signal_pending(current));
</I>&gt;<i> +
</I>&gt;<i> +	switch (ret) {
</I>&gt;<i> +	case RES_NONE:
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;%s: no response from card\n&quot;, msg);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case RES_NOK:
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;%s: response from card nok\n&quot;,
</I>&gt;<i> +				msg);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case RES_UNKNOWN:
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;%s: command 0x%04x unknown\n&quot;,
</I>&gt;<i> +			msg, cmd);
</I>&gt;<i> +		break;
</I>&gt;<i> +	default:
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;%s: bad response from card: %i\n&quot;,
</I>&gt;<i> +			msg, ret);
</I>&gt;<i> +		break;
</I>&gt;<i> +	}
</I>&gt;<i> +	return ret ?: 1;
</I>
Ditto.

&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int fw_parse(const uint8_t **pmem, uint16_t *ptype, uint32_t *paddr,
</I>&gt;<i> +		uint16_t *plen, const uint8_t **pdat)
</I>&gt;<i> +{
</I>&gt;<i> +	uint16_t checksum[2];
</I>&gt;<i> +	const uint8_t *mem;
</I>&gt;<i> +	const uint8_t *end;
</I>&gt;<i> +
</I>&gt;<i> +	mem = *pmem;
</I>&gt;<i> +	*ptype = le16_to_cpup((void *)&amp;mem[0]);
</I>&gt;<i> +	*paddr = le32_to_cpup((void *)&amp;mem[2]);
</I>&gt;<i> +	*plen = le16_to_cpup((void *)&amp;mem[6]);
</I>&gt;<i> +	*pdat = &amp;mem[8];
</I>
You often handle arrays of specific data. Couldn't those be described
better by structs also avoiding ugly casts??

&gt;<i> +	/* verify checksum */
</I>&gt;<i> +	end = &amp;mem[8 + *plen];
</I>&gt;<i> +	checksum[0] = le16_to_cpup((void *)end);
</I>&gt;<i> +	for (checksum[1] = 0; mem &lt; end; ++mem)
</I>&gt;<i> +		checksum[1] += *mem;
</I>&gt;<i> +	if (checksum[0] != checksum[1])
</I>&gt;<i> +		return -EINVAL;
</I>&gt;<i> +	/* increment */
</I>&gt;<i> +	*pmem += 10 + *plen;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +int softing_load_fw(const char *file, struct softing *card,
</I>&gt;<i> +			__iomem uint8_t *dpram, unsigned int size, int offset)
</I>&gt;<i> +{
</I>&gt;<i> +	const struct firmware *fw;
</I>&gt;<i> +	int ret, ok = 0;
</I>&gt;<i> +	const uint8_t *mem, *end, *dat;
</I>&gt;<i> +	uint16_t type, len;
</I>&gt;<i> +	uint32_t addr;
</I>&gt;<i> +	uint8_t buf[1024];
</I>
Please avoid allocating large arrays on the stack.

&gt;<i> +
</I>&gt;<i> +	ret = request_firmware(&amp;fw, file, &amp;card-&gt;pdev-&gt;dev);
</I>&gt;<i> +	if (ret) {
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;request_firmware(%s) got %i\n&quot;,
</I>&gt;<i> +			file, ret);
</I>&gt;<i> +		return ret;
</I>&gt;<i> +	}
</I>&gt;<i> +	dev_dbg(&amp;card-&gt;pdev-&gt;dev, &quot;%s, firmware(%s) got %u bytes&quot;
</I>&gt;<i> +		&quot;, offset %c0x%04x\n&quot;,
</I>&gt;<i> +		card-&gt;pdat-&gt;name, file, (unsigned int)fw-&gt;size,
</I>&gt;<i> +		(offset &gt;= 0) ? '+' : '-', (unsigned int)abs(offset));
</I>&gt;<i> +	/* parse the firmware */
</I>&gt;<i> +	mem = fw-&gt;data;
</I>&gt;<i> +	end = &amp;mem[fw-&gt;size];
</I>&gt;<i> +	/* look for header record */
</I>&gt;<i> +	ret = fw_parse(&amp;mem, &amp;type, &amp;addr, &amp;len, &amp;dat);
</I>&gt;<i> +	if (ret &lt; 0)
</I>&gt;<i> +		goto fw_end;
</I>&gt;<i> +	if (type != 0xffff) {
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;firware starts with type 0x%04x\n&quot;,
</I>&gt;<i> +			type);
</I>&gt;<i> +		goto fw_end;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (strncmp(&quot;Structured Binary Format, Softing GmbH&quot; , dat, len)) {
</I>&gt;<i> +		dev_info(&amp;card-&gt;pdev-&gt;dev, &quot;firware string '%.*s'\n&quot;, len, dat);
</I>&gt;<i> +		goto fw_end;
</I>&gt;<i> +	}
</I>&gt;<i> +	ok |= 1;
</I>&gt;<i> +	/* ok, we had a header */
</I>&gt;<i> +	while (mem &lt; end) {
</I>&gt;<i> +		ret = fw_parse(&amp;mem, &amp;type, &amp;addr, &amp;len, &amp;dat);
</I>&gt;<i> +		if (ret)
</I>&gt;<i> +			break;
</I>&gt;<i> +		if (type == 3) {
</I>&gt;<i> +			/* start address */
</I>&gt;<i> +			ok |= 2;
</I>&gt;<i> +			continue;
</I>&gt;<i> +		} else if (type == 1) {
</I>&gt;<i> +			/* eof */
</I>&gt;<i> +			ok |= 4;
</I>&gt;<i> +			goto fw_end;
</I>&gt;<i> +		} else if (type != 0) {
</I>&gt;<i> +			dev_alert(&amp;card-&gt;pdev-&gt;dev,
</I>&gt;<i> +					&quot;unknown record type 0x%04x\n&quot;, type);
</I>&gt;<i> +			break;
</I>&gt;<i> +		}
</I>
You still use a lot of magic constants. Giving them a name would make
the code more readable.

&gt;<i> +		if ((addr + len + offset) &gt; size) {
</I>&gt;<i> +			dev_alert(&amp;card-&gt;pdev-&gt;dev,
</I>&gt;<i> +				&quot;firmware out of range (0x%08x / 0x%08x)\n&quot;,
</I>&gt;<i> +				(addr + len + offset), size);
</I>&gt;<i> +			goto fw_end;
</I>&gt;<i> +		}
</I>&gt;<i> +		memcpy_toio(&amp;dpram[addr + offset], dat, len);
</I>&gt;<i> +		/* be sure to flush caches from IO space */
</I>&gt;<i> +		mb();
</I>&gt;<i> +		if (len &gt; sizeof(buf)) {
</I>&gt;<i> +			dev_info(&amp;card-&gt;pdev-&gt;dev,
</I>&gt;<i> +				&quot;record too big for verify (%u)\n&quot;, len);
</I>&gt;<i> +			continue;
</I>&gt;<i> +		}
</I>&gt;<i> +		/* verify record data */
</I>&gt;<i> +		memcpy_fromio(buf, &amp;dpram[addr + offset], len);
</I>&gt;<i> +		if (!memcmp(buf, dat, len))
</I>&gt;<i> +			/* is ok */
</I>&gt;<i> +			continue;
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;0x%08x:0x%03x at 0x%u failed\n&quot;,
</I>&gt;<i> +				addr, len, addr + offset);
</I>&gt;<i> +		goto fw_end;
</I>&gt;<i> +	}
</I>&gt;<i> +fw_end:
</I>&gt;<i> +	release_firmware(fw);
</I>&gt;<i> +	if (0x5 == (ok &amp; 0x5))
</I>&gt;<i> +		/* got eof &amp; start */
</I>&gt;<i> +		return 0;
</I>
Ditto.

&gt;<i> +	dev_info(&amp;card-&gt;pdev-&gt;dev, &quot;firmware %s failed\n&quot;, file);
</I>&gt;<i> +	return ret ?: -EINVAL;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +int softing_load_app_fw(const char *file, struct softing *card)
</I>&gt;<i> +{
</I>&gt;<i> +	const struct firmware *fw;
</I>&gt;<i> +	const uint8_t *mem, *end, *dat;
</I>&gt;<i> +	int ret, ok = 0, j;
</I>&gt;<i> +	uint16_t type, len;
</I>&gt;<i> +	uint32_t addr, start_addr = 0;
</I>&gt;<i> +	unsigned int sum, rx_sum;
</I>&gt;<i> +
</I>&gt;<i> +	ret = request_firmware(&amp;fw, file, &amp;card-&gt;pdev-&gt;dev);
</I>&gt;<i> +	if (ret) {
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;request_firmware(%s) got %i\n&quot;,
</I>&gt;<i> +			file, ret);
</I>&gt;<i> +		return ret;
</I>&gt;<i> +	}
</I>&gt;<i> +	dev_dbg(&amp;card-&gt;pdev-&gt;dev, &quot;firmware(%s) got %lu bytes\n&quot;,
</I>&gt;<i> +		file, (unsigned long)fw-&gt;size);
</I>&gt;<i> +	/* parse the firmware */
</I>&gt;<i> +	mem = fw-&gt;data;
</I>&gt;<i> +	end = &amp;mem[fw-&gt;size];
</I>&gt;<i> +	/* look for header record */
</I>&gt;<i> +	ret = fw_parse(&amp;mem, &amp;type, &amp;addr, &amp;len, &amp;dat);
</I>&gt;<i> +	if (ret)
</I>&gt;<i> +		goto fw_end;
</I>&gt;<i> +	if (type != 0xffff) {
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;firware starts with type 0x%04x\n&quot;,
</I>
Typo?

&gt;<i> +			type);
</I>&gt;<i> +		goto fw_end;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (strncmp(&quot;Structured Binary Format, Softing GmbH&quot;, dat, len)) {
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;firware string '%.*s' fault\n&quot;,
</I>&gt;<i> +				len, dat);
</I>&gt;<i> +		goto fw_end;
</I>&gt;<i> +	}
</I>&gt;<i> +	ok |= 1;
</I>&gt;<i> +	/* ok, we had a header */
</I>&gt;<i> +	while (mem &lt; end) {
</I>&gt;<i> +		ret = fw_parse(&amp;mem, &amp;type, &amp;addr, &amp;len, &amp;dat);
</I>&gt;<i> +		if (ret)
</I>&gt;<i> +			break;
</I>&gt;<i> +
</I>&gt;<i> +		if (type == 3) {
</I>&gt;<i> +			/* start address */
</I>&gt;<i> +			start_addr = addr;
</I>&gt;<i> +			ok |= 2;
</I>&gt;<i> +			continue;
</I>&gt;<i> +		} else if (type == 1) {
</I>&gt;<i> +			/* eof */
</I>&gt;<i> +			ok |= 4;
</I>&gt;<i> +			goto fw_end;
</I>&gt;<i> +		} else if (type != 0) {
</I>&gt;<i> +			dev_alert(&amp;card-&gt;pdev-&gt;dev,
</I>&gt;<i> +					&quot;unknown record type 0x%04x\n&quot;, type);
</I>&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		/* regualar data */
</I>&gt;<i> +		for (sum = 0, j = 0; j &lt; len; ++j)
</I>&gt;<i> +			sum += dat[j];
</I>&gt;<i> +		/* work in 16bit (target) */
</I>&gt;<i> +		sum &amp;= 0xffff;
</I>&gt;<i> +
</I>&gt;<i> +		memcpy_toio(&amp;card-&gt;dpram[card-&gt;pdat-&gt;app.offs], dat, len);
</I>&gt;<i> +		iowrite32(card-&gt;pdat-&gt;app.offs + card-&gt;pdat-&gt;app.addr,
</I>&gt;<i> +				&amp;card-&gt;dpram[DPRAM_COMMAND + 2]);
</I>&gt;<i> +		iowrite32(addr, &amp;card-&gt;dpram[DPRAM_COMMAND + 6]);
</I>&gt;<i> +		iowrite16(len, &amp;card-&gt;dpram[DPRAM_COMMAND + 10]);
</I>&gt;<i> +		iowrite8(1, &amp;card-&gt;dpram[DPRAM_COMMAND + 12]);
</I>
See my comment about using arrays above.

&gt;<i> +		if (softing_bootloader_command(card, 1, &quot;loading app.&quot;))
</I>&gt;<i> +			goto fw_end;
</I>&gt;<i> +		/* verify checksum */
</I>&gt;<i> +		rx_sum = ioread16(&amp;card-&gt;dpram[DPRAM_RECEIPT + 2]);
</I>&gt;<i> +		if (rx_sum != sum) {
</I>&gt;<i> +			dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;SRAM seems to be damaged&quot;
</I>&gt;<i> +				&quot;, wanted 0x%04x, got 0x%04x\n&quot;, sum, rx_sum);
</I>&gt;<i> +			goto fw_end;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +fw_end:
</I>&gt;<i> +	release_firmware(fw);
</I>&gt;<i> +	if (ok != 7)
</I>&gt;<i> +		goto fw_failed;
</I>&gt;<i> +	/* got start, start_addr, &amp; eof */
</I>&gt;<i> +	iowrite32(start_addr, &amp;card-&gt;dpram[DPRAM_COMMAND + 2]);
</I>&gt;<i> +	iowrite8(1, &amp;card-&gt;dpram[DPRAM_COMMAND + 6]);
</I>&gt;<i> +	if (softing_bootloader_command(card, 3, &quot;start app.&quot;))
</I>&gt;<i> +		goto fw_failed;
</I>&gt;<i> +	dev_info(&amp;card-&gt;pdev-&gt;dev, &quot;firmware %s up\n&quot;, file);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +fw_failed:
</I>&gt;<i> +	dev_info(&amp;card-&gt;pdev-&gt;dev, &quot;firmware %s failed\n&quot;, file);
</I>&gt;<i> +	return ret ?: -EINVAL;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int softing_reset_chip(struct softing *card)
</I>&gt;<i> +{
</I>&gt;<i> +	do {
</I>&gt;<i> +		/* reset chip */
</I>&gt;<i> +		iowrite8(0, &amp;card-&gt;dpram[DPRAM_RESET_RX_FIFO]);
</I>&gt;<i> +		iowrite8(0, &amp;card-&gt;dpram[DPRAM_RESET_RX_FIFO+1]);
</I>&gt;<i> +		iowrite8(1, &amp;card-&gt;dpram[DPRAM_RESET]);
</I>&gt;<i> +		iowrite8(0, &amp;card-&gt;dpram[DPRAM_RESET+1]);
</I>&gt;<i> +
</I>&gt;<i> +		if (!softing_fct_cmd(card, 0, 0, &quot;reset_chip&quot;))
</I>&gt;<i> +			break;
</I>&gt;<i> +		if (signal_pending(current))
</I>&gt;<i> +			goto failed;
</I>&gt;<i> +		/* sync */
</I>&gt;<i> +		if (softing_fct_cmd(card, 99, 0x55, &quot;sync-a&quot;))
</I>&gt;<i> +			goto failed;
</I>&gt;<i> +		if (softing_fct_cmd(card, 99, 0xaa, &quot;sync-a&quot;))
</I>&gt;<i> +			goto failed;
</I>&gt;<i> +	} while (1);
</I>&gt;<i> +	card-&gt;tx.pending = 0;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +failed:
</I>&gt;<i> +	return -EIO;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void softing_initialize_timestamp(struct softing *card)
</I>&gt;<i> +{
</I>&gt;<i> +	uint64_t ovf;
</I>&gt;<i> +
</I>&gt;<i> +	card-&gt;ts_ref = ktime_get();
</I>&gt;<i> +
</I>&gt;<i> +	/* 16MHz is the reference */
</I>&gt;<i> +	ovf = 0x100000000ULL * 16;
</I>&gt;<i> +	do_div(ovf, card-&gt;pdat-&gt;freq ?: 16);
</I>&gt;<i> +
</I>&gt;<i> +	card-&gt;ts_overflow = ktime_add_us(ktime_set(0, 0), ovf);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +ktime_t softing_raw2ktime(struct softing *card, u32 raw)
</I>&gt;<i> +{
</I>&gt;<i> +	uint64_t rawl;
</I>&gt;<i> +	ktime_t now, real_offset;
</I>&gt;<i> +	ktime_t target;
</I>&gt;<i> +	ktime_t tmp;
</I>&gt;<i> +
</I>&gt;<i> +	now = ktime_get();
</I>&gt;<i> +	real_offset = ktime_sub(ktime_get_real(), now);
</I>&gt;<i> +
</I>&gt;<i> +	/* find nsec from card */
</I>&gt;<i> +	rawl = raw * 16;
</I>&gt;<i> +	do_div(rawl, card-&gt;pdat-&gt;freq ?: 16);
</I>&gt;<i> +	target = ktime_add_us(card-&gt;ts_ref, rawl);
</I>&gt;<i> +	/* test for overflows */
</I>&gt;<i> +	tmp = ktime_add(target, card-&gt;ts_overflow);
</I>&gt;<i> +	while (unlikely(ktime_to_ns(tmp) &gt; ktime_to_ns(now))) {
</I>&gt;<i> +		card-&gt;ts_ref = ktime_add(card-&gt;ts_ref, card-&gt;ts_overflow);
</I>&gt;<i> +		target = tmp;
</I>&gt;<i> +		tmp = ktime_add(target, card-&gt;ts_overflow);
</I>&gt;<i> +	}
</I>&gt;<i> +	return ktime_add(target, real_offset);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline int softing_error_reporting(struct net_device *netdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct softing_priv *priv = netdev_priv(netdev);
</I>&gt;<i> +
</I>&gt;<i> +	return (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_BERR_REPORTING)
</I>&gt;<i> +		? 1 : 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +int softing_startstop(struct net_device *dev, int up)
</I>&gt;<i> +{
</I>&gt;<i> +	int ret;
</I>&gt;<i> +	struct softing *card;
</I>&gt;<i> +	struct softing_priv *priv;
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	int mask_start;
</I>&gt;<i> +	int j, error_reporting;
</I>&gt;<i> +	struct can_frame msg;
</I>&gt;<i> +	const struct can_bittiming *bt;
</I>&gt;<i> +
</I>&gt;<i> +	priv = netdev_priv(dev);
</I>&gt;<i> +	card = priv-&gt;card;
</I>&gt;<i> +
</I>&gt;<i> +	if (!card-&gt;fw.up)
</I>&gt;<i> +		return -EIO;
</I>&gt;<i> +
</I>&gt;<i> +	ret = mutex_lock_interruptible(&amp;card-&gt;fw.lock);
</I>&gt;<i> +	if (ret)
</I>&gt;<i> +		return ret;
</I>&gt;<i> +
</I>&gt;<i> +	mask_start = 0;
</I>&gt;<i> +	if (dev &amp;&amp; up)
</I>&gt;<i> +		/* prepare to start this bus as well */
</I>&gt;<i> +		mask_start |= (1 &lt;&lt; priv-&gt;index);
</I>&gt;<i> +	/* bring netdevs down */
</I>&gt;<i> +	for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
</I>&gt;<i> +		netdev = card-&gt;net[j];
</I>&gt;<i> +		if (!netdev)
</I>&gt;<i> +			continue;
</I>&gt;<i> +		priv = netdev_priv(netdev);
</I>&gt;<i> +
</I>&gt;<i> +		if (dev != netdev)
</I>&gt;<i> +			netif_stop_queue(netdev);
</I>&gt;<i> +
</I>&gt;<i> +		if (netif_running(netdev)) {
</I>&gt;<i> +			if (dev != netdev)
</I>&gt;<i> +				mask_start |= (1 &lt;&lt; j);
</I>&gt;<i> +			priv-&gt;tx.pending = 0;
</I>&gt;<i> +			priv-&gt;tx.echo_put = 0;
</I>&gt;<i> +			priv-&gt;tx.echo_get = 0;
</I>&gt;<i> +			/* this bus' may just have called open_candev()
</I>
Please use

  /*
   * Comment
   */

&gt;<i> +			 * which is rather stupid to call close_candev()
</I>&gt;<i> +			 * already
</I>&gt;<i> +			 * but we may come here from busoff recovery too
</I>&gt;<i> +			 * in which case the echo_skb _needs_ flushing too.
</I>&gt;<i> +			 * just be sure to call open_candev() again
</I>&gt;<i> +			 */
</I>&gt;<i> +			close_candev(netdev);
</I>&gt;<i> +		}
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> +	}
</I>&gt;<i> +	card-&gt;tx.pending = 0;
</I>
&gt;<i> +
</I>&gt;<i> +	softing_enable_irq(card, 0);
</I>&gt;<i> +	ret = softing_reset_chip(card);
</I>&gt;<i> +	if (ret)
</I>&gt;<i> +		goto failed;
</I>&gt;<i> +	if (!mask_start)
</I>&gt;<i> +		/* no busses to be brought up */
</I>&gt;<i> +		goto card_done;
</I>&gt;<i> +
</I>&gt;<i> +	if ((mask_start &amp; 1) &amp;&amp; (mask_start &amp; 2)
</I>&gt;<i> +			&amp;&amp; (softing_error_reporting(card-&gt;net[0])
</I>&gt;<i> +				!= softing_error_reporting(card-&gt;net[1]))) {
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev,
</I>&gt;<i> +				&quot;err_reporting flag differs for busses\n&quot;);
</I>&gt;<i> +		goto invalid;
</I>&gt;<i> +	}
</I>&gt;<i> +	error_reporting = 0;
</I>&gt;<i> +	if (mask_start &amp; 1) {
</I>&gt;<i> +		netdev = card-&gt;net[0];
</I>&gt;<i> +		priv = netdev_priv(netdev);
</I>&gt;<i> +		error_reporting += softing_error_reporting(netdev);
</I>&gt;<i> +		/* init chip 1 */
</I>&gt;<i> +		bt = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> +		iowrite16(bt-&gt;brp, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
</I>&gt;<i> +		iowrite16(bt-&gt;sjw, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 4]);
</I>&gt;<i> +		iowrite16(bt-&gt;phase_seg1 + bt-&gt;prop_seg,
</I>&gt;<i> +				&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 6]);
</I>&gt;<i> +		iowrite16(bt-&gt;phase_seg2, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 8]);
</I>&gt;<i> +		iowrite16((priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES) ? 1 : 0,
</I>&gt;<i> +				&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 10]);
</I>&gt;<i> +		if (softing_fct_cmd(card, 1, 0, &quot;initialize_chip[0]&quot;))
</I>&gt;<i> +			goto failed;
</I>&gt;<i> +		/* set mode */
</I>&gt;<i> +		iowrite16(0, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
</I>&gt;<i> +		iowrite16(0, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 4]);
</I>&gt;<i> +		if (softing_fct_cmd(card, 3, 0, &quot;set_mode[0]&quot;))
</I>&gt;<i> +			goto failed;
</I>&gt;<i> +		/* set filter */
</I>&gt;<i> +		/* 11bit id &amp; mask */
</I>&gt;<i> +		iowrite16(0x0000, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
</I>&gt;<i> +		iowrite16(0x07ff, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 4]);
</I>&gt;<i> +		/* 29bit id.lo &amp; mask.lo &amp; id.hi &amp; mask.hi */
</I>&gt;<i> +		iowrite16(0x0000, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 6]);
</I>&gt;<i> +		iowrite16(0xffff, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 8]);
</I>&gt;<i> +		iowrite16(0x0000, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 10]);
</I>&gt;<i> +		iowrite16(0x1fff, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 12]);
</I>&gt;<i> +		if (softing_fct_cmd(card, 7, 0, &quot;set_filter[0]&quot;))
</I>&gt;<i> +			goto failed;
</I>&gt;<i> +		/* set output control */
</I>&gt;<i> +		iowrite16(priv-&gt;output, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
</I>&gt;<i> +		if (softing_fct_cmd(card, 5, 0, &quot;set_output[0]&quot;))
</I>&gt;<i> +			goto failed;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (mask_start &amp; 2) {
</I>
Magic constants?

&gt;<i> +		netdev = card-&gt;net[1];
</I>&gt;<i> +		priv = netdev_priv(netdev);
</I>&gt;<i> +		error_reporting += softing_error_reporting(netdev);
</I>&gt;<i> +		/* init chip2 */
</I>&gt;<i> +		bt = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> +		iowrite16(bt-&gt;brp, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
</I>&gt;<i> +		iowrite16(bt-&gt;sjw, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 4]);
</I>&gt;<i> +		iowrite16(bt-&gt;phase_seg1 + bt-&gt;prop_seg,
</I>&gt;<i> +				&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 6]);
</I>&gt;<i> +		iowrite16(bt-&gt;phase_seg2, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 8]);
</I>&gt;<i> +		iowrite16((priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES) ? 1 : 0,
</I>&gt;<i> +				&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 10]);
</I>&gt;<i> +		if (softing_fct_cmd(card, 2, 0, &quot;initialize_chip[1]&quot;))
</I>&gt;<i> +			goto failed;
</I>&gt;<i> +		/* set mode2 */
</I>&gt;<i> +		iowrite16(0, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
</I>&gt;<i> +		iowrite16(0, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 4]);
</I>&gt;<i> +		if (softing_fct_cmd(card, 4, 0, &quot;set_mode[1]&quot;))
</I>&gt;<i> +			goto failed;
</I>&gt;<i> +		/* set filter2 */
</I>&gt;<i> +		/* 11bit id &amp; mask */
</I>&gt;<i> +		iowrite16(0x0000, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
</I>&gt;<i> +		iowrite16(0x07ff, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 4]);
</I>&gt;<i> +		/* 29bit id.lo &amp; mask.lo &amp; id.hi &amp; mask.hi */
</I>&gt;<i> +		iowrite16(0x0000, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 6]);
</I>&gt;<i> +		iowrite16(0xffff, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 8]);
</I>&gt;<i> +		iowrite16(0x0000, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 10]);
</I>&gt;<i> +		iowrite16(0x1fff, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 12]);
</I>&gt;<i> +		if (softing_fct_cmd(card, 8, 0, &quot;set_filter[1]&quot;))
</I>&gt;<i> +			goto failed;
</I>&gt;<i> +		/* set output control2 */
</I>&gt;<i> +		iowrite16(priv-&gt;output, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
</I>&gt;<i> +		if (softing_fct_cmd(card, 6, 0, &quot;set_output[1]&quot;))
</I>&gt;<i> +			goto failed;
</I>&gt;<i> +	}
</I>&gt;<i> +	/* enable_error_frame */
</I>&gt;<i> +	/*
</I>&gt;<i> +	if (error_reporting) {
</I>&gt;<i> +		if (softing_fct_cmd(card, 51, 0, &quot;enable_error_frame&quot;))
</I>&gt;<i> +			goto failed;
</I>&gt;<i> +	}
</I>&gt;<i> +	*/
</I>
Please remove dead code!

&gt;<i> +	/* initialize interface */
</I>&gt;<i> +	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
</I>&gt;<i> +	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 4]);
</I>&gt;<i> +	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 6]);
</I>&gt;<i> +	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 8]);
</I>&gt;<i> +	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 10]);
</I>&gt;<i> +	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 12]);
</I>&gt;<i> +	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 14]);
</I>&gt;<i> +	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 16]);
</I>&gt;<i> +	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 18]);
</I>&gt;<i> +	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 20]);
</I>
Could be coded more efficiently with a for loop.

&gt;<i> +	if (softing_fct_cmd(card, 17, 0, &quot;initialize_interface&quot;))
</I>&gt;<i> +		goto failed;
</I>&gt;<i> +	/* enable_fifo */
</I>&gt;<i> +	if (softing_fct_cmd(card, 36, 0, &quot;enable_fifo&quot;))
</I>&gt;<i> +		goto failed;
</I>&gt;<i> +	/* enable fifo tx ack */
</I>&gt;<i> +	if (softing_fct_cmd(card, 13, 0, &quot;fifo_tx_ack[0]&quot;))
</I>&gt;<i> +		goto failed;
</I>&gt;<i> +	/* enable fifo tx ack2 */
</I>&gt;<i> +	if (softing_fct_cmd(card, 14, 0, &quot;fifo_tx_ack[1]&quot;))
</I>&gt;<i> +		goto failed;
</I>&gt;<i> +	/* enable timestamps */
</I>&gt;<i> +	/* is default, no code found */
</I>&gt;<i> +	/* start_chip */
</I>&gt;<i> +	if (softing_fct_cmd(card, 11, 0, &quot;start_chip&quot;))
</I>&gt;<i> +		goto failed;
</I>&gt;<i> +	iowrite8(0, &amp;card-&gt;dpram[DPRAM_INFO_BUSSTATE]);
</I>&gt;<i> +	iowrite8(0, &amp;card-&gt;dpram[DPRAM_INFO_BUSSTATE2]);
</I>&gt;<i> +	dev_info(&amp;card-&gt;pdev-&gt;dev, &quot;%s up\n&quot;, __func__);
</I>&gt;<i> +	if (card-&gt;pdat-&gt;generation &lt; 2) {
</I>&gt;<i> +		iowrite8(0, &amp;card-&gt;dpram[DPRAM_V2_IRQ_TOHOST]);
</I>&gt;<i> +		/* flush the DPRAM caches */
</I>&gt;<i> +		wmb();
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	softing_initialize_timestamp(card);
</I>&gt;<i> +
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * do socketcan notifications/status changes
</I>&gt;<i> +	 * from here, no errors should occur, or the failed: part
</I>&gt;<i> +	 * must be reviewed
</I>&gt;<i> +	 */
</I>&gt;<i> +	memset(&amp;msg, 0, sizeof(msg));
</I>&gt;<i> +	msg.can_id = CAN_ERR_FLAG | CAN_ERR_RESTARTED;
</I>&gt;<i> +	msg.can_dlc = CAN_ERR_DLC;
</I>&gt;<i> +	for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
</I>&gt;<i> +		if (!(mask_start &amp; (1 &lt;&lt; j)))
</I>&gt;<i> +			continue;
</I>&gt;<i> +		netdev = card-&gt;net[j];
</I>&gt;<i> +		if (!netdev)
</I>&gt;<i> +			continue;
</I>&gt;<i> +		priv = netdev_priv(netdev);
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +		open_candev(netdev);
</I>&gt;<i> +		if (dev != netdev) {
</I>&gt;<i> +			/* notify other busses on the restart */
</I>&gt;<i> +			softing_netdev_rx(netdev, &amp;msg, ktime_set(0, 0));
</I>&gt;<i> +			++priv-&gt;can.can_stats.restarts;
</I>&gt;<i> +		}
</I>&gt;<i> +		netif_wake_queue(netdev);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* enable interrupts */
</I>&gt;<i> +	ret = softing_enable_irq(card, 1);
</I>&gt;<i> +	if (ret)
</I>&gt;<i> +		goto failed;
</I>&gt;<i> +card_done:
</I>&gt;<i> +	mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +failed:
</I>&gt;<i> +	dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;firmware failed, going idle\n&quot;);
</I>&gt;<i> +invalid:
</I>&gt;<i> +	softing_enable_irq(card, 0);
</I>&gt;<i> +	softing_reset_chip(card);
</I>&gt;<i> +	mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i> +	/* bring all other interfaces down */
</I>&gt;<i> +	for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
</I>&gt;<i> +		netdev = card-&gt;net[j];
</I>&gt;<i> +		if (!netdev)
</I>&gt;<i> +			continue;
</I>&gt;<i> +		dev_close(netdev);
</I>&gt;<i> +	}
</I>&gt;<i> +	return -EIO;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +int softing_default_output(struct net_device *netdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct softing_priv *priv = netdev_priv(netdev);
</I>&gt;<i> +	struct softing *card = priv-&gt;card;
</I>&gt;<i> +
</I>&gt;<i> +	switch (priv-&gt;chip) {
</I>&gt;<i> +	case 1000:
</I>&gt;<i> +		if (card-&gt;pdat-&gt;generation &lt; 2)
</I>&gt;<i> +			return 0xfb;
</I>&gt;<i> +		return 0xfa;
</I>&gt;<i> +	case 5:
</I>&gt;<i> +		return 0x60;
</I>&gt;<i> +	default:
</I>&gt;<i> +		return 0x40;
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>
Again, some magic constants.

&gt;<i> diff --git a/drivers/net/can/softing/softing_main.c b/drivers/net/can/softing/softing_main.c
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..4f74075
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/softing/softing_main.c
</I>&gt;<i> @@ -0,0 +1,903 @@
</I>&gt;<i> +/*
</I>&gt;<i> +* drivers/net/can/softing/softing_main.c
</I>&gt;<i> +*
</I>&gt;<i> +* Copyright (C) 2008-2010
</I>&gt;<i> +*
</I>&gt;<i> +* - Kurt Van Dijck, EIA Electronics
</I>&gt;<i> +*
</I>&gt;<i> +* This program is free software; you can redistribute it and/or modify
</I>&gt;<i> +* it under the terms of the version 2 of the GNU General Public License
</I>&gt;<i> +* as published by the Free Software Foundation
</I>&gt;<i> +*
</I>&gt;<i> +* This program is distributed in the hope that it will be useful,
</I>&gt;<i> +* but WITHOUT ANY WARRANTY; without even the implied warranty of
</I>&gt;<i> +* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
</I>&gt;<i> +* GNU General Public License for more details.
</I>&gt;<i> +*
</I>&gt;<i> +* You should have received a copy of the GNU General Public License
</I>&gt;<i> +* along with this program; if not, write to the Free Software
</I>&gt;<i> +* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
</I>&gt;<i> +*/
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/version.h&gt;
</I>&gt;<i> +#include &lt;linux/module.h&gt;
</I>&gt;<i> +#include &lt;linux/init.h&gt;
</I>&gt;<i> +#include &lt;linux/interrupt.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#include &quot;softing.h&quot;
</I>&gt;<i> +
</I>&gt;<i> +#define TX_ECHO_SKB_MAX (TXMAX/2)
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * test is a specific CAN netdev
</I>&gt;<i> + * is online (ie. up 'n running, not sleeping, not busoff
</I>&gt;<i> + */
</I>&gt;<i> +static inline int canif_is_active(struct net_device *netdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct can_priv *can = netdev_priv(netdev);
</I>
Empty line, please.

&gt;<i> +	if (!netif_running(netdev))
</I>&gt;<i> +		return 0;
</I>&gt;<i> +	return (can-&gt;state &lt;= CAN_STATE_ERROR_PASSIVE);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/* trigger the tx queue-ing */
</I>&gt;<i> +static netdev_tx_t
</I>&gt;<i> +softing_netdev_start_xmit(struct sk_buff *skb, struct net_device *dev)
</I>
See general comments.

&gt;<i> +{
</I>&gt;<i> +	struct softing_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct softing *card = priv-&gt;card;
</I>&gt;<i> +	int ret;
</I>&gt;<i> +	uint8_t *ptr;
</I>&gt;<i> +	uint8_t fifo_wr, fifo_rd;
</I>&gt;<i> +	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> +	uint8_t buf[DPRAM_TX_SIZE];
</I>&gt;<i> +
</I>&gt;<i> +	if (can_dropped_invalid_skb(dev, skb))
</I>&gt;<i> +		return NETDEV_TX_OK;
</I>&gt;<i> +
</I>&gt;<i> +	spin_lock(&amp;card-&gt;spin);
</I>&gt;<i> +
</I>&gt;<i> +	ret = NETDEV_TX_BUSY;
</I>&gt;<i> +	if (!card-&gt;fw.up)
</I>&gt;<i> +		goto xmit_done;
</I>&gt;<i> +	if (card-&gt;tx.pending &gt;= TXMAX)
</I>&gt;<i> +		goto xmit_done;
</I>&gt;<i> +	if (priv-&gt;tx.pending &gt;= TX_ECHO_SKB_MAX)
</I>&gt;<i> +		goto xmit_done;
</I>
What about using &quot;||&quot;?

&gt;<i> +	fifo_wr = ioread8(&amp;card-&gt;dpram[DPRAM_TX_WR]);
</I>&gt;<i> +	fifo_rd = ioread8(&amp;card-&gt;dpram[DPRAM_TX_RD]);
</I>&gt;<i> +	if (fifo_wr == fifo_rd)
</I>&gt;<i> +		/* fifo full */
</I>&gt;<i> +		goto xmit_done;
</I>&gt;<i> +	memset(buf, 0, sizeof(buf));
</I>&gt;<i> +	ptr = buf;
</I>&gt;<i> +	*ptr = CMD_TX;
</I>&gt;<i> +	if (cf-&gt;can_id &amp; CAN_RTR_FLAG)
</I>&gt;<i> +		*ptr |= CMD_RTR;
</I>&gt;<i> +	if (cf-&gt;can_id &amp; CAN_EFF_FLAG)
</I>&gt;<i> +		*ptr |= CMD_XTD;
</I>&gt;<i> +	if (priv-&gt;index)
</I>&gt;<i> +		*ptr |= CMD_BUS2;
</I>&gt;<i> +	++ptr;
</I>&gt;<i> +	*ptr++ = cf-&gt;can_dlc;
</I>&gt;<i> +	*ptr++ = (cf-&gt;can_id &gt;&gt; 0);
</I>&gt;<i> +	*ptr++ = (cf-&gt;can_id &gt;&gt; 8);
</I>&gt;<i> +	if (cf-&gt;can_id &amp; CAN_EFF_FLAG) {
</I>&gt;<i> +		*ptr++ = (cf-&gt;can_id &gt;&gt; 16);
</I>&gt;<i> +		*ptr++ = (cf-&gt;can_id &gt;&gt; 24);
</I>&gt;<i> +	} else {
</I>&gt;<i> +		/* increment 1, not 2 as you might think */
</I>&gt;<i> +		ptr += 1;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (!(cf-&gt;can_id &amp; CAN_RTR_FLAG))
</I>&gt;<i> +		memcpy(ptr, &amp;cf-&gt;data[0], cf-&gt;can_dlc);
</I>&gt;<i> +	memcpy_toio(&amp;card-&gt;dpram[DPRAM_TX + DPRAM_TX_SIZE * fifo_wr],
</I>&gt;<i> +			buf, DPRAM_TX_SIZE);
</I>&gt;<i> +	if (++fifo_wr &gt;= DPRAM_TX_CNT)
</I>&gt;<i> +		fifo_wr = 0;
</I>&gt;<i> +	iowrite8(fifo_wr, &amp;card-&gt;dpram[DPRAM_TX_WR]);
</I>&gt;<i> +	card-&gt;tx.last_bus = priv-&gt;index;
</I>&gt;<i> +	++card-&gt;tx.pending;
</I>&gt;<i> +	++priv-&gt;tx.pending;
</I>&gt;<i> +	can_put_echo_skb(skb, dev, priv-&gt;tx.echo_put);
</I>&gt;<i> +	++priv-&gt;tx.echo_put;
</I>&gt;<i> +	if (priv-&gt;tx.echo_put &gt;= TX_ECHO_SKB_MAX)
</I>&gt;<i> +		priv-&gt;tx.echo_put = 0;
</I>&gt;<i> +	/* can_put_echo_skb() saves the skb, safe to return TX_OK */
</I>&gt;<i> +	ret = NETDEV_TX_OK;
</I>&gt;<i> +xmit_done:
</I>&gt;<i> +	spin_unlock(&amp;card-&gt;spin);
</I>&gt;<i> +	if (card-&gt;tx.pending &gt;= TXMAX) {
</I>&gt;<i> +		int j;
</I>
Empty line please.

&gt;<i> +		for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
</I>&gt;<i> +			if (card-&gt;net[j])
</I>&gt;<i> +				netif_stop_queue(card-&gt;net[j]);
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +	if (ret != NETDEV_TX_OK)
</I>&gt;<i> +		netif_stop_queue(dev);
</I>&gt;<i> +
</I>&gt;<i> +	return ret;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * shortcut for skb delivery
</I>&gt;<i> + */
</I>&gt;<i> +int softing_netdev_rx(struct net_device *netdev,
</I>&gt;<i> +		const struct can_frame *msg, ktime_t ktime)
</I>&gt;<i> +{
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	int ret;
</I>&gt;<i> +
</I>&gt;<i> +	skb = alloc_can_skb(netdev, &amp;cf);
</I>&gt;<i> +	if (!skb)
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	memcpy(cf, msg, sizeof(*msg));
</I>&gt;<i> +	skb-&gt;tstamp = ktime;
</I>&gt;<i> +	ret = netif_rx(skb);
</I>&gt;<i> +	if (ret == NET_RX_DROP)
</I>&gt;<i> +		++netdev-&gt;stats.rx_dropped;
</I>
Hm, I wonder if all Socket-CAN drivers should handle the return value of
netif_rx that way?

&gt;<i> +	return ret;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * softing_handle_1
</I>&gt;<i> + * pop 1 entry from the DPRAM queue, and process
</I>&gt;<i> + */
</I>&gt;<i> +static int softing_handle_1(struct softing *card)
</I>&gt;<i> +{
</I>&gt;<i> +	int j;
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	struct softing_priv *priv;
</I>&gt;<i> +	ktime_t ktime;
</I>&gt;<i> +	struct can_frame msg;
</I>&gt;<i> +
</I>&gt;<i> +	int lost_msg;
</I>&gt;<i> +	uint8_t fifo_rd, fifo_wr;
</I>&gt;<i> +	unsigned int cnt = 0;
</I>&gt;<i> +	uint8_t *ptr;
</I>&gt;<i> +	u32 tmp;
</I>&gt;<i> +	u8 cmd;
</I>&gt;<i> +	uint8_t buf[DPRAM_RX_SIZE];
</I>&gt;<i> +
</I>&gt;<i> +	memset(&amp;msg, 0, sizeof(msg));
</I>&gt;<i> +	/* test for lost msgs */
</I>&gt;<i> +	lost_msg = ioread8(&amp;card-&gt;dpram[DPRAM_RX_LOST]);
</I>&gt;<i> +	if (lost_msg) {
</I>&gt;<i> +		/* reset condition */
</I>&gt;<i> +		iowrite8(0, &amp;card-&gt;dpram[DPRAM_RX_LOST]);
</I>&gt;<i> +		/* prepare msg */
</I>&gt;<i> +		msg.can_id = CAN_ERR_FLAG | CAN_ERR_CRTL;
</I>&gt;<i> +		msg.can_dlc = CAN_ERR_DLC;
</I>&gt;<i> +		msg.data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
</I>&gt;<i> +		/*
</I>&gt;<i> +		 * service to all busses, we don't know which it was applicable
</I>&gt;<i> +		 * but only service busses that are online
</I>&gt;<i> +		 */
</I>&gt;<i> +		for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
</I>&gt;<i> +			netdev = card-&gt;net[j];
</I>&gt;<i> +			if (!netdev)
</I>&gt;<i> +				continue;
</I>&gt;<i> +			if (!canif_is_active(netdev))
</I>&gt;<i> +				/* a dead bus has no overflows */
</I>&gt;<i> +				continue;
</I>&gt;<i> +			++netdev-&gt;stats.rx_over_errors;
</I>&gt;<i> +			softing_netdev_rx(netdev, &amp;msg, ktime_set(0, 0));
</I>&gt;<i> +		}
</I>&gt;<i> +		/* prepare for other use */
</I>&gt;<i> +		memset(&amp;msg, 0, sizeof(msg));
</I>&gt;<i> +		++cnt;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	fifo_rd = ioread8(&amp;card-&gt;dpram[DPRAM_RX_RD]);
</I>&gt;<i> +	fifo_wr = ioread8(&amp;card-&gt;dpram[DPRAM_RX_WR]);
</I>&gt;<i> +
</I>&gt;<i> +	if (++fifo_rd &gt;= DPRAM_RX_CNT)
</I>&gt;<i> +		fifo_rd = 0;
</I>&gt;<i> +	if (fifo_wr == fifo_rd)
</I>&gt;<i> +		return cnt;
</I>&gt;<i> +
</I>&gt;<i> +	memcpy_fromio(buf, &amp;card-&gt;dpram[DPRAM_RX + DPRAM_RX_SIZE*fifo_rd],
</I>&gt;<i> +			DPRAM_RX_SIZE);
</I>&gt;<i> +	mb();
</I>&gt;<i> +	/* trigger dual port RAM */
</I>&gt;<i> +	iowrite8(fifo_rd, &amp;card-&gt;dpram[DPRAM_RX_RD]);
</I>&gt;<i> +
</I>&gt;<i> +	ptr = buf;
</I>&gt;<i> +	cmd = *ptr++;
</I>&gt;<i> +	if (cmd == 0xff) {
</I>&gt;<i> +		/* not quite usefull, probably the card has got out */
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;got cmd 0x%02x,&quot;
</I>&gt;<i> +			&quot; I suspect the card is lost\n&quot;, cmd);
</I>&gt;<i> +		return 0;
</I>&gt;<i> +	}
</I>&gt;<i> +	netdev = card-&gt;net[0];
</I>&gt;<i> +	if (cmd &amp; CMD_BUS2)
</I>&gt;<i> +		netdev = card-&gt;net[1];
</I>&gt;<i> +	priv = netdev_priv(netdev);
</I>&gt;<i> +
</I>&gt;<i> +	if (cmd &amp; CMD_ERR) {
</I>&gt;<i> +		u8 can_state;
</I>&gt;<i> +		u8 state;
</I>&gt;<i> +		state = *ptr++;
</I>&gt;<i> +
</I>&gt;<i> +		msg.can_id = CAN_ERR_FLAG;
</I>&gt;<i> +		msg.can_dlc = CAN_ERR_DLC;
</I>&gt;<i> +
</I>&gt;<i> +		if (state &amp; 0x80) {
</I>
Again some magic constants!

&gt;<i> +			can_state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +			msg.can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> +			state = 2;
</I>
Ditto.

&gt;<i> +		} else if (state &amp; 0x60) {
</I>&gt;<i> +			can_state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> +			msg.can_id |= CAN_ERR_BUSERROR;
</I>
A state change is not a bus error! You should use:

  msg.can_id |= CAN_ERR_CRTL;

&gt;<i> +			msg.data[1] = CAN_ERR_CRTL_TX_PASSIVE;
</I>&gt;<i> +			state = 1;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			can_state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +			state = 0;
</I>&gt;<i> +			msg.can_id |= CAN_ERR_BUSERROR;
</I>
Ditto.

&gt;<i> +		}
</I>&gt;<i> +		/* update DPRAM */
</I>&gt;<i> +		iowrite8(state, &amp;card-&gt;dpram[priv-&gt;index ?
</I>&gt;<i> +				DPRAM_INFO_BUSSTATE2 : DPRAM_INFO_BUSSTATE]);
</I>&gt;<i> +		/* timestamp */
</I>&gt;<i> +		tmp = le32_to_cpup((void *)ptr);
</I>&gt;<i> +		ptr += 4;
</I>&gt;<i> +		ktime = softing_raw2ktime(card, tmp);
</I>&gt;<i> +
</I>&gt;<i> +		++priv-&gt;can.can_stats.bus_error;
</I>
Ditto.

&gt;<i> +		++netdev-&gt;stats.rx_errors;
</I>&gt;<i> +		/* update internal status */
</I>&gt;<i> +		if (can_state != priv-&gt;can.state) {
</I>&gt;<i> +			priv-&gt;can.state = can_state;
</I>&gt;<i> +			if (can_state == CAN_STATE_ERROR_PASSIVE)
</I>&gt;<i> +				++priv-&gt;can.can_stats.error_passive;
</I>&gt;<i> +			if (can_state == CAN_STATE_BUS_OFF) {
</I>
else if?

&gt;<i> +				/* this calls can_close_cleanup() */
</I>&gt;<i> +				can_bus_off(netdev);
</I>&gt;<i> +				netif_stop_queue(netdev);
</I>&gt;<i> +			}
</I>&gt;<i> +			/* trigger socketcan */
</I>&gt;<i> +			softing_netdev_rx(netdev, &amp;msg, ktime);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +	} else {
</I>&gt;<i> +		if (cmd &amp; CMD_RTR)
</I>&gt;<i> +			msg.can_id |= CAN_RTR_FLAG;
</I>&gt;<i> +		/* acknowledge, was tx msg
</I>&gt;<i> +		 * no real tx flag to set
</I>&gt;<i> +		if (cmd &amp; CMD_ACK) {
</I>&gt;<i> +		}
</I>&gt;<i> +		 */
</I>&gt;<i> +		msg.can_dlc = get_can_dlc(*ptr++);
</I>&gt;<i> +		if (cmd &amp; CMD_XTD) {
</I>&gt;<i> +			msg.can_id |= CAN_EFF_FLAG;
</I>&gt;<i> +			msg.can_id |= le32_to_cpup((void *)ptr);
</I>&gt;<i> +			ptr += 4;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			msg.can_id |= le16_to_cpup((void *)ptr);
</I>&gt;<i> +			ptr += 2;
</I>&gt;<i> +		}
</I>&gt;<i> +		/* timestamp */
</I>&gt;<i> +		tmp = le32_to_cpup((void *)ptr);
</I>&gt;<i> +		ptr += 4;
</I>&gt;<i> +		ktime = softing_raw2ktime(card, tmp);
</I>&gt;<i> +		if (!(msg.can_id &amp; CAN_RTR_FLAG))
</I>&gt;<i> +			memcpy(&amp;msg.data[0], ptr, 8);
</I>&gt;<i> +		ptr += 8;
</I>&gt;<i> +		/* update socket */
</I>&gt;<i> +		if (cmd &amp; CMD_ACK) {
</I>&gt;<i> +			struct sk_buff *skb;
</I>&gt;<i> +			skb = priv-&gt;can.echo_skb[priv-&gt;tx.echo_get];
</I>&gt;<i> +			if (skb)
</I>&gt;<i> +				skb-&gt;tstamp = ktime;
</I>&gt;<i> +			can_get_echo_skb(netdev, priv-&gt;tx.echo_get);
</I>&gt;<i> +			++priv-&gt;tx.echo_get;
</I>&gt;<i> +			if (priv-&gt;tx.echo_get &gt;= TX_ECHO_SKB_MAX)
</I>&gt;<i> +				priv-&gt;tx.echo_get = 0;
</I>&gt;<i> +			if (priv-&gt;tx.pending)
</I>&gt;<i> +				--priv-&gt;tx.pending;
</I>&gt;<i> +			if (card-&gt;tx.pending)
</I>&gt;<i> +				--card-&gt;tx.pending;
</I>&gt;<i> +			++netdev-&gt;stats.tx_packets;
</I>&gt;<i> +			netdev-&gt;stats.tx_bytes += msg.can_dlc;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			++netdev-&gt;stats.rx_packets;
</I>&gt;<i> +			netdev-&gt;stats.rx_bytes += msg.can_dlc;
</I>&gt;<i> +			softing_netdev_rx(netdev, &amp;msg, ktime);
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +	++cnt;
</I>&gt;<i> +	return cnt;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * real interrupt handler
</I>&gt;<i> + */
</I>&gt;<i> +static irqreturn_t softing_irq_thread(int irq, void *dev_id)
</I>&gt;<i> +{
</I>&gt;<i> +	struct softing *card = (struct softing *)dev_id;
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	struct softing_priv *priv;
</I>&gt;<i> +	int j, offset, work_done;
</I>&gt;<i> +
</I>&gt;<i> +	work_done = 0;
</I>&gt;<i> +	spin_lock_bh(&amp;card-&gt;spin);
</I>&gt;<i> +	while (softing_handle_1(card) &gt; 0) {
</I>&gt;<i> +		++card-&gt;irq.svc_count;
</I>&gt;<i> +		++work_done;
</I>&gt;<i> +	}
</I>&gt;<i> +	spin_unlock_bh(&amp;card-&gt;spin);
</I>&gt;<i> +	/* resume tx queue's */
</I>&gt;<i> +	offset = card-&gt;tx.last_bus;
</I>&gt;<i> +	for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
</I>&gt;<i> +		if (card-&gt;tx.pending &gt;= TXMAX)
</I>&gt;<i> +			break;
</I>&gt;<i> +		netdev = card-&gt;net[(j + offset + 1) % card-&gt;pdat-&gt;nbus];
</I>&gt;<i> +		if (!netdev)
</I>&gt;<i> +			continue;
</I>&gt;<i> +		priv = netdev_priv(netdev);
</I>&gt;<i> +		if (!canif_is_active(netdev))
</I>&gt;<i> +			/* it makes no sense to wake dead busses */
</I>&gt;<i> +			continue;
</I>&gt;<i> +		if (priv-&gt;tx.pending &gt;= TX_ECHO_SKB_MAX)
</I>&gt;<i> +			continue;
</I>&gt;<i> +		++work_done;
</I>&gt;<i> +		netif_wake_queue(netdev);
</I>&gt;<i> +	}
</I>&gt;<i> +	return work_done ? IRQ_HANDLED : IRQ_NONE;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * interrupt routines:
</I>&gt;<i> + * schedule the 'real interrupt handler'
</I>&gt;<i> + */
</I>&gt;<i> +static
</I>&gt;<i> +irqreturn_t softing_irq_v2(int irq, void *dev_id)
</I>&gt;<i> +{
</I>&gt;<i> +	struct softing *card = (struct softing *)dev_id;
</I>&gt;<i> +	uint8_t ir;
</I>&gt;<i> +
</I>&gt;<i> +	ir = ioread8(&amp;card-&gt;dpram[DPRAM_V2_IRQ_TOHOST]);
</I>&gt;<i> +	iowrite8(0, &amp;card-&gt;dpram[DPRAM_V2_IRQ_TOHOST]);
</I>&gt;<i> +	return (1 == ir) ? IRQ_WAKE_THREAD : IRQ_NONE;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static
</I>&gt;<i> +irqreturn_t softing_irq_v1(int irq, void *dev_id)
</I>
See general comments.

&gt;<i> +{
</I>&gt;<i> +	struct softing *card = (struct softing *)dev_id;
</I>&gt;<i> +	uint8_t ir;
</I>&gt;<i> +
</I>&gt;<i> +	ir = ioread8(&amp;card-&gt;dpram[DPRAM_IRQ_TOHOST]);
</I>&gt;<i> +	iowrite8(0, &amp;card-&gt;dpram[DPRAM_IRQ_TOHOST]);
</I>&gt;<i> +	return ir ? IRQ_WAKE_THREAD : IRQ_NONE;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * netdev/candev inter-operability
</I>&gt;<i> + */
</I>&gt;<i> +static int softing_netdev_open(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	int ret;
</I>&gt;<i> +
</I>&gt;<i> +	/* check or determine and set bittime */
</I>&gt;<i> +	ret = open_candev(ndev);
</I>&gt;<i> +	if (ret)
</I>&gt;<i> +		goto failed;
</I>&gt;<i> +	ret = softing_startstop(ndev, 1);
</I>&gt;<i> +	if (ret)
</I>&gt;<i> +		goto failed;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +failed:
</I>&gt;<i> +	return ret;
</I>
Do you really need that label?

&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int softing_netdev_stop(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	int ret;
</I>&gt;<i> +
</I>&gt;<i> +	netif_stop_queue(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	/* softing cycle does close_candev() */
</I>&gt;<i> +	ret = softing_startstop(ndev, 0);
</I>&gt;<i> +	return ret;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int softing_candev_set_mode(struct net_device *ndev, enum can_mode mode)
</I>&gt;<i> +{
</I>&gt;<i> +	int ret;
</I>&gt;<i> +
</I>&gt;<i> +	switch (mode) {
</I>&gt;<i> +	case CAN_MODE_START:
</I>&gt;<i> +		/* softing_startstop does close_candev() */
</I>&gt;<i> +		ret = softing_startstop(ndev, 1);
</I>&gt;<i> +		return ret;
</I>&gt;<i> +	case CAN_MODE_STOP:
</I>&gt;<i> +	case CAN_MODE_SLEEP:
</I>&gt;<i> +		return -EOPNOTSUPP;
</I>&gt;<i> +	}
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * Softing device management helpers
</I>&gt;<i> + */
</I>&gt;<i> +int softing_enable_irq(struct softing *card, int enable)
</I>&gt;<i> +{
</I>&gt;<i> +	int ret;
</I>
Empty line, please.

&gt;<i> +	if (!enable) {
</I>&gt;<i> +		if (card-&gt;irq.requested &amp;&amp; card-&gt;irq.nr) {
</I>&gt;<i> +			free_irq(card-&gt;irq.nr, card);
</I>&gt;<i> +			card-&gt;irq.requested = 0;
</I>&gt;<i> +		}
</I>&gt;<i> +		return 0;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (!card-&gt;irq.requested &amp;&amp; (card-&gt;irq.nr)) {
</I>&gt;<i> +		ret = request_threaded_irq(card-&gt;irq.nr,
</I>&gt;<i> +				(card-&gt;pdat-&gt;generation &gt;= 2)
</I>&gt;<i> +					? softing_irq_v2 : softing_irq_v1,
</I>&gt;<i> +				softing_irq_thread, IRQF_SHARED,
</I>&gt;<i> +				dev_name(&amp;card-&gt;pdev-&gt;dev), card);
</I>&gt;<i> +		if (ret) {
</I>&gt;<i> +			dev_alert(&amp;card-&gt;pdev-&gt;dev,
</I>&gt;<i> +					&quot;request_threaded_irq(%u) failed\n&quot;,
</I>&gt;<i> +					card-&gt;irq.nr);
</I>&gt;<i> +			return ret;
</I>&gt;<i> +		}
</I>&gt;<i> +		card-&gt;irq.requested = 1;
</I>&gt;<i> +	}
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void softing_card_shutdown(struct softing *card)
</I>&gt;<i> +{
</I>&gt;<i> +	int fw_up = 0;
</I>
Empty line, please.

&gt;<i> +	dev_dbg(&amp;card-&gt;pdev-&gt;dev, &quot;%s()\n&quot;, __func__);
</I>
Please reduce the debugging output to a few useful messages (for the
final user).

&gt;<i> +	if (mutex_lock_interruptible(&amp;card-&gt;fw.lock))
</I>&gt;<i> +		/* return -ERESTARTSYS*/;
</I>
What is the &quot;if&quot; then good for? Do you want to handle the return code?

&gt;<i> +	fw_up = card-&gt;fw.up;
</I>&gt;<i> +	card-&gt;fw.up = 0;
</I>&gt;<i> +
</I>&gt;<i> +	if (card-&gt;irq.requested &amp;&amp; card-&gt;irq.nr) {
</I>&gt;<i> +		free_irq(card-&gt;irq.nr, card);
</I>&gt;<i> +		card-&gt;irq.requested = 0;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (fw_up) {
</I>&gt;<i> +		if (card-&gt;pdat-&gt;enable_irq)
</I>&gt;<i> +			card-&gt;pdat-&gt;enable_irq(card-&gt;pdev, 0);
</I>&gt;<i> +		softing_set_reset_dpram(card);
</I>&gt;<i> +		if (card-&gt;pdat-&gt;reset)
</I>&gt;<i> +			card-&gt;pdat-&gt;reset(card-&gt;pdev, 1);
</I>&gt;<i> +	}
</I>&gt;<i> +	mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int softing_card_boot(struct softing *card)
</I>&gt;<i> +{
</I>&gt;<i> +	int j;
</I>&gt;<i> +	static const uint8_t stream[] = {
</I>&gt;<i> +		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, };
</I>&gt;<i> +	unsigned char back[sizeof(stream)];
</I>
Empty line please.

&gt;<i> +	dev_dbg(&amp;card-&gt;pdev-&gt;dev, &quot;%s()\n&quot;, __func__);
</I>
See comment above.

&gt;<i> +	if (mutex_lock_interruptible(&amp;card-&gt;fw.lock))
</I>&gt;<i> +		return -ERESTARTSYS;
</I>&gt;<i> +	if (card-&gt;fw.up) {
</I>&gt;<i> +		mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i> +		return 0;
</I>&gt;<i> +	}
</I>&gt;<i> +	/* reset board */
</I>&gt;<i> +	if (card-&gt;pdat-&gt;enable_irq)
</I>&gt;<i> +		card-&gt;pdat-&gt;enable_irq(card-&gt;pdev, 1);
</I>&gt;<i> +	/* boot card */
</I>&gt;<i> +	softing_set_reset_dpram(card);
</I>&gt;<i> +	if (card-&gt;pdat-&gt;reset)
</I>&gt;<i> +		card-&gt;pdat-&gt;reset(card-&gt;pdev, 1);
</I>&gt;<i> +	for (j = 0; (j + sizeof(stream)) &lt; card-&gt;dpram_size;
</I>&gt;<i> +			j += sizeof(stream)) {
</I>&gt;<i> +
</I>&gt;<i> +		memcpy_toio(&amp;card-&gt;dpram[j], stream, sizeof(stream));
</I>&gt;<i> +		/* flush IO cache */
</I>&gt;<i> +		mb();
</I>&gt;<i> +		memcpy_fromio(back, &amp;card-&gt;dpram[j], sizeof(stream));
</I>&gt;<i> +
</I>&gt;<i> +		if (!memcmp(back, stream, sizeof(stream)))
</I>&gt;<i> +			continue;
</I>&gt;<i> +		/* memory is not equal */
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;dpram failed at 0x%04x\n&quot;, j);
</I>&gt;<i> +		goto open_failed;
</I>&gt;<i> +	}
</I>&gt;<i> +	wmb();
</I>&gt;<i> +	/* load boot firmware */
</I>&gt;<i> +	if (softing_load_fw(card-&gt;pdat-&gt;boot.fw, card, card-&gt;dpram,
</I>&gt;<i> +				 card-&gt;dpram_size,
</I>&gt;<i> +				 card-&gt;pdat-&gt;boot.offs -
</I>&gt;<i> +				 card-&gt;pdat-&gt;boot.addr))
</I>&gt;<i> +		goto open_failed;
</I>&gt;<i> +	/* load loader firmware */
</I>&gt;<i> +	if (softing_load_fw(card-&gt;pdat-&gt;load.fw, card, card-&gt;dpram,
</I>&gt;<i> +				 card-&gt;dpram_size,
</I>&gt;<i> +				 card-&gt;pdat-&gt;load.offs -
</I>&gt;<i> +				 card-&gt;pdat-&gt;load.addr))
</I>&gt;<i> +		goto open_failed;
</I>&gt;<i> +
</I>&gt;<i> +	if (card-&gt;pdat-&gt;reset)
</I>&gt;<i> +		card-&gt;pdat-&gt;reset(card-&gt;pdev, 0);
</I>&gt;<i> +	softing_clr_reset_dpram(card);
</I>&gt;<i> +	if (softing_bootloader_command(card, 0, &quot;card boot&quot;))
</I>&gt;<i> +		goto open_failed;
</I>&gt;<i> +	if (softing_load_app_fw(card-&gt;pdat-&gt;app.fw, card))
</I>&gt;<i> +		goto open_failed;
</I>&gt;<i> +	/* reset chip */
</I>&gt;<i> +	iowrite8(0, &amp;card-&gt;dpram[DPRAM_RESET_RX_FIFO]);
</I>&gt;<i> +	iowrite8(0, &amp;card-&gt;dpram[DPRAM_RESET_RX_FIFO+1]);
</I>&gt;<i> +	iowrite8(1, &amp;card-&gt;dpram[DPRAM_RESET]);
</I>&gt;<i> +	iowrite8(0, &amp;card-&gt;dpram[DPRAM_RESET+1]);
</I>&gt;<i> +	/* sync */
</I>&gt;<i> +	if (softing_fct_cmd(card, 99, 0x55, &quot;sync-a&quot;))
</I>&gt;<i> +		goto open_failed;
</I>&gt;<i> +	if (softing_fct_cmd(card, 99, 0xaa, &quot;sync-a&quot;))
</I>&gt;<i> +		goto open_failed;
</I>&gt;<i> +	/* reset chip */
</I>&gt;<i> +	if (softing_fct_cmd(card, 0, 0, &quot;reset_chip&quot;))
</I>&gt;<i> +		goto open_failed;
</I>&gt;<i> +	/* get_serial */
</I>&gt;<i> +	if (softing_fct_cmd(card, 43, 0, &quot;get_serial_number&quot;))
</I>&gt;<i> +		goto open_failed;
</I>&gt;<i> +	card-&gt;id.serial = ioread32(&amp;card-&gt;dpram[DPRAM_FCT_PARAM]);
</I>&gt;<i> +	/* get_version */
</I>&gt;<i> +	if (softing_fct_cmd(card, 12, 0, &quot;get_version&quot;))
</I>&gt;<i> +		goto open_failed;
</I>&gt;<i> +	card-&gt;id.fw = ioread16(&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
</I>&gt;<i> +	card-&gt;id.hw = ioread16(&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 4]);
</I>&gt;<i> +	card-&gt;id.lic = ioread16(&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 6]);
</I>&gt;<i> +	card-&gt;id.chip[0] = ioread16(&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 8]);
</I>&gt;<i> +	card-&gt;id.chip[1] = ioread16(&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 10]);
</I>&gt;<i> +
</I>&gt;<i> +	dev_info(&amp;card-&gt;pdev-&gt;dev, &quot;card booted, type %s, &quot;
</I>&gt;<i> +			&quot;serial %u, fw %u, hw %u, lic %u, chip (%u,%u)\n&quot;,
</I>&gt;<i> +		  card-&gt;pdat-&gt;name, card-&gt;id.serial, card-&gt;id.fw, card-&gt;id.hw,
</I>&gt;<i> +		  card-&gt;id.lic, card-&gt;id.chip[0], card-&gt;id.chip[1]);
</I>&gt;<i> +
</I>&gt;<i> +	card-&gt;fw.up = 1;
</I>&gt;<i> +	mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +open_failed:
</I>&gt;<i> +	card-&gt;fw.up = 0;
</I>&gt;<i> +	if (card-&gt;pdat-&gt;enable_irq)
</I>&gt;<i> +		card-&gt;pdat-&gt;enable_irq(card-&gt;pdev, 0);
</I>&gt;<i> +	softing_set_reset_dpram(card);
</I>&gt;<i> +	if (card-&gt;pdat-&gt;reset)
</I>&gt;<i> +		card-&gt;pdat-&gt;reset(card-&gt;pdev, 1);
</I>&gt;<i> +	mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i> +	return -EIO;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * netdev sysfs
</I>&gt;<i> + */
</I>&gt;<i> +static ssize_t show_channel(struct device *dev
</I>&gt;<i> +		, struct device_attribute *attr, char *buf)
</I>
See general comments. Here and for the following function declarations.

&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = to_net_dev(dev);
</I>&gt;<i> +	struct softing_priv *priv = netdev2softing(ndev);
</I>&gt;<i> +	return sprintf(buf, &quot;%i\n&quot;, priv-&gt;index);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static ssize_t show_chip(struct device *dev
</I>&gt;<i> +		, struct device_attribute *attr, char *buf)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = to_net_dev(dev);
</I>&gt;<i> +	struct softing_priv *priv = netdev2softing(ndev);
</I>&gt;<i> +	return sprintf(buf, &quot;%i\n&quot;, priv-&gt;chip);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static ssize_t show_output(struct device *dev
</I>&gt;<i> +		, struct device_attribute *attr, char *buf)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = to_net_dev(dev);
</I>&gt;<i> +	struct softing_priv *priv = netdev2softing(ndev);
</I>&gt;<i> +	return sprintf(buf, &quot;0x%02x\n&quot;, priv-&gt;output);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static ssize_t store_output(struct device *dev
</I>&gt;<i> +		, struct device_attribute *attr
</I>&gt;<i> +		, const char *buf, size_t count)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = to_net_dev(dev);
</I>&gt;<i> +	struct softing_priv *priv = netdev2softing(ndev);
</I>&gt;<i> +	struct softing *card = priv-&gt;card;
</I>&gt;<i> +	unsigned long val;
</I>&gt;<i> +	int ret;
</I>&gt;<i> +
</I>&gt;<i> +	ret = strict_strtoul(buf, 0, &amp;val);
</I>&gt;<i> +	if (ret &lt; 0)
</I>&gt;<i> +		return ret;
</I>&gt;<i> +	val &amp;= 0xFF;
</I>&gt;<i> +
</I>&gt;<i> +	ret = mutex_lock_interruptible(&amp;card-&gt;fw.lock);
</I>&gt;<i> +	if (ret)
</I>&gt;<i> +		return -ERESTARTSYS;
</I>&gt;<i> +	if (netif_running(ndev)) {
</I>&gt;<i> +		mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i> +		return -EBUSY;
</I>&gt;<i> +	}
</I>&gt;<i> +	priv-&gt;output = val;
</I>&gt;<i> +	mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i> +	return count;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static const DEVICE_ATTR(channel, S_IRUGO, show_channel, NULL);
</I>&gt;<i> +static const DEVICE_ATTR(chip, S_IRUGO, show_chip, NULL);
</I>&gt;<i> +static const DEVICE_ATTR(output, S_IRUGO | S_IWUSR, show_output, store_output);
</I>&gt;<i> +
</I>&gt;<i> +static const struct attribute *const netdev_sysfs_attrs[] = {
</I>&gt;<i> +	&amp;dev_attr_channel.attr,
</I>&gt;<i> +	&amp;dev_attr_chip.attr,
</I>&gt;<i> +	&amp;dev_attr_output.attr,
</I>&gt;<i> +	NULL,
</I>&gt;<i> +};
</I>&gt;<i> +static const struct attribute_group netdev_sysfs_group = {
</I>&gt;<i> +	.name  = NULL,
</I>&gt;<i> +	.attrs = (struct attribute **)netdev_sysfs_attrs,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static const struct net_device_ops softing_netdev_ops = {
</I>&gt;<i> +	.ndo_open = softing_netdev_open,
</I>&gt;<i> +	.ndo_stop = softing_netdev_stop,
</I>&gt;<i> +	.ndo_start_xmit	= softing_netdev_start_xmit,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static const struct can_bittiming_const softing_btr_const = {
</I>&gt;<i> +	.tseg1_min = 1,
</I>&gt;<i> +	.tseg1_max = 16,
</I>&gt;<i> +	.tseg2_min = 1,
</I>&gt;<i> +	.tseg2_max = 8,
</I>&gt;<i> +	.sjw_max = 4, /* overruled */
</I>&gt;<i> +	.brp_min = 1,
</I>&gt;<i> +	.brp_max = 32, /* overruled */
</I>&gt;<i> +	.brp_inc = 1,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static struct net_device *softing_netdev_create(
</I>&gt;<i> +		struct softing *card, u16 chip_id)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	struct softing_priv *priv;
</I>&gt;<i> +
</I>&gt;<i> +	netdev = alloc_candev(sizeof(*priv), TX_ECHO_SKB_MAX);
</I>&gt;<i> +	if (!netdev) {
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;alloc_candev failed\n&quot;);
</I>&gt;<i> +		return NULL;
</I>&gt;<i> +	}
</I>&gt;<i> +	priv = netdev_priv(netdev);
</I>&gt;<i> +	priv-&gt;netdev = netdev;
</I>&gt;<i> +	priv-&gt;card = card;
</I>&gt;<i> +	memcpy(&amp;priv-&gt;btr_const, &amp;softing_btr_const, sizeof(priv-&gt;btr_const));
</I>&gt;<i> +	priv-&gt;btr_const.brp_max = card-&gt;pdat-&gt;max_brp;
</I>&gt;<i> +	priv-&gt;btr_const.sjw_max = card-&gt;pdat-&gt;max_sjw;
</I>&gt;<i> +	priv-&gt;can.bittiming_const = &amp;priv-&gt;btr_const;
</I>&gt;<i> +	priv-&gt;can.clock.freq = 8000000;
</I>
Another magic constant.

&gt;<i> +	priv-&gt;chip = chip_id;
</I>&gt;<i> +	priv-&gt;output = softing_default_output(netdev);
</I>&gt;<i> +	SET_NETDEV_DEV(netdev, &amp;card-&gt;pdev-&gt;dev);
</I>&gt;<i> +
</I>&gt;<i> +	netdev-&gt;flags |= IFF_ECHO;
</I>&gt;<i> +	netdev-&gt;netdev_ops	= &amp;softing_netdev_ops;
</I>&gt;<i> +	priv-&gt;can.do_set_mode	= softing_candev_set_mode;
</I>
See general comments.

&gt;<i> +	priv-&gt;can.ctrlmode_supported =
</I>&gt;<i> +		CAN_CTRLMODE_3_SAMPLES;/* | CAN_CTRLMODE_BERR_REPORTING */;
</I>
Hm, any chance to support CAN_CTRLMODE_BERR_REPORTING? If not, please
remove the comment.

&gt;<i> +	return netdev;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int softing_netdev_register(struct net_device *netdev)
</I>&gt;<i> +{
</I>&gt;<i> +	int ret;
</I>&gt;<i> +
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * provide bus-specific sysfs attributes _during_ the uevent
</I>&gt;<i> +	 */
</I>&gt;<i> +	netdev-&gt;sysfs_groups[0] = &amp;netdev_sysfs_group;
</I>&gt;<i> +	ret = register_candev(netdev);
</I>&gt;<i> +	if (ret) {
</I>&gt;<i> +		dev_alert(&amp;netdev-&gt;dev, &quot;register failed\n&quot;);
</I>&gt;<i> +		return ret;
</I>&gt;<i> +	}
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void softing_netdev_cleanup(struct net_device *netdev)
</I>&gt;<i> +{
</I>&gt;<i> +	unregister_candev(netdev);
</I>&gt;<i> +	free_candev(netdev);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * sysfs for Platform device
</I>&gt;<i> + */
</I>&gt;<i> +#define DEV_ATTR_RO(name, member) \
</I>&gt;<i> +static ssize_t show_##name(struct device *dev, \
</I>&gt;<i> +		struct device_attribute *attr, char *buf) \
</I>&gt;<i> +{ \
</I>&gt;<i> +	struct softing *card = platform_get_drvdata(to_platform_device(dev)); \
</I>&gt;<i> +	return sprintf(buf, &quot;%u\n&quot;, card-&gt;member); \
</I>&gt;<i> +} \
</I>&gt;<i> +static DEVICE_ATTR(name, 0444, show_##name, NULL)
</I>&gt;<i> +
</I>&gt;<i> +DEV_ATTR_RO(serial	, id.serial);
</I>&gt;<i> +DEV_ATTR_RO(firmware	, id.fw);
</I>&gt;<i> +DEV_ATTR_RO(hardware	, id.hw);
</I>&gt;<i> +DEV_ATTR_RO(license	, id.lic);
</I>&gt;<i> +DEV_ATTR_RO(freq	, id.freq);
</I>&gt;<i> +DEV_ATTR_RO(txpending	, tx.pending);
</I>&gt;<i> +
</I>&gt;<i> +static struct attribute *softing_pdev_attrs[] = {
</I>&gt;<i> +	&amp;dev_attr_serial.attr,
</I>&gt;<i> +	&amp;dev_attr_firmware.attr,
</I>&gt;<i> +	&amp;dev_attr_hardware.attr,
</I>&gt;<i> +	&amp;dev_attr_license.attr,
</I>&gt;<i> +	&amp;dev_attr_freq.attr,
</I>&gt;<i> +	&amp;dev_attr_txpending.attr,
</I>&gt;<i> +	NULL,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static const struct attribute_group softing_pdev_group = {
</I>&gt;<i> +	.attrs = softing_pdev_attrs,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * platform driver
</I>&gt;<i> + */
</I>&gt;<i> +static int softing_pdev_remove(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct softing *card = platform_get_drvdata(pdev);
</I>&gt;<i> +	int j;
</I>&gt;<i> +
</I>&gt;<i> +	/* first, disable card*/
</I>&gt;<i> +	softing_card_shutdown(card);
</I>&gt;<i> +
</I>&gt;<i> +	for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
</I>&gt;<i> +		if (!card-&gt;net[j])
</I>&gt;<i> +			continue;
</I>&gt;<i> +		softing_netdev_cleanup(card-&gt;net[j]);
</I>&gt;<i> +		card-&gt;net[j] = NULL;
</I>&gt;<i> +	}
</I>&gt;<i> +	sysfs_remove_group(&amp;pdev-&gt;dev.kobj, &amp;softing_pdev_group);
</I>&gt;<i> +
</I>&gt;<i> +	iounmap(card-&gt;dpram);
</I>&gt;<i> +	kfree(card);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int softing_pdev_probe(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	const struct softing_platform_data *pdat = pdev-&gt;dev.platform_data;
</I>&gt;<i> +	struct softing *card;
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	struct softing_priv *priv;
</I>&gt;<i> +	struct resource *pres;
</I>&gt;<i> +	int ret;
</I>&gt;<i> +	int j;
</I>&gt;<i> +
</I>&gt;<i> +	if (!pdat) {
</I>&gt;<i> +		dev_warn(&amp;pdev-&gt;dev, &quot;no platform data\n&quot;);
</I>&gt;<i> +		return -EINVAL;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (pdat-&gt;nbus &gt; ARRAY_SIZE(card-&gt;net)) {
</I>&gt;<i> +		dev_warn(&amp;pdev-&gt;dev, &quot;%u nets??\n&quot;, pdat-&gt;nbus);
</I>&gt;<i> +		return -EINVAL;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	card = kzalloc(sizeof(*card), GFP_KERNEL);
</I>&gt;<i> +	if (!card)
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	card-&gt;pdat = pdat;
</I>&gt;<i> +	card-&gt;pdev = pdev;
</I>&gt;<i> +	platform_set_drvdata(pdev, card);
</I>&gt;<i> +	/* try_module_get(THIS_MODULE); */
</I>&gt;<i> +	mutex_init(&amp;card-&gt;fw.lock);
</I>&gt;<i> +	spin_lock_init(&amp;card-&gt;spin);
</I>&gt;<i> +
</I>&gt;<i> +	ret = -EINVAL;
</I>&gt;<i> +	pres = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;<i> +	if (!pres)
</I>&gt;<i> +		goto platform_resource_failed;;
</I>&gt;<i> +	card-&gt;dpram_phys = pres-&gt;start;
</I>&gt;<i> +	card-&gt;dpram_size = pres-&gt;end - pres-&gt;start + 1;
</I>&gt;<i> +	card-&gt;dpram = ioremap_nocache(card-&gt;dpram_phys, card-&gt;dpram_size);
</I>&gt;<i> +	if (!card-&gt;dpram) {
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;dpram ioremap failed\n&quot;);
</I>&gt;<i> +		goto ioremap_failed;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	pres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
</I>&gt;<i> +	if (pres)
</I>&gt;<i> +		card-&gt;irq.nr = pres-&gt;start;
</I>&gt;<i> +
</I>&gt;<i> +	/* reset card */
</I>&gt;<i> +	ret = -EIO;
</I>&gt;<i> +	if (softing_card_boot(card)) {
</I>&gt;<i> +		dev_alert(&amp;pdev-&gt;dev, &quot;failed to boot\n&quot;);
</I>&gt;<i> +		goto boot_failed;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* only now, the chip's are known */
</I>&gt;<i> +	card-&gt;id.freq = card-&gt;pdat-&gt;freq * 1000000UL;
</I>
It would be more flexible to specific the frequency in Hz!? Or use a
more logical member name, frey_mhz, at least.

&gt;<i> +
</I>&gt;<i> +	ret = sysfs_create_group(&amp;pdev-&gt;dev.kobj, &amp;softing_pdev_group);
</I>&gt;<i> +	if (ret &lt; 0) {
</I>&gt;<i> +		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;sysfs failed\n&quot;);
</I>&gt;<i> +		goto sysfs_failed;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	ret = -ENOMEM;
</I>&gt;<i> +	for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
</I>&gt;<i> +		card-&gt;net[j] = netdev =
</I>&gt;<i> +			softing_netdev_create(card, card-&gt;id.chip[j]);
</I>&gt;<i> +		if (!netdev) {
</I>&gt;<i> +			dev_alert(&amp;pdev-&gt;dev, &quot;failed to make can[%i]&quot;, j);
</I>&gt;<i> +			goto netdev_failed;
</I>&gt;<i> +		}
</I>&gt;<i> +		priv = netdev_priv(card-&gt;net[j]);
</I>&gt;<i> +		priv-&gt;index = j;
</I>&gt;<i> +		ret = softing_netdev_register(netdev);
</I>&gt;<i> +		if (ret) {
</I>&gt;<i> +			free_candev(netdev);
</I>&gt;<i> +			card-&gt;net[j] = NULL;
</I>&gt;<i> +			dev_alert(&amp;card-&gt;pdev-&gt;dev,
</I>&gt;<i> +				&quot;failed to register can[%i]\n&quot;, j);
</I>&gt;<i> +			goto netdev_failed;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +	dev_info(&amp;card-&gt;pdev-&gt;dev, &quot;card initialised\n&quot;);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +netdev_failed:
</I>&gt;<i> +	for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
</I>&gt;<i> +		if (!card-&gt;net[j])
</I>&gt;<i> +			continue;
</I>&gt;<i> +		softing_netdev_cleanup(card-&gt;net[j]);
</I>&gt;<i> +	}
</I>&gt;<i> +	sysfs_remove_group(&amp;pdev-&gt;dev.kobj, &amp;softing_pdev_group);
</I>&gt;<i> +sysfs_failed:
</I>&gt;<i> +	softing_card_shutdown(card);
</I>&gt;<i> +boot_failed:
</I>&gt;<i> +	iounmap(card-&gt;dpram);
</I>&gt;<i> +ioremap_failed:
</I>&gt;<i> +platform_resource_failed:
</I>&gt;<i> +	kfree(card);
</I>&gt;<i> +	return ret;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static struct platform_driver softing_driver = {
</I>&gt;<i> +	.driver = {
</I>&gt;<i> +		.name = &quot;softing&quot;,
</I>&gt;<i> +		.owner = THIS_MODULE,
</I>&gt;<i> +	},
</I>&gt;<i> +	.probe = softing_pdev_probe,
</I>&gt;<i> +	.remove = softing_pdev_remove,
</I>&gt;<i> +};
</I>
I'm missing the use of __devinit and friends.


&gt;<i> +MODULE_ALIAS(&quot;platform:softing&quot;);
</I>&gt;<i> +
</I>&gt;<i> +static int __init softing_start(void)
</I>&gt;<i> +{
</I>&gt;<i> +	return platform_driver_register(&amp;softing_driver);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void __exit softing_stop(void)
</I>&gt;<i> +{
</I>&gt;<i> +	platform_driver_unregister(&amp;softing_driver);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +module_init(softing_start);
</I>&gt;<i> +module_exit(softing_stop);
</I>&gt;<i> +
</I>&gt;<i> +MODULE_DESCRIPTION(&quot;Softing DPRAM CAN driver&quot;);
</I>&gt;<i> +MODULE_AUTHOR(&quot;Kurt Van Dijck &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kurt.van.dijck at eia.be</A>&gt;&quot;);
</I>&gt;<i> +MODULE_LICENSE(&quot;GPL&quot;);
</I>
GPL v2 ?

&gt;<i> diff --git a/drivers/net/can/softing/softing_platform.h b/drivers/net/can/softing/softing_platform.h
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..678df36
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/softing/softing_platform.h
</I>&gt;<i> @@ -0,0 +1,38 @@
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/platform_device.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#ifndef _SOFTING_DEVICE_H_
</I>&gt;<i> +#define _SOFTING_DEVICE_H_
</I>&gt;<i> +
</I>&gt;<i> +/* softing firmware directory prefix */
</I>&gt;<i> +#define fw_dir &quot;softing-4.6/&quot;
</I>&gt;<i> +
</I>&gt;<i> +struct softing_platform_data {
</I>&gt;<i> +	unsigned int manf;
</I>&gt;<i> +	unsigned int prod;
</I>&gt;<i> +	/* generation
</I>&gt;<i> +	 * 1st with NEC or SJA1000
</I>&gt;<i> +	 * 8bit, exclusive interrupt, ...
</I>&gt;<i> +	 * 2nd only SJA1000
</I>&gt;<i> +	 * 16bit, shared interrupt
</I>&gt;<i> +	 */
</I>
Please the usual multiline comment style.

&gt;<i> +	int generation;
</I>&gt;<i> +	int nbus; /* # busses on device */
</I>&gt;<i> +	unsigned int freq; /* crystal in MHz */
</I>&gt;<i> +	unsigned int max_brp;
</I>&gt;<i> +	unsigned int max_sjw;
</I>&gt;<i> +	unsigned long dpram_size;
</I>&gt;<i> +	char name[32];
</I>&gt;<i> +	struct {
</I>&gt;<i> +		unsigned long offs;
</I>&gt;<i> +		unsigned long addr;
</I>&gt;<i> +		const char *fw;
</I>&gt;<i> +	} boot, load, app;
</I>&gt;<i> +	/* reset() function, bring pdev in or out of reset, depending on
</I>&gt;<i> +	   value */
</I>&gt;<i> +	int (*reset)(struct platform_device *pdev, int value);
</I>&gt;<i> +	int (*enable_irq)(struct platform_device *pdev, int value);
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>
Wolfgang.

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005287.html">[PATCH net-next-2.6 v2 1/2] can: add driver for Softing card
</A></li>
	<LI>Next message: <A HREF="005305.html">[PATCH net-next-2.6 v2 1/2] can: add driver for Softing card
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5294">[ date ]</a>
              <a href="thread.html#5294">[ thread ]</a>
              <a href="subject.html#5294">[ subject ]</a>
              <a href="author.html#5294">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
