<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Socketcan-users] Looping back TX messages
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2006-September/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BSocketcan-users%5D%20Looping%20back%20TX%20messages&In-Reply-To=%3C44FB1735.9030809%40grandegger.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000335.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Socketcan-users] Looping back TX messages</H1>
    <B>Wolfgang Grandegger</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BSocketcan-users%5D%20Looping%20back%20TX%20messages&In-Reply-To=%3C44FB1735.9030809%40grandegger.com%3E"
       TITLE="[Socketcan-users] Looping back TX messages">wg at grandegger.com
       </A><BR>
    <I>Sun Sep  3 19:56:05 CEST 2006</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000335.html">[Socketcan-users] Looping back TX messages
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#333">[ date ]</a>
              <a href="thread.html#333">[ thread ]</a>
              <a href="subject.html#333">[ subject ]</a>
              <a href="author.html#333">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Oliver,

Oliver Hartkopp wrote:
&gt;<i> Jan Kiszka wrote:
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> Urs Thuermann wrote:
</I>&gt;&gt;<i>   
</I>&gt;&gt;&gt;&gt;&gt;<i> Since we are talking about a multiuser and multitasking system where
</I>&gt;&gt;&gt;&gt;&gt;<i> many processes run on the same machine, several of which may use CAN
</I>&gt;&gt;&gt;&gt;&gt;<i> sockets, IMO the default should be to do loopback, so that different
</I>&gt;&gt;&gt;&gt;&gt;<i> sockets in different processes can see packets generated by other
</I>&gt;&gt;&gt;&gt;&gt;<i> sockets.  If one knows he's the only one on the system using a CAN
</I>&gt;&gt;&gt;&gt;&gt;<i> socket (or a CAN socket bound to some specific CAN ID), he can disable
</I>&gt;&gt;&gt;&gt;&gt;<i> the default behaviour with the socket option.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>     
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Don't forget the masses of user porting over from &quot;classic&quot; CAN APIs.
</I>&gt;&gt;&gt;<i> They don't expect loopback, they likely don't care about it (until
</I>&gt;&gt;&gt;<i> someone tells them that it can cause workload/WCET spikes for their
</I>&gt;&gt;&gt;<i> use-cases), they are mostly interested in similar interfaces.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> IMOH, Socket-CAN should not try to evangelise users where it is not
</I>&gt;&gt;&gt;<i> required. Rather, it should provide clear interfaces to let them pick
</I>&gt;&gt;&gt;<i> /their/ preferred behaviour.
</I>&gt;&gt;<i>   
</I>&gt;<i> 
</I>&gt;<i> Hi Jan,
</I>&gt;<i> 
</I>&gt;<i> if your major concern is the porting from 'classic' CAN APIs and the
</I>&gt;<i> expectations from the masses please tell me why they should use
</I>&gt;<i> socket-can anyhow? Isn't Char-device enough? And which 'masses' are
</I>&gt;<i> considered here? The masses of CAN-programmers or the masses of
</I>&gt;<i> Socket-programmers?
</I>&gt;<i> 
</I>&gt;<i>  ;-) 
</I>&gt;<i> 
</I>&gt;<i> I think the right way is somewhere in between:
</I>&gt;<i> 
</I>&gt;<i> Define the CAN API for socket-can as clean as possible to behave like the
</I>&gt;<i> masses of Socket-programmers (its named socket-can!)  would expect but also
</I>&gt;<i> meet the needs of the guys porting from 'single user CAN' (a bit like legacy
</I>&gt;<i> support in other new technologies).
</I>&gt;<i> 
</I>&gt;<i> IMO the SUCPs (single user CAN programmers) expect not receiving what they
</I>&gt;<i> have sent on their socket. And the SUCPs do not think about other
</I>&gt;<i> applications on their machine - so the loopback does not affect them as they
</I>&gt;<i> do not recognize it (as SUCP). Maybe they recognize it later (and then they
</I>&gt;<i> will love it - e.g. using a candump tool locally).
</I>&gt;<i> 
</I>&gt;<i> The SPs (socket programmers) expect having on all sockets the same behaviour
</I>&gt;<i> to access the CAN and that they even get back the 'broadcasted' Frames
</I>&gt;<i> they've sent. (Yes, Urs expected this!)
</I>&gt;<i> 
</I>&gt;<i> So loopback is mandatory (and in the first glance not seen by SUCPs).
</I>&gt;<i> Receiving their own sent frames must be possible (to have a real
</I>&gt;<i> broadcast/multicast behaviour for SPs).
</I>&gt;<i> 
</I>&gt;<i> As most of the SUCPs getting in contact with socket-can will use the
</I>&gt;<i> RAW-socket first, it should be default NOT to receive the own sent frames to
</I>&gt;<i> meet the mostly expected behaviour. If there is a SP who want's it all, he
</I>&gt;<i> can use sockopt (he knows good).
</I>&gt;<i> 
</I>&gt;<i> Disabling loopback for one socket is a power-user feature to save resources
</I>&gt;<i> but breaks with the original CAN broadcasting idea. So at this point this
</I>&gt;<i> power-user also knows sockopts and can use it.
</I>&gt;<i> 
</I>&gt;<i> So the differences on both sides and the resulting defaults are clear to me:
</I>&gt;<i> 
</I>&gt;<i> Create two sockopts for CAN_RAW-specialists:
</I>&gt;<i> - one to disable loopback
</I>&gt;<i> - one to receive even the own sent frames
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> IMOH, Socket-CAN should not try to evangelise users where it is not
</I>&gt;&gt;&gt;<i> required. Rather, it should provide clear interfaces to let them pick
</I>&gt;&gt;&gt;<i> /their/ preferred behaviour.
</I>&gt;&gt;<i>   
</I>&gt;<i> 
</I>&gt;<i> Done!
</I>
OK, so far you and Urs have been happy with the loopback solution in the 
Linux socket-can driver and you didn't miss the ability to switch it 
off. Jan and I still prefer the implementation via protocol because we 
want to keep it simple and are concerned about the RT latency. I think
a resonable minimal solution for the time being could be the use of:

	socket(PF_CAN, SOCK_RAW, CAN_PROTO_NET); /* local loopback */
	socket(PF_CAN, SOCK_RAW, CAN_PROTO_DEVICE); /* no loopback */

         #define CAN_PROTO_NET 0     (or maybe better CAN_RAW_NET?)
         #define CAN_PROTO_DEVICE 1  (or maybe bettr CAN_RAW_DEVICE?)
	
The default &quot;0&quot; is what your current implementation does. You have to 
change nothing. If in the future, there is the need to change the 
behavior as well, we could still implement an appropriate socket option.

What do you think? Would the names be OK?

Wolfgang.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000335.html">[Socketcan-users] Looping back TX messages
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#333">[ date ]</a>
              <a href="thread.html#333">[ thread ]</a>
              <a href="subject.html#333">[ subject ]</a>
              <a href="author.html#333">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
