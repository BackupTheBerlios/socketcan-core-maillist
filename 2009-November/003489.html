<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH] net/can: add driver for mscan family &amp; mpc52xx_mscan
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-November/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20net/can%3A%20add%20driver%20for%20mscan%20family%20%26%20mpc52xx_mscan&In-Reply-To=%3C1258128892-28800-1-git-send-email-w.sang%40pengutronix.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003482.html">
   <LINK REL="Next"  HREF="003493.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH] net/can: add driver for mscan family &amp; mpc52xx_mscan</H1>
    <B>Wolfram Sang</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20net/can%3A%20add%20driver%20for%20mscan%20family%20%26%20mpc52xx_mscan&In-Reply-To=%3C1258128892-28800-1-git-send-email-w.sang%40pengutronix.de%3E"
       TITLE="[PATCH] net/can: add driver for mscan family &amp; mpc52xx_mscan">w.sang at pengutronix.de
       </A><BR>
    <I>Fri Nov 13 17:14:52 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003482.html">[PATCH] mscan: fix bus-off recovery procedure
</A></li>
        <LI>Next message: <A HREF="003493.html">[PATCH] net/can: add driver for mscan family &amp; mpc52xx_mscan
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3489">[ date ]</a>
              <a href="thread.html#3489">[ thread ]</a>
              <a href="subject.html#3489">[ subject ]</a>
              <a href="author.html#3489">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Taken from socketcan-svn, fixed remaining todos, cleaned up, tested with a
phyCORE-MPC5200B-IO and a custom board.

Signed-off-by: Wolfram Sang &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">w.sang at pengutronix.de</A>&gt;
Cc: Wolfgang Grandegger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">wg at grandegger.com</A>&gt;
Cc: Grant Likely &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">grant.likely at secretlab.ca</A>&gt;
Cc: David Miller &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">davem at davemloft.net</A>&gt;
---

This patch is based on net-next as of yesterday.

To make the review easier for those who are already familiar with earlier
versions of this driver (especially for Wolfgang), I put my development branch
online, so you can check my changes incrementally:

<A HREF="http://git.pengutronix.de/?p=wsa/linux-2.6.git;a=summary">http://git.pengutronix.de/?p=wsa/linux-2.6.git;a=summary</A>

 Documentation/powerpc/dts-bindings/fsl/mpc5200.txt |    9 +
 drivers/net/can/Kconfig                            |   19 +
 drivers/net/can/Makefile                           |    1 +
 drivers/net/can/mscan/Makefile                     |    5 +
 drivers/net/can/mscan/mpc52xx_can.c                |  279 ++++++++
 drivers/net/can/mscan/mscan.c                      |  699 ++++++++++++++++++++
 drivers/net/can/mscan/mscan.h                      |  262 ++++++++
 7 files changed, 1274 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/can/mscan/Makefile
 create mode 100644 drivers/net/can/mscan/mpc52xx_can.c
 create mode 100644 drivers/net/can/mscan/mscan.c
 create mode 100644 drivers/net/can/mscan/mscan.h

diff --git a/Documentation/powerpc/dts-bindings/fsl/mpc5200.txt b/Documentation/powerpc/dts-bindings/fsl/mpc5200.txt
index 8447fd7..b151fb1 100644
--- a/Documentation/powerpc/dts-bindings/fsl/mpc5200.txt
+++ b/Documentation/powerpc/dts-bindings/fsl/mpc5200.txt
@@ -178,3 +178,12 @@ External interrupts:
 	external irq3:	interrupts = &lt;1 3 n&gt;;
 'n' is sense (0: level high, 1: edge rising, 2: edge falling 3: level low)
 
+fsl,mpc5200-mscan nodes
+-----------------------
+In addition to the required compatible-, reg- and interrupt-properites, you can
+also specify which clock shall be used for the bus:
+
+- fsl,mscan-clk-src	- a string describing the clock source. Valid values
+			  are &quot;ip&quot; for IP_CLK and &quot;sys&quot; for SYS_XTAL.
+			  &quot;sys&quot; is the default in case the property is not
+			  present.
diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
index b819cc2..c16e6ff 100644
--- a/drivers/net/can/Kconfig
+++ b/drivers/net/can/Kconfig
@@ -108,6 +108,25 @@ config CAN_MCP251X
 	---help---
 	  Driver for the Microchip MCP251x SPI CAN controllers.
 
+config CAN_MSCAN
+	depends on CAN_DEV &amp;&amp; (PPC || M68K || M68KNOMMU)
+	tristate &quot;Support for Freescale MSCAN based chips&quot;
+	---help---
+	  The Motorola Scalable Controller Area Network (MSCAN) definition
+	  is based on the MSCAN12 definition which is the specific
+	  implementation of the Motorola Scalable CAN concept targeted for
+	  the Motorola MC68HC12 Microcontroller Family.
+
+config CAN_MPC52XX
+	tristate &quot;Freescale MPC5xxx onboard CAN controller&quot;
+	depends on CAN_MSCAN &amp;&amp; PPC_MPC52xx
+	---help---
+	  If you say yes here you get support for Freescale's MPC52xx
+	  onboard dualCAN controller.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called mpc5xxx_can.
+
 config CAN_DEBUG_DEVICES
 	bool &quot;CAN devices debugging messages&quot;
 	depends on CAN
diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
index 1489181..56899fe 100644
--- a/drivers/net/can/Makefile
+++ b/drivers/net/can/Makefile
@@ -10,6 +10,7 @@ can-dev-y			:= dev.o
 obj-y				+= usb/
 
 obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
+obj-$(CONFIG_CAN_MSCAN)		+= mscan/
 obj-$(CONFIG_CAN_AT91)		+= at91_can.o
 obj-$(CONFIG_CAN_TI_HECC)	+= ti_hecc.o
 obj-$(CONFIG_CAN_MCP251X)	+= mcp251x.o
diff --git a/drivers/net/can/mscan/Makefile b/drivers/net/can/mscan/Makefile
new file mode 100644
index 0000000..2bd9f04
--- /dev/null
+++ b/drivers/net/can/mscan/Makefile
@@ -0,0 +1,5 @@
+
+obj-$(CONFIG_CAN_MPC52XX)	+= mscan-mpc52xx.o
+mscan-mpc52xx-objs		:= mscan.o mpc52xx_can.o
+
+ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
diff --git a/drivers/net/can/mscan/mpc52xx_can.c b/drivers/net/can/mscan/mpc52xx_can.c
new file mode 100644
index 0000000..4707a82
--- /dev/null
+++ b/drivers/net/can/mscan/mpc52xx_can.c
@@ -0,0 +1,279 @@
+/*
+ * CAN bus driver for the Freescale MPC5xxx embedded CPU.
+ *
+ * Copyright (C) 2004-2005 Andrey Volkov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">avolkov at varma-el.com</A>&gt;,
+ *                         Varma Electronics Oy
+ * Copyright (C) 2008-2009 Wolfgang Grandegger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">wg at grandegger.com</A>&gt;
+ * Copyright (C) 2009 Wolfram Sang, Pengutronix &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">w.sang at pengutronix.de</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/platform_device.h&gt;
+#include &lt;linux/netdevice.h&gt;
+#include &lt;linux/can.h&gt;
+#include &lt;linux/can/dev.h&gt;
+#include &lt;linux/of_platform.h&gt;
+#include &lt;sysdev/fsl_soc.h&gt;
+#include &lt;linux/io.h&gt;
+#include &lt;asm/mpc52xx.h&gt;
+
+#include &quot;mscan.h&quot;
+
+
+#define DRV_NAME &quot;mpc5xxx_can&quot;
+
+static struct of_device_id mpc52xx_cdm_ids[] __devinitdata = {
+	{ .compatible = &quot;fsl,mpc5200-cdm&quot;, },
+	{ .compatible = &quot;fsl,mpc5200b-cdm&quot;, },
+	{}
+};
+
+/*
+ * Get the frequency of the external oscillator clock connected
+ * to the SYS_XTAL_IN pin, or return 0 if it cannot be determined.
+ */
+static unsigned int  __devinit mpc52xx_can_xtal_freq(struct of_device *of)
+{
+	struct mpc52xx_cdm  __iomem *cdm;
+	struct device_node *np_cdm;
+	unsigned int freq;
+	u32 val;
+
+	freq = mpc5xxx_get_bus_frequency(of-&gt;node);
+	if (!freq)
+		return 0;
+
+	/*
+	 * Determine SYS_XTAL_IN frequency from the clock domain settings
+	 */
+	np_cdm = of_find_matching_node(NULL, mpc52xx_cdm_ids);
+	if (!np_cdm) {
+		dev_err(&amp;of-&gt;dev, &quot;can't get clock node!\n&quot;);
+		return 0;
+	}
+	cdm = of_iomap(np_cdm, 0);
+	of_node_put(np_cdm);
+
+	if (in_8(&amp;cdm-&gt;ipb_clk_sel) &amp; 0x1)
+		freq *= 2;
+	val  = in_be32(&amp;cdm-&gt;rstcfg);
+	if (val &amp; (1 &lt;&lt; 5))
+		freq *= 8;
+	else
+		freq *= 4;
+	if (val &amp; (1 &lt;&lt; 6))
+		freq /= 12;
+	else
+		freq /= 16;
+
+	iounmap(cdm);
+
+	return freq;
+}
+
+/*
+ * Get frequency of the MSCAN clock source
+ *
+ * Either the oscillator clock (SYS_XTAL_IN) or the IP bus clock (IP_CLK)
+ * can be selected. According to the MPC5200 user's manual, the oscillator
+ * clock is the better choice as it has less jitter but due to a hardware
+ * bug, it can not be selected for the old MPC5200 Rev. A chips.
+ */
+
+static unsigned int  __devinit mpc52xx_can_clock_freq(struct of_device *of,
+						      int clock_src)
+{
+	unsigned int pvr;
+
+	pvr = mfspr(SPRN_PVR);
+
+	if (clock_src == MSCAN_CLKSRC_BUS || pvr == 0x80822011)
+		return mpc5xxx_get_bus_frequency(of-&gt;node);
+
+	return mpc52xx_can_xtal_freq(of);
+}
+
+static int __devinit mpc5xxx_can_probe(struct of_device *ofdev,
+				       const struct of_device_id *id)
+{
+	struct device_node *np = ofdev-&gt;node;
+	struct net_device *dev;
+	struct mscan_priv *priv;
+	void __iomem *base;
+	const char *clk_src;
+	int err, irq, clock_src;
+
+	base = of_iomap(ofdev-&gt;node, 0);
+	if (!base) {
+		dev_err(&amp;ofdev-&gt;dev, &quot;couldn't ioremap\n&quot;);
+		err = -ENOMEM;
+		goto exit_release_mem;
+	}
+
+	irq = irq_of_parse_and_map(np, 0);
+	if (!irq) {
+		dev_err(&amp;ofdev-&gt;dev, &quot;no irq found\n&quot;);
+		err = -ENODEV;
+		goto exit_unmap_mem;
+	}
+
+	dev = alloc_mscandev();
+	if (!dev) {
+		err = -ENOMEM;
+		goto exit_dispose_irq;
+	}
+
+	priv = netdev_priv(dev);
+	priv-&gt;reg_base = base;
+	dev-&gt;irq = irq;
+
+	/*
+	 * Either the oscillator clock (SYS_XTAL_IN) or the IP bus clock
+	 * (IP_CLK) can be selected as MSCAN clock source. According to
+	 * the MPC5200 user's manual, the oscillator clock is the better
+	 * choice as it has less jitter. For this reason, it is selected
+	 * by default.
+	 */
+	clk_src = of_get_property(np, &quot;fsl,mscan-clk-src&quot;, NULL);
+	if (clk_src &amp;&amp; strcmp(clk_src, &quot;ip&quot;) == 0)
+		clock_src = MSCAN_CLKSRC_BUS;
+	else
+		clock_src = MSCAN_CLKSRC_XTAL;
+	priv-&gt;can.clock.freq = mpc52xx_can_clock_freq(ofdev, clock_src);
+	if (!priv-&gt;can.clock.freq) {
+		dev_err(&amp;ofdev-&gt;dev, &quot;couldn't get MSCAN clock frequency\n&quot;);
+		err = -ENODEV;
+		goto exit_free_mscan;
+	}
+
+	SET_NETDEV_DEV(dev, &amp;ofdev-&gt;dev);
+
+	err = register_mscandev(dev, clock_src);
+	if (err) {
+		dev_err(&amp;ofdev-&gt;dev, &quot;registering %s failed (err=%d)\n&quot;,
+			DRV_NAME, err);
+		goto exit_free_mscan;
+	}
+
+	dev_set_drvdata(&amp;ofdev-&gt;dev, dev);
+
+	dev_info(&amp;ofdev-&gt;dev, &quot;MSCAN at 0x%p, irq %d, clock %d Hz\n&quot;,
+		 priv-&gt;reg_base, dev-&gt;irq, priv-&gt;can.clock.freq);
+
+	return 0;
+
+exit_free_mscan:
+	free_candev(dev);
+exit_dispose_irq:
+	irq_dispose_mapping(irq);
+exit_unmap_mem:
+	iounmap(base);
+exit_release_mem:
+	return err;
+}
+
+static int __devexit mpc5xxx_can_remove(struct of_device *ofdev)
+{
+	struct net_device *dev = dev_get_drvdata(&amp;ofdev-&gt;dev);
+	struct mscan_priv *priv = netdev_priv(dev);
+
+	dev_set_drvdata(&amp;ofdev-&gt;dev, NULL);
+
+	unregister_mscandev(dev);
+	iounmap(priv-&gt;reg_base);
+	irq_dispose_mapping(dev-&gt;irq);
+	free_candev(dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static struct mscan_regs saved_regs;
+static int mpc5xxx_can_suspend(struct of_device *ofdev, pm_message_t state)
+{
+	struct net_device *dev = dev_get_drvdata(&amp;ofdev-&gt;dev);
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv-&gt;reg_base;
+
+	_memcpy_fromio(&amp;saved_regs, regs, sizeof(*regs));
+
+	return 0;
+}
+
+static int mpc5xxx_can_resume(struct of_device *ofdev)
+{
+	struct net_device *dev = dev_get_drvdata(&amp;ofdev-&gt;dev);
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv-&gt;reg_base;
+
+	regs-&gt;canctl0 |= MSCAN_INITRQ;
+	while ((regs-&gt;canctl1 &amp; MSCAN_INITAK) == 0)
+		udelay(10);
+
+	regs-&gt;canctl1 = saved_regs.canctl1;
+	regs-&gt;canbtr0 = saved_regs.canbtr0;
+	regs-&gt;canbtr1 = saved_regs.canbtr1;
+	regs-&gt;canidac = saved_regs.canidac;
+
+	/* restore masks, buffers etc. */
+	_memcpy_toio(&amp;regs-&gt;canidar1_0, (void *)&amp;saved_regs.canidar1_0,
+		     sizeof(*regs) - offsetof(struct mscan_regs, canidar1_0));
+
+	regs-&gt;canctl0 &amp;= ~MSCAN_INITRQ;
+	regs-&gt;cantbsel = saved_regs.cantbsel;
+	regs-&gt;canrier = saved_regs.canrier;
+	regs-&gt;cantier = saved_regs.cantier;
+	regs-&gt;canctl0 = saved_regs.canctl0;
+
+	return 0;
+}
+#endif
+
+static struct of_device_id __devinitdata mpc5xxx_can_table[] = {
+	{.compatible = &quot;fsl,mpc5200-mscan&quot;},
+	{.compatible = &quot;fsl,mpc5200b-mscan&quot;},
+	{},
+};
+
+static struct of_platform_driver mpc5xxx_can_driver = {
+	.owner = THIS_MODULE,
+	.name = &quot;mpc5xxx_can&quot;,
+	.probe = mpc5xxx_can_probe,
+	.remove = __devexit_p(mpc5xxx_can_remove),
+#ifdef CONFIG_PM
+	.suspend = mpc5xxx_can_suspend,
+	.resume = mpc5xxx_can_resume,
+#endif
+	.match_table = mpc5xxx_can_table,
+};
+
+static int __init mpc5xxx_can_init(void)
+{
+	return of_register_platform_driver(&amp;mpc5xxx_can_driver);
+}
+module_init(mpc5xxx_can_init);
+
+static void __exit mpc5xxx_can_exit(void)
+{
+	return of_unregister_platform_driver(&amp;mpc5xxx_can_driver);
+};
+module_exit(mpc5xxx_can_exit);
+
+MODULE_AUTHOR(&quot;Wolfgang Grandegger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">wg at grandegger.com</A>&gt;&quot;);
+MODULE_DESCRIPTION(&quot;Freescale MPC5200 CAN driver&quot;);
+MODULE_LICENSE(&quot;GPL v2&quot;);
diff --git a/drivers/net/can/mscan/mscan.c b/drivers/net/can/mscan/mscan.c
new file mode 100644
index 0000000..49542ca
--- /dev/null
+++ b/drivers/net/can/mscan/mscan.c
@@ -0,0 +1,699 @@
+/*
+ * CAN bus driver for the alone generic (as possible as) MSCAN controller.
+ *
+ * Copyright (C) 2005-2006 Andrey Volkov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">avolkov at varma-el.com</A>&gt;,
+ *                         Varma Electronics Oy
+ * Copyright (C) 2008-2009 Wolfgang Grandegger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">wg at grandegger.com</A>&gt;
+ * Copytight (C) 2008-2009 Pengutronix &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kernel at pengutronix.de</A>&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/delay.h&gt;
+#include &lt;linux/netdevice.h&gt;
+#include &lt;linux/if_arp.h&gt;
+#include &lt;linux/if_ether.h&gt;
+#include &lt;linux/list.h&gt;
+#include &lt;linux/can.h&gt;
+#include &lt;linux/can/dev.h&gt;
+#include &lt;linux/can/error.h&gt;
+#include &lt;linux/io.h&gt;
+
+#include &quot;mscan.h&quot;
+
+#define MSCAN_NORMAL_MODE	0
+#define MSCAN_SLEEP_MODE	MSCAN_SLPRQ
+#define MSCAN_INIT_MODE		(MSCAN_INITRQ | MSCAN_SLPRQ)
+#define MSCAN_POWEROFF_MODE	(MSCAN_CSWAI | MSCAN_SLPRQ)
+#define MSCAN_SET_MODE_RETRIES	255
+#define MSCAN_ECHO_SKB_MAX	3
+
+#define BTR0_BRP_MASK		0x3f
+#define BTR0_SJW_SHIFT		6
+#define BTR0_SJW_MASK		(0x3 &lt;&lt; BTR0_SJW_SHIFT)
+
+#define BTR1_TSEG1_MASK 	0xf
+#define BTR1_TSEG2_SHIFT	4
+#define BTR1_TSEG2_MASK 	(0x7 &lt;&lt; BTR1_TSEG2_SHIFT)
+#define BTR1_SAM_SHIFT  	7
+
+#define BTR0_SET_BRP(brp)	(((brp) - 1) &amp; BTR0_BRP_MASK)
+#define BTR0_SET_SJW(sjw)	((((sjw) - 1) &lt;&lt; BTR0_SJW_SHIFT) &amp; \
+				 BTR0_SJW_MASK)
+
+#define BTR1_SET_TSEG1(tseg1)	(((tseg1) - 1) &amp;  BTR1_TSEG1_MASK)
+#define BTR1_SET_TSEG2(tseg2)	((((tseg2) - 1) &lt;&lt; BTR1_TSEG2_SHIFT) &amp; \
+				 BTR1_TSEG2_MASK)
+#define BTR1_SET_SAM(sam)	((sam) ? 1 &lt;&lt; BTR1_SAM_SHIFT : 0)
+
+static struct can_bittiming_const mscan_bittiming_const = {
+	.name = &quot;mscan&quot;,
+	.tseg1_min = 4,
+	.tseg1_max = 16,
+	.tseg2_min = 2,
+	.tseg2_max = 8,
+	.sjw_max = 4,
+	.brp_min = 1,
+	.brp_max = 64,
+	.brp_inc = 1,
+};
+
+struct mscan_state {
+	u8 mode;
+	u8 canrier;
+	u8 cantier;
+};
+
+#define F_RX_PROGRESS	0
+#define F_TX_PROGRESS	1
+#define F_TX_WAIT_ALL	2
+
+static enum can_state state_map[] = {
+	CAN_STATE_ERROR_ACTIVE,
+	CAN_STATE_ERROR_WARNING,
+	CAN_STATE_ERROR_PASSIVE,
+	CAN_STATE_BUS_OFF
+};
+
+static int mscan_set_mode(struct net_device *dev, u8 mode)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv-&gt;reg_base;
+	int ret = 0;
+	int i;
+	u8 canctl1;
+
+	if (mode != MSCAN_NORMAL_MODE) {
+
+		if (priv-&gt;tx_active) {
+			/* Abort transfers before going to sleep */#
+			out_8(&amp;regs-&gt;cantarq, priv-&gt;tx_active);
+			/* Suppress TX done interrupts */
+			out_8(&amp;regs-&gt;cantier, 0);
+		}
+
+		canctl1 = in_8(&amp;regs-&gt;canctl1);
+		if ((mode &amp; MSCAN_SLPRQ) &amp;&amp; (canctl1 &amp; MSCAN_SLPAK) == 0) {
+			out_8(&amp;regs-&gt;canctl0,
+			      in_8(&amp;regs-&gt;canctl0) | MSCAN_SLPRQ);
+			for (i = 0; i &lt; MSCAN_SET_MODE_RETRIES; i++) {
+				if (in_8(&amp;regs-&gt;canctl1) &amp; MSCAN_SLPAK)
+					break;
+				udelay(100);
+			}
+			/*
+			 * The mscan controller will fail to enter sleep mode,
+			 * while there are irregular activities on bus, like
+			 * somebody keeps retransmitting. This behavior is
+			 * undocumented and seems to differ between mscan built
+			 * in mpc5200b and mpc5200. We proceed in that case,
+			 * since otherwise the slprq will be kept set and the
+			 * controller will get stuck. NOTE: INITRQ or CSWAI
+			 * will abort all active transmit actions, if still
+			 * any, at once.
+			 */
+			if (i &gt;= MSCAN_SET_MODE_RETRIES)
+				dev_dbg(dev-&gt;dev.parent,
+					&quot;device failed to enter sleep mode. &quot;
+					&quot;We proceed anyhow.\n&quot;);
+			else
+				priv-&gt;can.state = CAN_STATE_SLEEPING;
+		}
+
+		if ((mode &amp; MSCAN_INITRQ) &amp;&amp; (canctl1 &amp; MSCAN_INITAK) == 0) {
+			out_8(&amp;regs-&gt;canctl0,
+			      in_8(&amp;regs-&gt;canctl0) | MSCAN_INITRQ);
+			for (i = 0; i &lt; MSCAN_SET_MODE_RETRIES; i++) {
+				if (in_8(&amp;regs-&gt;canctl1) &amp; MSCAN_INITAK)
+					break;
+			}
+			if (i &gt;= MSCAN_SET_MODE_RETRIES)
+				ret = -ENODEV;
+		}
+		if (!ret)
+			priv-&gt;can.state = CAN_STATE_STOPPED;
+
+		if (mode &amp; MSCAN_CSWAI)
+			out_8(&amp;regs-&gt;canctl0,
+			      in_8(&amp;regs-&gt;canctl0) | MSCAN_CSWAI);
+
+	} else {
+		canctl1 = in_8(&amp;regs-&gt;canctl1);
+		if (canctl1 &amp; (MSCAN_SLPAK | MSCAN_INITAK)) {
+			out_8(&amp;regs-&gt;canctl0, in_8(&amp;regs-&gt;canctl0) &amp;
+			      ~(MSCAN_SLPRQ | MSCAN_INITRQ));
+			for (i = 0; i &lt; MSCAN_SET_MODE_RETRIES; i++) {
+				canctl1 = in_8(&amp;regs-&gt;canctl1);
+				if (!(canctl1 &amp; (MSCAN_INITAK | MSCAN_SLPAK)))
+					break;
+			}
+			if (i &gt;= MSCAN_SET_MODE_RETRIES)
+				ret = -ENODEV;
+			else
+				priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
+		}
+	}
+	return ret;
+}
+
+static int mscan_start(struct net_device *dev)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv-&gt;reg_base;
+	u8 canrflg;
+	int err;
+
+	out_8(&amp;regs-&gt;canrier, 0);
+
+	INIT_LIST_HEAD(&amp;priv-&gt;tx_head);
+	priv-&gt;prev_buf_id = 0;
+	priv-&gt;cur_pri = 0;
+	priv-&gt;tx_active = 0;
+	priv-&gt;shadow_canrier = 0;
+	priv-&gt;flags = 0;
+
+	err = mscan_set_mode(dev, MSCAN_NORMAL_MODE);
+	if (err)
+		return err;
+
+	canrflg = in_8(&amp;regs-&gt;canrflg);
+	priv-&gt;shadow_statflg = canrflg &amp; MSCAN_STAT_MSK;
+	priv-&gt;can.state = state_map[max(MSCAN_STATE_RX(canrflg),
+				    MSCAN_STATE_TX(canrflg))];
+	out_8(&amp;regs-&gt;cantier, 0);
+
+	/* Enable receive interrupts. */
+	out_8(&amp;regs-&gt;canrier, MSCAN_OVRIE | MSCAN_RXFIE | MSCAN_CSCIE |
+	      MSCAN_RSTATE1 | MSCAN_RSTATE0 | MSCAN_TSTATE1 | MSCAN_TSTATE0);
+
+	return 0;
+}
+
+static netdev_tx_t mscan_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct can_frame *frame = (struct can_frame *)skb-&gt;data;
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv-&gt;reg_base;
+	int i, rtr, buf_id;
+	u32 can_id;
+
+	if (frame-&gt;can_dlc &gt; 8)
+		return -EINVAL;
+
+	out_8(&amp;regs-&gt;cantier, 0);
+
+	i = ~priv-&gt;tx_active &amp; MSCAN_TXE;
+	buf_id = ffs(i) - 1;
+	switch (hweight8(i)) {
+	case 0:
+		netif_stop_queue(dev);
+		dev_err(dev-&gt;dev.parent, &quot;Tx Ring full when queue awake!\n&quot;);
+		return NETDEV_TX_BUSY;
+	case 1:
+		/*
+		 * if buf_id &lt; 3, then current frame will be send out of order,
+		 * since buffer with lower id have higher priority (hell..)
+		 */
+		netif_stop_queue(dev);
+	case 2:
+		if (buf_id &lt; priv-&gt;prev_buf_id) {
+			priv-&gt;cur_pri++;
+			if (priv-&gt;cur_pri == 0xff) {
+				set_bit(F_TX_WAIT_ALL, &amp;priv-&gt;flags);
+				netif_stop_queue(dev);
+			}
+		}
+		set_bit(F_TX_PROGRESS, &amp;priv-&gt;flags);
+		break;
+	}
+	priv-&gt;prev_buf_id = buf_id;
+	out_8(&amp;regs-&gt;cantbsel, i);
+
+	rtr = frame-&gt;can_id &amp; CAN_RTR_FLAG;
+
+	if (frame-&gt;can_id &amp; CAN_EFF_FLAG) {
+		can_id = (frame-&gt;can_id &amp; CAN_EFF_MASK) &lt;&lt; 1;
+		if (rtr)
+			can_id |= 1;
+		out_be16(&amp;regs-&gt;tx.idr3_2, can_id);
+
+		can_id &gt;&gt;= 16;
+		can_id = (can_id &amp; 0x7) | ((can_id &lt;&lt; 2) &amp; 0xffe0) | (3 &lt;&lt; 3);
+	} else {
+		can_id = (frame-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; 5;
+		if (rtr)
+			can_id |= 1 &lt;&lt; 4;
+	}
+	out_be16(&amp;regs-&gt;tx.idr1_0, can_id);
+
+	if (!rtr) {
+		void __iomem *data = &amp;regs-&gt;tx.dsr1_0;
+		u16 *payload = (u16 *) frame-&gt;data;
+		/* It is safe to write into dsr[dlc+1] */
+		for (i = 0; i &lt; (frame-&gt;can_dlc + 1) / 2; i++) {
+			out_be16(data, *payload++);
+			data += 2 + _MSCAN_RESERVED_DSR_SIZE;
+		}
+	}
+
+	out_8(&amp;regs-&gt;tx.dlr, frame-&gt;can_dlc);
+	out_8(&amp;regs-&gt;tx.tbpr, priv-&gt;cur_pri);
+
+	/* Start transmission. */
+	out_8(&amp;regs-&gt;cantflg, 1 &lt;&lt; buf_id);
+
+	if (!test_bit(F_TX_PROGRESS, &amp;priv-&gt;flags))
+		dev-&gt;trans_start = jiffies;
+
+	list_add_tail(&amp;priv-&gt;tx_queue[buf_id].list, &amp;priv-&gt;tx_head);
+
+	can_put_echo_skb(skb, dev, buf_id);
+
+	/* Enable interrupt. */
+	priv-&gt;tx_active |= 1 &lt;&lt; buf_id;
+	out_8(&amp;regs-&gt;cantier, priv-&gt;tx_active);
+
+	return NETDEV_TX_OK;
+}
+
+/* This function returns the old state to see where we came from */
+static enum can_state check_set_state(struct net_device *dev, u8 canrflg)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	enum can_state state, old_state = priv-&gt;can.state;
+
+	if (canrflg &amp; MSCAN_CSCIF &amp;&amp; old_state &lt;= CAN_STATE_BUS_OFF) {
+		state = state_map[max(MSCAN_STATE_RX(canrflg),
+				      MSCAN_STATE_TX(canrflg))];
+		priv-&gt;can.state = state;
+	}
+	return old_state;
+}
+
+static void mscan_get_rx_frame(struct net_device *dev, struct can_frame *frame)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv-&gt;reg_base;
+	u32 can_id;
+	int i;
+
+	can_id = in_be16(&amp;regs-&gt;rx.idr1_0);
+	if (can_id &amp; (1 &lt;&lt; 3)) {
+		frame-&gt;can_id = CAN_EFF_FLAG;
+		can_id = ((can_id &lt;&lt; 16) | in_be16(&amp;regs-&gt;rx.idr3_2));
+		can_id = ((can_id &amp; 0xffe00000) |
+			  ((can_id &amp; 0x7ffff) &lt;&lt; 2)) &gt;&gt; 2;
+	} else {
+		can_id &gt;&gt;= 4;
+		frame-&gt;can_id = 0;
+	}
+
+	frame-&gt;can_id |= can_id &gt;&gt; 1;
+	if (can_id &amp; 1)
+		frame-&gt;can_id |= CAN_RTR_FLAG;
+	frame-&gt;can_dlc = in_8(&amp;regs-&gt;rx.dlr) &amp; 0xf;
+
+	if (!(frame-&gt;can_id &amp; CAN_RTR_FLAG)) {
+		void __iomem *data = &amp;regs-&gt;rx.dsr1_0;
+		u16 *payload = (u16 *) frame-&gt;data;
+		for (i = 0; i &lt; (frame-&gt;can_dlc + 1) / 2; i++) {
+			*payload++ = in_be16(data);
+			data += 2 + _MSCAN_RESERVED_DSR_SIZE;
+		}
+	}
+
+	out_8(&amp;regs-&gt;canrflg, MSCAN_RXF);
+}
+
+static void mscan_get_err_frame(struct net_device *dev, struct can_frame *frame,
+				u8 canrflg)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv-&gt;reg_base;
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+	enum can_state old_state;
+
+	dev_dbg(dev-&gt;dev.parent, &quot;error interrupt (canrflg=%#x)\n&quot;, canrflg);
+	frame-&gt;can_id = CAN_ERR_FLAG;
+
+	if (canrflg &amp; MSCAN_OVRIF) {
+		frame-&gt;can_id |= CAN_ERR_CRTL;
+		frame-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+		stats-&gt;rx_over_errors++;
+		stats-&gt;rx_errors++;
+	} else
+		frame-&gt;data[1] = 0;
+
+	old_state = check_set_state(dev, canrflg);
+	/* State changed */
+	if (old_state != priv-&gt;can.state) {
+		switch (priv-&gt;can.state) {
+		case CAN_STATE_ERROR_WARNING:
+			frame-&gt;can_id |= CAN_ERR_CRTL;
+			priv-&gt;can.can_stats.error_warning++;
+			if ((priv-&gt;shadow_statflg &amp; MSCAN_RSTAT_MSK) &lt;
+			    (canrflg &amp; MSCAN_RSTAT_MSK))
+				frame-&gt;data[1] |= CAN_ERR_CRTL_RX_WARNING;
+
+			if ((priv-&gt;shadow_statflg &amp; MSCAN_TSTAT_MSK) &lt;
+			    (canrflg &amp; MSCAN_TSTAT_MSK))
+				frame-&gt;data[1] |= CAN_ERR_CRTL_TX_WARNING;
+			break;
+		case CAN_STATE_ERROR_PASSIVE:
+			frame-&gt;can_id |= CAN_ERR_CRTL;
+			priv-&gt;can.can_stats.error_passive++;
+			frame-&gt;data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
+			break;
+		case CAN_STATE_BUS_OFF:
+			frame-&gt;can_id |= CAN_ERR_BUSOFF;
+			/*
+			 * The MSCAN on the MPC5200 does recover from bus-off
+			 * automatically. To avoid that we stop the chip doing
+			 * a light-weight stop (we are in irq-context).
+			 */
+			out_8(&amp;regs-&gt;cantier, 0);
+			out_8(&amp;regs-&gt;canrier, 0);
+			out_8(&amp;regs-&gt;canctl0, in_8(&amp;regs-&gt;canctl0) |
+				MSCAN_SLPRQ | MSCAN_INITRQ);
+			can_bus_off(dev);
+			break;
+		default:
+			break;
+		}
+	}
+	priv-&gt;shadow_statflg = canrflg &amp; MSCAN_STAT_MSK;
+	frame-&gt;can_dlc = CAN_ERR_DLC;
+	out_8(&amp;regs-&gt;canrflg, MSCAN_ERR_IF);
+}
+
+static int mscan_rx_poll(struct napi_struct *napi, int quota)
+{
+	struct mscan_priv *priv = container_of(napi, struct mscan_priv, napi);
+	struct net_device *dev = napi-&gt;dev;
+	struct mscan_regs *regs = (struct mscan_regs *)priv-&gt;reg_base;
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+	int npackets = 0;
+	int ret = 1;
+	struct sk_buff *skb;
+	struct can_frame *frame;
+	u8 canrflg;
+
+	while (npackets &lt; quota &amp;&amp; ((canrflg = in_8(&amp;regs-&gt;canrflg)) &amp;
+				    (MSCAN_RXF | MSCAN_ERR_IF))) {
+
+		skb = alloc_can_skb(dev, &amp;frame);
+		if (!skb) {
+			if (printk_ratelimit())
+				dev_notice(dev-&gt;dev.parent, &quot;packet dropped\n&quot;);
+			stats-&gt;rx_dropped++;
+			out_8(&amp;regs-&gt;canrflg, canrflg);
+			continue;
+		}
+
+		if (canrflg &amp; MSCAN_RXF)
+			mscan_get_rx_frame(dev, frame);
+		 else if (canrflg &amp; MSCAN_ERR_IF)
+			mscan_get_err_frame(dev, frame, canrflg);
+
+		stats-&gt;rx_packets++;
+		stats-&gt;rx_bytes += frame-&gt;can_dlc;
+		npackets++;
+		netif_receive_skb(skb);
+	}
+
+	if (!(in_8(&amp;regs-&gt;canrflg) &amp; (MSCAN_RXF | MSCAN_ERR_IF))) {
+		napi_complete(&amp;priv-&gt;napi);
+		clear_bit(F_RX_PROGRESS, &amp;priv-&gt;flags);
+		if (priv-&gt;can.state &lt; CAN_STATE_BUS_OFF)
+			out_8(&amp;regs-&gt;canrier, priv-&gt;shadow_canrier);
+		ret = 0;
+	}
+	return ret;
+}
+
+static irqreturn_t mscan_isr(int irq, void *dev_id)
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv-&gt;reg_base;
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+	u8 cantier, cantflg, canrflg;
+	irqreturn_t ret = IRQ_NONE;
+
+	cantier = in_8(&amp;regs-&gt;cantier) &amp; MSCAN_TXE;
+	cantflg = in_8(&amp;regs-&gt;cantflg) &amp; cantier;
+
+	if (cantier &amp;&amp; cantflg) {
+
+		struct list_head *tmp, *pos;
+
+		list_for_each_safe(pos, tmp, &amp;priv-&gt;tx_head) {
+			struct tx_queue_entry *entry =
+			    list_entry(pos, struct tx_queue_entry, list);
+			u8 mask = entry-&gt;mask;
+
+			if (!(cantflg &amp; mask))
+				continue;
+
+			out_8(&amp;regs-&gt;cantbsel, mask);
+			stats-&gt;tx_bytes += in_8(&amp;regs-&gt;tx.dlr);
+			stats-&gt;tx_packets++;
+			can_get_echo_skb(dev, entry-&gt;id);
+			priv-&gt;tx_active &amp;= ~mask;
+			list_del(pos);
+		}
+
+		if (list_empty(&amp;priv-&gt;tx_head)) {
+			clear_bit(F_TX_WAIT_ALL, &amp;priv-&gt;flags);
+			clear_bit(F_TX_PROGRESS, &amp;priv-&gt;flags);
+			priv-&gt;cur_pri = 0;
+		} else
+			dev-&gt;trans_start = jiffies;
+
+		if (!test_bit(F_TX_WAIT_ALL, &amp;priv-&gt;flags))
+			netif_wake_queue(dev);
+
+		out_8(&amp;regs-&gt;cantier, priv-&gt;tx_active);
+		ret = IRQ_HANDLED;
+	}
+
+	canrflg = in_8(&amp;regs-&gt;canrflg);
+	if ((canrflg &amp; ~MSCAN_STAT_MSK) &amp;&amp;
+	    !test_and_set_bit(F_RX_PROGRESS, &amp;priv-&gt;flags)) {
+		if (canrflg &amp; ~MSCAN_STAT_MSK) {
+			priv-&gt;shadow_canrier = in_8(&amp;regs-&gt;canrier);
+			out_8(&amp;regs-&gt;canrier, 0);
+			napi_schedule(&amp;priv-&gt;napi);
+			ret = IRQ_HANDLED;
+		} else
+			clear_bit(F_RX_PROGRESS, &amp;priv-&gt;flags);
+	}
+	return ret;
+}
+
+static int mscan_do_set_mode(struct net_device *dev, enum can_mode mode)
+{
+
+	struct mscan_priv *priv = netdev_priv(dev);
+	int ret = 0;
+
+	if (!priv-&gt;open_time)
+		return -EINVAL;
+
+	switch (mode) {
+	case CAN_MODE_SLEEP:
+	case CAN_MODE_STOP:
+		netif_stop_queue(dev);
+		mscan_set_mode(dev,
+			       (mode ==
+				CAN_MODE_STOP) ? MSCAN_INIT_MODE :
+			       MSCAN_SLEEP_MODE);
+		break;
+	case CAN_MODE_START:
+		if (priv-&gt;can.state &lt;= CAN_STATE_BUS_OFF)
+			mscan_set_mode(dev, MSCAN_INIT_MODE);
+		ret = mscan_start(dev);
+		if (ret)
+			break;
+		if (netif_queue_stopped(dev))
+			netif_wake_queue(dev);
+		break;
+
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+	return ret;
+}
+
+static int mscan_do_set_bittiming(struct net_device *dev)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv-&gt;reg_base;
+	struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
+	u8 btr0, btr1;
+
+	btr0 = BTR0_SET_BRP(bt-&gt;brp) | BTR0_SET_SJW(bt-&gt;sjw);
+	btr1 = (BTR1_SET_TSEG1(bt-&gt;prop_seg + bt-&gt;phase_seg1) |
+		BTR1_SET_TSEG2(bt-&gt;phase_seg2) |
+		BTR1_SET_SAM(priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES));
+
+	dev_info(dev-&gt;dev.parent, &quot;setting BTR0=0x%02x BTR1=0x%02x\n&quot;,
+		btr0, btr1);
+
+	out_8(&amp;regs-&gt;canbtr0, btr0);
+	out_8(&amp;regs-&gt;canbtr1, btr1);
+
+	return 0;
+}
+
+static int mscan_open(struct net_device *dev)
+{
+	int ret;
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv-&gt;reg_base;
+
+	/* common open */
+	ret = open_candev(dev);
+	if (ret)
+		return ret;
+
+	napi_enable(&amp;priv-&gt;napi);
+
+	ret = request_irq(dev-&gt;irq, mscan_isr, 0, dev-&gt;name, dev);
+	if (ret &lt; 0) {
+		napi_disable(&amp;priv-&gt;napi);
+		printk(KERN_ERR &quot;%s - failed to attach interrupt\n&quot;,
+		       dev-&gt;name);
+		return ret;
+	}
+
+	priv-&gt;open_time = jiffies;
+
+	out_8(&amp;regs-&gt;canctl1, in_8(&amp;regs-&gt;canctl1) &amp; ~MSCAN_LISTEN);
+
+	ret = mscan_start(dev);
+	if (ret)
+		return ret;
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int mscan_close(struct net_device *dev)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv-&gt;reg_base;
+
+	netif_stop_queue(dev);
+	napi_disable(&amp;priv-&gt;napi);
+
+	out_8(&amp;regs-&gt;cantier, 0);
+	out_8(&amp;regs-&gt;canrier, 0);
+	mscan_set_mode(dev, MSCAN_INIT_MODE);
+	close_candev(dev);
+	free_irq(dev-&gt;irq, dev);
+	priv-&gt;open_time = 0;
+
+	return 0;
+}
+
+static const struct net_device_ops mscan_netdev_ops = {
+       .ndo_open               = mscan_open,
+       .ndo_stop               = mscan_close,
+       .ndo_start_xmit         = mscan_start_xmit,
+};
+
+int register_mscandev(struct net_device *dev, int clock_src)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv-&gt;reg_base;
+	u8 ctl1;
+
+	ctl1 = in_8(&amp;regs-&gt;canctl1);
+	if (clock_src)
+		ctl1 |= MSCAN_CLKSRC;
+	else
+		ctl1 &amp;= ~MSCAN_CLKSRC;
+
+	ctl1 |= MSCAN_CANE;
+	out_8(&amp;regs-&gt;canctl1, ctl1);
+	udelay(100);
+
+	/* acceptance mask/acceptance code (accept everything) */
+	out_be16(&amp;regs-&gt;canidar1_0, 0);
+	out_be16(&amp;regs-&gt;canidar3_2, 0);
+	out_be16(&amp;regs-&gt;canidar5_4, 0);
+	out_be16(&amp;regs-&gt;canidar7_6, 0);
+
+	out_be16(&amp;regs-&gt;canidmr1_0, 0xffff);
+	out_be16(&amp;regs-&gt;canidmr3_2, 0xffff);
+	out_be16(&amp;regs-&gt;canidmr5_4, 0xffff);
+	out_be16(&amp;regs-&gt;canidmr7_6, 0xffff);
+	/* Two 32 bit Acceptance Filters */
+	out_8(&amp;regs-&gt;canidac, MSCAN_AF_32BIT);
+
+	mscan_set_mode(dev, MSCAN_INIT_MODE);
+
+	return register_candev(dev);
+}
+EXPORT_SYMBOL_GPL(register_mscandev);
+
+void unregister_mscandev(struct net_device *dev)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)priv-&gt;reg_base;
+	mscan_set_mode(dev, MSCAN_INIT_MODE);
+	out_8(&amp;regs-&gt;canctl1, in_8(&amp;regs-&gt;canctl1) &amp; ~MSCAN_CANE);
+	unregister_candev(dev);
+}
+EXPORT_SYMBOL_GPL(unregister_mscandev);
+
+struct net_device *alloc_mscandev(void)
+{
+	struct net_device *dev;
+	struct mscan_priv *priv;
+	int i;
+
+	dev = alloc_candev(sizeof(struct mscan_priv), MSCAN_ECHO_SKB_MAX);
+	if (!dev)
+		return NULL;
+	priv = netdev_priv(dev);
+
+	dev-&gt;netdev_ops = &amp;mscan_netdev_ops;
+
+	dev-&gt;flags |= IFF_ECHO;	/* we support local echo */
+
+	netif_napi_add(dev, &amp;priv-&gt;napi, mscan_rx_poll, 8);
+
+	priv-&gt;can.bittiming_const = &amp;mscan_bittiming_const;
+	priv-&gt;can.do_set_bittiming = mscan_do_set_bittiming;
+	priv-&gt;can.do_set_mode = mscan_do_set_mode;
+
+	for (i = 0; i &lt; TX_QUEUE_SIZE; i++) {
+		priv-&gt;tx_queue[i].id = i;
+		priv-&gt;tx_queue[i].mask = 1 &lt;&lt; i;
+	}
+
+	return dev;
+}
+EXPORT_SYMBOL_GPL(alloc_mscandev);
+
+MODULE_AUTHOR(&quot;Andrey Volkov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">avolkov at varma-el.com</A>&gt;&quot;);
+MODULE_LICENSE(&quot;GPL v2&quot;);
+MODULE_DESCRIPTION(&quot;CAN port driver for a MSCAN based chips&quot;);
diff --git a/drivers/net/can/mscan/mscan.h b/drivers/net/can/mscan/mscan.h
new file mode 100644
index 0000000..57820f5
--- /dev/null
+++ b/drivers/net/can/mscan/mscan.h
@@ -0,0 +1,262 @@
+/*
+ * Definitions of consts/structs to drive the Freescale MSCAN.
+ *
+ * Copyright (C) 2005-2006 Andrey Volkov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">avolkov at varma-el.com</A>&gt;,
+ *                         Varma Electronics Oy
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __MSCAN_H__
+#define __MSCAN_H__
+
+#include &lt;linux/types.h&gt;
+
+/* MSCAN control register 0 (CANCTL0) bits */
+#define MSCAN_RXFRM		0x80
+#define MSCAN_RXACT		0x40
+#define MSCAN_CSWAI		0x20
+#define MSCAN_SYNCH		0x10
+#define MSCAN_TIME		0x08
+#define MSCAN_WUPE		0x04
+#define MSCAN_SLPRQ		0x02
+#define MSCAN_INITRQ		0x01
+
+/* MSCAN control register 1 (CANCTL1) bits */
+#define MSCAN_CANE		0x80
+#define MSCAN_CLKSRC		0x40
+#define MSCAN_LOOPB		0x20
+#define MSCAN_LISTEN		0x10
+#define MSCAN_WUPM		0x04
+#define MSCAN_SLPAK		0x02
+#define MSCAN_INITAK		0x01
+
+/* Use the MPC5200 MSCAN variant? */
+#ifdef CONFIG_PPC
+#define MSCAN_FOR_MPC5200
+#endif
+
+#ifdef MSCAN_FOR_MPC5200
+#define MSCAN_CLKSRC_BUS	0
+#define MSCAN_CLKSRC_XTAL	MSCAN_CLKSRC
+#else
+#define MSCAN_CLKSRC_BUS	MSCAN_CLKSRC
+#define MSCAN_CLKSRC_XTAL	0
+#endif
+
+/* MSCAN receiver flag register (CANRFLG) bits */
+#define MSCAN_WUPIF		0x80
+#define MSCAN_CSCIF		0x40
+#define MSCAN_RSTAT1		0x20
+#define MSCAN_RSTAT0		0x10
+#define MSCAN_TSTAT1		0x08
+#define MSCAN_TSTAT0		0x04
+#define MSCAN_OVRIF		0x02
+#define MSCAN_RXF		0x01
+#define MSCAN_ERR_IF 		(MSCAN_OVRIF | MSCAN_CSCIF)
+#define MSCAN_RSTAT_MSK		(MSCAN_RSTAT1 | MSCAN_RSTAT0)
+#define MSCAN_TSTAT_MSK		(MSCAN_TSTAT1 | MSCAN_TSTAT0)
+#define MSCAN_STAT_MSK		(MSCAN_RSTAT_MSK | MSCAN_TSTAT_MSK)
+
+#define MSCAN_STATE_BUS_OFF	(MSCAN_RSTAT1 | MSCAN_RSTAT0 | \
+				 MSCAN_TSTAT1 | MSCAN_TSTAT0)
+#define MSCAN_STATE_TX(canrflg)	(((canrflg)&amp;MSCAN_TSTAT_MSK)&gt;&gt;2)
+#define MSCAN_STATE_RX(canrflg)	(((canrflg)&amp;MSCAN_RSTAT_MSK)&gt;&gt;4)
+#define MSCAN_STATE_ACTIVE	0
+#define MSCAN_STATE_WARNING	1
+#define MSCAN_STATE_PASSIVE	2
+#define MSCAN_STATE_BUSOFF	3
+
+/* MSCAN receiver interrupt enable register (CANRIER) bits */
+#define MSCAN_WUPIE		0x80
+#define MSCAN_CSCIE		0x40
+#define MSCAN_RSTATE1		0x20
+#define MSCAN_RSTATE0		0x10
+#define MSCAN_TSTATE1		0x08
+#define MSCAN_TSTATE0		0x04
+#define MSCAN_OVRIE		0x02
+#define MSCAN_RXFIE		0x01
+
+/* MSCAN transmitter flag register (CANTFLG) bits */
+#define MSCAN_TXE2		0x04
+#define MSCAN_TXE1		0x02
+#define MSCAN_TXE0		0x01
+#define MSCAN_TXE		(MSCAN_TXE2 | MSCAN_TXE1 | MSCAN_TXE0)
+
+/* MSCAN transmitter interrupt enable register (CANTIER) bits */
+#define MSCAN_TXIE2		0x04
+#define MSCAN_TXIE1		0x02
+#define MSCAN_TXIE0		0x01
+#define MSCAN_TXIE		(MSCAN_TXIE2 | MSCAN_TXIE1 | MSCAN_TXIE0)
+
+/* MSCAN transmitter message abort request (CANTARQ) bits */
+#define MSCAN_ABTRQ2		0x04
+#define MSCAN_ABTRQ1		0x02
+#define MSCAN_ABTRQ0		0x01
+
+/* MSCAN transmitter message abort ack (CANTAAK) bits */
+#define MSCAN_ABTAK2		0x04
+#define MSCAN_ABTAK1		0x02
+#define MSCAN_ABTAK0		0x01
+
+/* MSCAN transmit buffer selection (CANTBSEL) bits */
+#define MSCAN_TX2		0x04
+#define MSCAN_TX1		0x02
+#define MSCAN_TX0		0x01
+
+/* MSCAN ID acceptance control register (CANIDAC) bits */
+#define MSCAN_IDAM1		0x20
+#define MSCAN_IDAM0		0x10
+#define MSCAN_IDHIT2		0x04
+#define MSCAN_IDHIT1		0x02
+#define MSCAN_IDHIT0		0x01
+
+#define MSCAN_AF_32BIT		0x00
+#define MSCAN_AF_16BIT		MSCAN_IDAM0
+#define MSCAN_AF_8BIT		MSCAN_IDAM1
+#define MSCAN_AF_CLOSED		(MSCAN_IDAM0|MSCAN_IDAM1)
+#define MSCAN_AF_MASK		(~(MSCAN_IDAM0|MSCAN_IDAM1))
+
+/* MSCAN Miscellaneous Register (CANMISC) bits */
+#define MSCAN_BOHOLD		0x01
+
+#ifdef MSCAN_FOR_MPC5200
+#define _MSCAN_RESERVED_(n, num) u8 _res##n[num]
+#define _MSCAN_RESERVED_DSR_SIZE	2
+#else
+#define _MSCAN_RESERVED_(n, num)
+#define _MSCAN_RESERVED_DSR_SIZE	0
+#endif
+
+/* Structure of the hardware registers */
+struct mscan_regs {
+	/* (see doc S12MSCANV3/D)		  MPC5200    MSCAN */
+	u8 canctl0;				/* + 0x00     0x00 */
+	u8 canctl1;				/* + 0x01     0x01 */
+	_MSCAN_RESERVED_(1, 2);			/* + 0x02          */
+	u8 canbtr0;				/* + 0x04     0x02 */
+	u8 canbtr1;				/* + 0x05     0x03 */
+	_MSCAN_RESERVED_(2, 2);			/* + 0x06          */
+	u8 canrflg;				/* + 0x08     0x04 */
+	u8 canrier;				/* + 0x09     0x05 */
+	_MSCAN_RESERVED_(3, 2);			/* + 0x0a          */
+	u8 cantflg;				/* + 0x0c     0x06 */
+	u8 cantier;				/* + 0x0d     0x07 */
+	_MSCAN_RESERVED_(4, 2);			/* + 0x0e          */
+	u8 cantarq;				/* + 0x10     0x08 */
+	u8 cantaak;				/* + 0x11     0x09 */
+	_MSCAN_RESERVED_(5, 2);			/* + 0x12          */
+	u8 cantbsel;				/* + 0x14     0x0a */
+	u8 canidac;				/* + 0x15     0x0b */
+	u8 reserved;				/* + 0x16     0x0c */
+	_MSCAN_RESERVED_(6, 5);			/* + 0x17          */
+#ifndef MSCAN_FOR_MPC5200
+	u8 canmisc;				/*            0x0d */
+#endif
+	u8 canrxerr;				/* + 0x1c     0x0e */
+	u8 cantxerr;				/* + 0x1d     0x0f */
+	_MSCAN_RESERVED_(7, 2);			/* + 0x1e          */
+	u16 canidar1_0;				/* + 0x20     0x10 */
+	_MSCAN_RESERVED_(8, 2);			/* + 0x22          */
+	u16 canidar3_2;				/* + 0x24     0x12 */
+	_MSCAN_RESERVED_(9, 2);			/* + 0x26          */
+	u16 canidmr1_0;				/* + 0x28     0x14 */
+	_MSCAN_RESERVED_(10, 2);		/* + 0x2a          */
+	u16 canidmr3_2;				/* + 0x2c     0x16 */
+	_MSCAN_RESERVED_(11, 2);		/* + 0x2e          */
+	u16 canidar5_4;				/* + 0x30     0x18 */
+	_MSCAN_RESERVED_(12, 2);		/* + 0x32          */
+	u16 canidar7_6;				/* + 0x34     0x1a */
+	_MSCAN_RESERVED_(13, 2);		/* + 0x36          */
+	u16 canidmr5_4;				/* + 0x38     0x1c */
+	_MSCAN_RESERVED_(14, 2);		/* + 0x3a          */
+	u16 canidmr7_6;				/* + 0x3c     0x1e */
+	_MSCAN_RESERVED_(15, 2);		/* + 0x3e          */
+	struct {
+		u16 idr1_0;			/* + 0x40     0x20 */
+		 _MSCAN_RESERVED_(16, 2);	/* + 0x42          */
+		u16 idr3_2;			/* + 0x44     0x22 */
+		 _MSCAN_RESERVED_(17, 2);	/* + 0x46          */
+		u16 dsr1_0;			/* + 0x48     0x24 */
+		 _MSCAN_RESERVED_(18, 2);	/* + 0x4a          */
+		u16 dsr3_2;			/* + 0x4c     0x26 */
+		 _MSCAN_RESERVED_(19, 2);	/* + 0x4e          */
+		u16 dsr5_4;			/* + 0x50     0x28 */
+		 _MSCAN_RESERVED_(20, 2);	/* + 0x52          */
+		u16 dsr7_6;			/* + 0x54     0x2a */
+		 _MSCAN_RESERVED_(21, 2);	/* + 0x56          */
+		u8 dlr;				/* + 0x58     0x2c */
+		 u8:8;				/* + 0x59     0x2d */
+		 _MSCAN_RESERVED_(22, 2);	/* + 0x5a          */
+		u16 time;			/* + 0x5c     0x2e */
+	} rx;
+	 _MSCAN_RESERVED_(23, 2);		/* + 0x5e          */
+	struct {
+		u16 idr1_0;			/* + 0x60     0x30 */
+		 _MSCAN_RESERVED_(24, 2);	/* + 0x62          */
+		u16 idr3_2;			/* + 0x64     0x32 */
+		 _MSCAN_RESERVED_(25, 2);	/* + 0x66          */
+		u16 dsr1_0;			/* + 0x68     0x34 */
+		 _MSCAN_RESERVED_(26, 2);	/* + 0x6a          */
+		u16 dsr3_2;			/* + 0x6c     0x36 */
+		 _MSCAN_RESERVED_(27, 2);	/* + 0x6e          */
+		u16 dsr5_4;			/* + 0x70     0x38 */
+		 _MSCAN_RESERVED_(28, 2);	/* + 0x72          */
+		u16 dsr7_6;			/* + 0x74     0x3a */
+		 _MSCAN_RESERVED_(29, 2);	/* + 0x76          */
+		u8 dlr;				/* + 0x78     0x3c */
+		u8 tbpr;			/* + 0x79     0x3d */
+		 _MSCAN_RESERVED_(30, 2);	/* + 0x7a          */
+		u16 time;			/* + 0x7c     0x3e */
+	} tx;
+	 _MSCAN_RESERVED_(31, 2);		/* + 0x7e          */
+} __attribute__ ((packed));
+
+#undef _MSCAN_RESERVED_
+#define MSCAN_REGION 	sizeof(struct mscan)
+
+#define TX_QUEUE_SIZE	3
+
+struct tx_queue_entry {
+	struct list_head list;
+	u8 mask;
+	u8 id;
+};
+
+struct mscan_priv {
+	struct can_priv can;	/* must be the first member */
+	long open_time;
+	unsigned long flags;
+	void __iomem *reg_base;	/* ioremap'ed address to registers */
+	u8 shadow_statflg;
+	u8 shadow_canrier;
+	u8 cur_pri;
+	u8 prev_buf_id;
+	u8 tx_active;
+
+	struct list_head tx_head;
+	struct tx_queue_entry tx_queue[TX_QUEUE_SIZE];
+	struct napi_struct napi;
+};
+
+struct net_device *alloc_mscandev(void);
+/*
+ * clock_src:
+ *	1 = The MSCAN clock source is the onchip Bus Clock.
+ *	0 = The MSCAN clock source is the chip Oscillator Clock.
+ */
+extern int register_mscandev(struct net_device *dev, int clock_src);
+extern void unregister_mscandev(struct net_device *dev);
+
+#endif /* __MSCAN_H__ */
-- 
1.6.3.3


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003482.html">[PATCH] mscan: fix bus-off recovery procedure
</A></li>
	<LI>Next message: <A HREF="003493.html">[PATCH] net/can: add driver for mscan family &amp; mpc52xx_mscan
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3489">[ date ]</a>
              <a href="thread.html#3489">[ thread ]</a>
              <a href="subject.html#3489">[ subject ]</a>
              <a href="author.html#3489">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
