<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH v4 1/1] can: add pruss CAN driver.
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2011-April/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20v4%201/1%5D%20can%3A%20add%20pruss%20CAN%20driver.&In-Reply-To=%3C4DB1A3B7.7060300%40pengutronix.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005652.html">
   <LINK REL="Next"  HREF="005659.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH v4 1/1] can: add pruss CAN driver.</H1>
    <B>Marc Kleine-Budde</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20v4%201/1%5D%20can%3A%20add%20pruss%20CAN%20driver.&In-Reply-To=%3C4DB1A3B7.7060300%40pengutronix.de%3E"
       TITLE="[PATCH v4 1/1] can: add pruss CAN driver.">mkl at pengutronix.de
       </A><BR>
    <I>Fri Apr 22 17:50:15 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="005652.html">[PATCH v4 1/1] can: add pruss CAN driver.
</A></li>
        <LI>Next message: <A HREF="005659.html">[PATCH v4 1/1] can: add pruss CAN driver.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5655">[ date ]</a>
              <a href="thread.html#5655">[ thread ]</a>
              <a href="subject.html#5655">[ subject ]</a>
              <a href="author.html#5655">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 04/22/2011 02:11 PM, Subhasish Ghosh wrote:
&gt;<i> This patch adds support for the CAN device emulated on PRUSS.
</I>
After commenting the code inline, some remarks:
- Your tx path looks broken, see commits inline
- Please setup a proper struct to describe your register layout, make
  use of arrays for rx and tx
- don't use u32, s32 for not hardware related variables like return
  codes and loop counter.
- the routines that load and save the can data bytes from/into your
  mailbox look way to complicated. Please write down the layout so that
  we can think of a elegant way to do it
- a lot of functions unconditionally return 0, make them void if no
  error can happen
- think about using managed devices, that would simplify the probe and
  release function

&gt;<i> 
</I>&gt;<i> Signed-off-by: Subhasish Ghosh &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">subhasish at mistralsolutions.com</A>&gt;
</I>&gt;<i> ---
</I>&gt;<i>  drivers/net/can/Kconfig     |    7 +
</I>&gt;<i>  drivers/net/can/Makefile    |    1 +
</I>&gt;<i>  drivers/net/can/pruss_can.c | 1074 +++++++++++++++++++++++++++++++++++++++++++
</I>&gt;<i>  3 files changed, 1082 insertions(+), 0 deletions(-)
</I>&gt;<i>  create mode 100644 drivers/net/can/pruss_can.c
</I>&gt;<i> 
</I>&gt;<i> diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
</I>&gt;<i> index 5dec456..4682a4f 100644
</I>&gt;<i> --- a/drivers/net/can/Kconfig
</I>&gt;<i> +++ b/drivers/net/can/Kconfig
</I>&gt;<i> @@ -111,6 +111,13 @@ config PCH_CAN
</I>&gt;<i>  	  embedded processor.
</I>&gt;<i>  	  This driver can access CAN bus.
</I>&gt;<i>  
</I>&gt;<i> +config CAN_TI_DA8XX_PRU
</I>&gt;<i> +	depends on CAN_DEV &amp;&amp; ARCH_DAVINCI &amp;&amp; ARCH_DAVINCI_DA850
</I>&gt;<i> +	tristate &quot;PRU based CAN emulation for DA8XX&quot;
</I>&gt;<i> +	---help---
</I>&gt;<i> +	Enable this to emulate a CAN controller on the PRU of DA8XX.
</I>&gt;<i> +	If not sure, mark N
</I>
Please indent the help text with 1 tab and 2 spaces

&gt;<i> +
</I>&gt;<i>  source &quot;drivers/net/can/mscan/Kconfig&quot;
</I>&gt;<i>  
</I>&gt;<i>  source &quot;drivers/net/can/sja1000/Kconfig&quot;
</I>&gt;<i> diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
</I>&gt;<i> index 53c82a7..d0b7cbd 100644
</I>&gt;<i> --- a/drivers/net/can/Makefile
</I>&gt;<i> +++ b/drivers/net/can/Makefile
</I>&gt;<i> @@ -15,6 +15,7 @@ obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
</I>&gt;<i>  obj-$(CONFIG_CAN_MSCAN)		+= mscan/
</I>&gt;<i>  obj-$(CONFIG_CAN_AT91)		+= at91_can.o
</I>&gt;<i>  obj-$(CONFIG_CAN_TI_HECC)	+= ti_hecc.o
</I>&gt;<i> +obj-$(CONFIG_CAN_TI_DA8XX_PRU)	+= pruss_can.o
</I>&gt;<i>  obj-$(CONFIG_CAN_MCP251X)	+= mcp251x.o
</I>&gt;<i>  obj-$(CONFIG_CAN_BFIN)		+= bfin_can.o
</I>&gt;<i>  obj-$(CONFIG_CAN_JANZ_ICAN3)	+= janz-ican3.o
</I>&gt;<i> diff --git a/drivers/net/can/pruss_can.c b/drivers/net/can/pruss_can.c
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..7702509
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/pruss_can.c
</I>&gt;<i> @@ -0,0 +1,1074 @@
</I>&gt;<i> +/*
</I>&gt;<i> + *  TI DA8XX PRU CAN Emulation device driver
</I>&gt;<i> + *  Author: <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">subhasish at mistralsolutions.com</A>
</I>&gt;<i> + *
</I>&gt;<i> + *  This driver supports TI's PRU CAN Emulation and the
</I>&gt;<i> + *  specs for the same is available at &lt;<A HREF="http://www.ti.com">http://www.ti.com</A>&gt;
</I>&gt;<i> + *
</I>&gt;<i> + *  Copyright (C) 2010, 2011 Texas Instruments Incorporated
</I>&gt;<i> + *
</I>&gt;<i> + *  This program is free software; you can redistribute it and/or
</I>&gt;<i> + *  modify it under the terms of the GNU General Public License as
</I>&gt;<i> + *  published by the Free Software Foundation version 2.
</I>&gt;<i> + *
</I>&gt;<i> + *  This program is distributed as is WITHOUT ANY WARRANTY of any
</I>&gt;<i> + *  kind, whether express or implied; without even the implied warranty
</I>&gt;<i> + *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</I>&gt;<i> + *  GNU General Public License for more details.
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/module.h&gt;
</I>&gt;<i> +#include &lt;linux/init.h&gt;
</I>&gt;<i> +#include &lt;linux/kernel.h&gt;
</I>&gt;<i> +#include &lt;linux/bitops.h&gt;
</I>&gt;<i> +#include &lt;linux/interrupt.h&gt;
</I>&gt;<i> +#include &lt;linux/errno.h&gt;
</I>&gt;<i> +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> +#include &lt;linux/skbuff.h&gt;
</I>&gt;<i> +#include &lt;linux/platform_device.h&gt;
</I>&gt;<i> +#include &lt;linux/firmware.h&gt;
</I>&gt;<i> +#include &lt;linux/clk.h&gt;
</I>&gt;<i> +#include &lt;linux/types.h&gt;
</I>&gt;<i> +#include &lt;linux/sysfs.h&gt;
</I>&gt;<i> +#include &lt;linux/can.h&gt;
</I>&gt;<i> +#include &lt;linux/can/dev.h&gt;
</I>&gt;<i> +#include &lt;linux/can/error.h&gt;
</I>&gt;<i> +#include &lt;linux/mfd/pruss.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#define PRUSS_CAN_RX_PRU_0			PRUSS_NUM0
</I>&gt;<i> +#define PRUSS_CAN_TX_PRU_1			PRUSS_NUM1
</I>&gt;<i> +#define PRUSS_CAN_TX_SYS_EVT			34
</I>&gt;<i> +#define PRUSS_CAN_RX_SYS_EVT			33
</I>&gt;<i> +#define PRUSS_CAN_ARM2DSP_SYS_EVT		32
</I>&gt;<i> +#define PRUSS_CAN_DELAY_LOOP_LENGTH		2
</I>&gt;<i> +#define PRUSS_CAN_TIMER_SETUP_DELAY		14
</I>&gt;<i> +#define PRUSS_CAN_GPIO_SETUP_DELAY		150
</I>&gt;<i> +#define PRUSS_CAN_TX_GBL_STAT_REG		(PRUSS_PRU1_BASE_ADDRESS + 0x04)
</I>&gt;<i> +#define PRUSS_CAN_TX_INTR_MASK_REG		(PRUSS_PRU1_BASE_ADDRESS + 0x08)
</I>&gt;<i> +#define PRUSS_CAN_TX_INTR_STAT_REG		(PRUSS_PRU1_BASE_ADDRESS + 0x0C)
</I>&gt;<i> +#define PRUSS_CAN_TX_MBOX0_STAT_REG		(PRUSS_PRU1_BASE_ADDRESS + 0x10)
</I>&gt;<i> +#define PRUSS_CAN_TX_ERR_CNTR_REG		(PRUSS_PRU1_BASE_ADDRESS + 0x30)
</I>
I think Wolfgang and me have asked you to describe the register layout
with a struct.

&gt;<i> +#define PRUSS_CAN_TX_INT_STAT			0x2
</I>&gt;<i> +#define PRUSS_CAN_MBOX_OFFSET			0x40
</I>&gt;<i> +#define PRUSS_CAN_MBOX_SIZE			0x10
</I>&gt;<i> +#define PRUSS_CAN_MBOX_STAT_OFFSET		0x10
</I>&gt;<i> +#define PRUSS_CAN_MBOX_STAT_SIZE		0x04
</I>&gt;<i> +#define PRUSS_CAN_GBL_STAT_REG_VAL		0x00000040
</I>&gt;<i> +#define PRUSS_CAN_INTR_MASK_REG_VAL		0x00004000
</I>&gt;<i> +#define PRUSS_CAN_TIMING_VAL_TX			(PRUSS_PRU1_BASE_ADDRESS + 0xC0)
</I>&gt;<i> +#define PRUSS_CAN_TIMING_SETUP			(PRUSS_PRU1_BASE_ADDRESS + 0xC4)
</I>&gt;<i> +#define PRUSS_CAN_RX_GBL_STAT_REG		(PRUSS_PRU0_BASE_ADDRESS + 0x04)
</I>&gt;<i> +#define PRUSS_CAN_RX_INTR_MASK_REG		(PRUSS_PRU0_BASE_ADDRESS + 0x08)
</I>&gt;<i> +#define PRUSS_CAN_RX_INTR_STAT_REG		(PRUSS_PRU0_BASE_ADDRESS + 0x0C)
</I>&gt;<i> +#define PRUSS_CAN_RX_ERR_CNTR_REG		(PRUSS_PRU0_BASE_ADDRESS + 0x34)
</I>&gt;<i> +#define PRUSS_CAN_TIMING_VAL_RX			(PRUSS_PRU0_BASE_ADDRESS + 0xD0)
</I>&gt;<i> +#define PRUSS_CAN_BIT_TIMING_VAL_RX		(PRUSS_PRU0_BASE_ADDRESS + 0xD4)
</I>&gt;<i> +#define PRUSS_CAN_ID_MAP			(PRUSS_PRU0_BASE_ADDRESS + 0xF0)
</I>&gt;<i> +#define PRUSS_CAN_ERROR_ACTIVE			128
</I>&gt;<i> +#define PRUSS_CAN_GBL_STAT_REG_MASK		0x1F
</I>&gt;<i> +#define PRUSS_CAN_GBL_STAT_REG_SET_TX		0x80
</I>&gt;<i> +#define PRUSS_CAN_GBL_STAT_REG_SET_RX		0x40
</I>&gt;<i> +#define PRUSS_CAN_GBL_STAT_REG_STOP_TX		0x7F
</I>&gt;<i> +#define PRUSS_CAN_GBL_STAT_REG_STOP_RX		0xBF
</I>&gt;<i> +#define PRUSS_CAN_SET_TX_REQ			0x00000080
</I>&gt;<i> +#define PRUSS_CAN_STD_FRAME_MASK		18
</I>&gt;<i> +#define PRUSS_CAN_START				1
</I>&gt;<i> +#define PRUSS_CAN_MB_MIN			0
</I>&gt;<i> +#define PRUSS_CAN_MB_MAX			7
</I>&gt;<i> +#define PRUSS_CAN_MID_IDE			BIT(29)
</I>&gt;<i> +#define PRUSS_CAN_ISR_BIT_CCI			BIT(15)
</I>&gt;<i> +#define PRUSS_CAN_ISR_BIT_ESI			BIT(14)
</I>&gt;<i> +#define PRUSS_CAN_ISR_BIT_SRDI			BIT(13)
</I>&gt;<i> +#define PRUSS_CAN_ISR_BIT_RRI			BIT(8)
</I>&gt;<i> +#define PRUSS_CAN_GSR_BIT_EPM			BIT(4)
</I>&gt;<i> +#define PRUSS_CAN_GSR_BIT_BFM			BIT(3)
</I>&gt;<i> +#define PRUSS_CAN_RTR_BUFF_NUM			8
</I>&gt;<i> +#define PRUSS_DEF_NAPI_WEIGHT			8
</I>&gt;<i> +#define PRUSS_CAN_DRV_NAME &quot;da8xx_pruss_can&quot;
</I>&gt;<i> +#define PRUSS_CAN_DRV_DESC &quot;TI PRU CAN Controller Driver v1.0&quot;
</I>&gt;<i> +
</I>&gt;<i> +enum can_tx_dir {
</I>&gt;<i> +	TRANSMIT = 1,
</I>&gt;<i> +	RECEIVE
</I>
please add a &quot;,&quot; after RECEIVE

&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct can_mbox {
</I>
I suggest to add a namespace to these structs, e.g. pru_can_mbox. Same
comment applies to the other structs.

&gt;<i> +	canid_t can_id;
</I>
You write this struct into the hardware, don't you? So you should not
use kernel internal types to describe your hardware layout. Think about
declaring this struct __packed__

&gt;<i> +	u8 data[8];
</I>&gt;<i> +	u16 datalength;
</I>&gt;<i> +	u16 crc;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct can_emu_cntx {
</I>&gt;<i> +	enum can_tx_dir txdir;
</I>&gt;<i> +	struct can_mbox mbox;
</I>&gt;<i> +	u32 mboxno;
</I>&gt;<i> +	u8 pruno;
</I>&gt;<i> +	u32 gbl_stat;
</I>&gt;<i> +	u32 intr_stat;
</I>&gt;<i> +	u32 mbox_stat;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct can_emu_priv {
</I>&gt;<i> +	struct can_priv can;
</I>&gt;<i> +	struct napi_struct napi;
</I>&gt;<i> +	struct net_device *ndev;
</I>&gt;<i> +	struct device *dev;
</I>&gt;<i> +	struct clk *clk_timer;
</I>&gt;<i> +	struct can_emu_cntx can_tx_cntx;
</I>&gt;<i> +	struct can_emu_cntx can_rx_cntx;
</I>
I have not looked at the rest of the code, but it smells that you should
make this an array of two cntx.

&gt;<i> +	unsigned int clk_freq_pru;
</I>&gt;<i> +	unsigned int trx_irq;
</I>&gt;<i> +	unsigned int tx_head;
</I>&gt;<i> +	unsigned int tx_tail;
</I>&gt;<i> +	unsigned int tx_next;
</I>&gt;<i> +	unsigned int mbx_id[8];
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static struct can_bittiming_const pru_can_bittiming_const = {
</I>&gt;<i> +	.name = PRUSS_CAN_DRV_NAME,
</I>&gt;<i> +	.tseg1_min = 1,
</I>&gt;<i> +	.tseg1_max = 16,
</I>&gt;<i> +	.tseg2_min = 1,
</I>&gt;<i> +	.tseg2_max = 8,
</I>&gt;<i> +	.sjw_max = 4,
</I>&gt;<i> +	.brp_min = 1,
</I>&gt;<i> +	.brp_max = 256,
</I>&gt;<i> +	.brp_inc = 1,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_mbox_write(struct device *dev,
</I>&gt;<i> +			struct can_emu_cntx *emu_cntx)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 offset = 0;
</I>                  ^^^^^

not needed

&gt;<i> +
</I>&gt;<i> +	offset = PRUSS_PRU1_BASE_ADDRESS + PRUSS_CAN_MBOX_OFFSET
</I>&gt;<i> +			+ (PRUSS_CAN_MBOX_SIZE * emu_cntx-&gt;mboxno);
</I>&gt;<i> +
</I>&gt;<i> +	pruss_writel_multi(dev, offset, (u32 *) &amp;(emu_cntx-&gt;mbox), 4);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_mbox_read(struct device *dev,
</I>&gt;<i> +			struct can_emu_cntx *emu_cntx)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 offset = 0;
</I>
dito

&gt;<i> +
</I>&gt;<i> +	offset = PRUSS_PRU0_BASE_ADDRESS + PRUSS_CAN_MBOX_OFFSET
</I>&gt;<i> +			+ (PRUSS_CAN_MBOX_SIZE * emu_cntx-&gt;mboxno);
</I>&gt;<i> +
</I>&gt;<i> +	pruss_readl_multi(dev, offset, (u32 *) &amp;emu_cntx-&gt;mbox, 4);
</I>
where does this &quot;4&quot; come from? consider using sizeof()

&gt;<i> +
</I>&gt;<i> +	return 0;
</I>
why do you return 0 here? pruss_readl_multi is not void, although it
always returns 0, too. consider make all void.
&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_rx_id_set(struct device *dev, u32 nodeid, u32 mboxno)
</I>&gt;<i> +{
</I>&gt;<i> +	pruss_writel(dev, (PRUSS_CAN_ID_MAP + (mboxno * 4)), nodeid);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>
consider making this a void function.
&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_intr_stat_get(struct device *dev,
</I>&gt;<i> +		struct can_emu_cntx *emu_cntx)
</I>&gt;<i> +{
</I>&gt;<i> +	if (emu_cntx-&gt;pruno == PRUCORE_1)
</I>&gt;<i> +		pruss_readl(dev, PRUSS_CAN_TX_INTR_STAT_REG,
</I>&gt;<i> +				&amp;emu_cntx-&gt;intr_stat);
</I>&gt;<i> +	else if (emu_cntx-&gt;pruno == PRUCORE_0)
</I>&gt;<i> +		pruss_readl(dev, PRUSS_CAN_RX_INTR_STAT_REG,
</I>&gt;<i> +				&amp;emu_cntx-&gt;intr_stat);
</I>
If you describe the register layout with a struct with an array
containing with rx and tx registers you can get rid of the if..else..
use emu_cntx-&gt;pruno as index to the array.

&gt;<i> +	else
</I>&gt;<i> +		return -EINVAL;
</I>
It's an internally used function, if emu_cntx-&gt;pruno is bogous here
you've got really big problems. I think it's save to remove this. Then
this function would become a void function.

&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_gbl_stat_get(struct device *dev,
</I>&gt;<i> +		struct can_emu_cntx *emu_cntx)
</I>&gt;<i> +{
</I>&gt;<i> +	if (emu_cntx-&gt;pruno == PRUCORE_1)
</I>&gt;<i> +		pruss_readl(dev, PRUSS_CAN_TX_GBL_STAT_REG,
</I>&gt;<i> +				&amp;emu_cntx-&gt;gbl_stat);
</I>&gt;<i> +	else if (emu_cntx-&gt;pruno == PRUCORE_0)
</I>&gt;<i> +		pruss_readl(dev, PRUSS_CAN_RX_GBL_STAT_REG,
</I>&gt;<i> +				&amp;emu_cntx-&gt;gbl_stat);
</I>&gt;<i> +	else
</I>&gt;<i> +		return -EINVAL;
</I>&gt;<i> +	return 0;
</I>
Same comments apply here, too.

&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_tx_mode_set(struct device *dev, bool transfer_flag,
</I>&gt;<i> +					enum can_tx_dir ecan_trx)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 value;
</I>&gt;<i> +
</I>&gt;<i> +	if (ecan_trx == TRANSMIT) {
</I>&gt;<i> +		pruss_readl(dev, PRUSS_CAN_RX_GBL_STAT_REG, &amp;value);
</I>&gt;<i> +		if (transfer_flag) {
</I>&gt;<i> +			value &amp;= PRUSS_CAN_GBL_STAT_REG_MASK;
</I>&gt;<i> +			value |= PRUSS_CAN_GBL_STAT_REG_SET_TX;
</I>&gt;<i> +		} else
</I>&gt;<i> +			value &amp;= PRUSS_CAN_GBL_STAT_REG_STOP_TX;
</I>&gt;<i> +
</I>&gt;<i> +		pruss_writel(dev, PRUSS_CAN_RX_GBL_STAT_REG, value);
</I>&gt;<i> +		pruss_writel(dev, PRUSS_CAN_TX_GBL_STAT_REG, value);
</I>&gt;<i> +	} else if (ecan_trx == RECEIVE) {
</I>&gt;<i> +		pruss_readl(dev, PRUSS_CAN_RX_GBL_STAT_REG, &amp;value);
</I>&gt;<i> +		if (transfer_flag) {
</I>&gt;<i> +			value &amp;= PRUSS_CAN_GBL_STAT_REG_MASK;
</I>&gt;<i> +			value |= PRUSS_CAN_GBL_STAT_REG_SET_RX;
</I>&gt;<i> +		} else
</I>&gt;<i> +			value &amp;= PRUSS_CAN_GBL_STAT_REG_STOP_RX;
</I>&gt;<i> +
</I>&gt;<i> +		pruss_writel(dev, PRUSS_CAN_RX_GBL_STAT_REG, value);
</I>&gt;<i> +		pruss_writel(dev, PRUSS_CAN_TX_GBL_STAT_REG, value);
</I>&gt;<i> +	} else
</I>
Same comments apply here, too.

&gt;<i> +		return -EINVAL;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>
is this array const?
&gt;<i> +static u32 pruss_intc_init[19][3] = {
</I>&gt;<i> +	{PRUSS_INTC_POLARITY0,		PRU_INTC_REGMAP_MASK,	0xFFFFFFFF},
</I>&gt;<i> +	{PRUSS_INTC_POLARITY1,		PRU_INTC_REGMAP_MASK,	0xFFFFFFFF},
</I>&gt;<i> +	{PRUSS_INTC_TYPE0,		PRU_INTC_REGMAP_MASK,	0x1C000000},
</I>&gt;<i> +	{PRUSS_INTC_TYPE1,		PRU_INTC_REGMAP_MASK,	0},
</I>&gt;<i> +	{PRUSS_INTC_GLBLEN,		0,			1},
</I>&gt;<i> +	{PRUSS_INTC_HOSTMAP0,		PRU_INTC_REGMAP_MASK,	0x03020100},
</I>&gt;<i> +	{PRUSS_INTC_HOSTMAP1,		PRU_INTC_REGMAP_MASK,	0x07060504},
</I>&gt;<i> +	{PRUSS_INTC_HOSTMAP2,		PRU_INTC_REGMAP_MASK,	0x0000908},
</I>&gt;<i> +	{PRUSS_INTC_CHANMAP0,		PRU_INTC_REGMAP_MASK,	0},
</I>&gt;<i> +	{PRUSS_INTC_CHANMAP8,		PRU_INTC_REGMAP_MASK,	0x00020200},
</I>&gt;<i> +	{PRUSS_INTC_STATIDXCLR,		0,			32},
</I>&gt;<i> +	{PRUSS_INTC_STATIDXCLR,		0,			19},
</I>&gt;<i> +	{PRUSS_INTC_ENIDXSET,		0,			19},
</I>&gt;<i> +	{PRUSS_INTC_STATIDXCLR,		0,			18},
</I>&gt;<i> +	{PRUSS_INTC_ENIDXSET,		0,			18},
</I>&gt;<i> +	{PRUSS_INTC_STATIDXCLR,		0,			34},
</I>&gt;<i> +	{PRUSS_INTC_ENIDXSET,		0,			34},
</I>&gt;<i> +	{PRUSS_INTC_ENIDXSET,		0,			32},
</I>&gt;<i> +	{PRUSS_INTC_HOSTINTEN,		0,			5}
</I>
please add &quot;,&quot;

&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_emu_init(struct device *dev, u32 pruclock)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 value[8] = {[0 ... 7] = 1};
</I>&gt;<i> +	u32 i;
</I>we usually use plain ints as a for-loop variable.
&gt;<i> +
</I>&gt;<i> +	/* PRU Internal Registers Initializations */
</I>&gt;<i> +	pruss_writel_multi(dev, PRUSS_CAN_TX_MBOX0_STAT_REG, value, 8);
</I>
use sizeof(), or ARRAY_SIZE

&gt;<i> +
</I>&gt;<i> +	*value = PRUSS_CAN_GBL_STAT_REG_VAL;
</I>&gt;<i> +	pruss_writel(dev, PRUSS_CAN_TX_GBL_STAT_REG, value[0]);
</I>&gt;<i> +	pruss_writel(dev, PRUSS_CAN_RX_GBL_STAT_REG, value[0]);
</I>
why not:
pruss_writel(dev, PRUSS_CAN_TX_GBL_STAT_REG, PRUSS_CAN_GBL_STAT_REG_VAL);

&gt;<i> +
</I>&gt;<i> +	*value = PRUSS_CAN_INTR_MASK_REG_VAL;
</I>&gt;<i> +	pruss_writel(dev, PRUSS_CAN_TX_INTR_MASK_REG, value[0]);
</I>&gt;<i> +	pruss_writel(dev, PRUSS_CAN_RX_INTR_MASK_REG, value[0]);
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; 19; i++)
</I>ARRAY_SIZE
&gt;<i> +		(i &lt; 12) ?	pruss_rmwl(dev, pruss_intc_init[i][0],
</I>&gt;<i> +						pruss_intc_init[i][1],
</I>&gt;<i> +						pruss_intc_init[i][2]) :
</I>&gt;<i> +				pruss_idx_writel(dev, pruss_intc_init[i][0],
</I>&gt;<i> +						pruss_intc_init[i][2]);
</I>
if..else here, please

or put the stuff into two arrays

&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pru_can_emu_exit(struct device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	pruss_disable(dev, PRUSS_CAN_RX_PRU_0);
</I>&gt;<i> +	pruss_disable(dev, PRUSS_CAN_TX_PRU_1);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_tx(struct device *dev, u8 mboxnumber, u8 pruno)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 value = 0;
</I>&gt;<i> +
</I>&gt;<i> +	if (PRUCORE_1 == pruno) {
</I>
we usually write it the other way round...:
if (pruno == PRUCORE_1)
&gt;<i> +		value = PRUSS_CAN_SET_TX_REQ;
</I>&gt;<i> +		pruss_writel(dev, ((PRUSS_PRU1_BASE_ADDRESS +
</I>&gt;<i> +				(PRUSS_CAN_MBOX_STAT_OFFSET +
</I>&gt;<i> +				(PRUSS_CAN_MBOX_STAT_SIZE * mboxnumber)))
</I>&gt;<i> +				&amp; 0xFFFF), value);
</I>
don't use value, use PRUSS_CAN_SET_TX_REQ directly

&gt;<i> +	} else if (PRUCORE_0 == pruno) {
</I>&gt;<i> +		pruss_readl(dev, PRUSS_CAN_RX_INTR_STAT_REG, &amp;value);
</I>&gt;<i> +		value = value &amp; ~(1 &lt;&lt; mboxnumber);
</I>&gt;<i> +		pruss_writel(dev, PRUSS_CAN_RX_INTR_STAT_REG, value);
</I>&gt;<i> +		value = 0;
</I>&gt;<i> +		pruss_writel(dev, ((PRUSS_PRU0_BASE_ADDRESS +
</I>&gt;<i> +				(PRUSS_CAN_MBOX_STAT_OFFSET +
</I>&gt;<i> +				(PRUSS_CAN_MBOX_STAT_SIZE * mboxnumber)))
</I>&gt;<i> +				&amp; 0xFFFF), value);
</I>
same here

&gt;<i> +	} else
</I>&gt;<i> +		return -EINVAL;
</I>
trust your own code, get rid of the -EINVAL, make this a void function.

&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_reset_tx(struct device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	pruss_idx_writel(dev, PRUSS_INTC_STATIDXCLR, PRUSS_CAN_ARM2DSP_SYS_EVT);
</I>&gt;<i> +	pruss_idx_writel(dev, PRUSS_INTC_ENIDXSET, PRUSS_CAN_ARM2DSP_SYS_EVT);
</I>&gt;<i> +	pruss_idx_writel(dev, PRUSS_INTC_STATIDXSET, PRUSS_CAN_ARM2DSP_SYS_EVT);
</I>&gt;<i> +	return 0;
</I>
void function?
&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pru_can_mask_ints(struct device *dev, u32 trx, bool enable)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 value = 0;
</I>
not needed
&gt;<i> +
</I>&gt;<i> +	value = (trx == PRUSS_CAN_TX_PRU_1) ?
</I>&gt;<i> +		PRUSS_CAN_TX_SYS_EVT : PRUSS_CAN_RX_SYS_EVT;
</I>
use a struct with arrays for the register description

&gt;<i> +	enable ? pruss_idx_writel(dev, PRUSS_INTC_ENIDXSET, value) :
</I>&gt;<i> +		pruss_idx_writel(dev, PRUSS_INTC_ENIDXCLR, value);
</I>
if..else
&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static unsigned int pru_can_get_error_cnt(struct device *dev, u8 pruno)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 value = 0;
</I>not needed
&gt;<i> +
</I>&gt;<i> +	if (pruno == PRUSS_CAN_RX_PRU_0)
</I>&gt;<i> +		pruss_readl(dev, PRUSS_CAN_RX_ERR_CNTR_REG, &amp;value);
</I>&gt;<i> +	else if (pruno == PRUSS_CAN_TX_PRU_1)
</I>&gt;<i> +		pruss_readl(dev, PRUSS_CAN_TX_ERR_CNTR_REG, &amp;value);
</I>&gt;<i> +	else
</I>&gt;<i> +		return -EINVAL;
</I>
remove the -EINVAL

&gt;<i> +
</I>&gt;<i> +	return value;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static unsigned int pru_can_get_intc_status(struct device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 value = 0;
</I>not needed
&gt;<i> +
</I>&gt;<i> +	pruss_readl(dev, PRUSS_INTC_STATCLRINT1, &amp;value);
</I>&gt;<i> +	return value;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pru_can_clr_intc_status(struct device *dev, u32 trx)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 value = 0;
</I>dito
&gt;<i> +
</I>&gt;<i> +	value = (trx == PRUSS_CAN_TX_PRU_1) ?
</I>&gt;<i> +		PRUSS_CAN_TX_SYS_EVT : PRUSS_CAN_RX_SYS_EVT;
</I>
use a struct + array for the resiter desc

&gt;<i> +	pruss_idx_writel(dev, PRUSS_INTC_STATIDXCLR, value);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_get_state(const struct net_device *ndev,
</I>&gt;<i> +					enum can_state *state)
</I>&gt;<i> +{
</I>&gt;<i> +	struct can_emu_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	*state = priv-&gt;can.state;
</I>
we don't implemnt this function anymore..
&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_set_bittiming(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct can_emu_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> +	u32 value;
</I>&gt;<i> +
</I>&gt;<i> +	value = priv-&gt;can.clock.freq / bt-&gt;bitrate;
</I>&gt;<i> +	pruss_writel(priv-&gt;dev, PRUSS_CAN_TIMING_VAL_TX, value);
</I>&gt;<i> +	pruss_writel(priv-&gt;dev, PRUSS_CAN_BIT_TIMING_VAL_RX, value);
</I>&gt;<i> +
</I>&gt;<i> +	value = (bt-&gt;phase_seg2 + bt-&gt;phase_seg1 +
</I>&gt;<i> +			bt-&gt;prop_seg + 1) * bt-&gt;brp;
</I>&gt;<i> +	value = (value &gt;&gt; 1) - PRUSS_CAN_TIMER_SETUP_DELAY;
</I>&gt;<i> +	value = (value &lt;&lt; 16) | value;
</I>&gt;<i> +	pruss_writel(priv-&gt;dev, PRUSS_CAN_TIMING_VAL_RX, value);
</I>&gt;<i> +
</I>&gt;<i> +	value = (PRUSS_CAN_GPIO_SETUP_DELAY *
</I>&gt;<i> +		(priv-&gt;clk_freq_pru / 1000000) / 1000) /
</I>&gt;<i> +		PRUSS_CAN_DELAY_LOOP_LENGTH;
</I>&gt;<i> +
</I>&gt;<i> +	pruss_writel(priv-&gt;dev, PRUSS_CAN_TIMING_SETUP, value);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pru_can_stop(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct can_emu_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	pru_can_mask_ints(priv-&gt;dev, PRUSS_CAN_TX_PRU_1, false);
</I>&gt;<i> +	pru_can_mask_ints(priv-&gt;dev, PRUSS_CAN_RX_PRU_0, false);
</I>&gt;<i> +	pru_can_reset_tx(priv-&gt;dev);
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * This is to just set the can state to ERROR_ACTIVE
</I>&gt;<i> + *	ip link set canX up type can bitrate 125000
</I>
fix the comment

&gt;<i> + */
</I>&gt;<i> +static void pru_can_start(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct can_emu_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	if (priv-&gt;can.state != CAN_STATE_STOPPED)
</I>&gt;<i> +		pru_can_stop(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	pru_can_mask_ints(priv-&gt;dev, PRUSS_CAN_TX_PRU_1, true);
</I>&gt;<i> +	pru_can_mask_ints(priv-&gt;dev, PRUSS_CAN_RX_PRU_0, true);
</I>&gt;<i> +
</I>&gt;<i> +	pru_can_gbl_stat_get(priv-&gt;dev, &amp;priv-&gt;can_tx_cntx);
</I>&gt;<i> +	pru_can_gbl_stat_get(priv-&gt;dev, &amp;priv-&gt;can_rx_cntx);
</I>&gt;<i> +
</I>&gt;<i> +	if (PRUSS_CAN_GSR_BIT_EPM &amp; priv-&gt;can_tx_cntx.gbl_stat)
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> +	else if (PRUSS_CAN_GSR_BIT_BFM &amp; priv-&gt;can_tx_cntx.gbl_stat)
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +	else
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_set_mode(struct net_device *ndev, enum can_mode mode)
</I>&gt;<i> +{
</I>&gt;<i> +	int ret = 0;
</I>&gt;<i> +
</I>&gt;<i> +	switch (mode) {
</I>&gt;<i> +	case CAN_MODE_START:
</I>&gt;<i> +		pru_can_start(ndev);
</I>&gt;<i> +		netif_wake_queue(ndev);
</I>&gt;<i> +		break;
</I>&gt;<i> +	default:
</I>&gt;<i> +		ret = -EOPNOTSUPP;
</I>&gt;<i> +		break;
</I>&gt;<i> +	}
</I>&gt;<i> +	return ret;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static netdev_tx_t pru_can_start_xmit(struct sk_buff *skb,
</I>&gt;<i> +					struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct can_emu_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> +	int count;
</I>&gt;<i> +	u8 *data = cf-&gt;data;
</I>&gt;<i> +	u8 dlc = cf-&gt;can_dlc;
</I>&gt;<i> +	u8 *pdata = NULL;
</I>&gt;<i> +
</I>&gt;<i> +	if (can_dropped_invalid_skb(ndev, skb))
</I>&gt;<i> +		return NETDEV_TX_OK;
</I>&gt;<i> +
</I>&gt;<i> +	netif_stop_queue(ndev);
</I>
why do you stop the queue unconditionally here?


&gt;<i> +	if (cf-&gt;can_id &amp; CAN_EFF_FLAG)	/* Extended frame format */
</I>&gt;<i> +		priv-&gt;can_tx_cntx.mbox.can_id =
</I>&gt;<i> +		    (cf-&gt;can_id &amp; CAN_EFF_MASK) | PRUSS_CAN_MID_IDE;
</I>&gt;<i> +	else			/* Standard frame format */
</I>&gt;<i> +		priv-&gt;can_tx_cntx.mbox.can_id =
</I>&gt;<i> +		    (cf-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; PRUSS_CAN_STD_FRAME_MASK;
</I>&gt;<i> +
</I>&gt;<i> +	if (cf-&gt;can_id &amp; CAN_RTR_FLAG)	/* Remote transmission request */
</I>&gt;<i> +		priv-&gt;can_tx_cntx.mbox.can_id |= CAN_RTR_FLAG;
</I>&gt;<i> +
</I>&gt;<i> +	pdata = &amp;priv-&gt;can_tx_cntx.mbox.data[0] + (dlc - 1);
</I>&gt;<i> +	for (count = 0; count &lt; (u8) dlc; count++)
</I>&gt;<i> +		*pdata-- = *data++;
</I>
What does this loop do? endianess conversion? Please don't open code this.

&gt;<i> +
</I>&gt;<i> +	priv-&gt;can_tx_cntx.mbox.datalength = (u16) dlc;
</I>no need to cast

&gt;<i> +	priv-&gt;can_tx_cntx.mbox.crc = 0;
</I>&gt;<i> +/*
</I>&gt;<i> + * search for the next available mbx
</I>&gt;<i> + * if the next mbx is busy, then try the next + 1
</I>&gt;<i> + * do this until the head is reached.
</I>&gt;<i> + * if still unable to tx, stop accepting any packets
</I>&gt;<i> + * if able to tx and the head is reached, then reset next to tail, i.e mbx0
</I>&gt;<i> + * if head is not reached, then just point to the next mbx
</I>&gt;<i> + */
</I>
indention, please

Your tx algorithm looks fishy. You always use can_get_echo_skb(ndev, 0).
This means you can have only 1 can frame on the fly. But you say you
look for a free mailbox. You have to tx mailboxes in a defined order,
otherwise your hardware/firmware is broken. If your hardware transmits
frames in order, you always know which one will be the next free
mailbox. You have a power of 2 number of mailboxes, you can simply apply
a mask to get to the real mailbox number. No need for manual wrap
around. Have a look at the at91_can tx sheme.

Activate the tx_interrupt, putting a can frame into a mailbox, stop the
tx_queue if there are no free mailboxes, or in case of a wrap around.
Reenable the tx_queue in the tx_complete interrupt handler.

&gt;<i> +	for (; priv-&gt;tx_next &lt;= priv-&gt;tx_head; priv-&gt;tx_next++) {
</I>&gt;<i> +		priv-&gt;can_tx_cntx.mboxno = priv-&gt;tx_next;
</I>&gt;<i> +		if (-1 == pru_can_mbox_write(priv-&gt;dev,
</I>&gt;<i> +					&amp;priv-&gt;can_tx_cntx)) {
</I>
this function will always return 0.

&gt;<i> +			if (priv-&gt;tx_next == priv-&gt;tx_head) {
</I>&gt;<i> +				priv-&gt;tx_next = priv-&gt;tx_tail;
</I>&gt;<i> +				netif_stop_queue(ndev);	/* IF stalled */
</I>&gt;<i> +				dev_err(priv-&gt;dev,
</I>&gt;<i> +					&quot;%s: no tx mbx available&quot;, __func__);
</I>&gt;<i> +				return NETDEV_TX_BUSY;
</I>&gt;<i> +			} else
</I>&gt;<i> +				continue;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			/* set transmit request */
</I>&gt;<i> +			pru_can_tx(priv-&gt;dev, priv-&gt;tx_next,
</I>&gt;<i> +						PRUSS_CAN_TX_PRU_1);
</I>&gt;<i> +			pru_can_tx_mode_set(priv-&gt;dev, false, RECEIVE);
</I>&gt;<i> +			pru_can_tx_mode_set(priv-&gt;dev, true, TRANSMIT);
</I>&gt;<i> +			pru_can_reset_tx(priv-&gt;dev);
</I>&gt;<i> +			priv-&gt;tx_next++;
</I>&gt;<i> +			can_put_echo_skb(skb, ndev, 0);
</I>                                                   ^^^

see comment above

&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +	if (priv-&gt;tx_next &gt; priv-&gt;tx_head)
</I>&gt;<i> +		priv-&gt;tx_next = priv-&gt;tx_tail;
</I>&gt;<i> +
</I>&gt;<i> +	return NETDEV_TX_OK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_rx(struct net_device *ndev, u32 mbxno)
</I>&gt;<i> +{
</I>&gt;<i> +	struct can_emu_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	u8 *data = NULL;
</I>&gt;<i> +	u8 *pdata = NULL;
</I>&gt;<i> +	int count = 0;
</I>&gt;<i> +
</I>&gt;<i> +	skb = alloc_can_skb(ndev, &amp;cf);
</I>&gt;<i> +	if (!skb) {
</I>&gt;<i> +		if (printk_ratelimit())
</I>&gt;<i> +			dev_err(priv-&gt;dev,
</I>&gt;<i> +				&quot;alloc_can_skb() failed\n&quot;);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>&gt;<i> +	data = cf-&gt;data;
</I>&gt;<i> +	/* get payload */
</I>&gt;<i> +	priv-&gt;can_rx_cntx.mboxno = mbxno;
</I>&gt;<i> +	if (pru_can_mbox_read(priv-&gt;dev, &amp;priv-&gt;can_rx_cntx)) {
</I>
function always returns 0!

&gt;<i> +		dev_err(priv-&gt;dev, &quot;failed to get data from mailbox\n&quot;);
</I>&gt;<i> +		return -EAGAIN;
</I>&gt;<i> +	}
</I>&gt;<i> +	/* give ownweship to pru */
</I>&gt;<i> +	pru_can_tx(priv-&gt;dev, mbxno, PRUSS_CAN_RX_PRU_0);
</I>&gt;<i> +
</I>&gt;<i> +	/* get data length code */
</I>&gt;<i> +	cf-&gt;can_dlc = get_can_dlc(priv-&gt;can_rx_cntx.mbox.datalength &amp; 0xF);
</I>
This looks to complicated. Please state how the individual can bytes are
placed in the mailbox, so that we can think of a simpler way to do this.

&gt;<i> +	if (cf-&gt;can_dlc &lt;= 4) {
</I>&gt;<i> +		pdata = &amp;priv-&gt;can_rx_cntx.mbox.data[4] + (4 - cf-&gt;can_dlc);
</I>&gt;<i> +		for (count = 0; count &lt; cf-&gt;can_dlc; count++)
</I>&gt;<i> +			*data++ = *pdata++;
</I>&gt;<i> +	} else {
</I>&gt;<i> +		pdata = &amp;priv-&gt;can_rx_cntx.mbox.data[4];
</I>&gt;<i> +		for (count = 0; count &lt; 4; count++)
</I>&gt;<i> +			*data++ = *pdata++;
</I>&gt;<i> +		pdata = &amp;priv-&gt;can_rx_cntx.mbox.data[3] - (cf-&gt;can_dlc - 5);
</I>&gt;<i> +		for (count = 0; count &lt; cf-&gt;can_dlc - 4; count++)
</I>&gt;<i> +			*data++ = *pdata++;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* get id extended or std */
</I>&gt;<i> +	if (priv-&gt;can_rx_cntx.mbox.can_id &amp; PRUSS_CAN_MID_IDE)
</I>&gt;<i> +		cf-&gt;can_id = (priv-&gt;can_rx_cntx.mbox.can_id &amp; CAN_EFF_MASK)
</I>&gt;<i> +								| CAN_EFF_FLAG;
</I>
the usual way is to write the &quot;|&quot; at the end of the line.

&gt;<i> +	else
</I>&gt;<i> +		cf-&gt;can_id = (priv-&gt;can_rx_cntx.mbox.can_id &gt;&gt; 18)
</I>&gt;<i> +							&amp; CAN_SFF_MASK;
</I>&gt;<i> +
</I>&gt;<i> +	if (priv-&gt;can_rx_cntx.mbox.can_id &amp; CAN_RTR_FLAG)
</I>&gt;<i> +		cf-&gt;can_id |= CAN_RTR_FLAG;
</I>
please don't copy any data to the can frame in case if an RTR message.

&gt;<i> +
</I>&gt;<i> +	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +	netif_receive_skb(skb);
</I>&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_err(struct net_device *ndev, int int_status,
</I>&gt;<i> +			     int err_status)
</I>&gt;<i> +{
</I>&gt;<i> +	struct can_emu_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	u32 tx_err_cnt, rx_err_cnt;
</I>&gt;<i> +
</I>&gt;<i> +	skb = alloc_can_err_skb(ndev, &amp;cf);
</I>&gt;<i> +	if (!skb) {
</I>&gt;<i> +		if (printk_ratelimit())
</I>&gt;<i> +			dev_err(priv-&gt;dev,
</I>&gt;<i> +				&quot;alloc_can_err_skb() failed\n&quot;);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (err_status &amp; PRUSS_CAN_GSR_BIT_EPM) {	/* error passive int */
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> +		++priv-&gt;can.can_stats.error_passive;
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +		tx_err_cnt = pru_can_get_error_cnt(priv-&gt;dev,
</I>&gt;<i> +						PRUSS_CAN_TX_PRU_1);
</I>&gt;<i> +		rx_err_cnt = pru_can_get_error_cnt(priv-&gt;dev,
</I>&gt;<i> +						PRUSS_CAN_RX_PRU_0);
</I>&gt;<i> +		if (tx_err_cnt &gt; PRUSS_CAN_ERROR_ACTIVE - 1)
</I>&gt;<i> +			cf-&gt;data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
</I>&gt;<i> +		if (rx_err_cnt &gt; PRUSS_CAN_ERROR_ACTIVE - 1)
</I>&gt;<i> +			cf-&gt;data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> +
</I>&gt;<i> +		dev_dbg(priv-&gt;ndev-&gt;dev.parent, &quot;Error passive interrupt\n&quot;);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (err_status &amp; PRUSS_CAN_GSR_BIT_BFM) {
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> +		/*
</I>&gt;<i> +		 *      Disable all interrupts in bus-off to avoid int hog
</I>&gt;<i> +		 *      this should be handled by the pru
</I>&gt;<i> +		 */
</I>&gt;<i> +		pru_can_mask_ints(priv-&gt;dev, PRUSS_CAN_TX_PRU_1, false);
</I>&gt;<i> +		pru_can_mask_ints(priv-&gt;dev, PRUSS_CAN_RX_PRU_0, false);
</I>&gt;<i> +		can_bus_off(ndev);
</I>&gt;<i> +		dev_dbg(priv-&gt;ndev-&gt;dev.parent, &quot;Bus off mode\n&quot;);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	netif_rx(skb);
</I>&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;<i> +	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_rx_poll(struct napi_struct *napi, int quota)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = napi-&gt;dev;
</I>&gt;<i> +	struct can_emu_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	u32 bit_set, mbxno = 0;
</I>&gt;<i> +	u32 num_pkts = 0;
</I>&gt;<i> +
</I>&gt;<i> +	if (!netif_running(ndev))
</I>&gt;<i> +		return 0;
</I>&gt;<i> +
</I>&gt;<i> +	do {
</I>&gt;<i> +		/* rx int sys_evt -&gt; 33 */
</I>&gt;<i> +		pru_can_clr_intc_status(priv-&gt;dev, PRUSS_CAN_RX_PRU_0);
</I>&gt;<i> +		if (pru_can_intr_stat_get(priv-&gt;dev, &amp;priv-&gt;can_rx_cntx))
</I>&gt;<i> +			return num_pkts;
</I>&gt;<i> +
</I>&gt;<i> +		if (PRUSS_CAN_ISR_BIT_RRI &amp; priv-&gt;can_rx_cntx.intr_stat) {
</I>&gt;<i> +			mbxno = PRUSS_CAN_RTR_BUFF_NUM;
</I>&gt;<i> +			pru_can_rx(ndev, mbxno);
</I>&gt;<i> +			num_pkts++;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			/* Extract the mboxno from the status */
</I>&gt;<i> +			bit_set = fls(priv-&gt;can_rx_cntx.intr_stat &amp; 0xFF);
</I>&gt;<i> +			if (bit_set) {
</I>&gt;<i> +				num_pkts++;
</I>&gt;<i> +				mbxno = bit_set - 1;
</I>&gt;<i> +				if (PRUSS_CAN_ISR_BIT_ESI &amp; priv-&gt;can_rx_cntx.
</I>&gt;<i> +				    intr_stat) {
</I>&gt;<i> +					pru_can_gbl_stat_get(priv-&gt;dev,
</I>&gt;<i> +						&amp;priv-&gt;can_rx_cntx);
</I>&gt;<i> +						pru_can_err(ndev,
</I>&gt;<i> +					priv-&gt;can_rx_cntx.intr_stat,
</I>&gt;<i> +					priv-&gt;can_rx_cntx.gbl_stat);
</I>&gt;<i> +				} else
</I>&gt;<i> +					pru_can_rx(ndev, mbxno);
</I>&gt;<i> +			} else
</I>&gt;<i> +				break;
</I>&gt;<i> +		}
</I>&gt;<i> +	} while (((PRUSS_CAN_TX_INT_STAT &amp; pru_can_get_intc_status(priv-&gt;dev))
</I>&gt;<i> +						&amp;&amp; (num_pkts &lt; quota)));
</I>&gt;<i> +
</I>&gt;<i> +	/* Enable packet interrupt if all pkts are handled */
</I>&gt;<i> +	if (!(PRUSS_CAN_TX_INT_STAT &amp; pru_can_get_intc_status(priv-&gt;dev))) {
</I>&gt;<i> +		napi_complete(napi);
</I>&gt;<i> +		/* Re-enable RX mailbox interrupts */
</I>&gt;<i> +		pru_can_mask_ints(priv-&gt;dev, PRUSS_CAN_RX_PRU_0, true);
</I>&gt;<i> +	}
</I>&gt;<i> +	return num_pkts;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static irqreturn_t pru_tx_can_intr(int irq, void *dev_id)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = dev_id;
</I>&gt;<i> +	struct can_emu_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> +	u32 bit_set, mbxno;
</I>&gt;<i> +
</I>&gt;<i> +	pru_can_intr_stat_get(priv-&gt;dev, &amp;priv-&gt;can_tx_cntx);
</I>&gt;<i> +	if ((PRUSS_CAN_ISR_BIT_CCI &amp; priv-&gt;can_tx_cntx.intr_stat)
</I>&gt;<i> +	    || (PRUSS_CAN_ISR_BIT_SRDI &amp; priv-&gt;can_tx_cntx.intr_stat)) {
</I>&gt;<i> +		dev_dbg(priv-&gt;ndev-&gt;dev.parent, &quot;tx_int_status = 0x%X\n&quot;,
</I>&gt;<i> +			    priv-&gt;can_tx_cntx.intr_stat);
</I>&gt;<i> +		can_free_echo_skb(ndev, 0);
</I>                                       ^^^

make no sense if using multiple tx mailboxes

&gt;<i> +	} else {
</I>&gt;<i> +		bit_set = fls(priv-&gt;can_tx_cntx.intr_stat &amp; 0xFF);
</I>&gt;<i> +		if (!bit_set) {
</I>&gt;<i> +			dev_err(priv-&gt;dev, &quot;%s: invalid mailbox number\n&quot;,
</I>&gt;<i> +								__func__);
</I>&gt;<i> +			can_free_echo_skb(ndev, 0);
</I>                                               ^^^^
&gt;<i> +		} else {
</I>&gt;<i> +			mbxno = bit_set - 1;
</I>&gt;<i> +			if (PRUSS_CAN_ISR_BIT_ESI &amp; priv-&gt;can_tx_cntx.
</I>&gt;<i> +								intr_stat) {
</I>&gt;<i> +				/* read gsr and ack pru */
</I>&gt;<i> +				pru_can_gbl_stat_get(priv-&gt;dev,
</I>&gt;<i> +							&amp;priv-&gt;can_tx_cntx);
</I>&gt;<i> +				pru_can_err(ndev, priv-&gt;can_tx_cntx.intr_stat,
</I>&gt;<i> +						priv-&gt;can_tx_cntx.gbl_stat);
</I>&gt;<i> +			} else {
</I>&gt;<i> +				stats-&gt;tx_packets++;
</I>&gt;<i> +				/* stats-&gt;tx_bytes += dlc; */
</I>&gt;<i> +				/*can_get_echo_skb(ndev, 0);*/
</I>
??

&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +	netif_wake_queue(ndev);
</I>&gt;<i> +	can_get_echo_skb(ndev, 0);
</I>again?
&gt;<i> +	pru_can_tx_mode_set(priv-&gt;dev, true, RECEIVE);
</I>&gt;<i> +	return IRQ_HANDLED;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static irqreturn_t pru_rx_can_intr(int irq, void *dev_id)
</I>
why is this function calles rx_can_intr it's a generic interrupt function..

&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = dev_id;
</I>&gt;<i> +	struct can_emu_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	u32 intc_status = 0;
</I>&gt;<i> +
</I>&gt;<i> +	intc_status = pru_can_get_intc_status(priv-&gt;dev);
</I>&gt;<i> +
</I>&gt;<i> +	/* tx int sys_evt -&gt; 34 */
</I>&gt;<i> +	if (intc_status &amp; 4) {
</I>&gt;<i> +		pru_can_clr_intc_status(priv-&gt;dev, PRUSS_CAN_TX_PRU_1);
</I>&gt;<i> +		return pru_tx_can_intr(irq, dev_id);
</I>why are you returning here? is is possible the you have a can frame to
receivce?
&gt;<i> +	}
</I>&gt;<i> +	/* Disable RX mailbox interrupts and let NAPI reenable them */
</I>&gt;<i> +	if (intc_status &amp; 2) {
</I>&gt;<i> +		pru_can_mask_ints(priv-&gt;dev, PRUSS_CAN_RX_PRU_0, false);
</I>&gt;<i> +		napi_schedule(&amp;priv-&gt;napi);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return IRQ_HANDLED;
</I>               ^^^^^^^^^^^^

that might not be true....

&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_open(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct can_emu_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	s32 err;
</I>&gt;<i> +
</I>&gt;<i> +	/* register interrupt handler */
</I>&gt;<i> +	err = request_irq(priv-&gt;trx_irq, &amp;pru_rx_can_intr, IRQF_SHARED,
</I>&gt;<i> +						&quot;pru_can_irq&quot;, ndev);
</I>
use dev-&gt;name for interrupt name

&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(priv-&gt;dev, &quot;error requesting rx interrupt\n&quot;);
</I>&gt;<i> +		goto exit_trx_irq;
</I>&gt;<i> +	}
</I>&gt;<i> +	err = open_candev(ndev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(priv-&gt;dev, &quot;open_candev() failed %d\n&quot;, err);
</I>&gt;<i> +		goto exit_open;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	pru_can_emu_init(priv-&gt;dev, priv-&gt;can.clock.freq);
</I>&gt;<i> +	priv-&gt;tx_tail = PRUSS_CAN_MB_MIN;
</I>&gt;<i> +	priv-&gt;tx_head = PRUSS_CAN_MB_MAX;
</I>&gt;<i> +	pru_can_start(ndev);
</I>&gt;<i> +	napi_enable(&amp;priv-&gt;napi);
</I>&gt;<i> +	netif_start_queue(ndev);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +exit_open:
</I>&gt;<i> +	free_irq(priv-&gt;trx_irq, ndev);
</I>&gt;<i> +exit_trx_irq:
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_close(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct can_emu_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	netif_stop_queue(ndev);
</I>&gt;<i> +	napi_disable(&amp;priv-&gt;napi);
</I>&gt;<i> +	close_candev(ndev);
</I>&gt;<i> +	free_irq(priv-&gt;trx_irq, ndev);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static const struct net_device_ops pru_can_netdev_ops = {
</I>&gt;<i> +	.ndo_open		= pru_can_open,
</I>&gt;<i> +	.ndo_stop		= pru_can_close,
</I>&gt;<i> +	.ndo_start_xmit		= pru_can_start_xmit,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/* Shows all the mailbox IDs */
</I>&gt;<i> +static ssize_t pru_sysfs_mbx_id_show(struct device *dev,
</I>&gt;<i> +		struct device_attribute *attr, char *buf)
</I>&gt;<i> +{
</I>&gt;<i> +	struct can_emu_priv *priv = netdev_priv(to_net_dev(dev));
</I>&gt;<i> +
</I>&gt;<i> +	return snprintf(buf, PAGE_SIZE, &quot;&lt;mbx_no:mbx_id&gt;\n&quot;
</I>&gt;<i> +					&quot;0:0x%X 1:0x%X 2:0x%X 3:0x%X &quot;
</I>&gt;<i> +					&quot;4:0x%X 5:0x%X 6:0x%X 7:0x%X\n&quot;,
</I>&gt;<i> +					priv-&gt;mbx_id[0], priv-&gt;mbx_id[1],
</I>&gt;<i> +					priv-&gt;mbx_id[2], priv-&gt;mbx_id[3],
</I>&gt;<i> +					priv-&gt;mbx_id[4], priv-&gt;mbx_id[5],
</I>&gt;<i> +					priv-&gt;mbx_id[6], priv-&gt;mbx_id[7]);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * Sets Mailbox IDs
</I>&gt;<i> + * This should be programmed as mbx_num:mbx_id (in hex)
</I>&gt;<i> + * eg: $ echo 0:0x123 &gt; /sys/class/net/can0/mbx_id
</I>&gt;<i> + */
</I>&gt;<i> +static ssize_t pru_sysfs_mbx_id_set(struct device *dev,
</I>&gt;<i> +		struct device_attribute *attr, const char *buf, size_t count)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = to_net_dev(dev);
</I>&gt;<i> +	struct can_emu_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	unsigned long can_id;
</I>&gt;<i> +	unsigned long mbx_num;
</I>&gt;<i> +	char mbx[2] = {*buf, '\0'}; /* mbx num */
</I>&gt;<i> +	ssize_t ret = count;
</I>&gt;<i> +	s32 err;
</I>
I think you have to lock here:
rtnl_lock();
&gt;<i> +
</I>&gt;<i> +	if (ndev-&gt;flags &amp; IFF_UP) {
</I>&gt;<i> +		ret = -EBUSY;
</I>&gt;<i> +		goto out;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (*(buf + 1) != ':') {
</I>&gt;<i> +		ret = -EINVAL;
</I>&gt;<i> +		goto out;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	err = strict_strtoul(mbx, 0, &amp;mbx_num);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		ret = err;
</I>&gt;<i> +		goto out;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (mbx_num &gt; 7) {
</I>&gt;<i> +		ret = -EINVAL;
</I>&gt;<i> +		goto out;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	err = strict_strtoul((buf + 2), 0, &amp;can_id);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		ret = err;
</I>&gt;<i> +		goto out;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;mbx_id[mbx_num] = can_id;
</I>&gt;<i> +	pru_can_rx_id_set(priv-&gt;dev, priv-&gt;mbx_id[mbx_num], mbx_num);
</I>&gt;<i> +
</I>&gt;<i> +	return ret;
</I>&gt;<i> +out:
</I>&gt;<i> +	dev_err(priv-&gt;dev, &quot;invalid buffer format\n&quot;);
</I>&gt;<i> +	return ret;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static DEVICE_ATTR(mbx_id, S_IWUSR | S_IRUGO,
</I>&gt;<i> +	pru_sysfs_mbx_id_show, pru_sysfs_mbx_id_set);
</I>&gt;<i> +
</I>&gt;<i> +static struct attribute *pru_sysfs_attrs[] = {
</I>&gt;<i> +	&amp;dev_attr_mbx_id.attr,
</I>&gt;<i> +	NULL,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static struct attribute_group pru_sysfs_attr_group = {
</I>&gt;<i> +	.attrs = pru_sysfs_attrs,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int __devinit pru_can_probe(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = NULL;
</I>&gt;<i> +	const struct da850_evm_pruss_can_data *pdata;
</I>&gt;<i> +	struct can_emu_priv *priv = NULL;
</I>&gt;<i> +	struct device *dev = &amp;pdev-&gt;dev;
</I>&gt;<i> +	struct clk *clk_pruss;
</I>&gt;<i> +	const struct firmware *fw_rx;
</I>&gt;<i> +	const struct firmware *fw_tx;
</I>&gt;<i> +	u32 err;
</I>use int
&gt;<i> +
</I>&gt;<i> +	pdata = dev-&gt;platform_data;
</I>&gt;<i> +	if (!pdata) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;platform data not found\n&quot;);
</I>&gt;<i> +		return -EINVAL;
</I>&gt;<i> +	}
</I>&gt;<i> +	(pdata-&gt;setup)();
</I>
no need fot the ( )

&gt;<i> +
</I>&gt;<i> +	ndev = alloc_candev(sizeof(struct can_emu_priv), PRUSS_CAN_MB_MAX + 1);
</I>&gt;<i> +	if (!ndev) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;alloc_candev failed\n&quot;);
</I>&gt;<i> +		err = -ENOMEM;
</I>&gt;<i> +		goto probe_exit;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	ndev-&gt;sysfs_groups[0] = &amp;pru_sysfs_attr_group;
</I>&gt;<i> +
</I>&gt;<i> +	priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;trx_irq = platform_get_irq(to_platform_device(dev-&gt;parent), 0);
</I>&gt;<i> +	if (!priv-&gt;trx_irq) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;unable to get pru &quot;
</I>&gt;<i> +						&quot;interrupt resources!\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_exit;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;ndev = ndev;
</I>&gt;<i> +	priv-&gt;dev = dev;
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.bittiming_const = &amp;pru_can_bittiming_const;
</I>&gt;<i> +	priv-&gt;can.do_set_bittiming = pru_can_set_bittiming;
</I>&gt;<i> +	priv-&gt;can.do_set_mode = pru_can_set_mode;
</I>&gt;<i> +	priv-&gt;can.do_get_state = pru_can_get_state;
</I>&gt;<i> +	priv-&gt;can_tx_cntx.pruno = PRUSS_CAN_TX_PRU_1;
</I>&gt;<i> +	priv-&gt;can_rx_cntx.pruno = PRUSS_CAN_RX_PRU_0;
</I>&gt;<i> +
</I>&gt;<i> +	/* we support local echo, no arp */
</I>&gt;<i> +	ndev-&gt;flags |= (IFF_ECHO | IFF_NOARP);
</I>
no need to se NOARP

&gt;<i> +
</I>&gt;<i> +	/* pdev-&gt;dev-&gt;device_private-&gt;driver_data = ndev */
</I>&gt;<i> +	platform_set_drvdata(pdev, ndev);
</I>&gt;<i> +	SET_NETDEV_DEV(ndev, &amp;pdev-&gt;dev);
</I>&gt;<i> +	ndev-&gt;netdev_ops = &amp;pru_can_netdev_ops;
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;clk_timer = clk_get(&amp;pdev-&gt;dev, &quot;pll1_sysclk2&quot;);
</I>&gt;<i> +	if (IS_ERR(priv-&gt;clk_timer)) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;no timer clock available\n&quot;);
</I>&gt;<i> +		err = PTR_ERR(priv-&gt;clk_timer);
</I>&gt;<i> +		priv-&gt;clk_timer = NULL;
</I>&gt;<i> +		goto probe_exit_candev;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.clock.freq = clk_get_rate(priv-&gt;clk_timer);
</I>&gt;<i> +
</I>&gt;<i> +	clk_pruss = clk_get(NULL, &quot;pruss&quot;);
</I>&gt;<i> +	if (IS_ERR(clk_pruss)) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;no clock available: pruss\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_exit_clk;
</I>&gt;<i> +	}
</I>&gt;<i> +	priv-&gt;clk_freq_pru = clk_get_rate(clk_pruss);
</I>&gt;<i> +	clk_put(clk_pruss);
</I>
why do you put the clock here?
&gt;<i> +
</I>&gt;<i> +	err = register_candev(ndev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;register_candev() failed\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_exit_clk;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	err = request_firmware(&amp;fw_tx, &quot;PRU_CAN_Emulation_Tx.bin&quot;,
</I>&gt;<i> +			&amp;pdev-&gt;dev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;can't load firmware\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_exit_clk;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	dev_info(&amp;pdev-&gt;dev, &quot;fw_tx size %d. downloading...\n&quot;, fw_tx-&gt;size);
</I>&gt;<i> +
</I>&gt;<i> +	err = request_firmware(&amp;fw_rx, &quot;PRU_CAN_Emulation_Rx.bin&quot;,
</I>&gt;<i> +			&amp;pdev-&gt;dev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;can't load firmware\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_release_fw;
</I>&gt;<i> +	}
</I>&gt;<i> +	dev_info(&amp;pdev-&gt;dev, &quot;fw_rx size %d. downloading...\n&quot;, fw_rx-&gt;size);
</I>&gt;<i> +
</I>&gt;<i> +	/* init the pru */
</I>&gt;<i> +	pru_can_emu_init(priv-&gt;dev, priv-&gt;can.clock.freq);
</I>&gt;<i> +	udelay(200);
</I>&gt;<i> +
</I>&gt;<i> +	netif_napi_add(ndev, &amp;priv-&gt;napi, pru_can_rx_poll,
</I>&gt;<i> +					PRUSS_DEF_NAPI_WEIGHT);
</I>
personally I'd wait to add the interface to napi until the firmware is
loaded.

&gt;<i> +
</I>&gt;<i> +	pruss_enable(priv-&gt;dev, PRUSS_CAN_RX_PRU_0);
</I>&gt;<i> +	pruss_enable(priv-&gt;dev, PRUSS_CAN_TX_PRU_1);
</I>&gt;<i> +
</I>&gt;<i> +	/* download firmware into pru */
</I>&gt;<i> +	err = pruss_load(priv-&gt;dev, PRUSS_CAN_RX_PRU_0,
</I>&gt;<i> +		(u32 *)fw_rx-&gt;data, (fw_rx-&gt;size / 4));
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;firmware download error\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_release_fw_1;
</I>&gt;<i> +	}
</I>&gt;<i> +	release_firmware(fw_rx);
</I>&gt;<i> +	err = pruss_load(priv-&gt;dev, PRUSS_CAN_TX_PRU_1,
</I>&gt;<i> +		(u32 *)fw_tx-&gt;data, (fw_tx-&gt;size / 4));
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;firmware download error\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_release_fw_1;
</I>&gt;<i> +	}
</I>&gt;<i> +	release_firmware(fw_tx);
</I>&gt;<i> +
</I>&gt;<i> +	pruss_run(priv-&gt;dev, PRUSS_CAN_RX_PRU_0);
</I>&gt;<i> +	pruss_run(priv-&gt;dev, PRUSS_CAN_TX_PRU_1);
</I>&gt;<i> +
</I>&gt;<i> +	dev_info(&amp;pdev-&gt;dev,
</I>&gt;<i> +		 &quot;%s device registered (trx_irq = %d,  clk = %d)\n&quot;,
</I>&gt;<i> +		 PRUSS_CAN_DRV_NAME, priv-&gt;trx_irq, priv-&gt;can.clock.freq);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +probe_release_fw_1:
</I>&gt;<i> +	release_firmware(fw_rx);
</I>&gt;<i> +probe_release_fw:
</I>&gt;<i> +	release_firmware(fw_tx);
</I>&gt;<i> +probe_exit_clk:
</I>&gt;<i> +	clk_put(priv-&gt;clk_timer);
</I>&gt;<i> +probe_exit_candev:
</I>&gt;<i> +	if (NULL != ndev)
</I>&gt;<i> +		free_candev(ndev);
</I>&gt;<i> +probe_exit:
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int __devexit pru_can_remove(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = platform_get_drvdata(pdev);
</I>&gt;<i> +	struct can_emu_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	pru_can_stop(ndev);
</I>&gt;<i> +	pru_can_emu_exit(priv-&gt;dev);
</I>&gt;<i> +	clk_put(priv-&gt;clk_timer);
</I>&gt;<i> +	unregister_candev(ndev);
</I>&gt;<i> +	free_candev(ndev);
</I>&gt;<i> +	platform_set_drvdata(pdev, NULL);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_PM
</I>&gt;<i> +static int pru_can_suspend(struct platform_device *pdev,
</I>&gt;<i> +			pm_message_t mesg)
</I>&gt;<i> +{
</I>&gt;<i> +	dev_info(&amp;pdev-&gt;dev, &quot;%s not yet implemented\n&quot;, __func__);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pru_can_resume(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	dev_info(&amp;pdev-&gt;dev, &quot;%s not yet implemented\n&quot;, __func__);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +#else
</I>&gt;<i> +#define pru_can_suspend NULL
</I>&gt;<i> +#define pru_can_resume NULL
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +static struct platform_driver omapl_pru_can_driver = {
</I>&gt;<i> +	.probe		= pru_can_probe,
</I>&gt;<i> +	.remove		= __devexit_p(pru_can_remove),
</I>&gt;<i> +	.suspend	= pru_can_suspend,
</I>&gt;<i> +	.resume		= pru_can_resume,
</I>&gt;<i> +	.driver		= {
</I>&gt;<i> +		.name	= PRUSS_CAN_DRV_NAME,
</I>&gt;<i> +		.owner	= THIS_MODULE,
</I>&gt;<i> +	},
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int __init pru_can_init(void)
</I>&gt;<i> +{
</I>&gt;<i> +	pr_debug(KERN_INFO PRUSS_CAN_DRV_DESC &quot;\n&quot;);
</I>&gt;<i> +	return platform_driver_register(&amp;omapl_pru_can_driver);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +module_init(pru_can_init);
</I>&gt;<i> +
</I>&gt;<i> +static void __exit pru_can_exit(void)
</I>&gt;<i> +{
</I>&gt;<i> +	pr_debug(KERN_INFO PRUSS_CAN_DRV_DESC &quot; unloaded\n&quot;);
</I>&gt;<i> +	platform_driver_unregister(&amp;omapl_pru_can_driver);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +module_exit(pru_can_exit);
</I>&gt;<i> +
</I>&gt;<i> +MODULE_AUTHOR(&quot;Subhasish Ghosh &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">subhasish at mistralsolutions.com</A>&gt;&quot;);
</I>&gt;<i> +MODULE_LICENSE(&quot;GPL&quot;);
</I>&gt;<i> +MODULE_DESCRIPTION(&quot;omapl pru CAN netdevice driver&quot;);
</I>
regards, Marc

-- 
Pengutronix e.K.                  | Marc Kleine-Budde           |
Industrial Linux Solutions        | Phone: +49-231-2826-924     |
Vertretung West/Dortmund          | Fax:   +49-5121-206917-5555 |
Amtsgericht Hildesheim, HRA 2686  | <A HREF="http://www.pengutronix.de">http://www.pengutronix.de</A>   |

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 262 bytes
Desc: OpenPGP digital signature
URL: &lt;<A HREF="https://lists.berlios.de/pipermail/socketcan-core/attachments/20110422/bd2fdced/attachment.pgp">https://lists.berlios.de/pipermail/socketcan-core/attachments/20110422/bd2fdced/attachment.pgp</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005652.html">[PATCH v4 1/1] can: add pruss CAN driver.
</A></li>
	<LI>Next message: <A HREF="005659.html">[PATCH v4 1/1] can: add pruss CAN driver.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5655">[ date ]</a>
              <a href="thread.html#5655">[ thread ]</a>
              <a href="subject.html#5655">[ subject ]</a>
              <a href="author.html#5655">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
