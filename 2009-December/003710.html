<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH] Add driver for esd USB2 CAN interface
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-December/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20Add%20driver%20for%20esd%20USB2%20CAN%20interface&In-Reply-To=%3C4B387260.70506%40grandegger.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003686.html">
   <LINK REL="Next"  HREF="003685.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH] Add driver for esd USB2 CAN interface</H1>
    <B>Wolfgang Grandegger</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20Add%20driver%20for%20esd%20USB2%20CAN%20interface&In-Reply-To=%3C4B387260.70506%40grandegger.com%3E"
       TITLE="[PATCH] Add driver for esd USB2 CAN interface">wg at grandegger.com
       </A><BR>
    <I>Mon Dec 28 09:54:56 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003686.html">[PATCH] Add driver for esd USB2 CAN interface
</A></li>
        <LI>Next message: <A HREF="003685.html">[PATCH] Add driver for esd USB2 CAN interface
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3710">[ date ]</a>
              <a href="thread.html#3710">[ thread ]</a>
              <a href="subject.html#3710">[ subject ]</a>
              <a href="author.html#3710">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Matthias,

I agree with most of Marc's comments and I will not address all of
them here.

Matthias Fuchs wrote:
&gt;<i> This patch adds support for esd's CAN/USB2 high speed USB 2.0 
</I>&gt;<i> CAN interface module. Multiple CAN interfaces per module are supported.
</I>&gt;<i> 
</I>&gt;<i> This driver has been tested on x86 and PowerPC.
</I>&gt;<i> 
</I>&gt;<i> Q: I am not absolutely sure if some locking is required inside
</I>&gt;<i> the driver code. Please have a look.
</I>
What do you have in mind. I suspect a race with &quot;active_tx_urbs&quot; but so
far I did not spot something critical. In general, please remove the
dev_dbg's mainly aiding in debugging. Also, use ND2D() in all can_dbg(),
can_info(), etc.

&gt;<i> Signed-off-by: Matthias Fuchs &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">matthias.fuchs at esd.eu</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> Index: kernel/2.6/Makefile
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- kernel/2.6/Makefile	(revision 1095)
</I>&gt;<i> +++ kernel/2.6/Makefile	(working copy)
</I>&gt;<i> @@ -24,6 +24,7 @@
</I>&gt;<i>  export CONFIG_CAN_EMS_104M=m
</I>&gt;<i>  export CONFIG_CAN_ESD_PCI=m
</I>&gt;<i>  export CONFIG_CAN_ESD_331=m
</I>&gt;<i> +export CONFIG_CAN_ESD_USB2=m
</I>&gt;<i>  export CONFIG_CAN_PIPCAN=m
</I>&gt;<i>  export CONFIG_CAN_SOFTING=m
</I>&gt;<i>  export CONFIG_CAN_SOFTING_CS=m
</I>&gt;<i> Index: kernel/2.6/drivers/net/can/usb/Kconfig
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- kernel/2.6/drivers/net/can/usb/Kconfig	(revision 1095)
</I>&gt;<i> +++ kernel/2.6/drivers/net/can/usb/Kconfig	(working copy)
</I>&gt;<i> @@ -7,4 +7,10 @@
</I>&gt;<i>  	  This driver is for the one channel CPC-USB/ARM7 CAN/USB interface
</I>&gt;<i>  	  from from EMS Dr. Thomas Wuensche (<A HREF="http://www.ems-wuensche.de">http://www.ems-wuensche.de</A>).
</I>&gt;<i>  
</I>&gt;<i> +config CAN_ESD_USB2
</I>&gt;<i> +	tristate &quot;ESD USB/2 CAN/USB interface&quot;
</I>&gt;<i> +	---help---
</I>&gt;<i> +	  This driver supports the CAN-USB/2 interface
</I>&gt;<i> +	  from esd electronic system design gmbh (<A HREF="http://www.esd.eu">http://www.esd.eu</A>).
</I>&gt;<i> +
</I>&gt;<i>  endmenu
</I>&gt;<i> Index: kernel/2.6/drivers/net/can/usb/esd_usb2.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- kernel/2.6/drivers/net/can/usb/esd_usb2.c	(revision 0)
</I>&gt;<i> +++ kernel/2.6/drivers/net/can/usb/esd_usb2.c	(revision 0)
</I>&gt;<i> @@ -0,0 +1,1113 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * CAN driver for esd CAN-USB/2
</I>&gt;<i> + *
</I>&gt;<i> + * Copyright (C) 2009 Matthias Fuchs &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">matthias.fuchs at esd.eu</A>&gt;, esd gmbh
</I>&gt;<i> + *
</I>&gt;<i> + * This program is free software; you can redistribute it and/or modify it
</I>&gt;<i> + * under the terms of the GNU General Public License as published
</I>&gt;<i> + * by the Free Software Foundation; version 2 of the License.
</I>&gt;<i> + *
</I>&gt;<i> + * This program is distributed in the hope that it will be useful, but
</I>&gt;<i> + * WITHOUT ANY WARRANTY; without even the implied warranty of
</I>&gt;<i> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
</I>&gt;<i> + * General Public License for more details.
</I>&gt;<i> + *
</I>&gt;<i> + * You should have received a copy of the GNU General Public License along
</I>&gt;<i> + * with this program; if not, write to the Free Software Foundation, Inc.,
</I>&gt;<i> + * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
</I>&gt;<i> + */
</I>&gt;<i> +#undef DEBUG
</I>
Please remove.

&gt;<i> +#include &lt;linux/init.h&gt;
</I>&gt;<i> +#include &lt;linux/signal.h&gt;
</I>&gt;<i> +#include &lt;linux/slab.h&gt;
</I>&gt;<i> +#include &lt;linux/module.h&gt;
</I>&gt;<i> +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> +#include &lt;linux/usb.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;socketcan/can.h&gt;
</I>&gt;<i> +#include &lt;socketcan/can/dev.h&gt;
</I>&gt;<i> +#include &lt;socketcan/can/error.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +MODULE_AUTHOR(&quot;Matthias Fuchs &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">matthias.fuchs at esd.eu</A>&gt;&quot;);
</I>&gt;<i> +MODULE_DESCRIPTION(&quot;CAN driver for esd CAN-USB/2 interfaces&quot;);
</I>&gt;<i> +MODULE_LICENSE(&quot;GPL v2&quot;);
</I>&gt;<i> +
</I>&gt;<i> +/* Define these values to match your devices */
</I>&gt;<i> +#define USB_ESDGMBH_VENDOR_ID	0x0ab4
</I>&gt;<i> +#define USB_CANUSB2_PRODUCT_ID	0x0010
</I>&gt;<i> +
</I>&gt;<i> +#define ESD_USB2_CAN_CLOCK	60000000
</I>&gt;<i> +#define ESD_USB2_MAX_NETS	2
</I>&gt;<i> +
</I>&gt;<i> +/* USB2 commands */
</I>&gt;<i> +#define CMD_VERSION	1 /* also used for VERSION_REPLY */
</I>&gt;<i> +#define CMD_CAN_RX	2 /* device to host only */
</I>&gt;<i> +#define CMD_CAN_TX	3 /* also used for TX_DONE */
</I>&gt;<i> +#define CMD_SETBAUD	4 /* also used for SETBAUD_REPLY */
</I>&gt;<i> +#define CMD_TS		5 /* also used for TS_REPLY */
</I>&gt;<i> +#define CMD_IDADD	6 /* also used for IDADD_REPLY */
</I>&gt;<i> +
</I>&gt;<i> +/* esd CAN message flags - dlc field */
</I>&gt;<i> +#define ESD_RTR		0x10
</I>&gt;<i> +
</I>&gt;<i> +/* esd CAN message flags - id field */
</I>&gt;<i> +#define ESD_EXTID	0x20000000
</I>&gt;<i> +#define ESD_EVENT	0x40000000
</I>&gt;<i> +#define ESD_IDMASK	0x1fffffff
</I>&gt;<i> +
</I>&gt;<i> +/* esd CAN event ids used by this driver */
</I>&gt;<i> +#define ESD_EV_CAN_ERROR_EXT 2
</I>&gt;<i> +
</I>&gt;<i> +/* baudrate message flags */
</I>&gt;<i> +#define ESD_UBR		0x80000000
</I>&gt;<i> +#define ESD_LOM		0x40000000
</I>&gt;<i> +#define ESD_NO_BAUDRATE 0x7fffffff
</I>&gt;<i> +
</I>&gt;<i> +/* esd IDADD message */
</I>&gt;<i> +#define ESD_ID_ENABLE	0x80
</I>&gt;<i> +
</I>&gt;<i> +struct header_msg {
</I>&gt;<i> +	u8	len;
</I>&gt;<i> +	u8	cmd;
</I>&gt;<i> +	u8	rsvd[2];
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct version_msg {
</I>&gt;<i> +	u8	len;
</I>&gt;<i> +	u8	cmd;
</I>&gt;<i> +	u8	rsvd;
</I>&gt;<i> +	u8	flags;
</I>&gt;<i> +	u32	drv_version;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct version_reply_msg {
</I>&gt;<i> +	u8	len;
</I>&gt;<i> +	u8	cmd;
</I>&gt;<i> +	u8	nets;
</I>&gt;<i> +	u8	features;
</I>&gt;<i> +	u32	version;
</I>&gt;<i> +	u8	name[16];
</I>&gt;<i> +	u32	rsvd;
</I>&gt;<i> +	u32	ts;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct rx_msg {
</I>&gt;<i> +	u8	len;
</I>&gt;<i> +	u8	cmd;
</I>&gt;<i> +	u8	net;
</I>&gt;<i> +	u8	dlc;
</I>&gt;<i> +	u32	ts;
</I>&gt;<i> +	u32	id; /* upper 3 bits contain flags */
</I>&gt;<i> +	u8	data[8];
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct tx_msg {
</I>&gt;<i> +	u8	len;
</I>&gt;<i> +	u8	cmd;
</I>&gt;<i> +	u8	net;
</I>&gt;<i> +	u8	dlc;
</I>&gt;<i> +	u32	hnd;
</I>&gt;<i> +	u32	id; /* upper 3 bits contain flags */
</I>&gt;<i> +	u8	data[8];
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct tx_done_msg {
</I>&gt;<i> +	u8	len;
</I>&gt;<i> +	u8	cmd;
</I>&gt;<i> +	u8	net;
</I>&gt;<i> +	u8	status;
</I>&gt;<i> +	u32	hnd;
</I>&gt;<i> +	u32	ts;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct id_filter_msg {
</I>&gt;<i> +	u8	len;
</I>&gt;<i> +	u8	cmd;
</I>&gt;<i> +	u8	net;
</I>&gt;<i> +	u8	option;
</I>&gt;<i> +	u32	mask[65];
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct id_filter_reply_msg {
</I>&gt;<i> +	u8	len;
</I>&gt;<i> +	u8	cmd;
</I>&gt;<i> +	u8	net;
</I>&gt;<i> +	u8	option;
</I>&gt;<i> +	u16	added;
</I>&gt;<i> +	u16	removed;
</I>&gt;<i> +	u16	error;
</I>&gt;<i> +	u16	active;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct set_baudrate_msg {
</I>&gt;<i> +	u8	len;
</I>&gt;<i> +	u8	cmd;
</I>&gt;<i> +	u8	net;
</I>&gt;<i> +	u8	rsvd;
</I>&gt;<i> +	u32	baud;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct set_baudrate_reply_msg {
</I>&gt;<i> +	u8	len;
</I>&gt;<i> +	u8	cmd;
</I>&gt;<i> +	u8	net;
</I>&gt;<i> +	u8	rsvd;
</I>&gt;<i> +	u32	baud;
</I>&gt;<i> +	u32	ts;
</I>&gt;<i> +};
</I>
Either align the members of structs *consequently* (and not just here)
*or* just don't align. That's what I told Marc for the at91_can driver
as well. I personally prefer the latter (*no* member alignment) like it
is required for expressions by the coding style.

&gt;<i> +
</I>&gt;<i> +/* Main message type used between library and application */
</I>&gt;<i> +struct __attribute__ ((packed)) esd_usb2_msg {
</I>&gt;<i> +	union {
</I>&gt;<i> +		struct header_msg hdr;
</I>&gt;<i> +		struct version_msg version;
</I>&gt;<i> +		struct version_reply_msg version_reply;
</I>&gt;<i> +		struct rx_msg rx;
</I>&gt;<i> +		struct tx_msg tx;
</I>&gt;<i> +		struct tx_done_msg txdone;
</I>&gt;<i> +		struct set_baudrate_msg setbaud;
</I>&gt;<i> +		struct set_baudrate_reply_msg setbaud_reply;
</I>&gt;<i> +		struct id_filter_msg filter;
</I>&gt;<i> +		struct id_filter_reply_msg filter_reply;
</I>&gt;<i> +	} msg;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static struct usb_device_id esd_usb2_table[] = {
</I>&gt;<i> +	{USB_DEVICE(USB_ESDGMBH_VENDOR_ID, USB_CANUSB2_PRODUCT_ID)},
</I>&gt;<i> +	{}
</I>&gt;<i> +};
</I>&gt;<i> +
</I>
Please remove the empty line above.

&gt;<i> +MODULE_DEVICE_TABLE(usb, esd_usb2_table);
</I>&gt;<i> +
</I>&gt;<i> +#define RX_BUFFER_SIZE	1024
</I>&gt;<i> +#define MAX_RX_URBS	4
</I>&gt;<i> +#define MAX_TX_URBS	10
</I>
See below.

&gt;<i> +struct esd_usb2_net;
</I>&gt;<i> +
</I>&gt;<i> +struct esd_tx_urb_context {
</I>&gt;<i> +	struct esd_usb2_net *net;
</I>&gt;<i> +	u32 echo_index;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct esd_usb2 {
</I>&gt;<i> +	struct usb_device *udev;
</I>&gt;<i> +	struct esd_usb2_net *nets[ESD_USB2_MAX_NETS];
</I>&gt;<i> +
</I>&gt;<i> +	struct usb_anchor rx_submitted;
</I>&gt;<i> +
</I>&gt;<i> +	int no_nets;
</I>&gt;<i> +        u32 version;
</I>
Tabs?

&gt;<i> +	int rxinitdone;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct esd_usb2_net {
</I>&gt;<i> +	struct can_priv can; /* must be the first member */
</I>&gt;<i> +
</I>&gt;<i> +	atomic_t active_tx_urbs;
</I>&gt;<i> +	struct usb_anchor tx_submitted;
</I>&gt;<i> +	struct esd_tx_urb_context tx_contexts[MAX_TX_URBS];
</I>&gt;<i> +
</I>&gt;<i> +	int open_time;
</I>&gt;<i> +	struct esd_usb2 *usb2;
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	int index;
</I>&gt;<i> +	u8 old_state;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/* SJA1000 ECC register (emulated by usb2 firmware) */
</I>&gt;<i> +#define SJA1000_ECC_SEG   0x1F
</I>&gt;<i> +#define SJA1000_ECC_DIR   0x20
</I>&gt;<i> +#define SJA1000_ECC_ERR   0x06
</I>&gt;<i> +#define SJA1000_ECC_BIT   0x00
</I>&gt;<i> +#define SJA1000_ECC_FORM  0x40
</I>&gt;<i> +#define SJA1000_ECC_STUFF 0x80
</I>&gt;<i> +#define SJA1000_ECC_MASK  0xc0
</I>
You are adding #define's, struct declarations and struct assignments
randomly. Could you please order them more logically.

&gt;<i> +static void esd_usb2_rx_event(struct esd_usb2_net *net,
</I>&gt;<i> +			      struct esd_usb2_msg *msg)
</I>&gt;<i> +{
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	struct net_device_stats *stats = &amp;net-&gt;netdev-&gt;stats;
</I>&gt;<i> +	u32 id;
</I>&gt;<i> +
</I>&gt;<i> +	id = le32_to_cpu(msg-&gt;msg.rx.id) &amp; ESD_IDMASK;
</I>&gt;<i> +
</I>&gt;<i> +	dev_dbg(net-&gt;usb2-&gt;udev-&gt;dev.parent,
</I>&gt;<i> +		&quot;event: id=%08x, len=%d, data=%02x %02x %02x %02x\n&quot;,
</I>&gt;<i> +		id, get_can_dlc(msg-&gt;msg.rx.dlc),
</I>&gt;<i> +		msg-&gt;msg.rx.data[0], msg-&gt;msg.rx.data[1],
</I>&gt;<i> +		msg-&gt;msg.rx.data[2], msg-&gt;msg.rx.data[3]);
</I>
For debugging?

&gt;<i> +	switch (id) {
</I>&gt;<i> +	case ESD_EV_CAN_ERROR_EXT:
</I>&gt;<i> +	{
</I>
The bracket should go one line up.

&gt;<i> +		u8 state = msg-&gt;msg.rx.data[0];
</I>&gt;<i> +		u8 ecc = msg-&gt;msg.rx.data[1];
</I>&gt;<i> +		u8 txerr = msg-&gt;msg.rx.data[2];
</I>&gt;<i> +		u8 rxerr = msg-&gt;msg.rx.data[3];
</I>&gt;<i> +
</I>&gt;<i> +		skb = alloc_can_err_skb(net-&gt;netdev, &amp;cf);
</I>&gt;<i> +		if (skb == NULL)
</I>&gt;<i> +			return;
</I>
Hm, not sure if we should accept the failure silently.

&gt;<i> +
</I>&gt;<i> +		if (state != net-&gt;old_state) {
</I>&gt;<i> +			net-&gt;old_state = state;
</I>&gt;<i> +
</I>&gt;<i> +			switch (state &amp; 0xc0) {
</I>&gt;<i> +			case 0xc0:
</I>&gt;<i> +				net-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +				cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> +				can_bus_off(net-&gt;netdev);
</I>&gt;<i> +				break;
</I>&gt;<i> +			case 0x40:
</I>&gt;<i> +				net-&gt;can.state = CAN_STATE_ERROR_WARNING;
</I>&gt;<i> +				net-&gt;can.can_stats.error_warning++;
</I>&gt;<i> +				break;
</I>&gt;<i> +			case 0x80:
</I>&gt;<i> +				net-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> +				net-&gt;can.can_stats.error_passive++;
</I>&gt;<i> +				break;
</I>&gt;<i> +			default:
</I>&gt;<i> +				net-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +				break;
</I>&gt;<i> +			}
</I>
Please use #define's for these switch cases as well.

&gt;<i> +		} else {
</I>&gt;<i> +			net-&gt;can.can_stats.bus_error++;
</I>&gt;<i> +			stats-&gt;rx_errors++;
</I>&gt;<i> +
</I>&gt;<i> +			cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
</I>&gt;<i> +
</I>&gt;<i> +			switch (ecc &amp; SJA1000_ECC_MASK) {
</I>&gt;<i> +			case SJA1000_ECC_BIT:
</I>&gt;<i> +				cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
</I>&gt;<i> +				break;
</I>&gt;<i> +			case SJA1000_ECC_FORM:
</I>&gt;<i> +				cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;<i> +				break;
</I>&gt;<i> +			case SJA1000_ECC_STUFF:
</I>&gt;<i> +				cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;<i> +				break;
</I>&gt;<i> +			default:
</I>&gt;<i> +				cf-&gt;data[2] |= CAN_ERR_PROT_UNSPEC;
</I>&gt;<i> +				cf-&gt;data[3] = ecc &amp; SJA1000_ECC_SEG;
</I>&gt;<i> +				break;
</I>&gt;<i> +			}
</I>&gt;<i> +
</I>&gt;<i> +			/* Error occured during transmission? */
</I>&gt;<i> +			if ((ecc &amp; SJA1000_ECC_DIR) == 0)
</I>&gt;<i> +				cf-&gt;data[2] |= CAN_ERR_PROT_TX;
</I>&gt;<i> +
</I>&gt;<i> +			if (net-&gt;can.state == CAN_STATE_ERROR_WARNING ||
</I>&gt;<i> +			    net-&gt;can.state == CAN_STATE_ERROR_PASSIVE) {
</I>&gt;<i> +				cf-&gt;data[1] = (txerr &gt; rxerr) ?
</I>&gt;<i> +					CAN_ERR_CRTL_TX_PASSIVE :
</I>&gt;<i> +					CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		netif_rx(skb);
</I>&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,32)
</I>&gt;<i> +		net-&gt;netdev-&gt;last_rx = jiffies;
</I>&gt;<i> +#endif
</I>&gt;<i> +		stats-&gt;rx_packets++;
</I>&gt;<i> +		stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +
</I>&gt;<i> +		break;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	default:
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	}
</I>
There is only *one* switch case. An &quot;if () {}&quot; would just be fine.

&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void esd_usb2_rx_can_msg(struct esd_usb2_net *net,
</I>&gt;<i> +				struct esd_usb2_msg *msg)
</I>&gt;<i> +{
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	int i;
</I>&gt;<i> +	struct net_device_stats *stats = &amp;net-&gt;netdev-&gt;stats;
</I>&gt;<i> +	u32 id;
</I>
Heavy nitpicking: I think it's common practice to order the declarations
somehow. This is also true for other functions.

&gt;<i> +
</I>&gt;<i> +	if (!netif_device_present(net-&gt;netdev))
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	id = le32_to_cpu(msg-&gt;msg.rx.id);
</I>&gt;<i> +
</I>&gt;<i> +	if (id &amp; ESD_EVENT) {
</I>&gt;<i> +		esd_usb2_rx_event(net, msg);
</I>&gt;<i> +	} else {
</I>&gt;<i> +		skb = alloc_can_skb(net-&gt;netdev, &amp;cf);
</I>&gt;<i> +		if (skb == NULL)
</I>&gt;<i> +			return;
</I>
See comment above.

&gt;<i> +		cf-&gt;can_id = id &amp; ESD_IDMASK;
</I>&gt;<i> +		cf-&gt;can_dlc = get_can_dlc(msg-&gt;msg.rx.dlc);
</I>&gt;<i> +
</I>&gt;<i> +		if (id &amp; ESD_EXTID)
</I>&gt;<i> +			cf-&gt;can_id |= CAN_EFF_FLAG;
</I>&gt;<i> +
</I>&gt;<i> +		if (msg-&gt;msg.rx.dlc &amp; ESD_RTR) {
</I>&gt;<i> +			cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			for (i = 0; i &lt; cf-&gt;can_dlc; i++)
</I>&gt;<i> +				cf-&gt;data[i] = msg-&gt;msg.rx.data[i];
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		netif_rx(skb);
</I>&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,32)
</I>&gt;<i> +		net-&gt;netdev-&gt;last_rx = jiffies;
</I>&gt;<i> +#endif
</I>&gt;<i> +		stats-&gt;rx_packets++;
</I>&gt;<i> +		stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void esd_usb2_tx_done_msg(struct esd_usb2_net *net,
</I>&gt;<i> +				 struct esd_usb2_msg *msg)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device_stats *stats = &amp;net-&gt;netdev-&gt;stats;
</I>&gt;<i> +
</I>&gt;<i> +	if (!netif_device_present(net-&gt;netdev))
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	if (msg-&gt;msg.txdone.status == 0) {
</I>&gt;<i> +		stats-&gt;tx_packets++;
</I>&gt;<i> +		stats-&gt;tx_bytes += msg-&gt;msg.txdone.hnd &amp; 0xf;
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void esd_usb2_read_bulk_callback(struct urb *urb)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2 *dev = urb-&gt;context;
</I>&gt;<i> +	int retval;
</I>&gt;<i> +	int pos = 0;
</I>&gt;<i> +	int i;
</I>&gt;<i> +
</I>&gt;<i> +	switch (urb-&gt;status) {
</I>&gt;<i> +	case 0: /* success */
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	case -ENOENT:
</I>&gt;<i> +	case -ESHUTDOWN:
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	default:
</I>&gt;<i> +		dev_info(dev-&gt;udev-&gt;dev.parent,
</I>&gt;<i> +			 &quot;Rx URB aborted (%d)\n&quot;, urb-&gt;status);
</I>&gt;<i> +		goto resubmit_urb;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	while (pos &lt; urb-&gt;actual_length) {
</I>&gt;<i> +		struct esd_usb2_msg *msg;
</I>&gt;<i> +		u8 *ibuf = urb-&gt;transfer_buffer;
</I>&gt;<i> +
</I>&gt;<i> +		msg = (struct esd_usb2_msg *)&amp;ibuf[pos];
</I>
I don't see a need for an extra variable. &quot;urb-&gt;transfer_buffer + pos&quot;
is pointing to the required location.

&gt;<i> +
</I>&gt;<i> +		dev_dbg(dev-&gt;udev-&gt;dev.parent, &quot;%d/%d msg=%02x\n&quot;,
</I>&gt;<i> +			pos, urb-&gt;actual_length, msg-&gt;msg.hdr.cmd);
</I>
For debugging?

&gt;<i> +		switch (msg-&gt;msg.hdr.cmd) {
</I>&gt;<i> +		case CMD_CAN_RX:
</I>&gt;<i> +			esd_usb2_rx_can_msg(dev-&gt;nets[msg-&gt;msg.rx.net], msg);
</I>&gt;<i> +			break;
</I>&gt;<i> +
</I>&gt;<i> +		case CMD_CAN_TX:
</I>&gt;<i> +			esd_usb2_tx_done_msg(dev-&gt;nets[msg-&gt;msg.txdone.net],
</I>&gt;<i> +					     msg);
</I>&gt;<i> +			break;
</I>&gt;<i> +
</I>&gt;<i> +		default:
</I>&gt;<i> +			break;
</I>
The above two lines can be removed savely, I think.

&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		pos += msg-&gt;msg.hdr.len &lt;&lt; 2;
</I>&gt;<i> +
</I>&gt;<i> +		if (pos &gt; urb-&gt;actual_length) {
</I>&gt;<i> +			dev_err(dev-&gt;udev-&gt;dev.parent, &quot;format error\n&quot;);
</I>&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +resubmit_urb:
</I>&gt;<i> +	usb_fill_bulk_urb(urb, dev-&gt;udev, usb_rcvbulkpipe(dev-&gt;udev, 1),
</I>&gt;<i> +			  urb-&gt;transfer_buffer, RX_BUFFER_SIZE,
</I>&gt;<i> +			  esd_usb2_read_bulk_callback, dev);
</I>&gt;<i> +
</I>&gt;<i> +	retval = usb_submit_urb(urb, GFP_ATOMIC);
</I>&gt;<i> +	if (retval == -ENODEV) {
</I>&gt;<i> +		for (i = 0; i &lt; dev-&gt;no_nets; i++)
</I>
&quot;no_nets&quot; sounds like &quot;No nets&quot; to me. &quot;no_of_nets&quot; of &quot;net_count&quot; is
more understandable, I believe.

&gt;<i> +			netif_device_detach(dev-&gt;nets[i]-&gt;netdev);
</I>&gt;<i> +	} else if (retval) {
</I>&gt;<i> +		dev_err(dev-&gt;udev-&gt;dev.parent,
</I>&gt;<i> +			&quot;failed resubmitting read bulk urb: %d\n&quot;, retval);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * callback for bulk IN urb
</I>&gt;<i> + */
</I>&gt;<i> +static void esd_usb2_write_bulk_callback(struct urb *urb)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_tx_urb_context *context = urb-&gt;context;
</I>&gt;<i> +	struct esd_usb2_net *net;
</I>&gt;<i> +	struct esd_usb2 *dev;
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	size_t size = sizeof(struct esd_usb2_msg);
</I>&gt;<i> +
</I>&gt;<i> +	BUG_ON(!context);
</I>&gt;<i> +
</I>&gt;<i> +	net = context-&gt;net;
</I>&gt;<i> +	netdev = net-&gt;netdev;
</I>&gt;<i> +	dev = net-&gt;usb2;
</I>&gt;<i> +
</I>&gt;<i> +	/* free up our allocated buffer */
</I>&gt;<i> +	usb_buffer_free(urb-&gt;dev, size,
</I>&gt;<i> +			urb-&gt;transfer_buffer, urb-&gt;transfer_dma);
</I>&gt;<i> +
</I>&gt;<i> +	atomic_dec(&amp;net-&gt;active_tx_urbs);
</I>&gt;<i> +
</I>&gt;<i> +	if (!netif_device_present(netdev))
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	if (urb-&gt;status)
</I>&gt;<i> +		dev_info(ND2D(netdev), &quot;Tx URB aborted (%d)\n&quot;,
</I>&gt;<i> +			 urb-&gt;status);
</I>&gt;<i> +
</I>&gt;<i> +	netdev-&gt;trans_start = jiffies;
</I>&gt;<i> +
</I>&gt;<i> +	can_get_echo_skb(netdev, context-&gt;echo_index);
</I>
This functions is called when the USB transfer has completed, right?
can_get_echo_skb() should be called when the TX done notification
arrives (in esd_usb2_tx_done_msg). This is *wrong* in the ems_usb driver
as well and should be fixed.

&gt;<i> +
</I>&gt;<i> +	/* Release context */
</I>&gt;<i> +	context-&gt;echo_index = MAX_TX_URBS;
</I>&gt;<i> +
</I>&gt;<i> +	if (netif_queue_stopped(netdev))
</I>&gt;<i> +		netif_wake_queue(netdev);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_SYSFS
</I>&gt;<i> +static ssize_t show_firmware(struct device *d,
</I>&gt;<i> +			     struct device_attribute *attr, char *buf)
</I>&gt;<i> +{
</I>&gt;<i> +	struct usb_interface *intf = to_usb_interface(d);
</I>&gt;<i> +	struct esd_usb2 *dev = usb_get_intfdata(intf);
</I>&gt;<i> +
</I>&gt;<i> +	return sprintf(buf, &quot;%d.%d.%d\n&quot;,
</I>&gt;<i> +		       (dev-&gt;version &gt;&gt; 12) &amp; 0xf,
</I>&gt;<i> +		       (dev-&gt;version &gt;&gt; 8) &amp; 0xf,
</I>&gt;<i> +		       dev-&gt;version &amp; 0xff);
</I>&gt;<i> +}
</I>&gt;<i> +static DEVICE_ATTR(firmware, S_IRUGO, show_firmware, NULL);
</I>&gt;<i> +
</I>&gt;<i> +static ssize_t show_hardware(struct device *d,
</I>&gt;<i> +			     struct device_attribute *attr, char *buf)
</I>&gt;<i> +{
</I>&gt;<i> +	struct usb_interface *intf = to_usb_interface(d);
</I>&gt;<i> +	struct esd_usb2 *dev = usb_get_intfdata(intf);
</I>&gt;<i> +
</I>&gt;<i> +	return sprintf(buf, &quot;%d.%d.%d\n&quot;,
</I>&gt;<i> +		       (dev-&gt;version &gt;&gt; 28) &amp; 0xf,
</I>&gt;<i> +		       (dev-&gt;version &gt;&gt; 24) &amp; 0xf,
</I>&gt;<i> +		       (dev-&gt;version &gt;&gt; 16) &amp; 0xff);
</I>&gt;<i> +}
</I>&gt;<i> +static DEVICE_ATTR(hardware, S_IRUGO, show_hardware, NULL);
</I>&gt;<i> +
</I>&gt;<i> +static ssize_t show_nets(struct device *d,
</I>&gt;<i> +			 struct device_attribute *attr, char *buf)
</I>&gt;<i> +{
</I>&gt;<i> +	struct usb_interface *intf = to_usb_interface(d);
</I>&gt;<i> +	struct esd_usb2 *dev = usb_get_intfdata(intf);
</I>&gt;<i> +
</I>&gt;<i> +	return sprintf(buf, &quot;%d&quot;, dev-&gt;no_nets);
</I>&gt;<i> +}
</I>&gt;<i> +static DEVICE_ATTR(nets, S_IRUGO, show_nets, NULL);
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +static int esd_usb2_send_msg(struct esd_usb2 *dev, struct esd_usb2_msg *msg)
</I>&gt;<i> +{
</I>&gt;<i> +	int actual_length;
</I>&gt;<i> +
</I>&gt;<i> +	return usb_bulk_msg(dev-&gt;udev,
</I>&gt;<i> +			    usb_sndbulkpipe(dev-&gt;udev, 2),
</I>&gt;<i> +			    msg,
</I>&gt;<i> +			    msg-&gt;msg.hdr.len &lt;&lt; 2,
</I>&gt;<i> +			    &amp;actual_length,
</I>&gt;<i> +			    1000);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd_usb2_wait_msg(struct esd_usb2 *dev,
</I>&gt;<i> +			     struct esd_usb2_msg *msg)
</I>&gt;<i> +{
</I>&gt;<i> +	int actual_length;
</I>&gt;<i> +
</I>&gt;<i> +	return usb_bulk_msg(dev-&gt;udev,
</I>&gt;<i> +			    usb_rcvbulkpipe(dev-&gt;udev, 1),
</I>&gt;<i> +			    msg,
</I>&gt;<i> +			    sizeof(*msg),
</I>&gt;<i> +			    &amp;actual_length,
</I>&gt;<i> +			    1000);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd_usb2_setup_rx_urbs(struct esd_usb2 *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	int i, err;
</I>&gt;<i> +
</I>&gt;<i> +	if (dev-&gt;rxinitdone)
</I>&gt;<i> +		return 0;
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; MAX_RX_URBS; i++) {
</I>&gt;<i> +		struct urb *urb = NULL;
</I>&gt;<i> +		u8 *buf = NULL;
</I>&gt;<i> +
</I>&gt;<i> +		/* create a URB, and a buffer for it */
</I>&gt;<i> +		urb = usb_alloc_urb(0, GFP_KERNEL);
</I>&gt;<i> +		if (!urb) {
</I>&gt;<i> +			dev_err(dev-&gt;udev-&gt;dev.parent,
</I>&gt;<i> +				&quot;No memory left for URBs\n&quot;);
</I>&gt;<i> +			return -ENOMEM;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		buf = usb_buffer_alloc(dev-&gt;udev, RX_BUFFER_SIZE, GFP_KERNEL,
</I>&gt;<i> +				       &amp;urb-&gt;transfer_dma);
</I>&gt;<i> +		if (!buf) {
</I>&gt;<i> +			dev_err(dev-&gt;udev-&gt;dev.parent,
</I>&gt;<i> +				&quot;No memory left for USB buffer\n&quot;);
</I>&gt;<i> +			usb_free_urb(urb);
</I>&gt;<i> +			return -ENOMEM;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		usb_fill_bulk_urb(urb, dev-&gt;udev,
</I>&gt;<i> +				  usb_rcvbulkpipe(dev-&gt;udev, 1),
</I>&gt;<i> +				  buf, RX_BUFFER_SIZE,
</I>&gt;<i> +				  esd_usb2_read_bulk_callback, dev);
</I>&gt;<i> +		urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
</I>&gt;<i> +		usb_anchor_urb(urb, &amp;dev-&gt;rx_submitted);
</I>&gt;<i> +
</I>&gt;<i> +		err = usb_submit_urb(urb, GFP_KERNEL);
</I>&gt;<i> +		if (err) {
</I>&gt;<i> +			usb_unanchor_urb(urb);
</I>&gt;<i> +			usb_buffer_free(dev-&gt;udev, RX_BUFFER_SIZE, buf,
</I>&gt;<i> +					urb-&gt;transfer_dma);
</I>
I wonder if skb_free_urb(urb); is missing here.

&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		/* Drop reference, USB core will take care of freeing it */
</I>&gt;<i> +		usb_free_urb(urb);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Did we submit any URBs */
</I>&gt;<i> +	if (i == 0) {
</I>&gt;<i> +		dev_warn(dev-&gt;udev-&gt;dev.parent, &quot;couldn't setup read URBs\n&quot;);
</I>&gt;<i> +		return err;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Warn if we've couldn't transmit all the URBs */
</I>&gt;<i> +	if (i &lt; MAX_RX_URBS) {
</I>&gt;<i> +		dev_warn(dev-&gt;udev-&gt;dev.parent,
</I>&gt;<i> +			 &quot;rx performance may be slow\n&quot;);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;rxinitdone = 1;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * Start interface
</I>&gt;<i> + */
</I>&gt;<i> +static int esd_usb2_start(struct esd_usb2_net *net)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2 *dev = net-&gt;usb2;
</I>&gt;<i> +	struct net_device *netdev = net-&gt;netdev;
</I>&gt;<i> +	int err, i;
</I>&gt;<i> +	struct esd_usb2_msg msg;
</I>&gt;<i> +
</I>&gt;<i> +	/* enable all (!) IDs */
</I>&gt;<i> +	msg.msg.hdr.cmd = CMD_IDADD;
</I>&gt;<i> +	msg.msg.hdr.len = 1 + 64 + 1;
</I>
Hm, I think you understand what it means, but for me &quot;1 + 64 + 1&quot; is
just magic. Please use a proper #define for 65 (or 64), also in the
struct above and problably add also some comment.

&gt;<i> +	msg.msg.filter.net = net-&gt;index;
</I>&gt;<i> +	msg.msg.filter.option = ESD_ID_ENABLE; /* start with segment 0 */
</I>&gt;<i> +	for (i = 0; i &lt; 64; i++)
</I>&gt;<i> +		msg.msg.filter.mask[i] = cpu_to_le32(0xffffffff);
</I>&gt;<i> +	msg.msg.filter.mask[64] = cpu_to_le32(0x00000001);
</I>&gt;<i> +
</I>&gt;<i> +	err = esd_usb2_send_msg(dev, &amp;msg);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		goto failed;
</I>&gt;<i> +
</I>&gt;<i> +	esd_usb2_setup_rx_urbs(dev);
</I>&gt;<i> +
</I>&gt;<i> +	net-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +failed:
</I>&gt;<i> +	if (err == -ENODEV)
</I>&gt;<i> +		netif_device_detach(netdev);
</I>&gt;<i> +
</I>&gt;<i> +	dev_warn(ND2D(netdev), &quot;couldn't submit control: %d\n&quot;, err);
</I>&gt;<i> +
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void unlink_all_urbs(struct esd_usb2 *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	int i;
</I>&gt;<i> +	struct esd_usb2_net *net;
</I>&gt;<i> +
</I>&gt;<i> +	usb_kill_anchored_urbs(&amp;dev-&gt;rx_submitted);
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; dev-&gt;no_nets; i++) {
</I>&gt;<i> +		net = dev-&gt;nets[i];
</I>&gt;<i> +		if (net) {
</I>&gt;<i> +			usb_kill_anchored_urbs(&amp;net-&gt;tx_submitted);
</I>&gt;<i> +			atomic_set(&amp;net-&gt;active_tx_urbs, 0);
</I>&gt;<i> +
</I>&gt;<i> +			for (i = 0; i &lt; MAX_TX_URBS; i++)
</I>&gt;<i> +				net-&gt;tx_contexts[i].echo_index = MAX_TX_URBS;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static int esd_usb2_open(struct net_device *netdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2_net *net = netdev_priv(netdev);
</I>&gt;<i> +	int err;
</I>&gt;<i> +
</I>&gt;<i> +	/* common open */
</I>&gt;<i> +	err = open_candev(netdev);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		return err;
</I>&gt;<i> +
</I>&gt;<i> +	/* finally start device */
</I>&gt;<i> +	err = esd_usb2_start(net);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		if (err == -ENODEV)
</I>&gt;<i> +			netif_device_detach(netdev);
</I>&gt;<i> +
</I>&gt;<i> +		dev_warn(ND2D(netdev), &quot;couldn't start device: %d\n&quot;, err);
</I>&gt;<i> +
</I>&gt;<i> +		close_candev(netdev);
</I>&gt;<i> +
</I>&gt;<i> +		return err;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	net-&gt;open_time = jiffies;
</I>&gt;<i> +
</I>&gt;<i> +	netif_start_queue(netdev);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,32)
</I>&gt;<i> +static int esd_usb2_start_xmit(struct sk_buff *skb, struct net_device *netdev)
</I>&gt;<i> +#else
</I>&gt;<i> +static netdev_tx_t esd_usb2_start_xmit(struct sk_buff *skb,
</I>&gt;<i> +				      struct net_device *netdev)
</I>&gt;<i> +#endif
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2_net *net = netdev_priv(netdev);
</I>&gt;<i> +	struct esd_usb2 *dev = net-&gt;usb2;
</I>&gt;<i> +	struct esd_tx_urb_context *context = NULL;
</I>&gt;<i> +	struct net_device_stats *stats = &amp;netdev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> +	struct esd_usb2_msg *msg;
</I>&gt;<i> +	struct urb *urb;
</I>&gt;<i> +	u8 *buf;
</I>&gt;<i> +	int i, err;
</I>&gt;<i> +	size_t size = sizeof(struct esd_usb2_msg);
</I>&gt;<i> +
</I>&gt;<i> +	/* create a URB, and a buffer for it, and copy the data to the URB */
</I>&gt;<i> +	urb = usb_alloc_urb(0, GFP_ATOMIC);
</I>&gt;<i> +	if (!urb) {
</I>&gt;<i> +		dev_err(ND2D(netdev), &quot;No memory left for URBs\n&quot;);
</I>&gt;<i> +		goto nomem;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	buf = usb_buffer_alloc(dev-&gt;udev, size, GFP_ATOMIC, &amp;urb-&gt;transfer_dma);
</I>&gt;<i> +	if (!buf) {
</I>&gt;<i> +		dev_err(ND2D(netdev), &quot;No memory left for USB buffer\n&quot;);
</I>&gt;<i> +		usb_free_urb(urb);
</I>&gt;<i> +		goto nomem;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	msg = (struct esd_usb2_msg *)buf;
</I>&gt;<i> +
</I>&gt;<i> +	msg-&gt;msg.hdr.len = 3; /* minimal lenght */
</I>&gt;<i> +	msg-&gt;msg.hdr.cmd = CMD_CAN_TX;
</I>&gt;<i> +	msg-&gt;msg.tx.net = net-&gt;index;
</I>&gt;<i> +	msg-&gt;msg.tx.dlc = cf-&gt;can_dlc;
</I>&gt;<i> +	/* hnd must not be 0 */
</I>&gt;<i> +	msg-&gt;msg.tx.hnd = 0x80000000 | cf-&gt;can_dlc;
</I>&gt;<i> +	msg-&gt;msg.tx.id = cpu_to_le32(cf-&gt;can_id &amp; CAN_ERR_MASK);
</I>&gt;<i> +
</I>&gt;<i> +	if (cf-&gt;can_id &amp; CAN_RTR_FLAG)
</I>&gt;<i> +		msg-&gt;msg.tx.dlc |= ESD_RTR;
</I>&gt;<i> +
</I>&gt;<i> +	if (cf-&gt;can_id &amp; CAN_EFF_FLAG)
</I>&gt;<i> +		msg-&gt;msg.tx.id |= cpu_to_le32(ESD_EXTID);
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; cf-&gt;can_dlc; i++)
</I>&gt;<i> +		msg-&gt;msg.tx.data[i] = cf-&gt;data[i];
</I>&gt;<i> +
</I>&gt;<i> +	msg-&gt;msg.hdr.len += (cf-&gt;can_dlc + 3) &gt;&gt; 2;
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; MAX_TX_URBS; i++) {
</I>&gt;<i> +		if (net-&gt;tx_contexts[i].echo_index == MAX_TX_URBS) {
</I>&gt;<i> +			context = &amp;net-&gt;tx_contexts[i];
</I>&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (!context) {
</I>&gt;<i> +		usb_buffer_free(dev-&gt;udev, size, buf, urb-&gt;transfer_dma);
</I>&gt;<i> +		usb_free_urb(urb);
</I>&gt;<i> +		dev_warn(ND2D(netdev), &quot;couldn't find free context\n&quot;);
</I>&gt;<i> +		return NETDEV_TX_BUSY;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	context-&gt;net = net;
</I>&gt;<i> +	context-&gt;echo_index = i;
</I>&gt;<i> +
</I>&gt;<i> +	usb_fill_bulk_urb(urb, dev-&gt;udev, usb_sndbulkpipe(dev-&gt;udev, 2), buf,
</I>&gt;<i> +			  msg-&gt;msg.hdr.len &lt;&lt; 2,
</I>&gt;<i> +			  esd_usb2_write_bulk_callback, context);
</I>&gt;<i> +
</I>&gt;<i> +	urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
</I>&gt;<i> +
</I>&gt;<i> +	usb_anchor_urb(urb, &amp;net-&gt;tx_submitted);
</I>&gt;<i> +
</I>&gt;<i> +	can_put_echo_skb(skb, netdev, context-&gt;echo_index);
</I>&gt;<i> +
</I>&gt;<i> +	atomic_inc(&amp;net-&gt;active_tx_urbs);
</I>&gt;<i> +
</I>&gt;<i> +	err = usb_submit_urb(urb, GFP_ATOMIC);
</I>&gt;<i> +	if (unlikely(err)) {
</I>
That's the only place where you use &quot;unlikely&quot;. Either drop it or use it
consequently for frequently executed branches throughout this file. It's
just copied from ems_usb, I think.

&gt;<i> +		can_free_echo_skb(netdev, context-&gt;echo_index);
</I>&gt;<i> +
</I>&gt;<i> +		usb_unanchor_urb(urb);
</I>&gt;<i> +		usb_buffer_free(dev-&gt;udev, size, buf, urb-&gt;transfer_dma);
</I>&gt;<i> +		dev_kfree_skb(skb);
</I>&gt;<i> +
</I>&gt;<i> +		atomic_dec(&amp;net-&gt;active_tx_urbs);
</I>&gt;<i> +
</I>&gt;<i> +		if (err == -ENODEV) {
</I>&gt;<i> +			netif_device_detach(netdev);
</I>&gt;<i> +		} else {
</I>&gt;<i> +			dev_warn(ND2D(netdev), &quot;failed tx_urb %d\n&quot;, err);
</I>&gt;<i> +			stats-&gt;tx_dropped++;
</I>&gt;<i> +		}
</I>&gt;<i> +	} else {
</I>&gt;<i> +		netdev-&gt;trans_start = jiffies;
</I>&gt;<i> +
</I>&gt;<i> +		/* Slow down tx path */
</I>&gt;<i> +		if (atomic_read(&amp;net-&gt;active_tx_urbs) &gt;= MAX_TX_URBS)
</I>&gt;<i> +			netif_stop_queue(netdev);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * Release our reference to this URB, the USB core will eventually free
</I>&gt;<i> +	 * it entirely.
</I>&gt;<i> +	 */
</I>&gt;<i> +	usb_free_urb(urb);
</I>&gt;<i> +
</I>&gt;<i> +	return NETDEV_TX_OK;
</I>&gt;<i> +
</I>&gt;<i> +nomem:
</I>&gt;<i> +	if (skb)
</I>&gt;<i> +		dev_kfree_skb(skb);
</I>&gt;<i> +
</I>&gt;<i> +	stats-&gt;tx_dropped++;
</I>&gt;<i> +
</I>&gt;<i> +	return NETDEV_TX_OK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd_usb2_close(struct net_device *netdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2_net *net = netdev_priv(netdev);
</I>&gt;<i> +	int i;
</I>&gt;<i> +	struct esd_usb2_msg msg;
</I>&gt;<i> +
</I>&gt;<i> +	/* Disable all IDs */
</I>&gt;<i> +	msg.msg.hdr.cmd = CMD_IDADD;
</I>&gt;<i> +	msg.msg.hdr.len = 1 + 64 + 1;
</I>&gt;<i> +	msg.msg.filter.net = net-&gt;index;
</I>&gt;<i> +	msg.msg.filter.option = ESD_ID_ENABLE; /* start with segment 0 */
</I>&gt;<i> +	for (i = 0; i &lt; 64; i++)
</I>&gt;<i> +		msg.msg.filter.mask[i] = 0;
</I>&gt;<i> +	msg.msg.filter.mask[64] = 0;
</I>
Hm, no need to assign mask[64] separately. Also, as commented above,
please use a macro definition for the maximum number.

&gt;<i> +	esd_usb2_send_msg(net-&gt;usb2, &amp;msg);
</I>&gt;<i> +
</I>&gt;<i> +	/* set CAN controller to reset mode */
</I>&gt;<i> +	msg.msg.setbaud.len = 2;
</I>&gt;<i> +	msg.msg.setbaud.cmd = CMD_SETBAUD;
</I>&gt;<i> +	msg.msg.setbaud.net = net-&gt;index;
</I>&gt;<i> +	msg.msg.setbaud.rsvd = 0;
</I>&gt;<i> +	msg.msg.setbaud.baud = cpu_to_le32(ESD_NO_BAUDRATE);
</I>&gt;<i> +	esd_usb2_send_msg(net-&gt;usb2, &amp;msg);
</I>&gt;<i> +
</I>&gt;<i> +	netif_stop_queue(netdev);
</I>&gt;<i> +
</I>&gt;<i> +	close_candev(netdev);
</I>&gt;<i> +
</I>&gt;<i> +	net-&gt;open_time = 0;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
</I>&gt;<i> +static const struct net_device_ops esd_usb2_netdev_ops = {
</I>&gt;<i> +	.ndo_open = esd_usb2_open,
</I>&gt;<i> +	.ndo_stop = esd_usb2_close,
</I>&gt;<i> +	.ndo_start_xmit = esd_usb2_start_xmit,
</I>&gt;<i> +};
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +static struct can_bittiming_const esd_usb2_bittiming_const = {
</I>&gt;<i> +	.name = &quot;esd_usb2&quot;,
</I>&gt;<i> +	.tseg1_min = 1,
</I>&gt;<i> +	.tseg1_max = 16,
</I>&gt;<i> +	.tseg2_min = 1,
</I>&gt;<i> +	.tseg2_max = 8,
</I>&gt;<i> +	.sjw_max = 4,
</I>&gt;<i> +	.brp_min = 1,
</I>&gt;<i> +	.brp_max = 1024,
</I>&gt;<i> +	.brp_inc = 1,
</I>&gt;<i> +};
</I>
Randomly placed? Consider moving it to the file header.

&gt;<i> +static int esd_usb2_set_mode(struct net_device *netdev, enum can_mode mode)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2_net *net = netdev_priv(netdev);
</I>&gt;<i> +
</I>&gt;<i> +	if (!net-&gt;open_time)
</I>&gt;<i> +		return -EINVAL;
</I>&gt;<i> +
</I>&gt;<i> +	switch (mode) {
</I>&gt;<i> +	case CAN_MODE_START:
</I>&gt;<i> +		if (netif_queue_stopped(netdev))
</I>&gt;<i> +			netif_wake_queue(netdev);
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	default:
</I>&gt;<i> +		return -EOPNOTSUPP;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd_usb2_set_bittiming(struct net_device *netdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2_net *net = netdev_priv(netdev);
</I>&gt;<i> +	struct can_bittiming *bt = &amp;net-&gt;can.bittiming;
</I>&gt;<i> +	struct esd_usb2_msg msg;
</I>&gt;<i> +	u32 canbtr;
</I>&gt;<i> +
</I>&gt;<i> +	canbtr = ESD_UBR;
</I>&gt;<i> +	canbtr |= (bt-&gt;brp - 1) &amp; 0x3ff;
</I>&gt;<i> +	canbtr |= ((bt-&gt;sjw - 1) &amp; 0x3) &lt;&lt; 14;
</I>&gt;<i> +	canbtr |= ((bt-&gt;prop_seg + bt-&gt;phase_seg1 - 1) &amp; 0xf) &lt;&lt; 16;
</I>&gt;<i> +	canbtr |= ((bt-&gt;phase_seg2 - 1) &amp; 0x7) &lt;&lt; 20;
</I>&gt;<i> +
</I>&gt;<i> +	if (net-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES)
</I>&gt;<i> +		canbtr |= 0x00800000;
</I>&gt;<i> +
</I>&gt;<i> +	msg.msg.setbaud.len = 2;
</I>&gt;<i> +	msg.msg.setbaud.cmd = CMD_SETBAUD;
</I>&gt;<i> +	msg.msg.setbaud.net = net-&gt;index;
</I>&gt;<i> +	msg.msg.setbaud.rsvd = 0;
</I>&gt;<i> +	msg.msg.setbaud.baud = cpu_to_le32(canbtr);
</I>
It's common practice to add here:

	dev_info(ND2D(netdev), &quot;Setting canbtr=%#x\n&quot;, ...);

&gt;<i> +
</I>&gt;<i> +	return esd_usb2_send_msg(net-&gt;usb2, &amp;msg);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd_usb2_probe_one_net(struct usb_interface *intf, int index)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2 *dev = usb_get_intfdata(intf);
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	struct esd_usb2_net *net;
</I>&gt;<i> +	int err;
</I>&gt;<i> +	int i;
</I>&gt;<i> +
</I>&gt;<i> +	netdev = alloc_candev(sizeof(struct esd_usb2_net), MAX_TX_URBS);
</I>
	netdev = alloc_candev(sizeof(*net), MAX_TX_URBS);

is clearer, IMHO.

&gt;<i> +	if (!netdev) {
</I>&gt;<i> +		dev_err(&amp;intf-&gt;dev, &quot;couldn't alloc candev\n&quot;);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	net = netdev_priv(netdev);
</I>
I personally don't find the name &quot;net&quot; well suited for the private data
of netdev. What about &quot;struct esd_usb2_priv&quot; and &quot;priv&quot;?

&gt;<i> +
</I>&gt;<i> +	init_usb_anchor(&amp;net-&gt;tx_submitted);
</I>&gt;<i> +	atomic_set(&amp;net-&gt;active_tx_urbs, 0);
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; MAX_TX_URBS; i++)
</I>&gt;<i> +		net-&gt;tx_contexts[i].echo_index = MAX_TX_URBS;
</I>&gt;<i> +
</I>&gt;<i> +	net-&gt;usb2 = dev;
</I>&gt;<i> +	net-&gt;netdev = netdev;
</I>&gt;<i> +	net-&gt;index = index;
</I>&gt;<i> +
</I>&gt;<i> +	net-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> +	net-&gt;can.clock.freq = ESD_USB2_CAN_CLOCK;
</I>&gt;<i> +	net-&gt;can.bittiming_const = &amp;esd_usb2_bittiming_const;
</I>&gt;<i> +	net-&gt;can.do_set_bittiming = esd_usb2_set_bittiming;
</I>&gt;<i> +	net-&gt;can.do_set_mode = esd_usb2_set_mode;
</I>&gt;<i> +
</I>&gt;<i> +	netdev-&gt;flags |= IFF_ECHO; /* we support local echo */
</I>&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
</I>&gt;<i> +	netdev-&gt;netdev_ops = &amp;esd_usb2_netdev_ops;
</I>&gt;<i> +#else
</I>&gt;<i> +	netdev-&gt;open = esd_usb2_open;
</I>&gt;<i> +	netdev-&gt;stop = esd_usb2_close;
</I>&gt;<i> +	netdev-&gt;hard_start_xmit = esd_usb2_start_xmit;
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +	netdev-&gt;flags |= IFF_ECHO; /* we support local echo */
</I>&gt;<i> +
</I>&gt;<i> +	SET_NETDEV_DEV(netdev, &amp;intf-&gt;dev);
</I>&gt;<i> +
</I>&gt;<i> +	err = register_candev(netdev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(netdev-&gt;dev.parent,
</I>&gt;<i> +			&quot;couldn't register CAN device: %d\n&quot;, err);
</I>&gt;<i> +		free_candev(netdev);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;nets[index] = net;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * probe function for new USB2 devices
</I>&gt;<i> + *
</I>&gt;<i> + * check version information and number of available
</I>&gt;<i> + * CAN interfaces
</I>&gt;<i> + */
</I>&gt;<i> +static int esd_usb2_probe(struct usb_interface *intf,
</I>&gt;<i> +			 const struct usb_device_id *id)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2 *dev;
</I>&gt;<i> +	struct esd_usb2_msg msg;
</I>&gt;<i> +	int i, err = -ENOMEM;
</I>&gt;<i> +
</I>&gt;<i> +	dev = kzalloc(sizeof(struct esd_usb2), GFP_KERNEL);
</I>
sizeof(*dev)?

&gt;<i> +	if (!dev)
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;udev = interface_to_usbdev(intf);
</I>&gt;<i> +
</I>&gt;<i> +	init_usb_anchor(&amp;dev-&gt;rx_submitted);
</I>&gt;<i> +
</I>&gt;<i> +	usb_set_intfdata(intf, dev);
</I>&gt;<i> +
</I>&gt;<i> +	/* query number of CAN interfaces (nets) */
</I>&gt;<i> +	msg.msg.hdr.cmd = CMD_VERSION;
</I>&gt;<i> +	msg.msg.hdr.len = 2;
</I>&gt;<i> +	msg.msg.version.rsvd = 0;
</I>&gt;<i> +	msg.msg.version.flags = 0;
</I>&gt;<i> +	msg.msg.version.drv_version = 0;
</I>&gt;<i> +
</I>&gt;<i> +	if (esd_usb2_send_msg(dev, &amp;msg) &lt; 0) {
</I>&gt;<i> +		dev_err(&amp;intf-&gt;dev, &quot;sending version message failed\n&quot;);
</I>&gt;<i> +		goto free_dev;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (esd_usb2_wait_msg(dev, &amp;msg) &lt; 0) {
</I>&gt;<i> +		dev_err(&amp;intf-&gt;dev, &quot;no version message answer\n&quot;);
</I>&gt;<i> +		goto free_dev;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;no_nets = (int)msg.msg.version_reply.nets;
</I>&gt;<i> +	dev-&gt;version = le32_to_cpu(msg.msg.version_reply.version);
</I>&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_SYSFS
</I>&gt;<i> +	device_create_file(&amp;intf-&gt;dev, &amp;dev_attr_firmware);
</I>&gt;<i> +	device_create_file(&amp;intf-&gt;dev, &amp;dev_attr_hardware);
</I>&gt;<i> +	device_create_file(&amp;intf-&gt;dev, &amp;dev_attr_nets);
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +	/* do per device probing */
</I>&gt;<i> +	for (i = 0; i &lt; dev-&gt;no_nets; i++)
</I>&gt;<i> +		esd_usb2_probe_one_net(intf, i);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +free_dev:
</I>&gt;<i> +	kfree(dev);
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * called by the usb core when the device is removed from the system
</I>&gt;<i> + */
</I>&gt;<i> +static void esd_usb2_disconnect(struct usb_interface *intf)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2 *dev = usb_get_intfdata(intf);
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	int i;
</I>&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_SYSFS
</I>&gt;<i> +	device_remove_file(&amp;intf-&gt;dev, &amp;dev_attr_firmware);
</I>&gt;<i> +	device_remove_file(&amp;intf-&gt;dev, &amp;dev_attr_hardware);
</I>&gt;<i> +	device_remove_file(&amp;intf-&gt;dev, &amp;dev_attr_nets);
</I>&gt;<i> +#endif
</I>&gt;<i> +	usb_set_intfdata(intf, NULL);
</I>&gt;<i> +
</I>&gt;<i> +	if (dev) {
</I>&gt;<i> +		for (i = 0; i &lt; dev-&gt;no_nets; i++) {
</I>&gt;<i> +			if (dev-&gt;nets[i]) {
</I>&gt;<i> +				netdev = dev-&gt;nets[i]-&gt;netdev;
</I>&gt;<i> +				unregister_netdev(netdev);
</I>&gt;<i> +				free_candev(netdev);
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +		unlink_all_urbs(dev);
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/* usb specific object needed to register this driver with the usb subsystem */
</I>&gt;<i> +static struct usb_driver esd_usb2_driver = {
</I>&gt;<i> +	.name = &quot;esd_usb2&quot;,
</I>&gt;<i> +	.probe = esd_usb2_probe,
</I>&gt;<i> +	.disconnect = esd_usb2_disconnect,
</I>&gt;<i> +	.id_table = esd_usb2_table,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int __init esd_usb2_init(void)
</I>&gt;<i> +{
</I>&gt;<i> +	int err;
</I>&gt;<i> +
</I>&gt;<i> +	printk(KERN_INFO &quot;esd USB Mini/2 kernel driver\n&quot;);
</I>&gt;<i> +
</I>&gt;<i> +	/* register this driver with the USB subsystem */
</I>&gt;<i> +	err = usb_register(&amp;esd_usb2_driver);
</I>&gt;<i> +
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		err(&quot;usb_register failed. Error number %d\n&quot;, err);
</I>&gt;<i> +		return err;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void __exit esd_usb2_exit(void)
</I>&gt;<i> +{
</I>&gt;<i> +	/* deregister this driver with the USB subsystem */
</I>&gt;<i> +	usb_deregister(&amp;esd_usb2_driver);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +module_init(esd_usb2_init);
</I>&gt;<i> +module_exit(esd_usb2_exit);
</I>&gt;<i> Index: kernel/2.6/drivers/net/can/usb/Makefile
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- kernel/2.6/drivers/net/can/usb/Makefile	(revision 1095)
</I>&gt;<i> +++ kernel/2.6/drivers/net/can/usb/Makefile	(working copy)
</I>&gt;<i> @@ -16,6 +16,7 @@
</I>&gt;<i>  -include $(TOPDIR)/Makefile.common
</I>&gt;<i>  
</I>&gt;<i>  obj-$(CONFIG_CAN_EMS_USB) += ems_usb.o
</I>&gt;<i> +obj-$(CONFIG_CAN_ESD_USB2) += esd_usb2.o
</I>&gt;<i>  
</I>&gt;<i>  ifeq ($(CONFIG_CAN_DEBUG_DEVICES),y)
</I>&gt;<i>  	EXTRA_CFLAGS += -DDEBUG
</I>&gt;<i> Index: kernel/2.6/drivers/net/can/Makefile
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- kernel/2.6/drivers/net/can/Makefile	(revision 1095)
</I>&gt;<i> +++ kernel/2.6/drivers/net/can/Makefile	(working copy)
</I>&gt;<i> @@ -19,6 +19,7 @@
</I>&gt;<i>  export CONFIG_CAN_EMS_PCI=m
</I>&gt;<i>  export CONFIG_CAN_EMS_PCMCIA=m
</I>&gt;<i>  export CONFIG_CAN_ESD_PCI331=m
</I>&gt;<i> +export CONFIG_CAN_ESD_USB2=m
</I>&gt;<i>  export CONFIG_CAN_PIPCAN=m
</I>&gt;<i>  export CONFIG_CAN_SOFTING=m
</I>&gt;<i>  export CONFIG_CAN_SOFTING_CS=m
</I>&gt;<i> _______________________________________________
</I>
Wolfgang.

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003686.html">[PATCH] Add driver for esd USB2 CAN interface
</A></li>
	<LI>Next message: <A HREF="003685.html">[PATCH] Add driver for esd USB2 CAN interface
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3710">[ date ]</a>
              <a href="thread.html#3710">[ thread ]</a>
              <a href="subject.html#3710">[ subject ]</a>
              <a href="author.html#3710">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
