<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH V3] Add driver for esd USB2 CAN interface
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2010-January/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20V3%5D%20Add%20driver%20for%20esd%20USB2%20CAN%20interface&In-Reply-To=%3C20100111165417.GC5176%40pengutronix.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003817.html">
   <LINK REL="Next"  HREF="003823.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH V3] Add driver for esd USB2 CAN interface</H1>
    <B>Wolfram Sang</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20V3%5D%20Add%20driver%20for%20esd%20USB2%20CAN%20interface&In-Reply-To=%3C20100111165417.GC5176%40pengutronix.de%3E"
       TITLE="[PATCH V3] Add driver for esd USB2 CAN interface">w.sang at pengutronix.de
       </A><BR>
    <I>Mon Jan 11 17:54:17 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003817.html">[PATCH V3] Add driver for esd USB2 CAN interface
</A></li>
        <LI>Next message: <A HREF="003823.html">[PATCH V3] Add driver for esd USB2 CAN interface
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3818">[ date ]</a>
              <a href="thread.html#3818">[ thread ]</a>
              <a href="subject.html#3818">[ subject ]</a>
              <a href="author.html#3818">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

just by glimpsing:

&gt;<i> here comes my updated V3 patch. tx_context handling is now working fine
</I>&gt;<i> and the implementation makes much more sense. No more crashes.
</I>&gt;<i> This seems to be a good candidate.
</I>&gt;<i> 
</I>&gt;<i> Matthias
</I>&gt;<i> 
</I>&gt;<i> Changelog:
</I>&gt;<i> V3:
</I>&gt;<i> - handle msg-&gt;msg.txdone.status != 0 in esd_usb2_tx_done_msg()
</I>&gt;<i> - move active_tx_urbs-- to esd_usb2_tx_done_msg() from
</I>&gt;<i>   ...write_bulk_callback
</I>&gt;<i> - move netif_wake_queue(netdev) to esd_usb2_tx_done_msg()
</I>&gt;<i> - add BTR macros
</I>&gt;<i> - rename active_tx_urbs into active_tx_jobs
</I>&gt;<i> 
</I>&gt;<i> V2:
</I>&gt;<i> - remove duplicate line &quot;netdev-&gt;flags |= IFF_ECHO; ...&quot;
</I>&gt;<i>   in esd_usb2_probe_one_net()
</I>&gt;<i> - set can.state back to CAN_STATE_STOPPED in esd_usb2_close()
</I>&gt;<i>   Without this setting the bitrate via sysfs after an interface
</I>&gt;<i>   up/down cycle does not work.
</I>&gt;<i> - remove &quot;#undef DEBUG&quot; line
</I>&gt;<i> - codingstyle clean (tabs, empty lines, ...)
</I>&gt;<i> - don't check against 0, but use !()
</I>&gt;<i> - remove netif_queue_stopped() check before calling netif_wake_queue()
</I>&gt;<i> - remove double netif_device_detach() from esd_usb2_open()
</I>&gt;<i> - print canbtr in esd_usb2_set_bittiming()
</I>&gt;<i> - use __types in structures that a exchanged with the device
</I>&gt;<i> - add ESD_MAX_ID_SEGMENT macro to get rid of the magic hardcoded &quot;64&quot;
</I>&gt;<i>   when setting up the device's ID filter.
</I>&gt;<i> - Add some comments about the IDADD message.
</I>&gt;<i> - move esd_usb2_bittiming_const close to esd_usb2_set_bittiming()
</I>&gt;<i> - move macro definitions to top of file
</I>&gt;<i> - use if() for single case switch statements
</I>&gt;<i> - add macros for esd bus state event codes
</I>&gt;<i> - order declarations somehow: move structs to top
</I>&gt;<i> - get rid of ibuf variable in esd_usb2_read_bulk_callback()
</I>&gt;<i> - rename no_nets to net_count :-)
</I>&gt;<i> - consequently do not use unlikely()
</I>&gt;<i> - call can_get_echo_skb() from esd_usb2_tx_done_msg() to loopback
</I>&gt;<i>   only when message has been sent successfully
</I>&gt;<i> - increase MAX_TX_URBS because releasing tx_contexts is now done
</I>&gt;<i>   much later and we easily run out of free tx_contexts
</I>&gt;<i> - check dev-&gt;nets[i] before netif_device_detach() in ...read_bulk_callback()
</I>&gt;<i> - make esd_usb2_setup_rx_urbs() succeed when we got at least one urb
</I>&gt;<i>   setup correctly
</I>&gt;<i> - implement common error handling in esd_usb2_start_xmit()
</I>&gt;<i> - handle failure of alloc_can_(err_)sbk: stats-&gt;rx_dropped++
</I>&gt;<i> - rename netdev's private data pointer from &quot;net&quot; to &quot;priv&quot;
</I>&gt;<i> - add &quot;device %s registered&quot; message on successful net creation
</I>&gt;<i> 
</I>&gt;<i> Index: Makefile
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- Makefile	(revision 1095)
</I>&gt;<i> +++ Makefile	(working copy)
</I>&gt;<i> @@ -24,6 +24,7 @@
</I>&gt;<i>  export CONFIG_CAN_EMS_104M=m
</I>&gt;<i>  export CONFIG_CAN_ESD_PCI=m
</I>&gt;<i>  export CONFIG_CAN_ESD_331=m
</I>&gt;<i> +export CONFIG_CAN_ESD_USB2=m
</I>&gt;<i>  export CONFIG_CAN_PIPCAN=m
</I>&gt;<i>  export CONFIG_CAN_SOFTING=m
</I>&gt;<i>  export CONFIG_CAN_SOFTING_CS=m
</I>&gt;<i> Index: drivers/net/can/usb/Kconfig
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- drivers/net/can/usb/Kconfig	(revision 1095)
</I>&gt;<i> +++ drivers/net/can/usb/Kconfig	(working copy)
</I>&gt;<i> @@ -7,4 +7,10 @@
</I>&gt;<i>  	  This driver is for the one channel CPC-USB/ARM7 CAN/USB interface
</I>&gt;<i>  	  from from EMS Dr. Thomas Wuensche (<A HREF="http://www.ems-wuensche.de">http://www.ems-wuensche.de</A>).
</I>&gt;<i>  
</I>&gt;<i> +config CAN_ESD_USB2
</I>&gt;<i> +	tristate &quot;ESD USB/2 CAN/USB interface&quot;
</I>&gt;<i> +	---help---
</I>&gt;<i> +	  This driver supports the CAN-USB/2 interface
</I>&gt;<i> +	  from esd electronic system design gmbh (<A HREF="http://www.esd.eu">http://www.esd.eu</A>).
</I>&gt;<i> +
</I>&gt;<i>  endmenu
</I>&gt;<i> Index: drivers/net/can/usb/esd_usb2.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- drivers/net/can/usb/esd_usb2.c	(revision 0)
</I>&gt;<i> +++ drivers/net/can/usb/esd_usb2.c	(revision 0)
</I>&gt;<i> @@ -0,0 +1,1144 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * CAN driver for esd CAN-USB/2
</I>&gt;<i> + *
</I>&gt;<i> + * Copyright (C) 2010 Matthias Fuchs &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">matthias.fuchs at esd.eu</A>&gt;, esd gmbh
</I>&gt;<i> + *
</I>&gt;<i> + * This program is free software; you can redistribute it and/or modify it
</I>&gt;<i> + * under the terms of the GNU General Public License as published
</I>&gt;<i> + * by the Free Software Foundation; version 2 of the License.
</I>&gt;<i> + *
</I>&gt;<i> + * This program is distributed in the hope that it will be useful, but
</I>&gt;<i> + * WITHOUT ANY WARRANTY; without even the implied warranty of
</I>&gt;<i> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
</I>&gt;<i> + * General Public License for more details.
</I>&gt;<i> + *
</I>&gt;<i> + * You should have received a copy of the GNU General Public License along
</I>&gt;<i> + * with this program; if not, write to the Free Software Foundation, Inc.,
</I>&gt;<i> + * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
</I>&gt;<i> + */
</I>&gt;<i> +#include &lt;linux/init.h&gt;
</I>&gt;<i> +#include &lt;linux/signal.h&gt;
</I>&gt;<i> +#include &lt;linux/slab.h&gt;
</I>&gt;<i> +#include &lt;linux/module.h&gt;
</I>&gt;<i> +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> +#include &lt;linux/usb.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;socketcan/can.h&gt;
</I>&gt;<i> +#include &lt;socketcan/can/dev.h&gt;
</I>&gt;<i> +#include &lt;socketcan/can/error.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +MODULE_AUTHOR(&quot;Matthias Fuchs &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">matthias.fuchs at esd.eu</A>&gt;&quot;);
</I>&gt;<i> +MODULE_DESCRIPTION(&quot;CAN driver for esd CAN-USB/2 interfaces&quot;);
</I>&gt;<i> +MODULE_LICENSE(&quot;GPL v2&quot;);
</I>&gt;<i> +
</I>&gt;<i> +/* Define these values to match your devices */
</I>&gt;<i> +#define USB_ESDGMBH_VENDOR_ID	0x0ab4
</I>&gt;<i> +#define USB_CANUSB2_PRODUCT_ID	0x0010
</I>&gt;<i> +
</I>&gt;<i> +#define ESD_USB2_CAN_CLOCK	60000000
</I>&gt;<i> +#define ESD_USB2_MAX_NETS	2
</I>&gt;<i> +
</I>&gt;<i> +/* USB2 commands */
</I>&gt;<i> +#define CMD_VERSION		1 /* also used for VERSION_REPLY */
</I>&gt;<i> +#define CMD_CAN_RX		2 /* device to host only */
</I>&gt;<i> +#define CMD_CAN_TX		3 /* also used for TX_DONE */
</I>&gt;<i> +#define CMD_SETBAUD		4 /* also used for SETBAUD_REPLY */
</I>&gt;<i> +#define CMD_TS			5 /* also used for TS_REPLY */
</I>&gt;<i> +#define CMD_IDADD		6 /* also used for IDADD_REPLY */
</I>&gt;<i> +
</I>&gt;<i> +/* esd CAN message flags - dlc field */
</I>&gt;<i> +#define ESD_RTR			0x10
</I>&gt;<i> +
</I>&gt;<i> +/* esd CAN message flags - id field */
</I>&gt;<i> +#define ESD_EXTID		0x20000000
</I>&gt;<i> +#define ESD_EVENT		0x40000000
</I>&gt;<i> +#define ESD_IDMASK		0x1fffffff
</I>&gt;<i> +
</I>&gt;<i> +/* esd CAN event ids used by this driver */
</I>&gt;<i> +#define ESD_EV_CAN_ERROR_EXT	2
</I>&gt;<i> +
</I>&gt;<i> +/* baudrate message flags */
</I>&gt;<i> +#define ESD_USB2_UBR		0x80000000
</I>&gt;<i> +#define ESD_USB2_LOM		0x40000000
</I>&gt;<i> +#define ESD_USB2_NO_BAUDRATE	0x7fffffff
</I>&gt;<i> +#define ESD_USB2_TSEG1_MIN	1
</I>&gt;<i> +#define ESD_USB2_TSEG1_MAX	16
</I>&gt;<i> +#define ESD_USB2_TSEG1_SHIFT	16
</I>&gt;<i> +#define ESD_USB2_TSEG2_MIN	1
</I>&gt;<i> +#define ESD_USB2_TSEG2_MAX	8
</I>&gt;<i> +#define ESD_USB2_TSEG2_SHIFT	20
</I>&gt;<i> +#define ESD_USB2_SJW_MAX	4
</I>&gt;<i> +#define ESD_USB2_SJW_SHIFT	14
</I>&gt;<i> +#define ESD_USB2_BRP_MIN	1
</I>&gt;<i> +#define ESD_USB2_BRP_MAX	1024
</I>&gt;<i> +#define ESD_USB2_BRP_INC	1
</I>&gt;<i> +#define ESD_USB2_3_SAMPLES	0x00800000
</I>&gt;<i> +
</I>&gt;<i> +/* esd IDADD message */
</I>&gt;<i> +#define ESD_ID_ENABLE		0x80
</I>&gt;<i> +#define ESD_MAX_ID_SEGMENT	64
</I>&gt;<i> +
</I>&gt;<i> +/* SJA1000 ECC register (emulated by usb2 firmware) */
</I>&gt;<i> +#define SJA1000_ECC_SEG		0x1F
</I>&gt;<i> +#define SJA1000_ECC_DIR		0x20
</I>&gt;<i> +#define SJA1000_ECC_ERR		0x06
</I>&gt;<i> +#define SJA1000_ECC_BIT		0x00
</I>&gt;<i> +#define SJA1000_ECC_FORM	0x40
</I>&gt;<i> +#define SJA1000_ECC_STUFF	0x80
</I>&gt;<i> +#define SJA1000_ECC_MASK	0xc0
</I>&gt;<i> +
</I>&gt;<i> +/* esd bus state event codes */
</I>&gt;<i> +#define ESD_BUSSTATE_MASK	0xc0
</I>&gt;<i> +#define ESD_BUSSTATE_WARN	0x40
</I>&gt;<i> +#define ESD_BUSSTATE_ERRPASSIVE	0x80
</I>&gt;<i> +#define ESD_BUSSTATE_BUSOFF	0xc0
</I>&gt;<i> +
</I>&gt;<i> +#define RX_BUFFER_SIZE		1024
</I>&gt;<i> +#define MAX_RX_URBS		4
</I>&gt;<i> +#define MAX_TX_URBS		10
</I>&gt;<i> +
</I>&gt;<i> +struct header_msg {
</I>&gt;<i> +	__u8 len; /* len is always the total message length in 32bit words */
</I>&gt;<i> +	__u8 cmd;
</I>&gt;<i> +	__u8 rsvd[2];
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct version_msg {
</I>&gt;<i> +	__u8 len;
</I>&gt;<i> +	__u8 cmd;
</I>&gt;<i> +	__u8 rsvd;
</I>&gt;<i> +	__u8 flags;
</I>&gt;<i> +	__le32 drv_version;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct version_reply_msg {
</I>&gt;<i> +	__u8 len;
</I>&gt;<i> +	__u8 cmd;
</I>&gt;<i> +	__u8 nets;
</I>&gt;<i> +	__u8 features;
</I>&gt;<i> +	__le32 version;
</I>&gt;<i> +	__u8 name[16];
</I>&gt;<i> +	__le32 rsvd;
</I>&gt;<i> +	__le32 ts;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct rx_msg {
</I>&gt;<i> +	__u8 len;
</I>&gt;<i> +	__u8 cmd;
</I>&gt;<i> +	__u8 net;
</I>&gt;<i> +	__u8 dlc;
</I>&gt;<i> +	__le32 ts;
</I>&gt;<i> +	__le32 id; /* upper 3 bits contain flags */
</I>&gt;<i> +	__u8 data[8];
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct tx_msg {
</I>&gt;<i> +	__u8 len;
</I>&gt;<i> +	__u8 cmd;
</I>&gt;<i> +	__u8 net;
</I>&gt;<i> +	__u8 dlc;
</I>&gt;<i> +	__le32 hnd;
</I>&gt;<i> +	__le32 id; /* upper 3 bits contain flags */
</I>&gt;<i> +	__u8 data[8];
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct tx_done_msg {
</I>&gt;<i> +	__u8 len;
</I>&gt;<i> +	__u8 cmd;
</I>&gt;<i> +	__u8 net;
</I>&gt;<i> +	__u8 status;
</I>&gt;<i> +	__le32 hnd;
</I>&gt;<i> +	__le32 ts;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct id_filter_msg {
</I>&gt;<i> +	__u8 len;
</I>&gt;<i> +	__u8 cmd;
</I>&gt;<i> +	__u8 net;
</I>&gt;<i> +	__u8 option;
</I>&gt;<i> +	__le32 mask[65];
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct id_filter_reply_msg {
</I>&gt;<i> +	__u8 len;
</I>&gt;<i> +	__u8 cmd;
</I>&gt;<i> +	__u8 net;
</I>&gt;<i> +	__u8 option;
</I>&gt;<i> +	__le16 added;
</I>&gt;<i> +	__le16 removed;
</I>&gt;<i> +	__le16 error;
</I>&gt;<i> +	__le16 active;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct set_baudrate_msg {
</I>&gt;<i> +	__u8 len;
</I>&gt;<i> +	__u8 cmd;
</I>&gt;<i> +	__u8 net;
</I>&gt;<i> +	__u8 rsvd;
</I>&gt;<i> +	__le32 baud;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct set_baudrate_reply_msg {
</I>&gt;<i> +	__u8 len;
</I>&gt;<i> +	__u8 cmd;
</I>&gt;<i> +	__u8 net;
</I>&gt;<i> +	__u8 rsvd;
</I>&gt;<i> +	__le32 baud;
</I>&gt;<i> +	__le32 ts;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/* Main message type used between library and application */
</I>&gt;<i> +struct __attribute__ ((packed)) esd_usb2_msg {
</I>&gt;<i> +	union {
</I>&gt;<i> +		struct header_msg hdr;
</I>&gt;<i> +		struct version_msg version;
</I>&gt;<i> +		struct version_reply_msg version_reply;
</I>&gt;<i> +		struct rx_msg rx;
</I>&gt;<i> +		struct tx_msg tx;
</I>&gt;<i> +		struct tx_done_msg txdone;
</I>&gt;<i> +		struct set_baudrate_msg setbaud;
</I>&gt;<i> +		struct set_baudrate_reply_msg setbaud_reply;
</I>&gt;<i> +		struct id_filter_msg filter;
</I>&gt;<i> +		struct id_filter_reply_msg filter_reply;
</I>&gt;<i> +	} msg;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static struct usb_device_id esd_usb2_table[] = {
</I>&gt;<i> +	{USB_DEVICE(USB_ESDGMBH_VENDOR_ID, USB_CANUSB2_PRODUCT_ID)},
</I>&gt;<i> +	{}
</I>&gt;<i> +};
</I>&gt;<i> +MODULE_DEVICE_TABLE(usb, esd_usb2_table);
</I>&gt;<i> +
</I>&gt;<i> +struct esd_usb2_net_priv;
</I>&gt;<i> +
</I>&gt;<i> +struct esd_tx_urb_context {
</I>&gt;<i> +	struct esd_usb2_net_priv *priv;
</I>&gt;<i> +	u32 echo_index;
</I>&gt;<i> +	int dlc;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct esd_usb2 {
</I>&gt;<i> +	struct usb_device *udev;
</I>&gt;<i> +	struct esd_usb2_net_priv *nets[ESD_USB2_MAX_NETS];
</I>&gt;<i> +
</I>&gt;<i> +	struct usb_anchor rx_submitted;
</I>&gt;<i> +
</I>&gt;<i> +	int net_count;
</I>&gt;<i> +	u32 version;
</I>&gt;<i> +	int rxinitdone;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct esd_usb2_net_priv {
</I>&gt;<i> +	struct can_priv can; /* must be the first member */
</I>&gt;<i> +
</I>&gt;<i> +	atomic_t active_tx_jobs;
</I>&gt;<i> +	struct usb_anchor tx_submitted;
</I>&gt;<i> +	struct esd_tx_urb_context tx_contexts[MAX_TX_URBS];
</I>&gt;<i> +
</I>&gt;<i> +	int open_time;
</I>&gt;<i> +	struct esd_usb2 *usb2;
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	int index;
</I>&gt;<i> +	u8 old_state;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static void esd_usb2_rx_event(struct esd_usb2_net_priv *priv,
</I>&gt;<i> +			      struct esd_usb2_msg *msg)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device_stats *stats = &amp;priv-&gt;netdev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	u32 id = le32_to_cpu(msg-&gt;msg.rx.id) &amp; ESD_IDMASK;
</I>&gt;<i> +
</I>&gt;<i> +	if (id == ESD_EV_CAN_ERROR_EXT) {
</I>&gt;<i> +		u8 state = msg-&gt;msg.rx.data[0];
</I>&gt;<i> +		u8 ecc = msg-&gt;msg.rx.data[1];
</I>&gt;<i> +		u8 txerr = msg-&gt;msg.rx.data[2];
</I>&gt;<i> +		u8 rxerr = msg-&gt;msg.rx.data[3];
</I>&gt;<i> +
</I>&gt;<i> +		skb = alloc_can_err_skb(priv-&gt;netdev, &amp;cf);
</I>&gt;<i> +		if (skb == NULL) {
</I>&gt;<i> +			stats-&gt;rx_dropped++;
</I>&gt;<i> +			return;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		if (state != priv-&gt;old_state) {
</I>&gt;<i> +			priv-&gt;old_state = state;
</I>&gt;<i> +
</I>&gt;<i> +			switch (state &amp; ESD_BUSSTATE_MASK) {
</I>&gt;<i> +			case ESD_BUSSTATE_BUSOFF:
</I>&gt;<i> +				priv-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +				cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> +				can_bus_off(priv-&gt;netdev);
</I>&gt;<i> +				break;
</I>&gt;<i> +			case ESD_BUSSTATE_WARN:
</I>&gt;<i> +				priv-&gt;can.state = CAN_STATE_ERROR_WARNING;
</I>&gt;<i> +				priv-&gt;can.can_stats.error_warning++;
</I>&gt;<i> +				break;
</I>&gt;<i> +			case ESD_BUSSTATE_ERRPASSIVE:
</I>&gt;<i> +				priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> +				priv-&gt;can.can_stats.error_passive++;
</I>&gt;<i> +				break;
</I>&gt;<i> +			default:
</I>&gt;<i> +				priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +				break;
</I>&gt;<i> +			}
</I>&gt;<i> +		} else {
</I>&gt;<i> +			priv-&gt;can.can_stats.bus_error++;
</I>&gt;<i> +			stats-&gt;rx_errors++;
</I>&gt;<i> +
</I>&gt;<i> +			cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
</I>&gt;<i> +
</I>&gt;<i> +			switch (ecc &amp; SJA1000_ECC_MASK) {
</I>&gt;<i> +			case SJA1000_ECC_BIT:
</I>&gt;<i> +				cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
</I>&gt;<i> +				break;
</I>&gt;<i> +			case SJA1000_ECC_FORM:
</I>&gt;<i> +				cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;<i> +				break;
</I>&gt;<i> +			case SJA1000_ECC_STUFF:
</I>&gt;<i> +				cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;<i> +				break;
</I>&gt;<i> +			default:
</I>&gt;<i> +				cf-&gt;data[2] |= CAN_ERR_PROT_UNSPEC;
</I>&gt;<i> +				cf-&gt;data[3] = ecc &amp; SJA1000_ECC_SEG;
</I>&gt;<i> +				break;
</I>&gt;<i> +			}
</I>&gt;<i> +
</I>&gt;<i> +			/* Error occured during transmission? */
</I>&gt;<i> +			if (!(ecc &amp; SJA1000_ECC_DIR))
</I>&gt;<i> +				cf-&gt;data[2] |= CAN_ERR_PROT_TX;
</I>&gt;<i> +
</I>&gt;<i> +			if (priv-&gt;can.state == CAN_STATE_ERROR_WARNING ||
</I>&gt;<i> +			    priv-&gt;can.state == CAN_STATE_ERROR_PASSIVE) {
</I>&gt;<i> +				cf-&gt;data[1] = (txerr &gt; rxerr) ?
</I>&gt;<i> +					CAN_ERR_CRTL_TX_PASSIVE :
</I>&gt;<i> +					CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		netif_rx(skb);
</I>&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,32)
</I>&gt;<i> +		priv-&gt;netdev-&gt;last_rx = jiffies;
</I>&gt;<i> +#endif
</I>&gt;<i> +		stats-&gt;rx_packets++;
</I>&gt;<i> +		stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void esd_usb2_rx_can_msg(struct esd_usb2_net_priv *priv,
</I>&gt;<i> +				struct esd_usb2_msg *msg)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device_stats *stats = &amp;priv-&gt;netdev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	int i;
</I>&gt;<i> +	u32 id;
</I>&gt;<i> +
</I>&gt;<i> +	if (!netif_device_present(priv-&gt;netdev))
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	id = le32_to_cpu(msg-&gt;msg.rx.id);
</I>&gt;<i> +
</I>&gt;<i> +	if (id &amp; ESD_EVENT) {
</I>&gt;<i> +		esd_usb2_rx_event(priv, msg);
</I>&gt;<i> +	} else {
</I>&gt;<i> +		skb = alloc_can_skb(priv-&gt;netdev, &amp;cf);
</I>&gt;<i> +		if (skb == NULL) {
</I>&gt;<i> +			stats-&gt;rx_dropped++;
</I>&gt;<i> +			return;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		cf-&gt;can_id = id &amp; ESD_IDMASK;
</I>&gt;<i> +		cf-&gt;can_dlc = get_can_dlc(msg-&gt;msg.rx.dlc);
</I>&gt;<i> +
</I>&gt;<i> +		if (id &amp; ESD_EXTID)
</I>&gt;<i> +			cf-&gt;can_id |= CAN_EFF_FLAG;
</I>&gt;<i> +
</I>&gt;<i> +		if (msg-&gt;msg.rx.dlc &amp; ESD_RTR) {
</I>&gt;<i> +			cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			for (i = 0; i &lt; cf-&gt;can_dlc; i++)
</I>&gt;<i> +				cf-&gt;data[i] = msg-&gt;msg.rx.data[i];
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		netif_rx(skb);
</I>&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,32)
</I>&gt;<i> +		priv-&gt;netdev-&gt;last_rx = jiffies;
</I>&gt;<i> +#endif
</I>&gt;<i> +		stats-&gt;rx_packets++;
</I>&gt;<i> +		stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void esd_usb2_tx_done_msg(struct esd_usb2_net_priv *priv,
</I>&gt;<i> +				 struct esd_usb2_msg *msg)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device_stats *stats = &amp;priv-&gt;netdev-&gt;stats;
</I>&gt;<i> +	struct net_device *netdev = priv-&gt;netdev;
</I>&gt;<i> +	struct esd_tx_urb_context *context;
</I>&gt;<i> +	int done_index;
</I>&gt;<i> +
</I>&gt;<i> +	if (!netif_device_present(netdev))
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	done_index = msg-&gt;msg.txdone.hnd &amp; ~0x80000000;
</I>&gt;<i> +	context = &amp;priv-&gt;tx_contexts[done_index];
</I>&gt;<i> +
</I>&gt;<i> +	if (!msg-&gt;msg.txdone.status) {
</I>&gt;<i> +		stats-&gt;tx_packets++;
</I>&gt;<i> +		stats-&gt;tx_bytes += context-&gt;dlc;
</I>&gt;<i> +		can_get_echo_skb(netdev, context-&gt;echo_index);
</I>&gt;<i> +	} else {
</I>&gt;<i> +		stats-&gt;tx_errors++;
</I>&gt;<i> +		can_free_echo_skb(netdev, context-&gt;echo_index);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Release context */
</I>&gt;<i> +	context-&gt;echo_index = MAX_TX_URBS;
</I>&gt;<i> +	atomic_dec(&amp;priv-&gt;active_tx_jobs);
</I>&gt;<i> +
</I>&gt;<i> +	netif_wake_queue(netdev);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void esd_usb2_read_bulk_callback(struct urb *urb)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2 *dev = urb-&gt;context;
</I>&gt;<i> +	int retval;
</I>&gt;<i> +	int pos = 0;
</I>&gt;<i> +	int i;
</I>&gt;<i> +
</I>&gt;<i> +	switch (urb-&gt;status) {
</I>&gt;<i> +	case 0: /* success */
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	case -ENOENT:
</I>&gt;<i> +	case -ESHUTDOWN:
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	default:
</I>&gt;<i> +		dev_info(dev-&gt;udev-&gt;dev.parent,
</I>&gt;<i> +			 &quot;Rx URB aborted (%d)\n&quot;, urb-&gt;status);
</I>&gt;<i> +		goto resubmit_urb;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	while (pos &lt; urb-&gt;actual_length) {
</I>&gt;<i> +		struct esd_usb2_msg *msg;
</I>&gt;<i> +
</I>&gt;<i> +		msg = (struct esd_usb2_msg *)(urb-&gt;transfer_buffer + pos);
</I>&gt;<i> +
</I>&gt;<i> +		switch (msg-&gt;msg.hdr.cmd) {
</I>&gt;<i> +		case CMD_CAN_RX:
</I>&gt;<i> +			esd_usb2_rx_can_msg(dev-&gt;nets[msg-&gt;msg.rx.net], msg);
</I>&gt;<i> +			break;
</I>&gt;<i> +
</I>&gt;<i> +		case CMD_CAN_TX:
</I>&gt;<i> +			esd_usb2_tx_done_msg(dev-&gt;nets[msg-&gt;msg.txdone.net],
</I>&gt;<i> +					     msg);
</I>&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		pos += msg-&gt;msg.hdr.len &lt;&lt; 2;
</I>&gt;<i> +
</I>&gt;<i> +		if (pos &gt; urb-&gt;actual_length) {
</I>&gt;<i> +			dev_err(dev-&gt;udev-&gt;dev.parent, &quot;format error\n&quot;);
</I>&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +resubmit_urb:
</I>&gt;<i> +	usb_fill_bulk_urb(urb, dev-&gt;udev, usb_rcvbulkpipe(dev-&gt;udev, 1),
</I>&gt;<i> +			  urb-&gt;transfer_buffer, RX_BUFFER_SIZE,
</I>&gt;<i> +			  esd_usb2_read_bulk_callback, dev);
</I>&gt;<i> +
</I>&gt;<i> +	retval = usb_submit_urb(urb, GFP_ATOMIC);
</I>&gt;<i> +	if (retval == -ENODEV) {
</I>&gt;<i> +		for (i = 0; i &lt; dev-&gt;net_count; i++) {
</I>&gt;<i> +			if (dev-&gt;nets[i])
</I>&gt;<i> +				netif_device_detach(dev-&gt;nets[i]-&gt;netdev);
</I>&gt;<i> +		}
</I>&gt;<i> +	} else if (retval) {
</I>&gt;<i> +		dev_err(dev-&gt;udev-&gt;dev.parent,
</I>&gt;<i> +			&quot;failed resubmitting read bulk urb: %d\n&quot;, retval);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * callback for bulk IN urb
</I>&gt;<i> + */
</I>&gt;<i> +static void esd_usb2_write_bulk_callback(struct urb *urb)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_tx_urb_context *context = urb-&gt;context;
</I>&gt;<i> +	struct esd_usb2_net_priv *priv;
</I>&gt;<i> +	struct esd_usb2 *dev;
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	size_t size = sizeof(struct esd_usb2_msg);
</I>&gt;<i> +
</I>&gt;<i> +	BUG_ON(!context);
</I>&gt;<i> +
</I>&gt;<i> +	priv = context-&gt;priv;
</I>&gt;<i> +	netdev = priv-&gt;netdev;
</I>&gt;<i> +	dev = priv-&gt;usb2;
</I>&gt;<i> +
</I>&gt;<i> +	/* free up our allocated buffer */
</I>&gt;<i> +	usb_buffer_free(urb-&gt;dev, size,
</I>&gt;<i> +			urb-&gt;transfer_buffer, urb-&gt;transfer_dma);
</I>&gt;<i> +
</I>&gt;<i> +	if (!netif_device_present(netdev))
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	if (urb-&gt;status)
</I>&gt;<i> +		dev_info(ND2D(netdev), &quot;Tx URB aborted (%d)\n&quot;,
</I>&gt;<i> +			 urb-&gt;status);
</I>&gt;<i> +
</I>&gt;<i> +	netdev-&gt;trans_start = jiffies;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_SYSFS
</I>&gt;<i> +static ssize_t show_firmware(struct device *d,
</I>&gt;<i> +			     struct device_attribute *attr, char *buf)
</I>&gt;<i> +{
</I>&gt;<i> +	struct usb_interface *intf = to_usb_interface(d);
</I>&gt;<i> +	struct esd_usb2 *dev = usb_get_intfdata(intf);
</I>&gt;<i> +
</I>&gt;<i> +	return sprintf(buf, &quot;%d.%d.%d\n&quot;,
</I>&gt;<i> +		       (dev-&gt;version &gt;&gt; 12) &amp; 0xf,
</I>&gt;<i> +		       (dev-&gt;version &gt;&gt; 8) &amp; 0xf,
</I>&gt;<i> +		       dev-&gt;version &amp; 0xff);
</I>&gt;<i> +}
</I>&gt;<i> +static DEVICE_ATTR(firmware, S_IRUGO, show_firmware, NULL);
</I>&gt;<i> +
</I>&gt;<i> +static ssize_t show_hardware(struct device *d,
</I>&gt;<i> +			     struct device_attribute *attr, char *buf)
</I>&gt;<i> +{
</I>&gt;<i> +	struct usb_interface *intf = to_usb_interface(d);
</I>&gt;<i> +	struct esd_usb2 *dev = usb_get_intfdata(intf);
</I>&gt;<i> +
</I>&gt;<i> +	return sprintf(buf, &quot;%d.%d.%d\n&quot;,
</I>&gt;<i> +		       (dev-&gt;version &gt;&gt; 28) &amp; 0xf,
</I>&gt;<i> +		       (dev-&gt;version &gt;&gt; 24) &amp; 0xf,
</I>&gt;<i> +		       (dev-&gt;version &gt;&gt; 16) &amp; 0xff);
</I>&gt;<i> +}
</I>&gt;<i> +static DEVICE_ATTR(hardware, S_IRUGO, show_hardware, NULL);
</I>&gt;<i> +
</I>&gt;<i> +static ssize_t show_nets(struct device *d,
</I>&gt;<i> +			 struct device_attribute *attr, char *buf)
</I>&gt;<i> +{
</I>&gt;<i> +	struct usb_interface *intf = to_usb_interface(d);
</I>&gt;<i> +	struct esd_usb2 *dev = usb_get_intfdata(intf);
</I>&gt;<i> +
</I>&gt;<i> +	return sprintf(buf, &quot;%d&quot;, dev-&gt;net_count);
</I>&gt;<i> +}
</I>&gt;<i> +static DEVICE_ATTR(nets, S_IRUGO, show_nets, NULL);
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +static int esd_usb2_send_msg(struct esd_usb2 *dev, struct esd_usb2_msg *msg)
</I>&gt;<i> +{
</I>&gt;<i> +	int actual_length;
</I>&gt;<i> +
</I>&gt;<i> +	return usb_bulk_msg(dev-&gt;udev,
</I>&gt;<i> +			    usb_sndbulkpipe(dev-&gt;udev, 2),
</I>&gt;<i> +			    msg,
</I>&gt;<i> +			    msg-&gt;msg.hdr.len &lt;&lt; 2,
</I>&gt;<i> +			    &amp;actual_length,
</I>&gt;<i> +			    1000);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd_usb2_wait_msg(struct esd_usb2 *dev,
</I>&gt;<i> +			     struct esd_usb2_msg *msg)
</I>&gt;<i> +{
</I>&gt;<i> +	int actual_length;
</I>&gt;<i> +
</I>&gt;<i> +	return usb_bulk_msg(dev-&gt;udev,
</I>&gt;<i> +			    usb_rcvbulkpipe(dev-&gt;udev, 1),
</I>&gt;<i> +			    msg,
</I>&gt;<i> +			    sizeof(*msg),
</I>&gt;<i> +			    &amp;actual_length,
</I>&gt;<i> +			    1000);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd_usb2_setup_rx_urbs(struct esd_usb2 *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	int i, err = 0;
</I>&gt;<i> +
</I>&gt;<i> +	if (dev-&gt;rxinitdone)
</I>&gt;<i> +		return 0;
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; MAX_RX_URBS; i++) {
</I>&gt;<i> +		struct urb *urb = NULL;
</I>&gt;<i> +		u8 *buf = NULL;
</I>&gt;<i> +
</I>&gt;<i> +		/* create a URB, and a buffer for it */
</I>&gt;<i> +		urb = usb_alloc_urb(0, GFP_KERNEL);
</I>&gt;<i> +		if (!urb) {
</I>&gt;<i> +			dev_warn(dev-&gt;udev-&gt;dev.parent,
</I>&gt;<i> +				 &quot;No memory left for URBs\n&quot;);
</I>&gt;<i> +			err = -ENOMEM;
</I>&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		buf = usb_buffer_alloc(dev-&gt;udev, RX_BUFFER_SIZE, GFP_KERNEL,
</I>&gt;<i> +				       &amp;urb-&gt;transfer_dma);
</I>&gt;<i> +		if (!buf) {
</I>&gt;<i> +			dev_warn(dev-&gt;udev-&gt;dev.parent,
</I>&gt;<i> +				 &quot;No memory left for USB buffer\n&quot;);
</I>&gt;<i> +			err = -ENOMEM;
</I>&gt;<i> +			goto freeurb;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		usb_fill_bulk_urb(urb, dev-&gt;udev,
</I>&gt;<i> +				  usb_rcvbulkpipe(dev-&gt;udev, 1),
</I>&gt;<i> +				  buf, RX_BUFFER_SIZE,
</I>&gt;<i> +				  esd_usb2_read_bulk_callback, dev);
</I>&gt;<i> +		urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
</I>&gt;<i> +		usb_anchor_urb(urb, &amp;dev-&gt;rx_submitted);
</I>&gt;<i> +
</I>&gt;<i> +		err = usb_submit_urb(urb, GFP_KERNEL);
</I>&gt;<i> +		if (err) {
</I>&gt;<i> +			usb_unanchor_urb(urb);
</I>&gt;<i> +			usb_buffer_free(dev-&gt;udev, RX_BUFFER_SIZE, buf,
</I>&gt;<i> +					urb-&gt;transfer_dma);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +	freeurb:
</I>&gt;<i> +		/* Drop reference, USB core will take care of freeing it */
</I>&gt;<i> +		usb_free_urb(urb);
</I>&gt;<i> +		if (err)
</I>&gt;<i> +			break;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Did we submit any URBs */
</I>&gt;<i> +	if (i == 0) {
</I>&gt;<i> +		dev_err(dev-&gt;udev-&gt;dev.parent, &quot;couldn't setup read URBs\n&quot;);
</I>&gt;<i> +		return err;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Warn if we've couldn't transmit all the URBs */
</I>&gt;<i> +	if (i &lt; MAX_RX_URBS) {
</I>&gt;<i> +		dev_warn(dev-&gt;udev-&gt;dev.parent,
</I>&gt;<i> +			 &quot;rx performance may be slow\n&quot;);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;rxinitdone = 1;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * Start interface
</I>&gt;<i> + */
</I>&gt;<i> +static int esd_usb2_start(struct esd_usb2_net_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2 *dev = priv-&gt;usb2;
</I>&gt;<i> +	struct net_device *netdev = priv-&gt;netdev;
</I>&gt;<i> +	struct esd_usb2_msg msg;
</I>&gt;<i> +	int err, i;
</I>&gt;<i> +
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * enable all (!) IDs
</I>&gt;<i> +	 * The IDADD message takes up to ESD_MAX_ID_SEGMENT 32 bit
</I>&gt;<i> +	 * bitmasks = 2048 bits. A set bit enables reception
</I>&gt;<i> +	 * of the corresponding CAN identifier.
</I>&gt;<i> +	 * The next bitmask value following the CAN 2.0A
</I>&gt;<i> +	 * bits is used to enable reception of extended CAN frames.
</I>&gt;<i> +	 */
</I>&gt;<i> +	msg.msg.hdr.cmd = CMD_IDADD;
</I>&gt;<i> +	msg.msg.hdr.len = 1 + ESD_MAX_ID_SEGMENT + 1;
</I>&gt;<i> +	msg.msg.filter.net = priv-&gt;index;
</I>&gt;<i> +	msg.msg.filter.option = ESD_ID_ENABLE; /* start with segment 0 */
</I>&gt;<i> +	for (i = 0; i &lt; ESD_MAX_ID_SEGMENT; i++)
</I>&gt;<i> +		msg.msg.filter.mask[i] = cpu_to_le32(0xffffffff);
</I>&gt;<i> +	/* enable 29bit extended IDs */
</I>&gt;<i> +	msg.msg.filter.mask[ESD_MAX_ID_SEGMENT] = cpu_to_le32(0x00000001);
</I>&gt;<i> +
</I>&gt;<i> +	err = esd_usb2_send_msg(dev, &amp;msg);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		goto failed;
</I>&gt;<i> +
</I>&gt;<i> +	err = esd_usb2_setup_rx_urbs(dev);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		goto failed;
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +failed:
</I>&gt;<i> +	if (err == -ENODEV)
</I>&gt;<i> +		netif_device_detach(netdev);
</I>&gt;<i> +
</I>&gt;<i> +	dev_err(ND2D(netdev), &quot;couldn't start device: %d\n&quot;, err);
</I>&gt;<i> +
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void unlink_all_urbs(struct esd_usb2 *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2_net_priv *priv;
</I>&gt;<i> +	int i;
</I>&gt;<i> +
</I>&gt;<i> +	usb_kill_anchored_urbs(&amp;dev-&gt;rx_submitted);
</I>&gt;<i> +	for (i = 0; i &lt; dev-&gt;net_count; i++) {
</I>&gt;<i> +		priv = dev-&gt;nets[i];
</I>&gt;<i> +		if (priv) {
</I>&gt;<i> +			usb_kill_anchored_urbs(&amp;priv-&gt;tx_submitted);
</I>&gt;<i> +			atomic_set(&amp;priv-&gt;active_tx_jobs, 0);
</I>&gt;<i> +
</I>&gt;<i> +			for (i = 0; i &lt; MAX_TX_URBS; i++)
</I>&gt;<i> +				priv-&gt;tx_contexts[i].echo_index = MAX_TX_URBS;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd_usb2_open(struct net_device *netdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2_net_priv *priv = netdev_priv(netdev);
</I>&gt;<i> +	int err;
</I>&gt;<i> +
</I>&gt;<i> +	/* common open */
</I>&gt;<i> +	err = open_candev(netdev);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		return err;
</I>&gt;<i> +
</I>&gt;<i> +	/* finally start device */
</I>&gt;<i> +	err = esd_usb2_start(priv);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_warn(ND2D(netdev), &quot;couldn't start device: %d\n&quot;, err);
</I>&gt;<i> +
</I>&gt;<i> +		close_candev(netdev);
</I>&gt;<i> +
</I>&gt;<i> +		return err;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;open_time = jiffies;
</I>&gt;<i> +
</I>&gt;<i> +	netif_start_queue(netdev);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,32)
</I>&gt;<i> +static int esd_usb2_start_xmit(struct sk_buff *skb, struct net_device *netdev)
</I>&gt;<i> +#else
</I>&gt;<i> +static netdev_tx_t esd_usb2_start_xmit(struct sk_buff *skb,
</I>&gt;<i> +				      struct net_device *netdev)
</I>&gt;<i> +#endif
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2_net_priv *priv = netdev_priv(netdev);
</I>&gt;<i> +	struct esd_usb2 *dev = priv-&gt;usb2;
</I>&gt;<i> +	struct esd_tx_urb_context *context = NULL;
</I>&gt;<i> +	struct net_device_stats *stats = &amp;netdev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> +	struct esd_usb2_msg *msg;
</I>&gt;<i> +	struct urb *urb;
</I>&gt;<i> +	u8 *buf;
</I>&gt;<i> +	int i, err;
</I>&gt;<i> +	int ret = NETDEV_TX_OK;
</I>&gt;<i> +	size_t size = sizeof(struct esd_usb2_msg);
</I>&gt;<i> +
</I>&gt;<i> +	/* create a URB, and a buffer for it, and copy the data to the URB */
</I>&gt;<i> +	urb = usb_alloc_urb(0, GFP_ATOMIC);
</I>&gt;<i> +	if (!urb) {
</I>&gt;<i> +		dev_err(ND2D(netdev), &quot;No memory left for URBs\n&quot;);
</I>&gt;<i> +		goto nourbmem;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	buf = usb_buffer_alloc(dev-&gt;udev, size, GFP_ATOMIC, &amp;urb-&gt;transfer_dma);
</I>&gt;<i> +	if (!buf) {
</I>&gt;<i> +		dev_err(ND2D(netdev), &quot;No memory left for USB buffer\n&quot;);
</I>&gt;<i> +		goto nobufmem;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	msg = (struct esd_usb2_msg *)buf;
</I>&gt;<i> +
</I>&gt;<i> +	msg-&gt;msg.hdr.len = 3; /* minimal length */
</I>&gt;<i> +	msg-&gt;msg.hdr.cmd = CMD_CAN_TX;
</I>&gt;<i> +	msg-&gt;msg.tx.net = priv-&gt;index;
</I>&gt;<i> +	msg-&gt;msg.tx.dlc = cf-&gt;can_dlc;
</I>&gt;<i> +	msg-&gt;msg.tx.id = cpu_to_le32(cf-&gt;can_id &amp; CAN_ERR_MASK);
</I>&gt;<i> +
</I>&gt;<i> +	if (cf-&gt;can_id &amp; CAN_RTR_FLAG)
</I>&gt;<i> +		msg-&gt;msg.tx.dlc |= ESD_RTR;
</I>&gt;<i> +
</I>&gt;<i> +	if (cf-&gt;can_id &amp; CAN_EFF_FLAG)
</I>&gt;<i> +		msg-&gt;msg.tx.id |= cpu_to_le32(ESD_EXTID);
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; cf-&gt;can_dlc; i++)
</I>&gt;<i> +		msg-&gt;msg.tx.data[i] = cf-&gt;data[i];
</I>&gt;<i> +
</I>&gt;<i> +	msg-&gt;msg.hdr.len += (cf-&gt;can_dlc + 3) &gt;&gt; 2;
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; MAX_TX_URBS; i++) {
</I>&gt;<i> +		if (priv-&gt;tx_contexts[i].echo_index == MAX_TX_URBS) {
</I>&gt;<i> +			context = &amp;priv-&gt;tx_contexts[i];
</I>&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * This may never happen.
</I>&gt;<i> +	 */
</I>&gt;<i> +	if (!context) {
</I>&gt;<i> +		dev_warn(ND2D(netdev), &quot;couldn't find free context\n&quot;);
</I>&gt;<i> +		ret = NETDEV_TX_BUSY;
</I>&gt;<i> +		goto releasebuf;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	context-&gt;priv = priv;
</I>&gt;<i> +	context-&gt;echo_index = i;
</I>&gt;<i> +	context-&gt;dlc = cf-&gt;can_dlc;
</I>&gt;<i> +
</I>&gt;<i> +	/* hnd must not be 0 */
</I>&gt;<i> +	msg-&gt;msg.tx.hnd = 0x80000000 | i; /* returned in TX done message */
</I>&gt;<i> +
</I>&gt;<i> +	usb_fill_bulk_urb(urb, dev-&gt;udev, usb_sndbulkpipe(dev-&gt;udev, 2), buf,
</I>&gt;<i> +			  msg-&gt;msg.hdr.len &lt;&lt; 2,
</I>&gt;<i> +			  esd_usb2_write_bulk_callback, context);
</I>&gt;<i> +
</I>&gt;<i> +	urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
</I>&gt;<i> +
</I>&gt;<i> +	usb_anchor_urb(urb, &amp;priv-&gt;tx_submitted);
</I>&gt;<i> +
</I>&gt;<i> +	can_put_echo_skb(skb, netdev, context-&gt;echo_index);
</I>&gt;<i> +
</I>&gt;<i> +	atomic_inc(&amp;priv-&gt;active_tx_jobs);
</I>&gt;<i> +
</I>&gt;<i> +	err = usb_submit_urb(urb, GFP_ATOMIC);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		can_free_echo_skb(netdev, context-&gt;echo_index);
</I>&gt;<i> +
</I>&gt;<i> +		atomic_dec(&amp;priv-&gt;active_tx_jobs);
</I>&gt;<i> +		usb_unanchor_urb(urb);
</I>&gt;<i> +
</I>&gt;<i> +		if (err == -ENODEV)
</I>&gt;<i> +			netif_device_detach(netdev);
</I>&gt;<i> +		else
</I>&gt;<i> +			dev_warn(ND2D(netdev), &quot;failed tx_urb %d\n&quot;, err);
</I>&gt;<i> +
</I>&gt;<i> +		goto releasebuf;
</I>&gt;<i> +	} else {
</I>
No need for else because the goto jumps away anyhow?

&gt;<i> +		netdev-&gt;trans_start = jiffies;
</I>&gt;<i> +
</I>&gt;<i> +		/* Slow down tx path */
</I>&gt;<i> +		if (atomic_read(&amp;priv-&gt;active_tx_jobs) &gt;= MAX_TX_URBS)
</I>&gt;<i> +			netif_stop_queue(netdev);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * Release our reference to this URB, the USB core will eventually free
</I>&gt;<i> +	 * it entirely.
</I>&gt;<i> +	 */
</I>&gt;<i> +	usb_free_urb(urb);
</I>&gt;<i> +
</I>&gt;<i> +	return NETDEV_TX_OK;
</I>&gt;<i> +
</I>&gt;<i> +releasebuf:
</I>&gt;<i> +	usb_buffer_free(dev-&gt;udev, size, buf, urb-&gt;transfer_dma);
</I>&gt;<i> +
</I>&gt;<i> +nobufmem:
</I>&gt;<i> +	usb_free_urb(urb);
</I>&gt;<i> +
</I>&gt;<i> +nourbmem:
</I>&gt;<i> +	if (ret != NETDEV_TX_BUSY) {
</I>&gt;<i> +		if (skb)
</I>&gt;<i> +			dev_kfree_skb(skb);
</I>&gt;<i> +
</I>&gt;<i> +		stats-&gt;tx_dropped++;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return ret;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd_usb2_close(struct net_device *netdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2_net_priv *priv = netdev_priv(netdev);
</I>&gt;<i> +	struct esd_usb2_msg msg;
</I>&gt;<i> +	int i;
</I>&gt;<i> +
</I>&gt;<i> +	/* Disable all IDs
</I>&gt;<i> +	 * The IDADD message takes up to ESD_MAX_ID_SEGMENT 32 bit
</I>&gt;<i> +	 * bitmasks = 2048 bits. A cleared bit disables reception
</I>&gt;<i> +	 * of the corresponding CAN identifier.
</I>&gt;<i> +	 * The next bitmask value following the CAN 2.0A
</I>&gt;<i> +	 * bits is used to disable reception of extended CAN frames
</I>&gt;<i> +	 * at all.
</I>
This line could probably be saved by reformatting the upper 3 lines.

&gt;<i> +	 */
</I>&gt;<i> +	msg.msg.hdr.cmd = CMD_IDADD;
</I>&gt;<i> +	msg.msg.hdr.len = 1 + ESD_MAX_ID_SEGMENT + 1;
</I>&gt;<i> +	msg.msg.filter.net = priv-&gt;index;
</I>&gt;<i> +	msg.msg.filter.option = ESD_ID_ENABLE; /* start with segment 0 */
</I>&gt;<i> +	for (i = 0; i &lt;= ESD_MAX_ID_SEGMENT; i++)
</I>&gt;<i> +		msg.msg.filter.mask[i] = 0;
</I>&gt;<i> +	esd_usb2_send_msg(priv-&gt;usb2, &amp;msg);
</I>&gt;<i> +
</I>&gt;<i> +	/* set CAN controller to reset mode */
</I>&gt;<i> +	msg.msg.hdr.len = 2;
</I>&gt;<i> +	msg.msg.hdr.cmd = CMD_SETBAUD;
</I>&gt;<i> +	msg.msg.setbaud.net = priv-&gt;index;
</I>&gt;<i> +	msg.msg.setbaud.rsvd = 0;
</I>&gt;<i> +	msg.msg.setbaud.baud = cpu_to_le32(ESD_USB2_NO_BAUDRATE);
</I>&gt;<i> +	esd_usb2_send_msg(priv-&gt;usb2, &amp;msg);
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> +
</I>&gt;<i> +	netif_stop_queue(netdev);
</I>&gt;<i> +
</I>&gt;<i> +	close_candev(netdev);
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;open_time = 0;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
</I>&gt;<i> +static const struct net_device_ops esd_usb2_netdev_ops = {
</I>&gt;<i> +	.ndo_open = esd_usb2_open,
</I>&gt;<i> +	.ndo_stop = esd_usb2_close,
</I>&gt;<i> +	.ndo_start_xmit = esd_usb2_start_xmit,
</I>&gt;<i> +};
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +static struct can_bittiming_const esd_usb2_bittiming_const = {
</I>&gt;<i> +	.name = &quot;esd_usb2&quot;,
</I>&gt;<i> +	.tseg1_min = ESD_USB2_TSEG1_MIN,
</I>&gt;<i> +	.tseg1_max = ESD_USB2_TSEG1_MAX,
</I>&gt;<i> +	.tseg2_min = ESD_USB2_TSEG2_MIN,
</I>&gt;<i> +	.tseg2_max = ESD_USB2_TSEG2_MAX,
</I>&gt;<i> +	.sjw_max = ESD_USB2_SJW_MAX,
</I>&gt;<i> +	.brp_min = ESD_USB2_BRP_MIN,
</I>&gt;<i> +	.brp_max = ESD_USB2_BRP_MAX,
</I>&gt;<i> +	.brp_inc = ESD_USB2_BRP_INC,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int esd_usb2_set_bittiming(struct net_device *netdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2_net_priv *priv = netdev_priv(netdev);
</I>&gt;<i> +	struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> +	struct esd_usb2_msg msg;
</I>&gt;<i> +	u32 canbtr;
</I>&gt;<i> +
</I>&gt;<i> +	canbtr = ESD_USB2_UBR;
</I>&gt;<i> +	canbtr |= (bt-&gt;brp - 1) &amp; (ESD_USB2_BRP_MAX - 1);
</I>&gt;<i> +	canbtr |= ((bt-&gt;sjw - 1) &amp; (ESD_USB2_SJW_MAX - 1))
</I>&gt;<i> +		&lt;&lt; ESD_USB2_SJW_SHIFT;
</I>&gt;<i> +	canbtr |= ((bt-&gt;prop_seg + bt-&gt;phase_seg1 - 1)
</I>&gt;<i> +		   &amp; (ESD_USB2_TSEG1_MAX - 1))
</I>&gt;<i> +		&lt;&lt; ESD_USB2_TSEG1_SHIFT;
</I>&gt;<i> +	canbtr |= ((bt-&gt;phase_seg2 - 1) &amp; (ESD_USB2_TSEG2_MAX - 1))
</I>&gt;<i> +		&lt;&lt; ESD_USB2_TSEG2_SHIFT;
</I>&gt;<i> +	if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES)
</I>&gt;<i> +		canbtr |= ESD_USB2_3_SAMPLES;
</I>&gt;<i> +
</I>&gt;<i> +	msg.msg.hdr.len = 2;
</I>&gt;<i> +	msg.msg.hdr.cmd = CMD_SETBAUD;
</I>&gt;<i> +	msg.msg.setbaud.net = priv-&gt;index;
</I>&gt;<i> +	msg.msg.setbaud.rsvd = 0;
</I>&gt;<i> +	msg.msg.setbaud.baud = cpu_to_le32(canbtr);
</I>&gt;<i> +
</I>&gt;<i> +	dev_info(ND2D(netdev), &quot;setting BTR=%#x\n&quot;, canbtr);
</I>&gt;<i> +
</I>&gt;<i> +	return esd_usb2_send_msg(priv-&gt;usb2, &amp;msg);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd_usb2_set_mode(struct net_device *netdev, enum can_mode mode)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2_net_priv *priv = netdev_priv(netdev);
</I>&gt;<i> +
</I>&gt;<i> +	if (!priv-&gt;open_time)
</I>&gt;<i> +		return -EINVAL;
</I>&gt;<i> +
</I>&gt;<i> +	switch (mode) {
</I>&gt;<i> +	case CAN_MODE_START:
</I>&gt;<i> +		netif_wake_queue(netdev);
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	default:
</I>&gt;<i> +		return -EOPNOTSUPP;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd_usb2_probe_one_net(struct usb_interface *intf, int index)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2 *dev = usb_get_intfdata(intf);
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	struct esd_usb2_net_priv *priv;
</I>&gt;<i> +	int err;
</I>&gt;<i> +	int i;
</I>&gt;<i> +
</I>&gt;<i> +	netdev = alloc_candev(sizeof(*priv), MAX_TX_URBS);
</I>&gt;<i> +	if (!netdev) {
</I>&gt;<i> +		dev_err(&amp;intf-&gt;dev, &quot;couldn't alloc candev\n&quot;);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	priv = netdev_priv(netdev);
</I>&gt;<i> +
</I>&gt;<i> +	init_usb_anchor(&amp;priv-&gt;tx_submitted);
</I>&gt;<i> +	atomic_set(&amp;priv-&gt;active_tx_jobs, 0);
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; MAX_TX_URBS; i++)
</I>&gt;<i> +		priv-&gt;tx_contexts[i].echo_index = MAX_TX_URBS;
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;usb2 = dev;
</I>&gt;<i> +	priv-&gt;netdev = netdev;
</I>&gt;<i> +	priv-&gt;index = index;
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> +	priv-&gt;can.clock.freq = ESD_USB2_CAN_CLOCK;
</I>&gt;<i> +	priv-&gt;can.bittiming_const = &amp;esd_usb2_bittiming_const;
</I>&gt;<i> +	priv-&gt;can.do_set_bittiming = esd_usb2_set_bittiming;
</I>&gt;<i> +	priv-&gt;can.do_set_mode = esd_usb2_set_mode;
</I>&gt;<i> +
</I>&gt;<i> +	netdev-&gt;flags |= IFF_ECHO; /* we support local echo */
</I>&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
</I>&gt;<i> +	netdev-&gt;netdev_ops = &amp;esd_usb2_netdev_ops;
</I>&gt;<i> +#else
</I>&gt;<i> +	netdev-&gt;open = esd_usb2_open;
</I>&gt;<i> +	netdev-&gt;stop = esd_usb2_close;
</I>&gt;<i> +	netdev-&gt;hard_start_xmit = esd_usb2_start_xmit;
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +	SET_NETDEV_DEV(netdev, &amp;intf-&gt;dev);
</I>&gt;<i> +
</I>&gt;<i> +	err = register_candev(netdev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(&amp;intf-&gt;dev,
</I>&gt;<i> +			&quot;couldn't register CAN device: %d\n&quot;, err);
</I>&gt;<i> +		free_candev(netdev);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;nets[index] = priv;
</I>&gt;<i> +	dev_info(ND2D(netdev), &quot;device %s registered\n&quot;, netdev-&gt;name);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * probe function for new USB2 devices
</I>&gt;<i> + *
</I>&gt;<i> + * check version information and number of available
</I>&gt;<i> + * CAN interfaces
</I>&gt;<i> + */
</I>&gt;<i> +static int esd_usb2_probe(struct usb_interface *intf,
</I>&gt;<i> +			 const struct usb_device_id *id)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2 *dev;
</I>&gt;<i> +	struct esd_usb2_msg msg;
</I>&gt;<i> +	int i, err = -ENOMEM;
</I>&gt;<i> +
</I>&gt;<i> +	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
</I>&gt;<i> +	if (!dev)
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;udev = interface_to_usbdev(intf);
</I>&gt;<i> +
</I>&gt;<i> +	init_usb_anchor(&amp;dev-&gt;rx_submitted);
</I>&gt;<i> +
</I>&gt;<i> +	usb_set_intfdata(intf, dev);
</I>&gt;<i> +
</I>&gt;<i> +	/* query number of CAN interfaces (nets) */
</I>&gt;<i> +	msg.msg.hdr.cmd = CMD_VERSION;
</I>&gt;<i> +	msg.msg.hdr.len = 2;
</I>&gt;<i> +	msg.msg.version.rsvd = 0;
</I>&gt;<i> +	msg.msg.version.flags = 0;
</I>&gt;<i> +	msg.msg.version.drv_version = 0;
</I>&gt;<i> +
</I>&gt;<i> +	if (esd_usb2_send_msg(dev, &amp;msg) &lt; 0) {
</I>&gt;<i> +		dev_err(&amp;intf-&gt;dev, &quot;sending version message failed\n&quot;);
</I>&gt;<i> +		goto free_dev;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (esd_usb2_wait_msg(dev, &amp;msg) &lt; 0) {
</I>&gt;<i> +		dev_err(&amp;intf-&gt;dev, &quot;no version message answer\n&quot;);
</I>&gt;<i> +		goto free_dev;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;net_count = (int)msg.msg.version_reply.nets;
</I>&gt;<i> +	dev-&gt;version = le32_to_cpu(msg.msg.version_reply.version);
</I>&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_SYSFS
</I>&gt;<i> +	device_create_file(&amp;intf-&gt;dev, &amp;dev_attr_firmware);
</I>&gt;<i> +	device_create_file(&amp;intf-&gt;dev, &amp;dev_attr_hardware);
</I>&gt;<i> +	device_create_file(&amp;intf-&gt;dev, &amp;dev_attr_nets);
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +	/* do per device probing */
</I>&gt;<i> +	for (i = 0; i &lt; dev-&gt;net_count; i++)
</I>&gt;<i> +		esd_usb2_probe_one_net(intf, i);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +free_dev:
</I>&gt;<i> +	kfree(dev);
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * called by the usb core when the device is removed from the system
</I>&gt;<i> + */
</I>&gt;<i> +static void esd_usb2_disconnect(struct usb_interface *intf)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd_usb2 *dev = usb_get_intfdata(intf);
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	int i;
</I>&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_SYSFS
</I>&gt;<i> +	device_remove_file(&amp;intf-&gt;dev, &amp;dev_attr_firmware);
</I>&gt;<i> +	device_remove_file(&amp;intf-&gt;dev, &amp;dev_attr_hardware);
</I>&gt;<i> +	device_remove_file(&amp;intf-&gt;dev, &amp;dev_attr_nets);
</I>&gt;<i> +#endif
</I>&gt;<i> +	usb_set_intfdata(intf, NULL);
</I>&gt;<i> +
</I>&gt;<i> +	if (dev) {
</I>&gt;<i> +		for (i = 0; i &lt; dev-&gt;net_count; i++) {
</I>&gt;<i> +			if (dev-&gt;nets[i]) {
</I>&gt;<i> +				netdev = dev-&gt;nets[i]-&gt;netdev;
</I>&gt;<i> +				unregister_netdev(netdev);
</I>&gt;<i> +				free_candev(netdev);
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +		unlink_all_urbs(dev);
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/* usb specific object needed to register this driver with the usb subsystem */
</I>&gt;<i> +static struct usb_driver esd_usb2_driver = {
</I>&gt;<i> +	.name = &quot;esd_usb2&quot;,
</I>&gt;<i> +	.probe = esd_usb2_probe,
</I>&gt;<i> +	.disconnect = esd_usb2_disconnect,
</I>&gt;<i> +	.id_table = esd_usb2_table,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int __init esd_usb2_init(void)
</I>&gt;<i> +{
</I>&gt;<i> +	int err;
</I>&gt;<i> +
</I>&gt;<i> +	printk(KERN_INFO &quot;esd CAN/USB2 kernel driver\n&quot;);
</I>
Please drop this. Imagine every driver would print out a message when loading :)
The dev_info message when probing will do.

&gt;<i> +
</I>&gt;<i> +	/* register this driver with the USB subsystem */
</I>&gt;<i> +	err = usb_register(&amp;esd_usb2_driver);
</I>&gt;<i> +
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		err(&quot;usb_register failed. Error number %d\n&quot;, err);
</I>&gt;<i> +		return err;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void __exit esd_usb2_exit(void)
</I>&gt;<i> +{
</I>&gt;<i> +	/* deregister this driver with the USB subsystem */
</I>&gt;<i> +	usb_deregister(&amp;esd_usb2_driver);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +module_init(esd_usb2_init);
</I>&gt;<i> +module_exit(esd_usb2_exit);
</I>
Those lines should be directly after the function itself.

&gt;<i> Index: drivers/net/can/usb/Makefile
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- drivers/net/can/usb/Makefile	(revision 1095)
</I>&gt;<i> +++ drivers/net/can/usb/Makefile	(working copy)
</I>&gt;<i> @@ -16,6 +16,7 @@
</I>&gt;<i>  -include $(TOPDIR)/Makefile.common
</I>&gt;<i>  
</I>&gt;<i>  obj-$(CONFIG_CAN_EMS_USB) += ems_usb.o
</I>&gt;<i> +obj-$(CONFIG_CAN_ESD_USB2) += esd_usb2.o
</I>&gt;<i>  
</I>&gt;<i>  ifeq ($(CONFIG_CAN_DEBUG_DEVICES),y)
</I>&gt;<i>  	EXTRA_CFLAGS += -DDEBUG
</I>&gt;<i> Index: drivers/net/can/Makefile
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- drivers/net/can/Makefile	(revision 1095)
</I>&gt;<i> +++ drivers/net/can/Makefile	(working copy)
</I>&gt;<i> @@ -19,6 +19,7 @@
</I>&gt;<i>  export CONFIG_CAN_EMS_PCI=m
</I>&gt;<i>  export CONFIG_CAN_EMS_PCMCIA=m
</I>&gt;<i>  export CONFIG_CAN_ESD_PCI331=m
</I>&gt;<i> +export CONFIG_CAN_ESD_USB2=m
</I>&gt;<i>  export CONFIG_CAN_PIPCAN=m
</I>&gt;<i>  export CONFIG_CAN_SOFTING=m
</I>&gt;<i>  export CONFIG_CAN_SOFTING_CS=m
</I>
Regards,

   Wolfram

-- 
Pengutronix e.K.                           | Wolfram Sang                |
Industrial Linux Solutions                 | <A HREF="http://www.pengutronix.de/">http://www.pengutronix.de/</A>  |
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 197 bytes
Desc: Digital signature
URL: &lt;<A HREF="https://lists.berlios.de/pipermail/socketcan-core/attachments/20100111/81f79c25/attachment.pgp">https://lists.berlios.de/pipermail/socketcan-core/attachments/20100111/81f79c25/attachment.pgp</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003817.html">[PATCH V3] Add driver for esd USB2 CAN interface
</A></li>
	<LI>Next message: <A HREF="003823.html">[PATCH V3] Add driver for esd USB2 CAN interface
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3818">[ date ]</a>
              <a href="thread.html#3818">[ thread ]</a>
              <a href="subject.html#3818">[ subject ]</a>
              <a href="author.html#3818">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
