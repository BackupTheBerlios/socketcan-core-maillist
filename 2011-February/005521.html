<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH v2 09/13] can: pruss CAN driver.
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2011-February/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20v2%2009/13%5D%20can%3A%20pruss%20CAN%20driver.&In-Reply-To=%3C4D55AB20.8060803%40pengutronix.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005520.html">
   <LINK REL="Next"  HREF="005594.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH v2 09/13] can: pruss CAN driver.</H1>
    <B>Marc Kleine-Budde</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20v2%2009/13%5D%20can%3A%20pruss%20CAN%20driver.&In-Reply-To=%3C4D55AB20.8060803%40pengutronix.de%3E"
       TITLE="[PATCH v2 09/13] can: pruss CAN driver.">mkl at pengutronix.de
       </A><BR>
    <I>Fri Feb 11 22:33:20 CET 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="005520.html">[PATCH v2 09/13] can: pruss CAN driver.
</A></li>
        <LI>Next message: <A HREF="005594.html">[PATCH v2 09/13] can: pruss CAN driver.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5521">[ date ]</a>
              <a href="thread.html#5521">[ thread ]</a>
              <a href="subject.html#5521">[ subject ]</a>
              <a href="author.html#5521">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 02/11/2011 03:51 PM, Subhasish Ghosh wrote:
&gt;<i> This patch adds support for the CAN device emulated on PRUSS.
</I>
Is this a software CAN device running on the omap dsp? Nice :)
My first impression is that this driver needs a lot of work, but we'll
help you.

Being new to the OMAP world here are soo many names for the same thing,
i.e. the CAN core and driver:

- da8cc
- pruss
- omap
- pru

These or combination of these are used all over the code. I'm preferring
one common prefix. I like the PRU_ prefix for the defines and the pru_
for functions.

Please don't encode the variable type into their names (a.k.a. polish
notation), e.g. it's &quot;u8 data&quot; not &quot;u8 u8data&quot;, No typedefs, enums just
like defines in uppercase.

Get rid of the of the extra layer in pruss_can_api.c.

More comments inline:

&gt;<i> Signed-off-by: Subhasish Ghosh &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">subhasish at mistralsolutions.com</A>&gt;
</I>&gt;<i> ---
</I>&gt;<i>  drivers/net/can/Kconfig                     |    1 +
</I>&gt;<i>  drivers/net/can/Makefile                    |    1 +
</I>&gt;<i>  drivers/net/can/da8xx_pruss/Kconfig         |   73 ++
</I>&gt;<i>  drivers/net/can/da8xx_pruss/Makefile        |    7 +
</I>&gt;<i>  drivers/net/can/da8xx_pruss/pruss_can.c     |  758 +++++++++++++++++
</I>&gt;<i>  drivers/net/can/da8xx_pruss/pruss_can_api.c | 1227 +++++++++++++++++++++++++++
</I>&gt;<i>  drivers/net/can/da8xx_pruss/pruss_can_api.h |  290 +++++++
</I>&gt;<i>  7 files changed, 2357 insertions(+), 0 deletions(-)
</I>&gt;<i>  create mode 100644 drivers/net/can/da8xx_pruss/Kconfig
</I>&gt;<i>  create mode 100644 drivers/net/can/da8xx_pruss/Makefile
</I>&gt;<i>  create mode 100644 drivers/net/can/da8xx_pruss/pruss_can.c
</I>&gt;<i>  create mode 100644 drivers/net/can/da8xx_pruss/pruss_can_api.c
</I>&gt;<i>  create mode 100644 drivers/net/can/da8xx_pruss/pruss_can_api.h
</I>&gt;<i> 
</I>&gt;<i> diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
</I>&gt;<i> index d5a9db6..ae8f0f9 100644
</I>&gt;<i> --- a/drivers/net/can/Kconfig
</I>&gt;<i> +++ b/drivers/net/can/Kconfig
</I>&gt;<i> @@ -112,6 +112,7 @@ config PCH_CAN
</I>&gt;<i>  	  This driver can access CAN bus.
</I>&gt;<i>  
</I>&gt;<i>  source &quot;drivers/net/can/mscan/Kconfig&quot;
</I>&gt;<i> +source &quot;drivers/net/can/da8xx_pruss/Kconfig&quot;
</I>&gt;<i>  
</I>&gt;<i>  source &quot;drivers/net/can/sja1000/Kconfig&quot;
</I>&gt;<i>  
</I>&gt;<i> diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
</I>&gt;<i> index 07ca159..849cdbf 100644
</I>&gt;<i> --- a/drivers/net/can/Makefile
</I>&gt;<i> +++ b/drivers/net/can/Makefile
</I>&gt;<i> @@ -14,6 +14,7 @@ obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
</I>&gt;<i>  obj-$(CONFIG_CAN_MSCAN)		+= mscan/
</I>&gt;<i>  obj-$(CONFIG_CAN_AT91)		+= at91_can.o
</I>&gt;<i>  obj-$(CONFIG_CAN_TI_HECC)	+= ti_hecc.o
</I>&gt;<i> +obj-$(CONFIG_CAN_TI_DA8XX_PRU)	+= da8xx_pruss/
</I>&gt;<i>  obj-$(CONFIG_CAN_MCP251X)	+= mcp251x.o
</I>&gt;<i>  obj-$(CONFIG_CAN_BFIN)		+= bfin_can.o
</I>&gt;<i>  obj-$(CONFIG_CAN_JANZ_ICAN3)	+= janz-ican3.o
</I>&gt;<i> diff --git a/drivers/net/can/da8xx_pruss/Kconfig b/drivers/net/can/da8xx_pruss/Kconfig
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..8b68f68
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/da8xx_pruss/Kconfig
</I>&gt;<i> @@ -0,0 +1,73 @@
</I>&gt;<i> +#
</I>&gt;<i> +# CAN Lite Kernel Configuration
</I>     ^^^^^^^^^^^^^^^

what's can lite?

&gt;<i> +#
</I>&gt;<i> +config CAN_TI_DA8XX_PRU
</I>&gt;<i> +	depends on CAN_DEV &amp;&amp; ARCH_DAVINCI &amp;&amp; ARCH_DAVINCI_DA850
</I>&gt;<i> +	tristate &quot;PRU based CAN emulation for DA8XX&quot;
</I>&gt;<i> +	---help---
</I>&gt;<i> +	Enable this to emulate a CAN controller on the PRU of DA8XX.
</I>&gt;<i> +	If not sure, mark N
</I>&gt;<i> +
</I>&gt;<i> +config DA8XX_PRU_CANID_MBX0
</I>&gt;<i> +	hex &quot;CANID for mailbox 0&quot;
</I>&gt;<i> +	depends on CAN_TI_DA8XX_PRU
</I>&gt;<i> +	default &quot;0x123&quot;
</I>&gt;<i> +	---help---
</I>&gt;<i> +	Enter the CANID for mailbox 0
</I>&gt;<i> +	Default value is set to 0x123, change this as required.
</I>&gt;<i> +
</I>&gt;<i> +config DA8XX_PRU_CANID_MBX1
</I>&gt;<i> +	hex &quot;CANID for mailbox 1&quot;
</I>&gt;<i> +	depends on CAN_TI_DA8XX_PRU
</I>&gt;<i> +	default &quot;0x123&quot;
</I>&gt;<i> +	 ---help---
</I>&gt;<i> +	Enter the CANID for mailbox 1
</I>&gt;<i> +	Default value is set to 0x123, change this as required.
</I>&gt;<i> +
</I>&gt;<i> +config DA8XX_PRU_CANID_MBX2
</I>&gt;<i> +	hex &quot;CANID for mailbox 2&quot;
</I>&gt;<i> +	depends on CAN_TI_DA8XX_PRU
</I>&gt;<i> +	default &quot;0x123&quot;
</I>&gt;<i> +	---help---
</I>&gt;<i> +	Enter the CANID for mailbox 2
</I>&gt;<i> +	Default value is set to 0x123, change this as required.
</I>&gt;<i> +
</I>&gt;<i> +config DA8XX_PRU_CANID_MBX3
</I>&gt;<i> +	hex &quot;CANID for mailbox 3&quot;
</I>&gt;<i> +	depends on CAN_TI_DA8XX_PRU
</I>&gt;<i> +	default &quot;0x123&quot;
</I>&gt;<i> +	---help---
</I>&gt;<i> +	Enter the CANID for mailbox 3
</I>&gt;<i> +	Default value is set to 0x123, change this as required.
</I>&gt;<i> +
</I>&gt;<i> +config DA8XX_PRU_CANID_MBX4
</I>&gt;<i> +	hex &quot;CANID for mailbox 4&quot;
</I>&gt;<i> +	depends on CAN_TI_DA8XX_PRU
</I>&gt;<i> +	default &quot;0x123&quot;
</I>&gt;<i> +	---help---
</I>&gt;<i> +	Enter the CANID for mailbox 4
</I>&gt;<i> +	Default value is set to 0x123, change this as required.
</I>&gt;<i> +
</I>&gt;<i> +config DA8XX_PRU_CANID_MBX5
</I>&gt;<i> +	hex &quot;CANID for mailbox 5&quot;
</I>&gt;<i> +	depends on CAN_TI_DA8XX_PRU
</I>&gt;<i> +	default &quot;0x123&quot;
</I>&gt;<i> +	---help---
</I>&gt;<i> +	Enter the CANID for mailbox 5
</I>&gt;<i> +	Default value is set to 0x123, change this as required.
</I>&gt;<i> +
</I>&gt;<i> +config DA8XX_PRU_CANID_MBX6
</I>&gt;<i> +	hex &quot;CANID for mailbox 6&quot;
</I>&gt;<i> +	depends on CAN_TI_DA8XX_PRU
</I>&gt;<i> +	default &quot;0x123&quot;
</I>&gt;<i> +	---help---
</I>&gt;<i> +	Enter the CANID for mailbox 6
</I>&gt;<i> +	Default value is set to 0x123, change this as required.
</I>&gt;<i> +
</I>&gt;<i> +config DA8XX_PRU_CANID_MBX7
</I>&gt;<i> +	hex &quot;CANID for mailbox 7&quot;
</I>&gt;<i> +	depends on CAN_TI_DA8XX_PRU
</I>&gt;<i> +	default &quot;0x123&quot;
</I>&gt;<i> +	---help---
</I>&gt;<i> +	Enter the CANID for mailbox 7
</I>&gt;<i> +	Default value is set to 0x123, change this as required.
</I>
This doesn't fit to the Socketcan abstraction of a CAN card. Please
remove. After this &quot;da8xx_pruss/Kconfig&quot; just contains the
CAN_TI_DA8XX_PRU symbol, which can be added directly to
drivers/net/can/Kconfig. (With a perhaps a simpler kconfig symbol name.)

&gt;<i> diff --git a/drivers/net/can/da8xx_pruss/Makefile b/drivers/net/can/da8xx_pruss/Makefile
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..48f3055
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/da8xx_pruss/Makefile
</I>&gt;<i> @@ -0,0 +1,7 @@
</I>&gt;<i> +#
</I>&gt;<i> +# Makefile for CAN Lite emulation
</I>&gt;<i> +#
</I>&gt;<i> +can_emu-objs :=   pruss_can.o \
</I>&gt;<i> +                  pruss_can_api.o
</I>
Do we need two c file? I haven't look at them, yet.

&gt;<i> +
</I>&gt;<i> +obj-$(CONFIG_CAN_TI_DA8XX_PRU)    += can_emu.o
</I>&gt;<i> diff --git a/drivers/net/can/da8xx_pruss/pruss_can.c b/drivers/net/can/da8xx_pruss/pruss_can.c
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..1b3afde
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/da8xx_pruss/pruss_can.c
</I>&gt;<i> @@ -0,0 +1,758 @@
</I>&gt;<i> +/*
</I>&gt;<i> + *  TI DA8XX PRU CAN Emulation device driver
</I>&gt;<i> + *  Author: <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">subhasish at mistralsolutions.com</A>
</I>&gt;<i> + *
</I>&gt;<i> + *  This driver supports TI's PRU CAN Emulation and the
</I>&gt;<i> + *  specs for the same is available at &lt;<A HREF="http://www.ti.com">http://www.ti.com</A>&gt;
</I>&gt;<i> + *
</I>&gt;<i> + *  Copyright (C) 2009 Texas Instruments Incorporated - <A HREF="http://www.ti.com/">http://www.ti.com/</A>
</I>
You'll probably do some work on the driver, so add a 2011, here :)

&gt;<i> + *
</I>&gt;<i> + *  This program is free software; you can redistribute it and/or
</I>&gt;<i> + *  modify it under the terms of the GNU General Public License as
</I>&gt;<i> + *  published by the Free Software Foundation version 2.
</I>&gt;<i> + *
</I>&gt;<i> + *  This program is distributed as is WITHOUT ANY WARRANTY of any
</I>&gt;<i> + *  kind, whether express or implied; without even the implied warranty
</I>&gt;<i> + *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</I>&gt;<i> + *  GNU General Public License for more details.
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/module.h&gt;
</I>&gt;<i> +#include &lt;linux/init.h&gt;
</I>&gt;<i> +#include &lt;linux/kernel.h&gt;
</I>&gt;<i> +#include &lt;linux/bitops.h&gt;
</I>&gt;<i> +#include &lt;linux/interrupt.h&gt;
</I>&gt;<i> +#include &lt;linux/errno.h&gt;
</I>&gt;<i> +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> +#include &lt;linux/skbuff.h&gt;
</I>&gt;<i> +#include &lt;linux/platform_device.h&gt;
</I>&gt;<i> +#include &lt;linux/firmware.h&gt;
</I>&gt;<i> +#include &lt;linux/clk.h&gt;
</I>&gt;<i> +#include &lt;linux/types.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/can.h&gt;
</I>&gt;<i> +#include &lt;linux/can/dev.h&gt;
</I>&gt;<i> +#include &lt;linux/can/error.h&gt;
</I>&gt;<i> +#include &lt;mach/da8xx.h&gt;
</I>&gt;<i> +#include &quot;pruss_can_api.h&quot;
</I>
Do we need a separate header file?
&gt;<i> +
</I>&gt;<i> +#define DRV_NAME &quot;da8xx_pruss_can&quot;
</I>&gt;<i> +#define DRV_DESC &quot;TI PRU CAN Controller Driver v0.1&quot;
</I>&gt;<i> +#define PRU_CAN_START		1
</I>&gt;<i> +#define PRU_CAN_STOP		0
</I>&gt;<i> +#define MB_MIN			0
</I>&gt;<i> +#define MB_MAX			7
</I>
please add the common PRU_ prefis to the MB_*, too.

&gt;<i> +
</I>&gt;<i> +#define PRU_CANMID_IDE			BIT(29)	/* Extended frame format */
</I>&gt;<i> +
</I>&gt;<i> +#define PRU_CAN_ISR_BIT_CCI		BIT(15)
</I>&gt;<i> +#define PRU_CAN_ISR_BIT_ESI		BIT(14)
</I>&gt;<i> +#define PRU_CAN_ISR_BIT_SRDI		BIT(13)
</I>&gt;<i> +#define PRU_CAN_ISR_BIT_RRI		BIT(8)
</I>&gt;<i> +
</I>&gt;<i> +#define PRU_CAN_MBXSR_BIT_STATE		BIT(7)
</I>&gt;<i> +#define PRU_CAN_MBXSR_BIT_TC		BIT(6)
</I>&gt;<i> +#define PRU_CAN_MBXSR_BIT_ERR		BIT(5)
</I>&gt;<i> +#define PRU_CAN_MBXSR_BIT_OF		BIT(0)
</I>&gt;<i> +
</I>&gt;<i> +#define PRU_CAN_GSR_BIT_TXM		BIT(7)
</I>&gt;<i> +#define PRU_CAN_GSR_BIT_RXM		BIT(6)
</I>&gt;<i> +#define PRU_CAN_GSR_BIT_CM		BIT(5)
</I>&gt;<i> +#define PRU_CAN_GSR_BIT_EPM		BIT(4)
</I>&gt;<i> +#define PRU_CAN_GSR_BIT_BFM		BIT(3)
</I>&gt;<i> +#define RTR_MBX_NO			8
</I>
We don't have special mailboxes for RTR, pleae remove.

add the PRU_ prefix here, too.
&gt;<i> +#define MAX_INIT_RETRIES		20
</I>&gt;<i> +#define L138_PRU_ARM_FREQ		312000
</I>&gt;<i> +#define DFLT_PRU_FREQ			156000000
</I>
Any change that you get these values from the a clock device?
e.g.:
<A HREF="http://lxr.linux.no/linux+v2.6.37/drivers/net/can/flexcan.c#L909">http://lxr.linux.no/linux+v2.6.37/drivers/net/can/flexcan.c#L909</A>
<A HREF="http://lxr.linux.no/linux+v2.6.37/drivers/net/can/flexcan.c#L946">http://lxr.linux.no/linux+v2.6.37/drivers/net/can/flexcan.c#L946</A>

&gt;<i> +#define DFLT_PRU_BITRATE		125000
</I>
Please remove, we don't have a default bitrate.

&gt;<i> +
</I>&gt;<i> +#define CONFIG_DA8XX_PRU_CANID_MBX0	0x123
</I>&gt;<i> +#define CONFIG_DA8XX_PRU_CANID_MBX1	0x123
</I>&gt;<i> +#define CONFIG_DA8XX_PRU_CANID_MBX2	0x123
</I>&gt;<i> +#define CONFIG_DA8XX_PRU_CANID_MBX3	0x123
</I>&gt;<i> +#define CONFIG_DA8XX_PRU_CANID_MBX4	0x123
</I>&gt;<i> +#define CONFIG_DA8XX_PRU_CANID_MBX5	0x123
</I>&gt;<i> +#define CONFIG_DA8XX_PRU_CANID_MBX6	0x123
</I>&gt;<i> +#define CONFIG_DA8XX_PRU_CANID_MBX7	0x123
</I>
as alreadt said, we don't have default canids, please remove.

&gt;<i> +
</I>&gt;<i> +#ifdef __CAN_DEBUG
</I>&gt;<i> +#define __can_debug(fmt, args...) printk(KERN_DEBUG &quot;can_debug: &quot; fmt, ## args)
</I>&gt;<i> +#else
</I>&gt;<i> +#define __can_debug(fmt, args...)
</I>&gt;<i> +#endif
</I>&gt;<i> +#define __can_err(fmt, args...) printk(KERN_ERR &quot;can_err: &quot; fmt, ## args)
</I>
please use pr_&lt;level&gt; and and friends, use pr_fmt to set a common
prefix. Or even better use netdev_&lt;level&gt;.

&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * omapl_pru can private data
</I>&gt;<i> + */
</I>&gt;<i> +struct omapl_pru_can_priv {
</I>&gt;<i> +	struct can_priv can;
</I>&gt;<i> +	struct workqueue_struct *pru_can_wQ;
</I>&gt;<i> +	struct work_struct rx_work;
</I>&gt;<i> +	struct net_device *ndev;
</I>&gt;<i> +	struct device *dev; /* pdev-&gt;dev */
</I>
nitpick: pointless comment :)

&gt;<i> +	struct clk *clk_timer;
</I>&gt;<i> +	u32 timer_freq;
</I>&gt;<i> +	can_emu_app_hndl can_tx_hndl;
</I>&gt;<i> +	can_emu_app_hndl can_rx_hndl;
</I>
please no new typedefs.

&gt;<i> +	const struct firmware *fw_rx;
</I>&gt;<i> +	const struct firmware *fw_tx;
</I>&gt;<i> +	spinlock_t mbox_lock;
</I>&gt;<i> +	u32 trx_irq;
</I>&gt;<i> +	u32 tx_head;
</I>&gt;<i> +	u32 tx_tail;
</I>&gt;<i> +	u32 tx_next;
</I>&gt;<i> +	u32 rx_next;
</I>
If these don't reflect register values, just use &quot;unsigned int&quot;s here.

&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int omapl_pru_can_get_state(const struct net_device *ndev,
</I>&gt;<i> +				   enum can_state *state)
</I>
just for consistency most other can drivers use &quot;struct net_device *dev&quot;.

&gt;<i> +{
</I>&gt;<i> +	struct omapl_pru_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	*state = priv-&gt;can.state;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int omapl_pru_can_set_bittiming(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct omapl_pru_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> +	long bit_error = 0;
</I>&gt;<i> +
</I>&gt;<i> +	if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES) {
</I>&gt;<i> +		dev_warn(priv-&gt;dev, &quot;WARN: Triple&quot;
</I>&gt;<i> +			 &quot;sampling not set due to h/w limitations&quot;);
</I>&gt;<i> +	}
</I>
No need to check this, just set the modes you support in
&quot;priv-&gt;can.ctrlmode_supported&quot;.

<A HREF="http://lxr.linux.no/linux+v2.6.37/drivers/net/can/at91_can.c#L1091">http://lxr.linux.no/linux+v2.6.37/drivers/net/can/at91_can.c#L1091</A>

&gt;<i> +	if (pru_can_calc_timing(priv-&gt;dev, priv-&gt;can.clock.freq,
</I>&gt;<i> +				bt-&gt;bitrate) != 0)
</I>
The above function does _set_ the bit timing into the hardware, calling
it &quot;can_calc_timing&quot; is a bit misleading.

Don't calculate the bit timing yoursef. Please define your
bittiming_const and set it, see:

<A HREF="http://lxr.linux.no/linux+v2.6.37/drivers/net/can/at91_can.c#L173">http://lxr.linux.no/linux+v2.6.37/drivers/net/can/at91_can.c#L173</A>
<A HREF="http://lxr.linux.no/linux+v2.6.37/drivers/net/can/at91_can.c#L1088">http://lxr.linux.no/linux+v2.6.37/drivers/net/can/at91_can.c#L1088</A>

&gt;<i> +		return -EINVAL;
</I>&gt;<i> +	bit_error =
</I>&gt;<i> +	    (((priv-&gt;timer_freq / (priv-&gt;timer_freq / bt-&gt;bitrate)) -
</I>&gt;<i> +	      bt-&gt;bitrate) * 1000) / bt-&gt;bitrate;
</I>&gt;<i> +	if (bit_error) {
</I>&gt;<i> +		bit_error =
</I>&gt;<i> +		    (((priv-&gt;timer_freq / (priv-&gt;timer_freq / bt-&gt;bitrate)) -
</I>&gt;<i> +		      bt-&gt;bitrate) * 1000000) / bt-&gt;bitrate;
</I>&gt;<i> +		printk(KERN_INFO &quot;\nBitrate error %ld.%ld%%\n&quot;,
</I>&gt;<i> +			bit_error / 10000, bit_error % 1000);
</I>&gt;<i> +	} else
</I>&gt;<i> +		printk(KERN_INFO &quot;\nBitrate error 0.0%%\n&quot;);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void omapl_pru_can_stop(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct omapl_pru_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	u16 int_mask = 0;
</I>&gt;<i> +
</I>&gt;<i> +	pru_can_mask_ints(priv-&gt;dev, int_mask);	/* mask all ints */
</I>&gt;<i> +	pru_can_start_abort_tx(priv-&gt;dev, PRU_CAN_STOP);
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * This is to just set the can state to ERROR_ACTIVE
</I>&gt;<i> + *	ip link set canX up type can bitrate 125000
</I>&gt;<i> + */
</I>&gt;<i> +static void omapl_pru_can_start(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct omapl_pru_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	u16 int_mask = 0xFFFF;
</I>&gt;<i> +
</I>&gt;<i> +	if (priv-&gt;can.state != CAN_STATE_STOPPED)
</I>&gt;<i> +		omapl_pru_can_stop(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	pru_can_mask_ints(priv-&gt;dev, int_mask);	/* unmask all ints */
</I>&gt;<i> +
</I>&gt;<i> +	pru_can_get_global_status(priv-&gt;dev, &amp;priv-&gt;can_tx_hndl);
</I>&gt;<i> +	pru_can_get_global_status(priv-&gt;dev, &amp;priv-&gt;can_rx_hndl);
</I>&gt;<i> +
</I>&gt;<i> +	if (PRU_CAN_GSR_BIT_EPM &amp; priv-&gt;can_tx_hndl.u32globalstatus)
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> +	else if (PRU_CAN_GSR_BIT_BFM &amp; priv-&gt;can_tx_hndl.u32globalstatus)
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +	else
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int omapl_pru_can_set_mode(struct net_device *ndev, enum can_mode mode)
</I>&gt;<i> +{
</I>&gt;<i> +	int ret = 0;
</I>&gt;<i> +
</I>&gt;<i> +	switch (mode) {
</I>&gt;<i> +	case CAN_MODE_START:
</I>&gt;<i> +		omapl_pru_can_start(ndev);
</I>&gt;<i> +		if (netif_queue_stopped(ndev))
</I>&gt;<i> +			netif_wake_queue(ndev);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case CAN_MODE_STOP:
</I>&gt;<i> +		omapl_pru_can_stop(ndev);
</I>&gt;<i> +		if (!netif_queue_stopped(ndev))
</I>&gt;<i> +			netif_stop_queue(ndev);
</I>&gt;<i> +		break;
</I>&gt;<i> +	default:
</I>&gt;<i> +		ret = -EOPNOTSUPP;
</I>&gt;<i> +		break;
</I>&gt;<i> +	}
</I>&gt;<i> +	return ret;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static netdev_tx_t omapl_pru_can_start_xmit(struct sk_buff *skb,
</I>&gt;<i> +					    struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct omapl_pru_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> +	int count;
</I>&gt;<i> +	u8 *data = cf-&gt;data;
</I>&gt;<i> +	u8 dlc = cf-&gt;can_dlc;
</I>&gt;<i> +	u8 *ptr8data = NULL;
</I>&gt;<i> +
</I>&gt;<i> +	netif_stop_queue(ndev);
</I>&gt;<i> +	if (cf-&gt;can_id &amp; CAN_EFF_FLAG)	/* Extended frame format */
</I>&gt;<i> +		*((u32 *) &amp;priv-&gt;can_tx_hndl.strcanmailbox) =
</I>&gt;<i> +		    (cf-&gt;can_id &amp; CAN_EFF_MASK) | PRU_CANMID_IDE;
</I>&gt;<i> +	else			/* Standard frame format */
</I>&gt;<i> +		*((u32 *) &amp;priv-&gt;can_tx_hndl.strcanmailbox) =
</I>&gt;<i> +		    (cf-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; 18;
</I>&gt;<i> +
</I>&gt;<i> +	if (cf-&gt;can_id &amp; CAN_RTR_FLAG)	/* Remote transmission request */
</I>&gt;<i> +		*((u32 *) &amp;priv-&gt;can_tx_hndl.strcanmailbox) |= CAN_RTR_FLAG;
</I>&gt;<i> +
</I>&gt;<i> +	ptr8data = &amp;priv-&gt;can_tx_hndl.strcanmailbox.u8data7 + (dlc - 1);
</I>&gt;<i> +	for (count = 0; count &lt; (u8) dlc; count++) {
</I>&gt;<i> +		*ptr8data-- = *data++;
</I>&gt;<i> +	}
</I>&gt;<i> +	*((u32 *) &amp;priv-&gt;can_tx_hndl.strcanmailbox.u16datalength) = (u32) dlc;
</I>&gt;<i> +/*
</I>&gt;<i> + * search for the next available mbx
</I>&gt;<i> + * if the next mbx is busy, then try the next + 1
</I>&gt;<i> + * do this until the head is reached.
</I>&gt;<i> + * if still unable to tx, stop accepting any packets
</I>&gt;<i> + * if able to tx and the head is reached, then reset next to tail, i.e mbx0
</I>&gt;<i> + * if head is not reached, then just point to the next mbx
</I>&gt;<i> + */
</I>&gt;<i> +	for (; priv-&gt;tx_next &lt;= priv-&gt;tx_head; priv-&gt;tx_next++) {
</I>&gt;<i> +		priv-&gt;can_tx_hndl.ecanmailboxnumber =
</I>&gt;<i> +		    (can_mailbox_number) priv-&gt;tx_next;
</I>&gt;<i> +		if (-1 == pru_can_write_data_to_mailbox(priv-&gt;dev,
</I>&gt;<i> +					&amp;priv-&gt;can_tx_hndl)) {
</I>&gt;<i> +			if (priv-&gt;tx_next == priv-&gt;tx_head) {
</I>&gt;<i> +				priv-&gt;tx_next = priv-&gt;tx_tail;
</I>&gt;<i> +				if (!netif_queue_stopped(ndev))
</I>&gt;<i> +					netif_stop_queue(ndev);	/* IF stalled */
</I>&gt;<i> +				dev_err(priv-&gt;dev,
</I>&gt;<i> +					&quot;%s: no tx mbx available&quot;, __func__);
</I>&gt;<i> +				return NETDEV_TX_BUSY;
</I>&gt;<i> +			} else
</I>&gt;<i> +				continue;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			/* set transmit request */
</I>&gt;<i> +			pru_can_tx(priv-&gt;dev, priv-&gt;tx_next, CAN_TX_PRU_1);
</I>&gt;<i> +			pru_can_tx_mode_set(priv-&gt;dev, false, ecanreceive);
</I>&gt;<i> +			pru_can_tx_mode_set(priv-&gt;dev, true, ecantransmit);
</I>&gt;<i> +			pru_can_start_abort_tx(priv-&gt;dev, PRU_CAN_START);
</I>&gt;<i> +			priv-&gt;tx_next++;
</I>&gt;<i> +			can_put_echo_skb(skb, ndev, 0);
</I>&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +	if (priv-&gt;tx_next &gt; priv-&gt;tx_head) {
</I>&gt;<i> +		priv-&gt;tx_next = priv-&gt;tx_tail;
</I>&gt;<i> +	}
</I>&gt;<i> +	return NETDEV_TX_OK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int omapl_pru_can_rx(struct net_device *ndev, u32 mbxno)
</I>&gt;<i> +{
</I>&gt;<i> +	struct omapl_pru_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	u32 pru_can_mbx_data;
</I>&gt;<i> +	u8 *data = NULL;
</I>&gt;<i> +	u8 *ptr8data = NULL;
</I>&gt;<i> +	int count = 0;
</I>&gt;<i> +
</I>&gt;<i> +	skb = alloc_can_skb(ndev, &amp;cf);
</I>&gt;<i> +	if (!skb) {
</I>&gt;<i> +		if (printk_ratelimit())
</I>&gt;<i> +			dev_err(priv-&gt;dev,
</I>&gt;<i> +				&quot;alloc_can_skb() failed\n&quot;);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>&gt;<i> +	data = cf-&gt;data;
</I>&gt;<i> +	/*      get payload */
</I>&gt;<i> +	priv-&gt;can_rx_hndl.ecanmailboxnumber = (can_mailbox_number) mbxno;
</I>&gt;<i> +	if (pru_can_get_data_from_mailbox(priv-&gt;dev, &amp;priv-&gt;can_rx_hndl)) {
</I>&gt;<i> +		__can_err(&quot;failed to get data from mailbox\n&quot;);
</I>&gt;<i> +		return -EAGAIN;
</I>&gt;<i> +	}
</I>&gt;<i> +	/* give ownweship to pru */
</I>&gt;<i> +	pru_can_tx(priv-&gt;dev, mbxno, CAN_RX_PRU_0);
</I>&gt;<i> +
</I>&gt;<i> +	/* get data length code */
</I>&gt;<i> +	cf-&gt;can_dlc =
</I>&gt;<i> +	    get_can_dlc(*
</I>&gt;<i> +			((u32 *) &amp;priv-&gt;can_rx_hndl.strcanmailbox.
</I>&gt;<i> +			 u16datalength) &amp; 0xF);
</I>&gt;<i> +	if (cf-&gt;can_dlc &lt;= 4) {
</I>&gt;<i> +		ptr8data =
</I>&gt;<i> +		    &amp;priv-&gt;can_rx_hndl.strcanmailbox.u8data3 + (4 -
</I>&gt;<i> +								cf-&gt;can_dlc);
</I>&gt;<i> +		for (count = 0; count &lt; cf-&gt;can_dlc; count++) {
</I>&gt;<i> +			*data++ = *ptr8data++;
</I>&gt;<i> +		}
</I>&gt;<i> +	} else {
</I>&gt;<i> +		ptr8data = &amp;priv-&gt;can_rx_hndl.strcanmailbox.u8data3;
</I>&gt;<i> +		for (count = 0; count &lt; 4; count++) {
</I>&gt;<i> +			*data++ = *ptr8data++;
</I>&gt;<i> +		}
</I>&gt;<i> +		ptr8data =
</I>&gt;<i> +		    &amp;priv-&gt;can_rx_hndl.strcanmailbox.u8data4 - (cf-&gt;can_dlc -
</I>&gt;<i> +								5);
</I>&gt;<i> +		for (count = 0; count &lt; cf-&gt;can_dlc - 4; count++) {
</I>&gt;<i> +			*data++ = *ptr8data++;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	pru_can_mbx_data = *((u32 *) &amp;priv-&gt;can_rx_hndl.strcanmailbox);
</I>&gt;<i> +	/* get id extended or std */
</I>&gt;<i> +	if (pru_can_mbx_data &amp; PRU_CANMID_IDE)
</I>&gt;<i> +		cf-&gt;can_id = (pru_can_mbx_data &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
</I>&gt;<i> +	else
</I>&gt;<i> +		cf-&gt;can_id = (pru_can_mbx_data &gt;&gt; 18) &amp; CAN_SFF_MASK;
</I>&gt;<i> +
</I>&gt;<i> +	if (pru_can_mbx_data &amp; CAN_RTR_FLAG)
</I>&gt;<i> +		cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> +
</I>&gt;<i> +	netif_rx_ni(skb);
</I>&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;<i> +	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int omapl_pru_can_err(struct net_device *ndev, int int_status,
</I>&gt;<i> +			     int err_status)
</I>&gt;<i> +{
</I>&gt;<i> +	struct omapl_pru_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	int tx_err_cnt, rx_err_cnt;
</I>&gt;<i> +
</I>&gt;<i> +	/* propogate the error condition to the can stack */
</I>&gt;<i> +	skb = alloc_can_err_skb(ndev, &amp;cf);
</I>&gt;<i> +	if (!skb) {
</I>&gt;<i> +		if (printk_ratelimit())
</I>&gt;<i> +			dev_err(priv-&gt;dev,
</I>&gt;<i> +				&quot;alloc_can_err_skb() failed\n&quot;);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (err_status &amp; PRU_CAN_GSR_BIT_EPM) {	/* error passive int */
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> +		++priv-&gt;can.can_stats.error_passive;
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +		tx_err_cnt = pru_can_get_error_cnt(priv-&gt;dev, CAN_TX_PRU_1);
</I>&gt;<i> +		rx_err_cnt = pru_can_get_error_cnt(priv-&gt;dev, CAN_RX_PRU_0);
</I>&gt;<i> +		if (tx_err_cnt &gt; 127)
</I>&gt;<i> +			cf-&gt;data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
</I>&gt;<i> +		if (rx_err_cnt &gt; 127)
</I>&gt;<i> +			cf-&gt;data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> +
</I>&gt;<i> +		dev_dbg(priv-&gt;ndev-&gt;dev.parent, &quot;Error passive interrupt\n&quot;);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (err_status &amp; PRU_CAN_GSR_BIT_BFM) {
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> +		/*
</I>&gt;<i> +		 *      Disable all interrupts in bus-off to avoid int hog
</I>&gt;<i> +		 *      this should be handled by the pru
</I>&gt;<i> +		 */
</I>&gt;<i> +		pru_can_mask_ints(priv-&gt;dev, 0xFFFF);
</I>&gt;<i> +		can_bus_off(ndev);
</I>&gt;<i> +		dev_dbg(priv-&gt;ndev-&gt;dev.parent, &quot;Bus off mode\n&quot;);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	netif_rx(skb);
</I>&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;<i> +	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +void omapl_pru_can_rx_wQ(struct work_struct *work)
</I>&gt;<i> +{
</I>&gt;<i> +	struct omapl_pru_can_priv *priv = container_of(work,
</I>&gt;<i> +			struct omapl_pru_can_priv, rx_work);
</I>&gt;<i> +	struct net_device *ndev = priv-&gt;ndev;
</I>&gt;<i> +	u32 bit_set, mbxno = 0;
</I>&gt;<i> +
</I>&gt;<i> +	if (-1 == pru_can_get_intr_status(priv-&gt;dev, &amp;priv-&gt;can_rx_hndl))
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	if (PRU_CAN_ISR_BIT_RRI &amp; priv-&gt;can_rx_hndl.u32interruptstatus) {
</I>&gt;<i> +		mbxno = RTR_MBX_NO;
</I>&gt;<i> +		omapl_pru_can_rx(ndev, mbxno);
</I>&gt;<i> +	} else {
</I>&gt;<i> +		/* Extract the mboxno from the status */
</I>&gt;<i> +		for (bit_set = 0; ((priv-&gt;can_rx_hndl.u32interruptstatus &amp; 0xFF)
</I>&gt;<i> +						&gt;&gt; bit_set != 0); bit_set++)
</I>&gt;<i> +		;
</I>&gt;<i> +		if (0 == bit_set) {
</I>&gt;<i> +			dev_err(priv-&gt;dev,
</I>&gt;<i> +				&quot;%s: invalid mailbox number: %X\n&quot;, __func__,
</I>&gt;<i> +				priv-&gt;can_rx_hndl.u32interruptstatus);
</I>&gt;<i> +		} else {
</I>&gt;<i> +			mbxno = bit_set - 1;
</I>&gt;<i> +			if (PRU_CAN_ISR_BIT_ESI &amp; priv-&gt;can_rx_hndl.
</I>&gt;<i> +			    u32interruptstatus) {
</I>&gt;<i> +				pru_can_get_global_status(priv-&gt;dev,
</I>&gt;<i> +					&amp;priv-&gt;can_rx_hndl);
</I>&gt;<i> +				omapl_pru_can_err(ndev,
</I>&gt;<i> +				priv-&gt;can_rx_hndl.u32interruptstatus,
</I>&gt;<i> +				priv-&gt;can_rx_hndl.u32globalstatus);
</I>&gt;<i> +			} else {
</I>&gt;<i> +				omapl_pru_can_rx(ndev, mbxno);
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +irqreturn_t omapl_tx_can_intr(int irq, void *dev_id)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = dev_id;
</I>&gt;<i> +	struct omapl_pru_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> +	u32 bit_set, mbxno;
</I>&gt;<i> +
</I>&gt;<i> +	pru_can_get_intr_status(priv-&gt;dev, &amp;priv-&gt;can_tx_hndl);
</I>&gt;<i> +	if ((PRU_CAN_ISR_BIT_CCI &amp; priv-&gt;can_tx_hndl.u32interruptstatus)
</I>&gt;<i> +	    || (PRU_CAN_ISR_BIT_SRDI &amp; priv-&gt;can_tx_hndl.u32interruptstatus)) {
</I>&gt;<i> +		__can_debug(&quot;tx_int_status = 0x%X\n&quot;,
</I>&gt;<i> +			    priv-&gt;can_tx_hndl.u32interruptstatus);
</I>&gt;<i> +		can_free_echo_skb(ndev, 0);
</I>&gt;<i> +	} else {
</I>&gt;<i> +		for (bit_set = 0; ((priv-&gt;can_tx_hndl.u32interruptstatus &amp; 0xFF)
</I>&gt;<i> +						&gt;&gt; bit_set != 0); bit_set++)
</I>&gt;<i> +		;
</I>&gt;<i> +		if (0 == bit_set) {
</I>&gt;<i> +			__can_err(&quot;%s: invalid mailbox number\n&quot;, __func__);
</I>&gt;<i> +			can_free_echo_skb(ndev, 0);
</I>&gt;<i> +		} else {
</I>&gt;<i> +			mbxno = bit_set - 1;	/* mail box numbering starts from 0 */
</I>&gt;<i> +			if (PRU_CAN_ISR_BIT_ESI &amp; priv-&gt;can_tx_hndl.
</I>&gt;<i> +			    u32interruptstatus) {
</I>&gt;<i> +				/* read gsr and ack pru */
</I>&gt;<i> +				pru_can_get_global_status(priv-&gt;dev, &amp;priv-&gt;can_tx_hndl);
</I>&gt;<i> +				omapl_pru_can_err(ndev,
</I>&gt;<i> +						  priv-&gt;can_tx_hndl.
</I>&gt;<i> +						  u32interruptstatus,
</I>&gt;<i> +						  priv-&gt;can_tx_hndl.
</I>&gt;<i> +						  u32globalstatus);
</I>&gt;<i> +			} else {
</I>&gt;<i> +				stats-&gt;tx_packets++;
</I>&gt;<i> +				/* stats-&gt;tx_bytes += dlc; */
</I>&gt;<i> +				/*can_get_echo_skb(ndev, 0);*/
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +	if (netif_queue_stopped(ndev))
</I>&gt;<i> +		netif_wake_queue(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	can_get_echo_skb(ndev, 0);
</I>&gt;<i> +	pru_can_tx_mode_set(priv-&gt;dev, true, ecanreceive);
</I>&gt;<i> +	return IRQ_HANDLED;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +irqreturn_t omapl_rx_can_intr(int irq, void *dev_id)
</I>&gt;<i> +{
</I>&gt;<i> +
</I>&gt;<i> +	struct net_device *ndev = dev_id;
</I>&gt;<i> +	struct omapl_pru_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	u32 intc_status = 0;
</I>&gt;<i> +
</I>&gt;<i> +	intc_status = pru_can_get_intc_status(priv-&gt;dev);
</I>&gt;<i> +	if (intc_status &amp; 4)
</I>&gt;<i> +		return omapl_tx_can_intr(irq, dev_id);
</I>&gt;<i> +	if (intc_status &amp; 2) {
</I>&gt;<i> +		if (!work_pending(&amp;priv-&gt;rx_work))
</I>&gt;<i> +			queue_work(priv-&gt;pru_can_wQ, &amp;priv-&gt;rx_work);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return IRQ_HANDLED;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int omapl_pru_can_open(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct omapl_pru_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	int err;
</I>&gt;<i> +
</I>&gt;<i> +	/* register interrupt handler */
</I>&gt;<i> +	err = request_irq(priv-&gt;trx_irq, &amp;omapl_rx_can_intr, IRQF_SHARED,
</I>&gt;<i> +			  &quot;pru_can_irq&quot;, ndev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(priv-&gt;dev, &quot;error requesting rx interrupt\n&quot;);
</I>&gt;<i> +		goto exit_trx_irq;
</I>&gt;<i> +	}
</I>&gt;<i> +	/* common open */
</I>&gt;<i> +	err = open_candev(ndev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(priv-&gt;dev, &quot;open_candev() failed %d\n&quot;, err);
</I>&gt;<i> +		goto exit_open;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	pru_can_emu_init(priv-&gt;dev, priv-&gt;can.clock.freq);
</I>&gt;<i> +	priv-&gt;tx_tail = MB_MIN;
</I>&gt;<i> +	priv-&gt;tx_head = MB_MAX;
</I>&gt;<i> +
</I>&gt;<i> +	pru_can_rx_id_map(priv-&gt;dev, CONFIG_DA8XX_PRU_CANID_MBX0, 0);
</I>&gt;<i> +	pru_can_rx_id_map(priv-&gt;dev, CONFIG_DA8XX_PRU_CANID_MBX1, 1);
</I>&gt;<i> +	pru_can_rx_id_map(priv-&gt;dev, CONFIG_DA8XX_PRU_CANID_MBX2, 2);
</I>&gt;<i> +	pru_can_rx_id_map(priv-&gt;dev, CONFIG_DA8XX_PRU_CANID_MBX3, 3);
</I>&gt;<i> +	pru_can_rx_id_map(priv-&gt;dev, CONFIG_DA8XX_PRU_CANID_MBX4, 4);
</I>&gt;<i> +	pru_can_rx_id_map(priv-&gt;dev, CONFIG_DA8XX_PRU_CANID_MBX5, 5);
</I>&gt;<i> +	pru_can_rx_id_map(priv-&gt;dev, CONFIG_DA8XX_PRU_CANID_MBX6, 6);
</I>&gt;<i> +	pru_can_rx_id_map(priv-&gt;dev, CONFIG_DA8XX_PRU_CANID_MBX7, 7);
</I>&gt;<i> +
</I>&gt;<i> +	omapl_pru_can_start(ndev);
</I>&gt;<i> +	netif_start_queue(ndev);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +exit_open:
</I>&gt;<i> +	free_irq(priv-&gt;trx_irq, ndev);
</I>&gt;<i> +exit_trx_irq:
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int omapl_pru_can_close(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct omapl_pru_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	if (!netif_queue_stopped(ndev))
</I>&gt;<i> +		netif_stop_queue(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	close_candev(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	free_irq(priv-&gt;trx_irq, ndev);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static const struct net_device_ops omapl_pru_can_netdev_ops = {
</I>&gt;<i> +	.ndo_open		= omapl_pru_can_open,
</I>&gt;<i> +	.ndo_stop		= omapl_pru_can_close,
</I>&gt;<i> +	.ndo_start_xmit		= omapl_pru_can_start_xmit,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int __devinit omapl_pru_can_probe(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = NULL;
</I>&gt;<i> +	const struct da8xx_pru_can_data *pdata;
</I>&gt;<i> +	struct omapl_pru_can_priv *priv = NULL;
</I>&gt;<i> +	struct device *dev = &amp;pdev-&gt;dev;
</I>&gt;<i> +	u32 err;
</I>&gt;<i> +
</I>&gt;<i> +	pdata = dev-&gt;platform_data;
</I>&gt;<i> +	if (!pdata) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;platform data not found\n&quot;);
</I>&gt;<i> +		return -EINVAL;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	ndev = alloc_candev(sizeof(struct omapl_pru_can_priv), MB_MAX + 1);
</I>&gt;<i> +	if (!ndev) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;alloc_candev failed\n&quot;);
</I>&gt;<i> +		err = -ENOMEM;
</I>&gt;<i> +		goto probe_exit;
</I>&gt;<i> +	}
</I>&gt;<i> +	priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;trx_irq = platform_get_irq(to_platform_device(dev-&gt;parent), 0);
</I>&gt;<i> +	if (!priv-&gt;trx_irq) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;unable to get pru interrupt resources!\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_exit;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;ndev = ndev;
</I>&gt;<i> +	priv-&gt;dev = dev; /* priv-&gt;dev = pdev-&gt;dev */
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.bittiming_const = NULL;
</I>&gt;<i> +	priv-&gt;can.do_set_bittiming = omapl_pru_can_set_bittiming;
</I>&gt;<i> +	priv-&gt;can.do_set_mode = omapl_pru_can_set_mode;
</I>&gt;<i> +	priv-&gt;can.do_get_state = omapl_pru_can_get_state;
</I>&gt;<i> +	priv-&gt;can_tx_hndl.u8prunumber = CAN_TX_PRU_1;
</I>&gt;<i> +	priv-&gt;can_rx_hndl.u8prunumber = CAN_RX_PRU_0;
</I>&gt;<i> +
</I>&gt;<i> +	/* we support local echo, no arp */
</I>&gt;<i> +	ndev-&gt;flags |= (IFF_ECHO | IFF_NOARP);
</I>&gt;<i> +
</I>&gt;<i> +	/* pdev-&gt;dev-&gt;device_private-&gt;driver_data = ndev */
</I>&gt;<i> +	platform_set_drvdata(pdev, ndev);
</I>&gt;<i> +	SET_NETDEV_DEV(ndev, &amp;pdev-&gt;dev);
</I>&gt;<i> +	ndev-&gt;netdev_ops = &amp;omapl_pru_can_netdev_ops;
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.clock.freq = pruss_get_clk_freq(priv-&gt;dev);
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;clk_timer = clk_get(&amp;pdev-&gt;dev, &quot;pll1_sysclk2&quot;);
</I>&gt;<i> +	if (IS_ERR(priv-&gt;clk_timer)) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;no timer clock available\n&quot;);
</I>&gt;<i> +		err = PTR_ERR(priv-&gt;clk_timer);
</I>&gt;<i> +		priv-&gt;clk_timer = NULL;
</I>&gt;<i> +		goto probe_exit_candev;
</I>&gt;<i> +	}
</I>&gt;<i> +	priv-&gt;timer_freq = clk_get_rate(priv-&gt;clk_timer);
</I>&gt;<i> +
</I>&gt;<i> +	err = register_candev(ndev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;register_candev() failed\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_exit_clk;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	err = request_firmware(&amp;priv-&gt;fw_tx, &quot;PRU_CAN_Emulation_Tx.bin&quot;,
</I>&gt;<i> +			&amp;pdev-&gt;dev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;can't load firmware\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_exit_clk;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	dev_info(&amp;pdev-&gt;dev, &quot;fw_tx size %d. downloading...\n&quot;,
</I>&gt;<i> +		 priv-&gt;fw_tx-&gt;size);
</I>&gt;<i> +
</I>&gt;<i> +	err = request_firmware(&amp;priv-&gt;fw_rx, &quot;PRU_CAN_Emulation_Rx.bin&quot;,
</I>&gt;<i> +			&amp;pdev-&gt;dev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;can't load firmware\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_release_fw;
</I>&gt;<i> +	}
</I>&gt;<i> +	dev_info(&amp;pdev-&gt;dev, &quot;fw_rx size %d. downloading...\n&quot;,
</I>&gt;<i> +		 priv-&gt;fw_rx-&gt;size);
</I>&gt;<i> +
</I>&gt;<i> +	/* init the pru */
</I>&gt;<i> +	pru_can_emu_init(priv-&gt;dev, priv-&gt;can.clock.freq);
</I>&gt;<i> +	udelay(200);
</I>&gt;<i> +
</I>&gt;<i> +	pruss_enable(priv-&gt;dev, CAN_RX_PRU_0);
</I>&gt;<i> +	pruss_enable(priv-&gt;dev, CAN_TX_PRU_1);
</I>&gt;<i> +
</I>&gt;<i> +	/* download firmware into pru */
</I>&gt;<i> +	err = pruss_load(priv-&gt;dev, CAN_RX_PRU_0,
</I>&gt;<i> +		(u32 *)priv-&gt;fw_rx-&gt;data, (priv-&gt;fw_rx-&gt;size / 4));
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;firmware download error\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_release_fw_1;
</I>&gt;<i> +	}
</I>&gt;<i> +	err = pruss_load(priv-&gt;dev, CAN_TX_PRU_1,
</I>&gt;<i> +		(u32 *)priv-&gt;fw_tx-&gt;data, (priv-&gt;fw_tx-&gt;size / 4));
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;firmware download error\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_release_fw_1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (pru_can_calc_timing(priv-&gt;dev, DFLT_PRU_FREQ,
</I>&gt;<i> +				DFLT_PRU_BITRATE) != 0)
</I>&gt;<i> +		return -EINVAL;
</I>&gt;<i> +
</I>&gt;<i> +	pruss_run(priv-&gt;dev, CAN_RX_PRU_0);
</I>&gt;<i> +	pruss_run(priv-&gt;dev, CAN_TX_PRU_1);
</I>&gt;<i> +
</I>&gt;<i> +	/*Create The Work Queue */
</I>&gt;<i> +	priv-&gt;pru_can_wQ = create_freezeable_workqueue(&quot;omapl_pru_wQ&quot;);
</I>&gt;<i> +	if (priv-&gt;pru_can_wQ == NULL) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;failed to create work queue\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_release_fw_1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	INIT_WORK(&amp;priv-&gt;rx_work, omapl_pru_can_rx_wQ);
</I>&gt;<i> +	dev_info(&amp;pdev-&gt;dev,
</I>&gt;<i> +		 &quot;%s device registered (trx_irq = %d,  clk = %d)\n&quot;,
</I>&gt;<i> +		 DRV_NAME, priv-&gt;trx_irq, priv-&gt;can.clock.freq);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +probe_release_fw_1:
</I>&gt;<i> +	release_firmware(priv-&gt;fw_rx);
</I>&gt;<i> +probe_release_fw:
</I>&gt;<i> +	release_firmware(priv-&gt;fw_tx);
</I>&gt;<i> +probe_exit_clk:
</I>&gt;<i> +	clk_put(priv-&gt;clk_timer);
</I>&gt;<i> +probe_exit_candev:
</I>&gt;<i> +	if (NULL != ndev)
</I>&gt;<i> +		free_candev(ndev);
</I>&gt;<i> +probe_exit:
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int __devexit omapl_pru_can_remove(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = platform_get_drvdata(pdev);
</I>&gt;<i> +	struct omapl_pru_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	omapl_pru_can_stop(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	pru_can_emu_exit(priv-&gt;dev);
</I>&gt;<i> +	release_firmware(priv-&gt;fw_tx);
</I>&gt;<i> +	release_firmware(priv-&gt;fw_rx);
</I>&gt;<i> +	clk_put(priv-&gt;clk_timer);
</I>&gt;<i> +	flush_workqueue(priv-&gt;pru_can_wQ);
</I>&gt;<i> +	destroy_workqueue(priv-&gt;pru_can_wQ);
</I>&gt;<i> +	unregister_candev(ndev);
</I>&gt;<i> +	free_candev(ndev);
</I>&gt;<i> +	platform_set_drvdata(pdev, NULL);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_PM
</I>&gt;<i> +static int omapl_pru_can_suspend(struct platform_device *pdev,
</I>&gt;<i> +			pm_message_t mesg)
</I>&gt;<i> +{
</I>&gt;<i> +	dev_info(&amp;pdev-&gt;dev, &quot;%s not yet implemented\n&quot;, __func__);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int omapl_pru_can_resume(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	dev_info(&amp;pdev-&gt;dev, &quot;%s not yet implemented\n&quot;, __func__);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +#else
</I>&gt;<i> +#define omapl_pru_can_suspend NULL
</I>&gt;<i> +#define omapl_pru_can_resume NULL
</I>&gt;<i> +#endif /* CONFIG_PM */
</I>&gt;<i> +
</I>&gt;<i> +static struct platform_driver omapl_pru_can_driver = {
</I>&gt;<i> +	.probe		= omapl_pru_can_probe,
</I>&gt;<i> +	.remove		= __devexit_p(omapl_pru_can_remove),
</I>&gt;<i> +	.suspend	= omapl_pru_can_suspend,
</I>&gt;<i> +	.resume		= omapl_pru_can_resume,
</I>&gt;<i> +	.driver		= {
</I>&gt;<i> +		.name	= DRV_NAME,
</I>&gt;<i> +		.owner	= THIS_MODULE,
</I>&gt;<i> +	},
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int __init omapl_pru_can_init(void)
</I>&gt;<i> +{
</I>&gt;<i> +	__can_debug(KERN_INFO DRV_DESC &quot;\n&quot;);
</I>&gt;<i> +	return platform_driver_register(&amp;omapl_pru_can_driver);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +module_init(omapl_pru_can_init);
</I>&gt;<i> +
</I>&gt;<i> +static void __exit omapl_pru_can_exit(void)
</I>&gt;<i> +{
</I>&gt;<i> +	__can_debug(KERN_INFO DRV_DESC &quot; unloaded\n&quot;);
</I>&gt;<i> +	platform_driver_unregister(&amp;omapl_pru_can_driver);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +module_exit(omapl_pru_can_exit);
</I>&gt;<i> +
</I>&gt;<i> +MODULE_AUTHOR(&quot;Subhasish Ghosh &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">subhasish at mistralsolutions.com</A>&gt;&quot;);
</I>&gt;<i> +MODULE_LICENSE(&quot;GPL&quot;);
</I>&gt;<i> +MODULE_DESCRIPTION(&quot;omapl pru CAN netdevice driver&quot;);
</I>&gt;<i> diff --git a/drivers/net/can/da8xx_pruss/pruss_can_api.c b/drivers/net/can/da8xx_pruss/pruss_can_api.c
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..2f7438a
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/da8xx_pruss/pruss_can_api.c
</I>&gt;<i> @@ -0,0 +1,1227 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * Copyright (C) 2010 Texas Instruments Incorporated
</I>&gt;<i> + * Author: Wilfred Felix
</I>&gt;<i> + *
</I>&gt;<i> + * This program is free software; you can redistribute it and/or modify it
</I>&gt;<i> + * under the terms of the GNU General Public License as  published by the
</I>&gt;<i> + * Free Software Foundation version 2.
</I>&gt;<i> + *
</I>&gt;<i> + * This program is distributed &quot;as is&quot; WITHOUT ANY WARRANTY of any kind,
</I>&gt;<i> + * whether express or implied; without even the implied warranty of
</I>&gt;<i> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
</I>&gt;<i> + * General Public License for more details.
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#include &quot;pruss_can_api.h&quot;
</I>&gt;<i> +
</I>&gt;<i> +static can_emu_drv_inst gstr_can_inst[ecanmaxinst];
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_set_brp()	Updates the  BRP register of PRU0
</I>&gt;<i> + * and PRU1 of OMAP L138. This API will be called by the
</I>&gt;<i> + * Application to updtae the BRP register of PRU0 and PRU1
</I>&gt;<i> + *
</I>&gt;<i> + * param	u16bitrateprescaler		The can bus bitrate
</I>&gt;<i> + * prescaler value be set
</I>&gt;<i> + *
</I>&gt;<i> + * return   SUCCESS or FAILURE
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_set_brp(struct device *dev, u16 u16bitrateprescaler)
</I>&gt;<i> +{
</I>&gt;<i> +
</I>&gt;<i> +	u32 u32offset;
</I>&gt;<i> +
</I>&gt;<i> +	if (u16bitrateprescaler &gt; 255) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_CLOCK_BRP_REGISTER);
</I>&gt;<i> +	pruss_writel(dev, u32offset, (u32 *) &amp;u16bitrateprescaler, 1);
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_CLOCK_BRP_REGISTER);
</I>&gt;<i> +	pruss_writel(dev, u32offset, (u32 *) &amp;u16bitrateprescaler, 1);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_set_bit_timing()		Updates the timing register
</I>&gt;<i> + * of PRU0 and PRU1 of OMAP L138. This API will be called by
</I>&gt;<i> + * the Application to updtae the timing register of PRU0 and PRU1
</I>&gt;<i> + *
</I>&gt;<i> + * param	pstrbittiming		Pointer to structure holding
</I>&gt;<i> + * the bit timing values for can bus.
</I>&gt;<i> + *
</I>&gt;<i> + * return   SUCCESS or FAILURE
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_set_bit_timing(struct device *dev,
</I>&gt;<i> +		can_bit_timing_consts *pstrbittiming)
</I>&gt;<i> +{
</I>&gt;<i> +
</I>&gt;<i> +	u32 u32offset;
</I>&gt;<i> +	u32 u32serregister;
</I>&gt;<i> +
</I>&gt;<i> +	u32serregister = 0;
</I>&gt;<i> +
</I>&gt;<i> +	if (pstrbittiming == NULL) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if ((pstrbittiming-&gt;u8syncjumpwidth &gt; PRU_CAN_MAX_SJW) ||
</I>&gt;<i> +	    (pstrbittiming-&gt;u8phseg1 &gt; PRU_CAN_MAX_PHSEG1) ||
</I>&gt;<i> +	    (pstrbittiming-&gt;u8phseg2 &gt; PRU_CAN_MAX_PHSEG2)) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32serregister = u32serregister |
</I>&gt;<i> +			((pstrbittiming-&gt;u8syncjumpwidth &lt;&lt; 7) |
</I>&gt;<i> +			(pstrbittiming-&gt;u8phseg1 &lt;&lt; 3) |
</I>&gt;<i> +			(pstrbittiming-&gt;u8phseg2));
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_TIMING_REGISTER);
</I>&gt;<i> +	pruss_writel(dev, u32offset, (u32 *) &amp;u32serregister, 1);
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_TIMING_REGISTER);
</I>&gt;<i> +	pruss_writel(dev, u32offset, (u32 *) &amp;u32serregister, 1);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_calc_timing()
</I>&gt;<i> + * Updates the  timing values of PRU0 and PRU1 of OMAP L138.
</I>&gt;<i> + * This API will be called by the
</I>&gt;<i> + * Application to updtae the timing values of PRU0 and PRU1
</I>&gt;<i> + *
</I>&gt;<i> + * return   SUCCESS or FAILURE
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +s16 pru_can_calc_timing(struct device *dev, u32 pru_freq, u32 bit_rate)
</I>&gt;<i> +{
</I>&gt;<i> +	u16 u16phaseseg1;
</I>&gt;<i> +	u16 u16phaseseg2;
</I>&gt;<i> +	u32 u32offset;
</I>&gt;<i> +	u32 u32timing_value;
</I>&gt;<i> +	u32 u32setup_value;
</I>&gt;<i> +	u32timing_value = TIMER_CLK_FREQ / bit_rate;
</I>&gt;<i> +	u32offset = (PRU_CAN_TIMING_VAL_TX);
</I>&gt;<i> +	pruss_writel(dev, u32offset, (u32 *) &amp;u32timing_value, 4);
</I>&gt;<i> +	pruss_readl(dev, u32offset, (u32 *) &amp;u32timing_value, 4);
</I>&gt;<i> +	u32setup_value =
</I>&gt;<i> +	    (GPIO_SETUP_DELAY * (pru_freq / 1000000) / 1000) /
</I>&gt;<i> +	    DELAY_LOOP_LENGTH;
</I>&gt;<i> +	u32offset = (PRU_CAN_TIMING_VAL_TX_SJW);
</I>&gt;<i> +	pruss_writel(dev, u32offset, (u32 *) &amp;u32setup_value, 4);
</I>&gt;<i> +	u16phaseseg1 = (u16) (u32timing_value / 2);
</I>&gt;<i> +	u16phaseseg2 = u32timing_value - u16phaseseg1;
</I>&gt;<i> +	u16phaseseg1 -= TIMER_SETUP_DELAY;
</I>&gt;<i> +	u16phaseseg2 -= TIMER_SETUP_DELAY;
</I>&gt;<i> +	u32setup_value = (u16phaseseg1 &lt;&lt; 16) | u16phaseseg2;
</I>&gt;<i> +	u32offset = (PRU_CAN_TIMING_VAL_RX);
</I>&gt;<i> +	pruss_writel(dev, u32offset, (u32 *) &amp;u32setup_value, 4);
</I>&gt;<i> +	u32offset = (PRU_CAN_TIMING_VAL_RX + 4);
</I>&gt;<i> +	pruss_writel(dev, u32offset, (u32 *) &amp;u32timing_value, 4);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_write_data_to_mailbox()
</I>&gt;<i> + * Updates the transmit mailboxes of PRU1 of OMAP L138.
</I>&gt;<i> + * This API will be called by the Application to update
</I>&gt;<i> + * the transmit mailboxes of PRU1
</I>&gt;<i> + *
</I>&gt;<i> + * param  pu16canframedata	Can mailbox data buffer
</I>&gt;<i> + *
</I>&gt;<i> + * param  u8mailboxnum		Mailbox to be updated
</I>&gt;<i> + *
</I>&gt;<i> + * return SUCCESS or FAILURE
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_write_data_to_mailbox(struct device *dev,
</I>&gt;<i> +			can_emu_app_hndl *pstremuapphndl)
</I>&gt;<i> +{
</I>&gt;<i> +	s16 s16subrtnretval;
</I>&gt;<i> +	u32 u32offset;
</I>&gt;<i> +
</I>&gt;<i> +	if (pstremuapphndl == NULL) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	switch ((u8) pstremuapphndl-&gt;ecanmailboxnumber) {
</I>&gt;<i> +	case 0:
</I>&gt;<i> +		u32offset = (PRU_CAN_TX_MAILBOX0);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case 1:
</I>&gt;<i> +		u32offset = (PRU_CAN_TX_MAILBOX1);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case 2:
</I>&gt;<i> +		u32offset = (PRU_CAN_TX_MAILBOX2);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case 3:
</I>&gt;<i> +		u32offset = (PRU_CAN_TX_MAILBOX3);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case 4:
</I>&gt;<i> +		u32offset = (PRU_CAN_TX_MAILBOX4);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case 5:
</I>&gt;<i> +		u32offset = (PRU_CAN_TX_MAILBOX5);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case 6:
</I>&gt;<i> +		u32offset = (PRU_CAN_TX_MAILBOX6);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case 7:
</I>&gt;<i> +		u32offset = (PRU_CAN_TX_MAILBOX7);
</I>&gt;<i> +		break;
</I>&gt;<i> +	default:
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +		(u32 *) &amp;(pstremuapphndl-&gt;strcanmailbox), 4);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_get_data_from_mailbox()
</I>&gt;<i> + * Receive data from the receive mailboxes of PRU0  of OMAP L138.
</I>&gt;<i> + * This API will be called by the Application to get data from
</I>&gt;<i> + * the receive mailboxes of PRU0
</I>&gt;<i> + *
</I>&gt;<i> + * param  pu16canframedata	Can mailbox data buffer
</I>&gt;<i> + *
</I>&gt;<i> + * param  u8mailboxnum		Mailbox to be updated
</I>&gt;<i> + *
</I>&gt;<i> + * return SUCCESS or FAILURE
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_get_data_from_mailbox(struct device *dev,
</I>&gt;<i> +		can_emu_app_hndl *pstremuapphndl)
</I>&gt;<i> +{
</I>&gt;<i> +	s16 s16subrtnretval;
</I>&gt;<i> +	u32 u32offset;
</I>&gt;<i> +
</I>&gt;<i> +	if (pstremuapphndl == NULL) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	switch ((u8) pstremuapphndl-&gt;ecanmailboxnumber) {
</I>&gt;<i> +	case 0:
</I>&gt;<i> +		u32offset = (PRU_CAN_RX_MAILBOX0);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case 1:
</I>&gt;<i> +		u32offset = (PRU_CAN_RX_MAILBOX1);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case 2:
</I>&gt;<i> +		u32offset = (PRU_CAN_RX_MAILBOX2);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case 3:
</I>&gt;<i> +		u32offset = (PRU_CAN_RX_MAILBOX3);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case 4:
</I>&gt;<i> +		u32offset = (PRU_CAN_RX_MAILBOX4);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case 5:
</I>&gt;<i> +		u32offset = (PRU_CAN_RX_MAILBOX5);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case 6:
</I>&gt;<i> +		u32offset = (PRU_CAN_RX_MAILBOX6);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case 7:
</I>&gt;<i> +		u32offset = (PRU_CAN_RX_MAILBOX7);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case 8:
</I>&gt;<i> +		u32offset = (PRU_CAN_RX_MAILBOX8);
</I>&gt;<i> +		break;
</I>&gt;<i> +	default:
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	s16subrtnretval =
</I>&gt;<i> +	    pruss_readl(dev, u32offset,
</I>&gt;<i> +		  (u32 *) &amp;(pstremuapphndl-&gt;strcanmailbox),
</I>&gt;<i> +				  4);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_receive_id_map()
</I>&gt;<i> + * Receive mailboxes ID Mapping of PRU0  of OMAP L138.
</I>&gt;<i> + * This API will be called by the Application
</I>&gt;<i> + * to map the IDs  to receive mailboxes of PRU0
</I>&gt;<i> + *
</I>&gt;<i> + * param  u32nodeid		Can node ID
</I>&gt;<i> + *
</I>&gt;<i> + * param  ecanmailboxno		Mailbox to be mapped
</I>&gt;<i> + *
</I>&gt;<i> + * return   SUCCESS or FAILURE
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_rx_id_map(struct device *dev, u32 u32nodeid,
</I>&gt;<i> +		can_mailbox_number ecanmailboxno)
</I>&gt;<i> +{
</I>&gt;<i> +
</I>&gt;<i> +	pruss_writel(dev, (PRU_CAN_ID_MAP +
</I>&gt;<i> +		(((u8) ecanmailboxno) * 4)), (u32 *) &amp;u32nodeid, 1);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_get_intr_status()
</I>&gt;<i> + * Gets the interrupts status register value.
</I>&gt;<i> + * This API will be called by the Application
</I>&gt;<i> + * to get the interrupts status register value
</I>&gt;<i> + *
</I>&gt;<i> + * param  u8prunumber	PRU number for which IntStatusReg
</I>&gt;<i> + * has to be read
</I>&gt;<i> + *
</I>&gt;<i> + * return   SUCCESS or FAILURE
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_get_intr_status(struct device *dev,
</I>&gt;<i> +		can_emu_app_hndl *pstremuapphndl)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 u32offset;
</I>&gt;<i> +	s16 s16subrtnretval = -1;
</I>&gt;<i> +
</I>&gt;<i> +	if (pstremuapphndl == NULL) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (pstremuapphndl-&gt;u8prunumber == DA8XX_PRUCORE_1) {
</I>&gt;<i> +		u32offset = (PRU_CAN_TX_INTERRUPT_STATUS_REGISTER);
</I>&gt;<i> +	} else if (pstremuapphndl-&gt;u8prunumber == DA8XX_PRUCORE_0) {
</I>&gt;<i> +		u32offset = (PRU_CAN_RX_INTERRUPT_STATUS_REGISTER);
</I>&gt;<i> +	} else {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	s16subrtnretval = pruss_readl(dev, u32offset,
</I>&gt;<i> +		(u32 *) &amp;pstremuapphndl-&gt;u32interruptstatus, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_get_global_status()	Gets the globalstatus
</I>&gt;<i> + * register value. This API will be called by the Application
</I>&gt;<i> + * to  get the global status register value
</I>&gt;<i> + *
</I>&gt;<i> + * return   SUCCESS or FAILURE
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_get_global_status(struct device *dev,
</I>&gt;<i> +		can_emu_app_hndl *pstremuapphndl)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 u32offset;
</I>&gt;<i> +	int s16subrtnretval = -1;
</I>&gt;<i> +
</I>&gt;<i> +	if (pstremuapphndl == NULL) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (pstremuapphndl-&gt;u8prunumber == DA8XX_PRUCORE_1) {
</I>&gt;<i> +		u32offset = (PRU_CAN_TX_GLOBAL_STATUS_REGISTER);
</I>&gt;<i> +	} else if (pstremuapphndl-&gt;u8prunumber == DA8XX_PRUCORE_0) {
</I>&gt;<i> +		u32offset = (PRU_CAN_RX_GLOBAL_STATUS_REGISTER);
</I>&gt;<i> +	} else {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	s16subrtnretval = pruss_readl(dev, u32offset,
</I>&gt;<i> +		(u32 *) &amp;pstremuapphndl-&gt;u32globalstatus, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_get_mailbox_status()		Gets the mailbox status
</I>&gt;<i> + * register value. This API will be called by the Application
</I>&gt;<i> + * to get the mailbox status register value
</I>&gt;<i> + *
</I>&gt;<i> + * return   SUCCESS or FAILURE
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_get_mailbox_status(struct device *dev,
</I>&gt;<i> +		can_emu_app_hndl *pstremuapphndl)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 u32offset;
</I>&gt;<i> +	s16 s16subrtnretval = -1;
</I>&gt;<i> +
</I>&gt;<i> +	if (pstremuapphndl == NULL) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (pstremuapphndl-&gt;u8prunumber == DA8XX_PRUCORE_1) {
</I>&gt;<i> +		switch (pstremuapphndl-&gt;ecanmailboxnumber) {
</I>&gt;<i> +		case 0:
</I>&gt;<i> +			u32offset = (PRU_CAN_TX_MAILBOX0_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 1:
</I>&gt;<i> +			u32offset = (PRU_CAN_TX_MAILBOX1_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 2:
</I>&gt;<i> +			u32offset = (PRU_CAN_TX_MAILBOX2_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 3:
</I>&gt;<i> +			u32offset = (PRU_CAN_TX_MAILBOX3_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 4:
</I>&gt;<i> +			u32offset = (PRU_CAN_TX_MAILBOX4_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 5:
</I>&gt;<i> +			u32offset = (PRU_CAN_TX_MAILBOX5_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 6:
</I>&gt;<i> +			u32offset = (PRU_CAN_TX_MAILBOX6_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 7:
</I>&gt;<i> +			u32offset = (PRU_CAN_TX_MAILBOX7_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		default:
</I>&gt;<i> +			return -1;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	else if (pstremuapphndl-&gt;u8prunumber == DA8XX_PRUCORE_0) {
</I>&gt;<i> +		switch (pstremuapphndl-&gt;ecanmailboxnumber) {
</I>&gt;<i> +		case 0:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX0_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 1:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX1_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 2:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX2_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 3:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX3_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 4:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX4_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 5:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX5_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 6:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX6_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 7:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX7_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 8:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX8_STATUS_REGISTER);
</I>&gt;<i> +			break;
</I>&gt;<i> +		default:
</I>&gt;<i> +			return -1;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	else {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	s16subrtnretval = pruss_readl(dev, u32offset,
</I>&gt;<i> +		(u32 *) &amp;pstremuapphndl-&gt;u32mailboxstatus, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +s16 pru_can_tx_mode_set(struct device *dev, bool btransfer_flag,
</I>&gt;<i> +				can_transfer_direction ecan_trx)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 u32offset;
</I>&gt;<i> +	u32 u32value;
</I>&gt;<i> +
</I>&gt;<i> +	if (ecan_trx == ecantransmit) {
</I>&gt;<i> +		u32offset = (PRU_CAN_RX_GLOBAL_STATUS_REGISTER);
</I>&gt;<i> +		pruss_readl(dev, u32offset, &amp;u32value, 1);
</I>&gt;<i> +		if (btransfer_flag == true) {
</I>&gt;<i> +			u32value &amp;= 0x1F;
</I>&gt;<i> +			u32value |= 0x80;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			u32value &amp;= 0x7F;
</I>&gt;<i> +		}
</I>&gt;<i> +		pruss_writel(dev, u32offset, &amp;u32value, 1);
</I>&gt;<i> +		u32offset = (PRU_CAN_TX_GLOBAL_STATUS_REGISTER);
</I>&gt;<i> +		pruss_writel(dev, u32offset, &amp;u32value, 1);
</I>&gt;<i> +	} else if (ecan_trx == ecanreceive) {
</I>&gt;<i> +		u32offset = (PRU_CAN_RX_GLOBAL_STATUS_REGISTER);
</I>&gt;<i> +		pruss_readl(dev, u32offset, &amp;u32value, 1);
</I>&gt;<i> +		if (btransfer_flag == true) {
</I>&gt;<i> +			u32value &amp;= 0x1F;
</I>&gt;<i> +			u32value |= 0x40;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			u32value &amp;= 0xBF;
</I>&gt;<i> +		}
</I>&gt;<i> +		pruss_writel(dev, u32offset, &amp;u32value, 1);
</I>&gt;<i> +		u32offset = (PRU_CAN_TX_GLOBAL_STATUS_REGISTER);
</I>&gt;<i> +		pruss_writel(dev, u32offset, &amp;u32value, 1);
</I>&gt;<i> +	} else
</I>&gt;<i> +		return -1;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_config_mode_set()		Sets the timing value
</I>&gt;<i> + * for data transfer. This API will be called by the Application
</I>&gt;<i> + * to set timing valus for data transfer
</I>&gt;<i> + *
</I>&gt;<i> + * return   SUCCESS or FAILURE
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_config_mode_set(struct device *dev, bool bconfigmodeflag)
</I>&gt;<i> +{
</I>&gt;<i> +
</I>&gt;<i> +	u32 u32bitrateprescaler;
</I>&gt;<i> +	u32 u32canbittiming;
</I>&gt;<i> +
</I>&gt;<i> +	pruss_readl(dev, (PRU_CAN_TX_CLOCK_BRP_REGISTER),
</I>&gt;<i> +			(u32 *) &amp;u32bitrateprescaler, 1);
</I>&gt;<i> +	pruss_readl(dev, (PRU_CAN_TX_TIMING_REGISTER),
</I>&gt;<i> +			(u32 *) &amp;u32canbittiming, 1);
</I>&gt;<i> +
</I>&gt;<i> +	if (bconfigmodeflag == 1) {
</I>&gt;<i> +		pru_can_calc_timing(dev, u32canbittiming, u32bitrateprescaler);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	else {
</I>&gt;<i> +		pru_can_calc_timing(dev, 0, 0);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_emu_init()		Initializes the Can
</I>&gt;<i> + * Emulation Parameters. This API will be called by the Application
</I>&gt;<i> + * to Initialize the Can Emulation Parameters
</I>&gt;<i> + *
</I>&gt;<i> + * param    u32pruclock         PRU Clock value
</I>&gt;<i> + *
</I>&gt;<i> + * return   SUCCESS or FAILURE
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_emu_init(struct device *dev, u32 u32pruclock)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 u32offset;
</I>&gt;<i> +	u32 u32value;
</I>&gt;<i> +	s16 s16subrtnretval = -1;
</I>&gt;<i> +	u8 u8loop;
</I>&gt;<i> +
</I>&gt;<i> +	for (u8loop = 0; u8loop &lt; (u8) ecanmaxinst; u8loop++) {
</I>&gt;<i> +		gstr_can_inst[u8loop].bcaninststate = (bool) 0;
</I>&gt;<i> +		gstr_can_inst[u8loop].ecantransferdirection =
</I>&gt;<i> +		    (can_transfer_direction) 0;
</I>&gt;<i> +		gstr_can_inst[u8loop].u32apphandlerptr = 0;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_GLOBAL_CONTROL_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_GLOBAL_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000040;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_GLOBAL_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000040;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_INTERRUPT_MASK_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00004000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_INTERRUPT_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_MAILBOX0_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000001;
</I>&gt;<i> +	s16subrtnretval =
</I>&gt;<i> +	    pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_MAILBOX1_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000001;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_MAILBOX2_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000001;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_MAILBOX3_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000001;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_MAILBOX4_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000001;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_MAILBOX5_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000001;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_MAILBOX6_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000001;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_MAILBOX7_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000001;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_ERROR_COUNTER_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_TIMING_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_CLOCK_BRP_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_TX_ERROR_COUNTER_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_POLARITY0 &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0xFFFFFFFF;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +	u32offset = (PRUSS_INTC_POLARITY1 &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0xFFFFFFFF;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +	u32offset = (PRUSS_INTC_TYPE0 &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x1C000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +	u32offset = (PRUSS_INTC_TYPE1 &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_HSTINTENIDXCLR &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x0;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_GLBLEN &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x1;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +	/* tx intr map arm-&gt;pru */
</I>&gt;<i> +	u32offset = (PRUSS_INTC_HSTINTENIDXSET &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x0;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_HOSTMAP0 &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x03020100;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_HOSTMAP1 &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x07060504;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_HOSTMAP2 &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x0000908;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_CHANMAP0 &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_CHANMAP8 &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00020200;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_STATIDXCLR &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 32;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_STATIDXCLR &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 19;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_ENIDXSET &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 19;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +	u32offset = (PRUSS_INTC_STATIDXCLR &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 18;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_ENIDXSET &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 18;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_STATIDXCLR &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 34;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_ENIDXSET &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 34;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_ENIDXSET &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 32;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_HOSTINTEN &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x5;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +/* PRU0 - Rx Internal Registers Initializations */
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_GLOBAL_CONTROL_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_GLOBAL_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000040;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_INTERRUPT_MASK_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00004000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_INTERRUPT_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_MAILBOX0_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_MAILBOX1_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x0000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_MAILBOX2_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_MAILBOX3_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_MAILBOX4_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_MAILBOX5_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_MAILBOX6_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_MAILBOX7_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_ERROR_COUNTER_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_TIMING_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x0000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRU_CAN_RX_CLOCK_BRP_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 0x00000000;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset, (u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_emu_open()		Opens the can emu for
</I>&gt;<i> + * application to use. This API will be called by the Application
</I>&gt;<i> + * to Open the can emu for application to use.
</I>&gt;<i> + *
</I>&gt;<i> + * param	pstremuapphndl	Pointer to application handler
</I>&gt;<i> + * structure
</I>&gt;<i> + *
</I>&gt;<i> + * return   SUCCESS or FAILURE
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_emu_open(struct device *dev, can_emu_app_hndl *pstremuapphndl)
</I>&gt;<i> +{
</I>&gt;<i> +
</I>&gt;<i> +	if (pstremuapphndl == NULL) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (gstr_can_inst[pstremuapphndl-&gt;ecaninstance].bcaninststate == 1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	gstr_can_inst[(u8) pstremuapphndl-&gt;ecaninstance].
</I>&gt;<i> +					bcaninststate = (bool)1;
</I>&gt;<i> +	gstr_can_inst[(u8) pstremuapphndl-&gt;
</I>&gt;<i> +		ecaninstance].ecantransferdirection =
</I>&gt;<i> +		(can_transfer_direction)(u8)pstremuapphndl-&gt;ecantransferdirection;
</I>&gt;<i> +	gstr_can_inst[(u8) pstremuapphndl-&gt;ecaninstance].
</I>&gt;<i> +		u32apphandlerptr = (u32) pstremuapphndl;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * brief    pru_can_emu_close()	Closes the can emu for other
</I>&gt;<i> + * applications to use. This API will be called by the Application to Close
</I>&gt;<i> + * the can emu for other applications to use
</I>&gt;<i> + *
</I>&gt;<i> + * param	pstremuapphndl	Pointer to application handler structure
</I>&gt;<i> + *
</I>&gt;<i> + * return   SUCCESS or FAILURE
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_emu_close(struct device *dev, can_emu_app_hndl *pstremuapphndl)
</I>&gt;<i> +{
</I>&gt;<i> +
</I>&gt;<i> +	if (pstremuapphndl == NULL) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (gstr_can_inst[pstremuapphndl-&gt;ecaninstance].bcaninststate == 0) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +	if ((u32) pstremuapphndl != gstr_can_inst[(u8) pstremuapphndl-&gt;
</I>&gt;<i> +			ecaninstance].u32apphandlerptr){
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +	gstr_can_inst[(u8) pstremuapphndl-&gt;ecaninstance].bcaninststate
</I>&gt;<i> +		= (bool) 0;
</I>&gt;<i> +	gstr_can_inst[(u8) pstremuapphndl-&gt;
</I>&gt;<i> +	ecaninstance].ecantransferdirection = (can_transfer_direction) 0;
</I>&gt;<i> +	gstr_can_inst[(u8) pstremuapphndl-&gt;ecaninstance].u32apphandlerptr = 0;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * brief    pru_can_emu_exit()	Diables all the PRUs
</I>&gt;<i> + * This API will be called by the Application to disable all PRUs
</I>&gt;<i> + * param	None
</I>&gt;<i> + * return   SUCCESS or FAILURE
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_emu_exit(struct device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	s16 s16subrtnretval;
</I>&gt;<i> +
</I>&gt;<i> +	s16subrtnretval = pruss_disable(dev, CAN_RX_PRU_0);
</I>&gt;<i> +	if (s16subrtnretval == -1)
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	s16subrtnretval = pruss_disable(dev, CAN_TX_PRU_1);
</I>&gt;<i> +	if (s16subrtnretval == -1)
</I>&gt;<i> +		return -1;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +s16 pru_can_emu_sreset(struct device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +s16 pru_can_tx(struct device *dev, u8 u8mailboxnumber, u8 u8prunumber)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 u32offset = 0;
</I>&gt;<i> +	u32 u32value = 0;
</I>&gt;<i> +	s16 s16subrtnretval = -1;
</I>&gt;<i> +
</I>&gt;<i> +	if (DA8XX_PRUCORE_1 == u8prunumber) {
</I>&gt;<i> +		switch (u8mailboxnumber) {
</I>&gt;<i> +		case 0:
</I>&gt;<i> +			u32offset = (PRU_CAN_TX_MAILBOX0_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +			u32value = 0x00000080;
</I>&gt;<i> +			s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +					(u32 *) &amp;u32value, 1);
</I>&gt;<i> +			if (s16subrtnretval == -1) {
</I>&gt;<i> +				return -1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 1:
</I>&gt;<i> +			u32offset = (PRU_CAN_TX_MAILBOX1_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +			u32value = 0x00000080;
</I>&gt;<i> +			s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +						(u32 *) &amp;u32value, 1);
</I>&gt;<i> +			if (s16subrtnretval == -1) {
</I>&gt;<i> +				return -1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 2:
</I>&gt;<i> +			u32offset = (PRU_CAN_TX_MAILBOX2_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +			u32value = 0x00000080;
</I>&gt;<i> +			s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +						(u32 *) &amp;u32value, 1);
</I>&gt;<i> +			if (s16subrtnretval == -1) {
</I>&gt;<i> +				return -1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 3:
</I>&gt;<i> +			u32offset = (PRU_CAN_TX_MAILBOX3_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +			u32value = 0x00000080;
</I>&gt;<i> +			s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +						(u32 *) &amp;u32value, 1);
</I>&gt;<i> +			if (s16subrtnretval == -1) {
</I>&gt;<i> +				return -1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 4:
</I>&gt;<i> +			u32offset = (PRU_CAN_TX_MAILBOX4_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +			u32value = 0x00000080;
</I>&gt;<i> +			s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +						(u32 *) &amp;u32value, 1);
</I>&gt;<i> +			if (s16subrtnretval == -1) {
</I>&gt;<i> +				return -1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 5:
</I>&gt;<i> +			u32offset = (PRU_CAN_TX_MAILBOX5_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +			u32value = 0x00000080;
</I>&gt;<i> +			s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +						(u32 *) &amp;u32value, 1);
</I>&gt;<i> +			if (s16subrtnretval == -1) {
</I>&gt;<i> +				return -1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 6:
</I>&gt;<i> +			u32offset = (PRU_CAN_TX_MAILBOX6_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +			u32value = 0x00000080;
</I>&gt;<i> +			s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +						(u32 *) &amp;u32value, 1);
</I>&gt;<i> +			if (s16subrtnretval == -1) {
</I>&gt;<i> +				return -1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 7:
</I>&gt;<i> +			u32offset = (PRU_CAN_TX_MAILBOX7_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +			u32value = 0x00000080;
</I>&gt;<i> +			s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +						(u32 *) &amp;u32value, 1);
</I>&gt;<i> +			if (s16subrtnretval == -1) {
</I>&gt;<i> +				return -1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +		default:
</I>&gt;<i> +			return -1;
</I>&gt;<i> +		}
</I>&gt;<i> +	} else {
</I>&gt;<i> +
</I>&gt;<i> +		u32offset = (PRU_CAN_RX_INTERRUPT_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +		u32value = 0x00000000;
</I>&gt;<i> +		s16subrtnretval = pruss_readl(dev, u32offset,
</I>&gt;<i> +						(u32 *) &amp;u32value, 1);
</I>&gt;<i> +		if (s16subrtnretval == -1) {
</I>&gt;<i> +			return -1;
</I>&gt;<i> +		}
</I>&gt;<i> +		u32value = u32value &amp; ~(1 &lt;&lt; u8mailboxnumber);
</I>&gt;<i> +		s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +					(u32 *) &amp;u32value, 1);
</I>&gt;<i> +		if (s16subrtnretval == -1) {
</I>&gt;<i> +			return -1;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		switch (u8mailboxnumber) {
</I>&gt;<i> +		case 0:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX0_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +			u32value = 0x00000000;
</I>&gt;<i> +			s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +						(u32 *) &amp;u32value, 1);
</I>&gt;<i> +			if (s16subrtnretval == -1) {
</I>&gt;<i> +				return -1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 1:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX1_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +			u32value = 0x00000000;
</I>&gt;<i> +			s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +						(u32 *) &amp;u32value, 1);
</I>&gt;<i> +			if (s16subrtnretval == -1) {
</I>&gt;<i> +				return -1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 2:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX2_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +			u32value = 0x00000000;
</I>&gt;<i> +			s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +						(u32 *) &amp;u32value, 1);
</I>&gt;<i> +			if (s16subrtnretval == -1) {
</I>&gt;<i> +				return -1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 3:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX3_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +			u32value = 0x00000000;
</I>&gt;<i> +			s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +						(u32 *) &amp;u32value, 1);
</I>&gt;<i> +			if (s16subrtnretval == -1) {
</I>&gt;<i> +				return -1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 4:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX4_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +			u32value = 0x00000000;
</I>&gt;<i> +			s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +						(u32 *) &amp;u32value, 1);
</I>&gt;<i> +			if (s16subrtnretval == -1) {
</I>&gt;<i> +				return -1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 5:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX5_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +			u32value = 0x00000000;
</I>&gt;<i> +			s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +						(u32 *) &amp;u32value, 1);
</I>&gt;<i> +			if (s16subrtnretval == -1) {
</I>&gt;<i> +				return -1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 6:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX6_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +			u32value = 0x00000000;
</I>&gt;<i> +			s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +						(u32 *) &amp;u32value, 1);
</I>&gt;<i> +			if (s16subrtnretval == -1) {
</I>&gt;<i> +				return -1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +		case 7:
</I>&gt;<i> +			u32offset = (PRU_CAN_RX_MAILBOX7_STATUS_REGISTER &amp; 0xFFFF);
</I>&gt;<i> +			u32value = 0x00000000;
</I>&gt;<i> +			s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +						(u32 *) &amp;u32value, 1);
</I>&gt;<i> +			if (s16subrtnretval == -1) {
</I>&gt;<i> +				return -1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +		default:
</I>&gt;<i> +			return -1;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +s16 pru_can_start_abort_tx(struct device *dev, bool bcantransmitabortflag)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 u32offset;
</I>&gt;<i> +	u32 u32value;
</I>&gt;<i> +	s16 s16subrtnretval;
</I>&gt;<i> +	u32offset = (PRUSS_INTC_STATIDXCLR &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 32;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +					(u32 *) &amp;u32value, 1);
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_ENIDXSET &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 32;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +					(u32 *) &amp;u32value, 1);
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_STATIDXSET &amp; 0xFFFF);
</I>&gt;<i> +	u32value = 32;
</I>&gt;<i> +	s16subrtnretval = pruss_writel(dev, u32offset,
</I>&gt;<i> +					(u32 *) &amp;u32value, 1);
</I>&gt;<i> +	if (s16subrtnretval == -1) {
</I>&gt;<i> +		return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +s16 pru_can_mask_ints(struct device *dev, u32 int_mask)
</I>&gt;<i> +{
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +int pru_can_get_error_cnt(struct device *dev, u8 u8prunumber)
</I>&gt;<i> +{
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +int pru_can_get_intc_status(struct device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 u32offset = 0;
</I>&gt;<i> +	u32 u32getvalue = 0;
</I>&gt;<i> +	u32 u32clrvalue = 0;
</I>&gt;<i> +
</I>&gt;<i> +	u32offset = (PRUSS_INTC_STATCLRINT1 &amp; 0xFFFF);
</I>&gt;<i> +	pruss_readl(dev, u32offset, (u32 *) &amp;u32getvalue, 1);
</I>&gt;<i> +
</I>&gt;<i> +	if (u32getvalue &amp; 4)
</I>&gt;<i> +		u32clrvalue = 34;	/* CLR Event 34 */
</I>&gt;<i> +
</I>&gt;<i> +	if (u32getvalue &amp; 2)
</I>&gt;<i> +		u32clrvalue = 33;	/* CLR Event 33  */
</I>&gt;<i> +
</I>&gt;<i> +	if (u32clrvalue) {
</I>&gt;<i> +		u32offset = (PRUSS_INTC_STATIDXCLR &amp; 0xFFFF);
</I>&gt;<i> +		pruss_writel(dev, u32offset, &amp;u32clrvalue, 1);
</I>&gt;<i> +	} else
</I>&gt;<i> +		return -1;
</I>&gt;<i> +
</I>&gt;<i> +	return u32getvalue;
</I>&gt;<i> +}
</I>&gt;<i> diff --git a/drivers/net/can/da8xx_pruss/pruss_can_api.h b/drivers/net/can/da8xx_pruss/pruss_can_api.h
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..7550456
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/da8xx_pruss/pruss_can_api.h
</I>&gt;<i> @@ -0,0 +1,290 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * Copyright (C) 2010 Texas Instruments Incorporated
</I>&gt;<i> + * Author: Ganeshan N
</I>&gt;<i> + *
</I>&gt;<i> + * This program is free software; you can redistribute it and/or modify it
</I>&gt;<i> + * under the terms of the GNU General Public License as  published by the
</I>&gt;<i> + * Free Software Foundation version 2.
</I>&gt;<i> + *
</I>&gt;<i> + * This program is distributed &quot;as is&quot; WITHOUT ANY WARRANTY of any kind,
</I>&gt;<i> + * whether express or implied; without even the implied warranty of
</I>&gt;<i> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
</I>&gt;<i> + * General Public License for more details.
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#ifndef _PRU_CAN_API_H_
</I>&gt;<i> +#define _PRU_CAN_API_H_
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/types.h&gt;
</I>&gt;<i> +#include &lt;linux/mfd/pruss/da8xx_pru.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_BIT_TIMINGS			(0x273)
</I>&gt;<i> +
</I>&gt;<i> +/* Timer Clock is sourced from DDR freq (PLL1 SYS CLK 2) */
</I>&gt;<i> +#define	TIMER_CLK_FREQ			132000000
</I>
any change to get this from a clk_dev?

&gt;<i> +
</I>&gt;<i> +#define TIMER_SETUP_DELAY		14
</I>&gt;<i> +#define GPIO_SETUP_DELAY		150
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_RX_PRU_0			PRUSS_NUM0
</I>&gt;<i> +#define CAN_TX_PRU_1			PRUSS_NUM1
</I>&gt;<i> +
</I>&gt;<i> +/* Number of Instruction in the Delay loop */
</I>&gt;<i> +#define DELAY_LOOP_LENGTH		2
</I>
please create a struct describing your register layout.

&gt;<i> +
</I>&gt;<i> +#define PRU1_BASE_ADDR			0x2000
</I>&gt;<i> +
</I>&gt;<i> +#define PRU_CAN_TX_GLOBAL_CONTROL_REGISTER		(PRU1_BASE_ADDR)
</I>&gt;<i> +#define PRU_CAN_TX_GLOBAL_STATUS_REGISTER		(PRU1_BASE_ADDR	+ 0x04)
</I>&gt;<i> +#define PRU_CAN_TX_INTERRUPT_MASK_REGISTER		(PRU1_BASE_ADDR	+ 0x08)
</I>&gt;<i> +#define PRU_CAN_TX_INTERRUPT_STATUS_REGISTER		(PRU1_BASE_ADDR	+ 0x0C)
</I>&gt;<i> +#define PRU_CAN_TX_MAILBOX0_STATUS_REGISTER		(PRU1_BASE_ADDR	+ 0x10)
</I>&gt;<i> +#define PRU_CAN_TX_MAILBOX1_STATUS_REGISTER		(PRU1_BASE_ADDR	+ 0x14)
</I>&gt;<i> +#define PRU_CAN_TX_MAILBOX2_STATUS_REGISTER		(PRU1_BASE_ADDR	+ 0x18)
</I>&gt;<i> +#define PRU_CAN_TX_MAILBOX3_STATUS_REGISTER		(PRU1_BASE_ADDR	+ 0x1C)
</I>&gt;<i> +#define PRU_CAN_TX_MAILBOX4_STATUS_REGISTER		(PRU1_BASE_ADDR	+ 0x20)
</I>&gt;<i> +#define PRU_CAN_TX_MAILBOX5_STATUS_REGISTER		(PRU1_BASE_ADDR	+ 0x24)
</I>&gt;<i> +#define PRU_CAN_TX_MAILBOX6_STATUS_REGISTER		(PRU1_BASE_ADDR	+ 0x28)
</I>&gt;<i> +#define PRU_CAN_TX_MAILBOX7_STATUS_REGISTER		(PRU1_BASE_ADDR	+ 0x2C)
</I>
please use an array for the mailbox status register.

&gt;<i> +#define PRU_CAN_TX_ERROR_COUNTER_REGISTER		(PRU1_BASE_ADDR	+ 0x30)
</I>&gt;<i> +#define PRU_CAN_TX_TIMING_REGISTER			(PRU1_BASE_ADDR	+ 0x34)
</I>&gt;<i> +#define PRU_CAN_TX_CLOCK_BRP_REGISTER			(PRU1_BASE_ADDR	+ 0x38)
</I>&gt;<i> +
</I>&gt;<i> +#define PRU_CAN_TX_MAILBOX0				(PRU1_BASE_ADDR	+ 0x40)
</I>&gt;<i> +#define PRU_CAN_TX_MAILBOX1				(PRU1_BASE_ADDR	+ 0x50)
</I>&gt;<i> +#define PRU_CAN_TX_MAILBOX2				(PRU1_BASE_ADDR	+ 0x60)
</I>&gt;<i> +#define PRU_CAN_TX_MAILBOX3				(PRU1_BASE_ADDR	+ 0x70)
</I>&gt;<i> +#define PRU_CAN_TX_MAILBOX4				(PRU1_BASE_ADDR	+ 0x80)
</I>&gt;<i> +#define PRU_CAN_TX_MAILBOX5				(PRU1_BASE_ADDR	+ 0x90)
</I>&gt;<i> +#define PRU_CAN_TX_MAILBOX6				(PRU1_BASE_ADDR	+ 0xA0)
</I>&gt;<i> +#define PRU_CAN_TX_MAILBOX7				(PRU1_BASE_ADDR	+ 0xB0)
</I>
also use an array here

&gt;<i> +
</I>&gt;<i> +#define PRU_CAN_TIMING_VAL_TX				(PRU1_BASE_ADDR	+ 0xC0)
</I>&gt;<i> +#define PRU_CAN_TIMING_VAL_TX_SJW			(PRU1_BASE_ADDR	+ 0xC4)
</I>&gt;<i> +#define PRU_CAN_TRANSMIT_FRAME				(PRU1_BASE_ADDR	+ 0xE0)
</I>&gt;<i> +
</I>&gt;<i> +#define PRU0_BASE_ADDR					0
</I>&gt;<i> +
</I>&gt;<i> +#define PRU_CAN_RX_GLOBAL_CONTROL_REGISTER		(PRU0_BASE_ADDR)
</I>&gt;<i> +#define PRU_CAN_RX_GLOBAL_STATUS_REGISTER		(PRU0_BASE_ADDR	+ 0x04)
</I>&gt;<i> +#define PRU_CAN_RX_INTERRUPT_MASK_REGISTER		(PRU0_BASE_ADDR	+ 0x08)
</I>&gt;<i> +#define PRU_CAN_RX_INTERRUPT_STATUS_REGISTER		(PRU0_BASE_ADDR	+ 0x0C)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX0_STATUS_REGISTER		(PRU0_BASE_ADDR	+ 0x10)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX1_STATUS_REGISTER		(PRU0_BASE_ADDR	+ 0x14)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX2_STATUS_REGISTER		(PRU0_BASE_ADDR	+ 0x18)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX3_STATUS_REGISTER		(PRU0_BASE_ADDR	+ 0x1C)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX4_STATUS_REGISTER		(PRU0_BASE_ADDR	+ 0x20)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX5_STATUS_REGISTER		(PRU0_BASE_ADDR	+ 0x24)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX6_STATUS_REGISTER		(PRU0_BASE_ADDR	+ 0x28)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX7_STATUS_REGISTER		(PRU0_BASE_ADDR	+ 0x2C)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX8_STATUS_REGISTER		(PRU0_BASE_ADDR	+ 0x30)
</I>
...array

&gt;<i> +#define PRU_CAN_RX_ERROR_COUNTER_REGISTER		(PRU0_BASE_ADDR	+ 0x34)
</I>&gt;<i> +#define PRU_CAN_RX_TIMING_REGISTER			(PRU0_BASE_ADDR	+ 0x38)
</I>&gt;<i> +#define PRU_CAN_RX_CLOCK_BRP_REGISTER			(PRU0_BASE_ADDR	+ 0x3C)
</I>&gt;<i> +
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX0				(PRU0_BASE_ADDR	+ 0x40)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX1				(PRU0_BASE_ADDR	+ 0x50)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX2				(PRU0_BASE_ADDR	+ 0x60)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX3				(PRU0_BASE_ADDR	+ 0x70)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX4				(PRU0_BASE_ADDR	+ 0x80)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX5				(PRU0_BASE_ADDR	+ 0x90)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX6				(PRU0_BASE_ADDR	+ 0xA0)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX7				(PRU0_BASE_ADDR	+ 0xB0)
</I>&gt;<i> +#define PRU_CAN_RX_MAILBOX8				(PRU0_BASE_ADDR	+ 0xC0)
</I>
..array

The rx and tx register set look quite similar. Is it intended that you
have 8 tx but 9 rx mailboxes? Anyway....make a struct descriing the
register set and use it twice, one for rx and one for tx.

&gt;<i> +
</I>&gt;<i> +#define PRU_CAN_TIMING_VAL_RX				(PRU0_BASE_ADDR	+ 0xD0)
</I>&gt;<i> +#define PRU_CAN_RECEIVE_FRAME				(PRU0_BASE_ADDR	+ 0xD4)
</I>&gt;<i> +#define PRU_CAN_ID_MAP					(PRU0_BASE_ADDR	+ 0xF0)
</I>&gt;<i> +
</I>&gt;<i> +#define PRU_CAN_ERROR_ACTIVE				128
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_ACK_FAILED					0xE
</I>&gt;<i> +#define CAN_ARBTR_FAIL					0xD
</I>&gt;<i> +#define CAN_BIT_ERROR					0xC
</I>&gt;<i> +#define CAN_TRANSMISSION_SUCCESS			0xA
</I>&gt;<i> +
</I>&gt;<i> +#define STD_DATA_FRAME					0x1
</I>&gt;<i> +#define EXTD_DATA_FRAME					0x2
</I>&gt;<i> +#define STD_REMOTE_FRAME				0x3
</I>&gt;<i> +#define EXTD_REMOTE_FRAME				0x4
</I>&gt;<i> +
</I>&gt;<i> +#define PRU_CAN_MAX_SJW					8
</I>&gt;<i> +#define PRU_CAN_MAX_PHSEG1				25
</I>&gt;<i> +#define PRU_CAN_MAX_PHSEG2				25
</I>&gt;<i> +
</I>&gt;<i> +#define DA8XX_PRUCANCORE_0_REGS				0x7000
</I>&gt;<i> +#define DA8XX_PRUCANCORE_1_REGS				0x7800
</I>&gt;<i> +#define PRU0_PROG_RAM_START_OFFSET			0x8000
</I>&gt;<i> +#define PRU1_PROG_RAM_START_OFFSET			0xC000
</I>&gt;<i> +#define PRU_CAN_INIT_MAX_TIMEOUT			0xFF
</I>&gt;<i> +
</I>&gt;<i> +typedef enum {
</I>&gt;<i> +	ecaninst0 = 0,
</I>&gt;<i> +	ecaninst1,
</I>&gt;<i> +	ecanmaxinst
</I>&gt;<i> +} can_instance_enum;
</I>
seens unused
&gt;<i> +
</I>&gt;<i> +typedef enum {
</I>&gt;<i> +	ecanmailbox0 = 0,
</I>&gt;<i> +	ecanmailbox1,
</I>&gt;<i> +	ecanmailbox2,
</I>&gt;<i> +	ecanmailbox3,
</I>&gt;<i> +	ecanmailbox4,
</I>&gt;<i> +	ecanmailbox5,
</I>&gt;<i> +	ecanmailbox6,
</I>&gt;<i> +	ecanmailbox7
</I>&gt;<i> +} can_mailbox_number;
</I>
unused, too
&gt;<i> +
</I>&gt;<i> +typedef enum {
</I>&gt;<i> +	ecandirectioninit = 0,
</I>&gt;<i> +	ecantransmit,
</I>&gt;<i> +	ecanreceive
</I>&gt;<i> +} can_transfer_direction;
</I>
please add a common prefix and please write them uppsercase.

&gt;<i> +
</I>&gt;<i> +typedef struct {
</I>&gt;<i> +	u16 u16extendedidentifier;
</I>&gt;<i> +	u16 u16baseidentifier;
</I>&gt;<i> +	u8 u8data7;
</I>&gt;<i> +	u8 u8data6;
</I>&gt;<i> +	u8 u8data5;
</I>&gt;<i> +	u8 u8data4;
</I>&gt;<i> +	u8 u8data3;
</I>&gt;<i> +	u8 u8data2;
</I>&gt;<i> +	u8 u8data1;
</I>&gt;<i> +	u8 u8data0;
</I>
use an array for the data.

&gt;<i> +	u16 u16datalength;
</I>&gt;<i> +	u16 u16crc;
</I>&gt;<i> +} can_mail_box_structure;
</I>&gt;<i> +
</I>&gt;<i> +typedef struct {
</I>&gt;<i> +	can_transfer_direction ecantransferdirection;
</I>&gt;<i> +} can_mailbox_config;
</I>&gt;<i> +
</I>&gt;<i> +typedef struct {
</I>&gt;<i> +	can_instance_enum ecaninstance;
</I>&gt;<i> +	can_transfer_direction ecantransferdirection;
</I>&gt;<i> +	can_mail_box_structure strcanmailbox;
</I>&gt;<i> +	can_mailbox_number ecanmailboxnumber;
</I>&gt;<i> +	u8 u8prunumber;
</I>&gt;<i> +	u32 u32globalstatus;
</I>&gt;<i> +	u32 u32interruptstatus;
</I>&gt;<i> +	u32 u32mailboxstatus;
</I>&gt;<i> +} can_emu_app_hndl;
</I>
You already have defines your priv. No need for further structs.

&gt;<i> +
</I>&gt;<i> +typedef struct {
</I>&gt;<i> +	bool bcaninststate;
</I>&gt;<i> +	can_transfer_direction ecantransferdirection;
</I>&gt;<i> +	u32 u32apphandlerptr;
</I>&gt;<i> +} can_emu_drv_inst;
</I>
dito

&gt;<i> +
</I>&gt;<i> +typedef struct {
</I>&gt;<i> +	u8 u8syncjumpwidth;
</I>&gt;<i> +	u8 u8phseg1;
</I>&gt;<i> +	u8 u8phseg2;
</I>&gt;<i> +} can_bit_timing_consts;
</I>&gt;<i> +
</I>&gt;<i> +/* Field Definition Macros  */
</I>&gt;<i> +
</I>&gt;<i> +/* CONTROL */
</I>&gt;<i>
</I>
get rid of all the following functions, you don't need that extra layer
in the can driver.

&gt;<i> +/*
</I>&gt;<i> + * pru_can_set_brp() Updates the  BRP register of PRU.
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_set_brp(struct device *dev, u16 u16prescaler);
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_set_bit_timing() Updates the  timing register of PRU
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_set_bit_timing(struct device *dev,
</I>&gt;<i> +			can_bit_timing_consts *pstrbittiming);
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_calc_timing() Updates the timing values of PRU
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_calc_timing(struct device *dev,
</I>&gt;<i> +			u32 u32bittiming, u32 u32bitrateprescaler);
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_write_data_to_mailbox() Updates the transmit mailboxes of PRU1
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_write_data_to_mailbox(struct device *dev,
</I>&gt;<i> +			can_emu_app_hndl *pstremuapphndl);
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_get_data_from_mailbox() Receive data from receive mailboxes
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_get_data_from_mailbox(struct device *dev,
</I>&gt;<i> +			can_emu_app_hndl *pstremuapphndl);
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_rx_id_map() Receive mailboxes ID Mapping of PRU0
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_rx_id_map(struct device *dev,
</I>&gt;<i> +			u32 u32nodeid, can_mailbox_number ecanmailboxno);
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + *pru_can_get_intr_status() Get interrupts status register value
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_get_intr_status(struct device *dev,
</I>&gt;<i> +			can_emu_app_hndl *pstremuapphndl);
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_get_global_status() Get the globalstatus register value
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_get_global_status(struct device *dev,
</I>&gt;<i> +			can_emu_app_hndl *pstremuapphndl);
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_get_mailbox_status() Get mailbox status reg value
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_get_mailbox_status(struct device *dev,
</I>&gt;<i> +			can_emu_app_hndl *pstremuapphndl);
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_configuration_mode_set() Sets timing val for data transfer
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_config_mode_set(struct device *dev,
</I>&gt;<i> +			bool bconfig_modeflag);
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_emu_init() Initializes Can Emulation Parameters
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_emu_init(struct device *dev,
</I>&gt;<i> +			u32 u32pruclock);
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_emu_open() Opens can emu for application to use
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_emu_open(struct device *dev,
</I>&gt;<i> +			can_emu_app_hndl *pstremuapphndl);
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_emu_close() Closes can emu for applications to use
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_emu_close(struct device *dev,
</I>&gt;<i> +			can_emu_app_hndl *pstremuapphndl);
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * pru_can_emu_exit() Diables all the PRUs
</I>&gt;<i> + */
</I>&gt;<i> +s16 pru_can_emu_exit(struct device *dev);
</I>&gt;<i> +
</I>&gt;<i> +s16 pru_can_tx_mode_set(struct device *dev, bool btransfer_flag,
</I>&gt;<i> +			 can_transfer_direction ecan_trx);
</I>&gt;<i> +
</I>&gt;<i> +s16 pru_can_emu_sreset(struct device *dev);
</I>&gt;<i> +
</I>&gt;<i> +s16 pru_can_tx(struct device *dev,
</I>&gt;<i> +			u8 u8mailboxnumber, u8 u8prunumber);
</I>&gt;<i> +
</I>&gt;<i> +s16 pru_can_start_abort_tx(struct device *dev,
</I>&gt;<i> +			bool btxabort_flag);
</I>&gt;<i> +
</I>&gt;<i> +s16 pru_can_mask_ints(struct device *dev, u32 int_mask);
</I>&gt;<i> +
</I>&gt;<i> +s32 pru_can_get_error_cnt(struct device *dev, u8 u8prunumber);
</I>&gt;<i> +
</I>&gt;<i> +s32 pru_can_get_intc_status(struct device *dev);
</I>&gt;<i> +#endif
</I>
regards, Marc

-- 
Pengutronix e.K.                  | Marc Kleine-Budde           |
Industrial Linux Solutions        | Phone: +49-231-2826-924     |
Vertretung West/Dortmund          | Fax:   +49-5121-206917-5555 |
Amtsgericht Hildesheim, HRA 2686  | <A HREF="http://www.pengutronix.de">http://www.pengutronix.de</A>   |

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 262 bytes
Desc: OpenPGP digital signature
URL: &lt;<A HREF="https://lists.berlios.de/pipermail/socketcan-core/attachments/20110211/b31c032b/attachment.pgp">https://lists.berlios.de/pipermail/socketcan-core/attachments/20110211/b31c032b/attachment.pgp</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005520.html">[PATCH v2 09/13] can: pruss CAN driver.
</A></li>
	<LI>Next message: <A HREF="005594.html">[PATCH v2 09/13] can: pruss CAN driver.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5521">[ date ]</a>
              <a href="thread.html#5521">[ thread ]</a>
              <a href="subject.html#5521">[ subject ]</a>
              <a href="author.html#5521">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
