<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH 1/2] cpc-usb: Removed driver from staging tree
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%201/2%5D%20cpc-usb%3A%20Removed%20driver%20from%20staging%20tree&In-Reply-To=%3C20090914082224.5441.87050.stgit%40localhost.localdomain%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003062.html">
   <LINK REL="Next"  HREF="003064.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH 1/2] cpc-usb: Removed driver from staging tree</H1>
    <B>Sebastian Haas</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%201/2%5D%20cpc-usb%3A%20Removed%20driver%20from%20staging%20tree&In-Reply-To=%3C20090914082224.5441.87050.stgit%40localhost.localdomain%3E"
       TITLE="[PATCH 1/2] cpc-usb: Removed driver from staging tree">haas at ems-wuensche.com
       </A><BR>
    <I>Mon Sep 14 10:22:24 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003062.html">[PATCH 0/2] ems_usb: Added support for EMS CPC-USB/ARM7 CAN interface
</A></li>
        <LI>Next message: <A HREF="003064.html">[PATCH 2/2] ems_usb: Added support for EMS CPC-USB/ARM7 CAN/USB	interface
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3063">[ date ]</a>
              <a href="thread.html#3063">[ thread ]</a>
              <a href="subject.html#3063">[ subject ]</a>
              <a href="author.html#3063">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This patch prepares replacing the staging driver cpc-usb with the new
developed ems_usb CAN driver.

Signed-off-by: Sebastian Haas &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">haas at ems-wuensche.com</A>&gt;
Acked-by: Greg Kroah-Hartman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">gregkh at suse.de</A>&gt;
---

 drivers/staging/Kconfig               |    2 
 drivers/staging/Makefile              |    1 
 drivers/staging/cpc-usb/Kconfig       |    4 
 drivers/staging/cpc-usb/Makefile      |    3 
 drivers/staging/cpc-usb/TODO          |    9 
 drivers/staging/cpc-usb/cpc-usb_drv.c | 1185 ---------------------------------
 drivers/staging/cpc-usb/cpc.h         |  440 ------------
 drivers/staging/cpc-usb/cpc_int.h     |   83 --
 drivers/staging/cpc-usb/cpcusb.h      |   86 --
 drivers/staging/cpc-usb/sja2m16c.h    |   41 -
 drivers/staging/cpc-usb/sja2m16c_2.c  |  452 -------------
 11 files changed, 0 insertions(+), 2306 deletions(-)
 delete mode 100644 drivers/staging/cpc-usb/Kconfig
 delete mode 100644 drivers/staging/cpc-usb/Makefile
 delete mode 100644 drivers/staging/cpc-usb/TODO
 delete mode 100644 drivers/staging/cpc-usb/cpc-usb_drv.c
 delete mode 100644 drivers/staging/cpc-usb/cpc.h
 delete mode 100644 drivers/staging/cpc-usb/cpc_int.h
 delete mode 100644 drivers/staging/cpc-usb/cpcusb.h
 delete mode 100644 drivers/staging/cpc-usb/sja2m16c.h
 delete mode 100644 drivers/staging/cpc-usb/sja2m16c_2.c

diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index 975ecdd..5e4b865 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -121,8 +121,6 @@ source &quot;drivers/staging/serqt_usb2/Kconfig&quot;
 
 source &quot;drivers/staging/vt6655/Kconfig&quot;
 
-source &quot;drivers/staging/cpc-usb/Kconfig&quot;
-
 source &quot;drivers/staging/pata_rdc/Kconfig&quot;
 
 source &quot;drivers/staging/udlfb/Kconfig&quot;
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index 2241ae1..ede1599 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -42,6 +42,5 @@ obj-$(CONFIG_LINE6_USB)		+= line6/
 obj-$(CONFIG_USB_SERIAL_QUATECH2)	+= serqt_usb2/
 obj-$(CONFIG_OCTEON_ETHERNET)	+= octeon/
 obj-$(CONFIG_VT6655)		+= vt6655/
-obj-$(CONFIG_USB_CPC)		+= cpc-usb/
 obj-$(CONFIG_RDC_17F3101X)	+= pata_rdc/
 obj-$(CONFIG_FB_UDL)		+= udlfb/
diff --git a/drivers/staging/cpc-usb/Kconfig b/drivers/staging/cpc-usb/Kconfig
deleted file mode 100644
index 2be0bc9..0000000
--- a/drivers/staging/cpc-usb/Kconfig
+++ /dev/null
@@ -1,4 +0,0 @@
-config USB_CPC
-	tristate &quot;CPC CAN USB driver&quot;
-	depends on USB &amp;&amp; PROC_FS
-	default n
diff --git a/drivers/staging/cpc-usb/Makefile b/drivers/staging/cpc-usb/Makefile
deleted file mode 100644
index 3f83170..0000000
--- a/drivers/staging/cpc-usb/Makefile
+++ /dev/null
@@ -1,3 +0,0 @@
-obj-$(CONFIG_USB_CPC)	+= cpc-usb.o
-
-cpc-usb-y := cpc-usb_drv.o sja2m16c_2.o
diff --git a/drivers/staging/cpc-usb/TODO b/drivers/staging/cpc-usb/TODO
deleted file mode 100644
index 000e8bb..0000000
--- a/drivers/staging/cpc-usb/TODO
+++ /dev/null
@@ -1,9 +0,0 @@
-Things to do for this driver to get merged into the main portion of the
-kernel:
-	- checkpatch cleanups
-	- sparse clean
-	- remove proc code
-	- tie into CAN socket interfaces if possible
-	- figure out sane userspace api
-
-Send patches to Greg Kroah-Hartman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">greg at kroah.com</A>&gt;
diff --git a/drivers/staging/cpc-usb/cpc-usb_drv.c b/drivers/staging/cpc-usb/cpc-usb_drv.c
deleted file mode 100644
index 9bf3f98..0000000
--- a/drivers/staging/cpc-usb/cpc-usb_drv.c
+++ /dev/null
@@ -1,1185 +0,0 @@
-/*
- * CPC-USB CAN Interface Kernel Driver
- *
- * Copyright (C) 2004-2009 EMS Dr. Thomas Wuensche
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published
- * by the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-#include &lt;linux/kernel.h&gt;
-#include &lt;linux/errno.h&gt;
-#include &lt;linux/init.h&gt;
-#include &lt;linux/slab.h&gt;
-#include &lt;linux/vmalloc.h&gt;
-#include &lt;linux/module.h&gt;
-#include &lt;linux/poll.h&gt;
-#include &lt;linux/smp_lock.h&gt;
-#include &lt;linux/completion.h&gt;
-#include &lt;asm/uaccess.h&gt;
-#include &lt;linux/usb.h&gt;
-
-#include &lt;linux/version.h&gt;
-
-#include &lt;linux/proc_fs.h&gt;
-
-#include &quot;cpc.h&quot;
-
-#include &quot;cpc_int.h&quot;
-#include &quot;cpcusb.h&quot;
-
-#include &quot;sja2m16c.h&quot;
-
-/* Version Information */
-#define DRIVER_AUTHOR  &quot;Sebastian Haas &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">haas at ems-wuensche.com</A>&gt;&quot;
-#define DRIVER_DESC    &quot;CPC-USB Driver for Linux Kernel 2.6&quot;
-#define DRIVER_VERSION CPC_DRIVER_VERSION
-
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_VERSION(DRIVER_VERSION);
-MODULE_LICENSE(&quot;GPL v2&quot;);
-
-/* Define these values to match your devices */
-#define USB_CPCUSB_VENDOR_ID	0x12D6
-
-#define USB_CPCUSB_M16C_PRODUCT_ID    0x0888
-#define USB_CPCUSB_LPC2119_PRODUCT_ID 0x0444
-
-#define CPC_USB_PROC_DIR     CPC_PROC_DIR &quot;cpc-usb&quot;
-
-static struct proc_dir_entry *procDir;
-static struct proc_dir_entry *procEntry;
-
-/* Module parameters */
-static int debug;
-module_param(debug, int, S_IRUGO);
-
-/* table of devices that work with this driver */
-static struct usb_device_id cpcusb_table[] = {
-	{USB_DEVICE(USB_CPCUSB_VENDOR_ID, USB_CPCUSB_M16C_PRODUCT_ID)},
-	{USB_DEVICE(USB_CPCUSB_VENDOR_ID, USB_CPCUSB_LPC2119_PRODUCT_ID)},
-	{}			/* Terminating entry */
-};
-
-MODULE_DEVICE_TABLE(usb, cpcusb_table);
-
-/* use to prevent kernel panic if driver is unloaded
- * while a programm has still open the device
- */
-DECLARE_WAIT_QUEUE_HEAD(rmmodWq);
-atomic_t useCount;
-
-static CPC_USB_T *CPCUSB_Table[CPC_USB_CARD_CNT] = { 0 };
-static unsigned int CPCUsbCnt;
-
-/* prevent races between open() and disconnect() */
-static DECLARE_MUTEX(disconnect_sem);
-
-/* local function prototypes */
-static ssize_t cpcusb_read(struct file *file, char *buffer, size_t count,
-			   loff_t *ppos);
-static ssize_t cpcusb_write(struct file *file, const char *buffer,
-			    size_t count, loff_t *ppos);
-static unsigned int cpcusb_poll(struct file *file, poll_table * wait);
-static int cpcusb_open(struct inode *inode, struct file *file);
-static int cpcusb_release(struct inode *inode, struct file *file);
-
-static int cpcusb_probe(struct usb_interface *interface,
-			const struct usb_device_id *id);
-static void cpcusb_disconnect(struct usb_interface *interface);
-
-static void cpcusb_read_bulk_callback(struct urb *urb);
-static void cpcusb_write_bulk_callback(struct urb *urb);
-static void cpcusb_read_interrupt_callback(struct urb *urb);
-
-static int cpcusb_setup_intrep(CPC_USB_T *card);
-
-static struct file_operations cpcusb_fops = {
-	/*
-	 * The owner field is part of the module-locking
-	 * mechanism. The idea is that the kernel knows
-	 * which module to increment the use-counter of
-	 * BEFORE it calls the device's open() function.
-	 * This also means that the kernel can decrement
-	 * the use-counter again before calling release()
-	 * or should the open() function fail.
-	 */
-	.owner = THIS_MODULE,
-
-	.read = cpcusb_read,
-	.write = cpcusb_write,
-	.poll = cpcusb_poll,
-	.open = cpcusb_open,
-	.release = cpcusb_release,
-};
-
-/*
- * usb class driver info in order to get a minor number from the usb core,
- * and to have the device registered with devfs and the driver core
- */
-static struct usb_class_driver cpcusb_class = {
-	.name = &quot;usb/cpc_usb%d&quot;,
-	.fops = &amp;cpcusb_fops,
-	.minor_base = CPC_USB_BASE_MNR,
-};
-
-/* usb specific object needed to register this driver with the usb subsystem */
-static struct usb_driver cpcusb_driver = {
-	.name = &quot;cpc-usb&quot;,
-	.probe = cpcusb_probe,
-	.disconnect = cpcusb_disconnect,
-	.id_table = cpcusb_table,
-};
-
-static int cpcusb_create_info_output(char *buf)
-{
-	int i = 0, j;
-
-	for (j = 0; j &lt; CPC_USB_CARD_CNT; j++) {
-		if (CPCUSB_Table[j]) {
-			CPC_USB_T *card = CPCUSB_Table[j];
-			CPC_CHAN_T *chan = card-&gt;chan;
-
-			/* MINOR CHANNELNO BUSNO SLOTNO */
-			i += sprintf(&amp;buf[i], &quot;%d %s\n&quot;, chan-&gt;minor,
-				     card-&gt;serialNumber);
-		}
-	}
-
-	return i;
-}
-
-static int cpcusb_proc_read_info(char *page, char **start, off_t off,
-				 int count, int *eof, void *data)
-{
-	int len = cpcusb_create_info_output(page);
-
-	if (len &lt;= off + count)
-		*eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len &gt; count)
-		len = count;
-	if (len &lt; 0)
-		len = 0;
-
-	return len;
-}
-
-/*
- * Remove CPC-USB and cleanup
- */
-static inline void cpcusb_delete(CPC_USB_T *card)
-{
-	if (card) {
-		if (card-&gt;chan) {
-			if (card-&gt;chan-&gt;buf)
-				vfree(card-&gt;chan-&gt;buf);
-
-			if (card-&gt;chan-&gt;CPCWait_q)
-				kfree(card-&gt;chan-&gt;CPCWait_q);
-
-			kfree(card-&gt;chan);
-		}
-
-		CPCUSB_Table[card-&gt;idx] = NULL;
-		kfree(card);
-	}
-}
-
-/*
- * setup the interrupt IN endpoint of a specific CPC-USB device
- */
-static int cpcusb_setup_intrep(CPC_USB_T *card)
-{
-	int retval = 0;
-	struct usb_endpoint_descriptor *ep;
-
-	ep = &amp;card-&gt;interface-&gt;altsetting[0].endpoint[card-&gt;num_intr_in].desc;
-
-	card-&gt;intr_in_buffer[0] = 0;
-	card-&gt;free_slots = 15;	/* initial size */
-
-	/* setup the urb */
-	usb_fill_int_urb(card-&gt;intr_in_urb, card-&gt;udev,
-			 usb_rcvintpipe(card-&gt;udev, card-&gt;num_intr_in),
-			 card-&gt;intr_in_buffer,
-			 sizeof(card-&gt;intr_in_buffer),
-			 cpcusb_read_interrupt_callback,
-			 card,
-			 ep-&gt;bInterval);
-
-	card-&gt;intr_in_urb-&gt;status = 0;	/* needed! */
-
-	/* submit the urb */
-	retval = usb_submit_urb(card-&gt;intr_in_urb, GFP_KERNEL);
-
-	if (retval)
-		err(&quot;%s - failed submitting intr urb, error %d&quot;, __func__,
-		    retval);
-
-	return retval;
-}
-
-static int cpcusb_open(struct inode *inode, struct file *file)
-{
-	CPC_USB_T *card = NULL;
-	struct usb_interface *interface;
-	int subminor;
-	int j, retval = 0;
-
-	subminor = iminor(inode);
-
-	/* prevent disconnects */
-	down(&amp;disconnect_sem);
-
-	interface = usb_find_interface(&amp;cpcusb_driver, subminor);
-	if (!interface) {
-		err(&quot;%s - error, can't find device for minor %d&quot;,
-				__func__, subminor);
-		retval = CPC_ERR_NO_INTERFACE_PRESENT;
-		goto exit_no_device;
-	}
-
-	card = usb_get_intfdata(interface);
-	if (!card) {
-		retval = CPC_ERR_NO_INTERFACE_PRESENT;
-		goto exit_no_device;
-	}
-
-	/* lock this device */
-	down(&amp;card-&gt;sem);
-
-	/* increment our usage count for the driver */
-	if (card-&gt;open) {
-		dbg(&quot;device already opened&quot;);
-		retval = CPC_ERR_CHANNEL_ALREADY_OPEN;
-		goto exit_on_error;
-	}
-
-	/* save our object in the file's private structure */
-	file-&gt;private_data = card;
-	for (j = 0; j &lt; CPC_USB_URB_CNT; j++) {
-		usb_fill_bulk_urb(card-&gt;urbs[j].urb, card-&gt;udev,
-				  usb_rcvbulkpipe(card-&gt;udev, card-&gt;num_bulk_in),
-				  card-&gt;urbs[j].buffer, card-&gt;urbs[j].size,
-				  cpcusb_read_bulk_callback, card);
-
-		retval = usb_submit_urb(card-&gt;urbs[j].urb, GFP_KERNEL);
-
-		if (retval) {
-			err(&quot;%s - failed submitting read urb, error %d&quot;,
-			    __func__, retval);
-			retval = CPC_ERR_TRANSMISSION_FAILED;
-			goto exit_on_error;
-		}
-	}
-
-	info(&quot;%s - %d URB's submitted&quot;, __func__, j);
-
-	ResetBuffer(card-&gt;chan);
-
-	cpcusb_setup_intrep(card);
-	card-&gt;open = 1;
-
-	atomic_inc(&amp;useCount);
-
-exit_on_error:
-	/* unlock this device */
-	up(&amp;card-&gt;sem);
-
-exit_no_device:
-	up(&amp;disconnect_sem);
-
-	return retval;
-}
-
-static unsigned int cpcusb_poll(struct file *file, poll_table * wait)
-{
-	CPC_USB_T *card = (CPC_USB_T *) file-&gt;private_data;
-	unsigned int retval = 0;
-
-	if (!card) {
-		err(&quot;%s - device object lost&quot;, __func__);
-		return -EIO;
-	}
-
-	poll_wait(file, card-&gt;chan-&gt;CPCWait_q, wait);
-
-	if (IsBufferNotEmpty(card-&gt;chan) || !(card-&gt;present))
-		retval |= (POLLIN | POLLRDNORM);
-
-	if (card-&gt;free_slots)
-		retval |= (POLLOUT | POLLWRNORM);
-
-	return retval;
-}
-
-static int cpcusb_release(struct inode *inode, struct file *file)
-{
-	CPC_USB_T *card = (CPC_USB_T *) file-&gt;private_data;
-	int j, retval = 0;
-
-	if (card == NULL) {
-		dbg(&quot;%s - object is NULL&quot;, __func__);
-		return CPC_ERR_NO_INTERFACE_PRESENT;
-	}
-
-	/* lock our device */
-	down(&amp;card-&gt;sem);
-
-	if (!card-&gt;open) {
-		dbg(&quot;%s - device not opened&quot;, __func__);
-		retval = CPC_ERR_NO_INTERFACE_PRESENT;
-		goto exit_not_opened;
-	}
-
-	/* if device wasn't unplugged kill all urbs */
-	if (card-&gt;present) {
-		/* kill read urbs */
-		for (j = 0; j &lt; CPC_USB_URB_CNT; j++) {
-			usb_kill_urb(card-&gt;urbs[j].urb);
-		}
-
-		/* kill irq urb */
-		usb_kill_urb(card-&gt;intr_in_urb);
-
-		/* kill write urbs */
-		for (j = 0; j &lt; CPC_USB_URB_CNT; j++) {
-			if (atomic_read(&amp;card-&gt;wrUrbs[j].busy)) {
-				usb_kill_urb(card-&gt;wrUrbs[j].urb);
-				wait_for_completion(&amp;card-&gt;wrUrbs[j].finished);
-			}
-		}
-	}
-
-	atomic_dec(&amp;useCount);
-
-	/* last process detached */
-	if (atomic_read(&amp;useCount) == 0) {
-		wake_up(&amp;rmmodWq);
-	}
-
-	if (!card-&gt;present &amp;&amp; card-&gt;open) {
-		/* the device was unplugged before the file was released */
-		up(&amp;card-&gt;sem);
-		cpcusb_delete(card);
-		return 0;
-	}
-
-	card-&gt;open = 0;
-
-exit_not_opened:
-	up(&amp;card-&gt;sem);
-
-	return 0;
-}
-
-static ssize_t cpcusb_read(struct file *file, char *buffer, size_t count,
-			   loff_t *ppos)
-{
-	CPC_USB_T *card = (CPC_USB_T *) file-&gt;private_data;
-	CPC_CHAN_T *chan;
-	int retval = 0;
-
-	if (count &lt; sizeof(CPC_MSG_T))
-		return CPC_ERR_UNKNOWN;
-
-	/* check if can read from the given address */
-	if (!access_ok(VERIFY_WRITE, buffer, count))
-		return CPC_ERR_UNKNOWN;
-
-	/* lock this object */
-	down(&amp;card-&gt;sem);
-
-	/* verify that the device wasn't unplugged */
-	if (!card-&gt;present) {
-		up(&amp;card-&gt;sem);
-		return CPC_ERR_NO_INTERFACE_PRESENT;
-	}
-
-	if (IsBufferEmpty(card-&gt;chan)) {
-		retval = 0;
-	} else {
-		chan = card-&gt;chan;
-
-#if 0
-		/* convert LPC2119 params back to SJA1000 params */
-		if (card-&gt;deviceRevision &gt;= 0x0200
-		    &amp;&amp; chan-&gt;buf[chan-&gt;oidx].type == CPC_MSG_T_CAN_PRMS) {
-			LPC2119_TO_SJA1000_Params(&amp;chan-&gt;buf[chan-&gt;oidx]);
-		}
-#endif
-
-		if (copy_to_user(buffer, &amp;chan-&gt;buf[chan-&gt;oidx], count) != 0) {
-			retval = CPC_ERR_IO_TRANSFER;
-		} else {
-			chan-&gt;oidx = (chan-&gt;oidx + 1) % CPC_MSG_BUF_CNT;
-			chan-&gt;WnR = 1;
-			retval = sizeof(CPC_MSG_T);
-		}
-	}
-/*	spin_unlock_irqrestore(&amp;card-&gt;slock, flags); */
-
-	/* unlock the device */
-	up(&amp;card-&gt;sem);
-
-	return retval;
-}
-
-#define SHIFT  1
-static inline void cpcusb_align_buffer_alignment(unsigned char *buf)
-{
-	/* CPC-USB uploads packed bytes. */
-	CPC_MSG_T *cpc = (CPC_MSG_T *) buf;
-	unsigned int i;
-
-	for (i = 0; i &lt; cpc-&gt;length + (2 * sizeof(unsigned long)); i++) {
-		((unsigned char *) &amp;cpc-&gt;msgid)[1 + i] =
-		    ((unsigned char *) &amp;cpc-&gt;msgid)[1 + SHIFT + i];
-	}
-}
-
-static int cpc_get_buffer_count(CPC_CHAN_T *chan)
-{
-	/* check the buffer parameters */
-	if (chan-&gt;iidx == chan-&gt;oidx)
-		return !chan-&gt;WnR ? CPC_MSG_BUF_CNT : 0;
-	else if (chan-&gt;iidx &gt;= chan-&gt;oidx)
-		return (chan-&gt;iidx - chan-&gt;oidx) % CPC_MSG_BUF_CNT;
-
-	return (chan-&gt;iidx + CPC_MSG_BUF_CNT - chan-&gt;oidx) % CPC_MSG_BUF_CNT;
-}
-
-static ssize_t cpcusb_write(struct file *file, const char *buffer,
-			    size_t count, loff_t *ppos)
-{
-	CPC_USB_T *card = (CPC_USB_T *) file-&gt;private_data;
-	CPC_USB_WRITE_URB_T *wrUrb = NULL;
-
-	ssize_t bytes_written = 0;
-	int retval = 0;
-	int j;
-
-	unsigned char *obuf = NULL;
-	unsigned char type = 0;
-	CPC_MSG_T *info = NULL;
-
-	dbg(&quot;%s - entered minor %d, count = %zu, present = %d&quot;,
-	    __func__, card-&gt;minor, count, card-&gt;present);
-
-	if (count &gt; sizeof(CPC_MSG_T))
-		return CPC_ERR_UNKNOWN;
-
-	/* check if can read from the given address */
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return CPC_ERR_UNKNOWN;
-
-	/* lock this object */
-	down(&amp;card-&gt;sem);
-
-	/* verify that the device wasn't unplugged */
-	if (!card-&gt;present) {
-		retval = CPC_ERR_NO_INTERFACE_PRESENT;
-		goto exit;
-	}
-
-	/* verify that we actually have some data to write */
-	if (count == 0) {
-		dbg(&quot;%s - write request of 0 bytes&quot;, __func__);
-		goto exit;
-	}
-
-	if (card-&gt;free_slots &lt;= 5) {
-		info = (CPC_MSG_T *) buffer;
-
-		if (info-&gt;type != CPC_CMD_T_CLEAR_CMD_QUEUE
-		    || card-&gt;free_slots &lt;= 0) {
-			dbg(&quot;%s - send buffer full please try again %d&quot;,
-			    __func__, card-&gt;free_slots);
-			retval = CPC_ERR_CAN_NO_TRANSMIT_BUF;
-			goto exit;
-		}
-	}
-
-	/* Find a free write urb */
-	for (j = 0; j &lt; CPC_USB_URB_CNT; j++) {
-		if (!atomic_read(&amp;card-&gt;wrUrbs[j].busy)) {
-			wrUrb = &amp;card-&gt;wrUrbs[j];	/* remember found URB */
-			atomic_set(&amp;wrUrb-&gt;busy, 1);	/* lock this URB      */
-			init_completion(&amp;wrUrb-&gt;finished);	/* init completion    */
-			dbg(&quot;WR URB no. %d started&quot;, j);
-			break;
-		}
-	}
-
-	/* don't found write urb say error */
-	if (!wrUrb) {
-		dbg(&quot;%s - no free send urb available&quot;, __func__);
-		retval = CPC_ERR_CAN_NO_TRANSMIT_BUF;
-		goto exit;
-	}
-	dbg(&quot;URB write req&quot;);
-
-	obuf = (unsigned char *) wrUrb-&gt;urb-&gt;transfer_buffer;
-
-	/* copy the data from userspace into our transfer buffer;
-	 * this is the only copy required.
-	 */
-	if (copy_from_user(&amp;obuf[4], buffer, count) != 0) {
-		atomic_set(&amp;wrUrb-&gt;busy, 0);	/* release urb */
-		retval = CPC_ERR_IO_TRANSFER;
-		goto exit;
-	}
-
-	/* check if it is a DRIVER information message, so we can
-	 * response to that message and not the USB
-	 */
-	info = (CPC_MSG_T *) &amp;obuf[4];
-
-	bytes_written = 11 + info-&gt;length;
-	if (bytes_written &gt;= wrUrb-&gt;size) {
-		retval = CPC_ERR_IO_TRANSFER;
-		goto exit;
-	}
-
-	switch (info-&gt;type) {
-	case CPC_CMD_T_CLEAR_MSG_QUEUE:
-		ResetBuffer(card-&gt;chan);
-		break;
-
-	case CPC_CMD_T_INQ_MSG_QUEUE_CNT:
-		retval = cpc_get_buffer_count(card-&gt;chan);
-		atomic_set(&amp;wrUrb-&gt;busy, 0);
-
-		goto exit;
-
-	case CPC_CMD_T_INQ_INFO:
-		if (info-&gt;msg.info.source == CPC_INFOMSG_T_DRIVER) {
-			/* release urb cause we'll use it for driver
-			 * information
-			 */
-			atomic_set(&amp;wrUrb-&gt;busy, 0);
-			if (IsBufferFull(card-&gt;chan)) {
-				retval = CPC_ERR_IO_TRANSFER;
-				goto exit;
-			}
-
-			/* it is a driver information request message and we have
-			 * free rx slots to store the response
-			 */
-			type = info-&gt;msg.info.type;
-			info = &amp;card-&gt;chan-&gt;buf[card-&gt;chan-&gt;iidx];
-
-			info-&gt;type = CPC_MSG_T_INFO;
-			info-&gt;msg.info.source = CPC_INFOMSG_T_DRIVER;
-			info-&gt;msg.info.type = type;
-
-			switch (type) {
-			case CPC_INFOMSG_T_VERSION:
-				info-&gt;length = strlen(CPC_DRIVER_VERSION) + 2;
-				sprintf(info-&gt;msg.info.msg, &quot;%s\n&quot;,
-					CPC_DRIVER_VERSION);
-				break;
-
-			case CPC_INFOMSG_T_SERIAL:
-				info-&gt;length = strlen(CPC_DRIVER_SERIAL) + 2;
-				sprintf(info-&gt;msg.info.msg, &quot;%s\n&quot;,
-					CPC_DRIVER_SERIAL);
-				break;
-
-			default:
-				info-&gt;length = 2;
-				info-&gt;msg.info.type =
-				    CPC_INFOMSG_T_UNKNOWN_TYPE;
-			}
-
-			card-&gt;chan-&gt;WnR = 0;
-			card-&gt;chan-&gt;iidx =
-			    (card-&gt;chan-&gt;iidx + 1) % CPC_MSG_BUF_CNT;
-
-			retval = info-&gt;length;
-			goto exit;
-		}
-		break;
-	case CPC_CMD_T_CAN_PRMS:
-		/* Check the controller type. If it's the new CPC-USB, make sure if these are SJA1000 params */
-		if (info-&gt;msg.canparams.cc_type != SJA1000
-		    &amp;&amp; info-&gt;msg.canparams.cc_type != M16C_BASIC
-		    &amp;&amp; (card-&gt;productId == USB_CPCUSB_LPC2119_PRODUCT_ID
-			&amp;&amp; info-&gt;msg.canparams.cc_type != SJA1000)) {
-			/* don't forget to release the urb */
-			atomic_set(&amp;wrUrb-&gt;busy, 0);
-			retval = CPC_ERR_WRONG_CONTROLLER_TYPE;
-			goto exit;
-		}
-		break;
-	}
-
-	/* just convert the params if it is an old CPC-USB with M16C controller */
-	if (card-&gt;productId == USB_CPCUSB_M16C_PRODUCT_ID) {
-		/* if it is a parameter message convert it from SJA1000 controller
-		 * settings to M16C Basic controller settings
-		 */
-		SJA1000_TO_M16C_BASIC_Params((CPC_MSG_T *) &amp;obuf[4]);
-	}
-
-	/* don't forget the byte alignment */
-	cpcusb_align_buffer_alignment(&amp;obuf[4]);
-
-	/* setup a the 4 byte header */
-	obuf[0] = obuf[1] = obuf[2] = obuf[3] = 0;
-
-	/* this urb was already set up, except for this write size */
-	wrUrb-&gt;urb-&gt;transfer_buffer_length = bytes_written + 4;
-
-	/* send the data out the bulk port */
-	/* a character device write uses GFP_KERNEL,
-	   unless a spinlock is held */
-	retval = usb_submit_urb(wrUrb-&gt;urb, GFP_KERNEL);
-	if (retval) {
-		atomic_set(&amp;wrUrb-&gt;busy, 0);	/* release urb */
-		err(&quot;%s - failed submitting write urb, error %d&quot;,
-		    __func__, retval);
-	} else {
-		retval = bytes_written;
-	}
-
-exit:
-	/* unlock the device */
-	up(&amp;card-&gt;sem);
-
-	dbg(&quot;%s - leaved&quot;, __func__);
-
-	return retval;
-}
-
-/*
- * callback for interrupt IN urb
- */
-static void cpcusb_read_interrupt_callback(struct urb *urb)
-{
-	CPC_USB_T *card = (CPC_USB_T *) urb-&gt;context;
-	int retval;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;card-&gt;slock, flags);
-
-	if (!card-&gt;present) {
-		spin_unlock_irqrestore(&amp;card-&gt;slock, flags);
-		info(&quot;%s - no such device&quot;, __func__);
-		return;
-	}
-
-	switch (urb-&gt;status) {
-	case 0: /* success */
-		card-&gt;free_slots = card-&gt;intr_in_buffer[1];
-		break;
-	case -ECONNRESET:
-	case -ENOENT:
-	case -ESHUTDOWN:
-		/* urb was killed */
-		spin_unlock_irqrestore(&amp;card-&gt;slock, flags);
-		dbg(&quot;%s - intr urb killed&quot;, __func__);
-		return;
-	default:
-		info(&quot;%s - nonzero urb status %d&quot;, __func__, urb-&gt;status);
-		break;
-	}
-
-	retval = usb_submit_urb(urb, GFP_ATOMIC);
-	if (retval) {
-		err(&quot;%s - failed resubmitting intr urb, error %d&quot;,
-		    __func__, retval);
-	}
-
-	spin_unlock_irqrestore(&amp;card-&gt;slock, flags);
-	wake_up_interruptible(card-&gt;chan-&gt;CPCWait_q);
-
-	return;
-}
-
-#define UN_SHIFT  1
-#define CPCMSG_HEADER_LEN_FIRMWARE   11
-static inline int cpcusb_unalign_and_copy_buffy(unsigned char *out,
-						unsigned char *in)
-{
-	unsigned int i, j;
-
-	for (i = 0; i &lt; 3; i++)
-		out[i] = in[i];
-
-	for (j = 0; j &lt; (in[1] + (CPCMSG_HEADER_LEN_FIRMWARE - 3)); j++)
-		out[j + i + UN_SHIFT] = in[j + i];
-
-	return i + j;
-}
-
-/*
- * callback for bulk IN urb
- */
-static void cpcusb_read_bulk_callback(struct urb *urb)
-{
-	CPC_USB_T *card = (CPC_USB_T *) urb-&gt;context;
-	CPC_CHAN_T *chan;
-	unsigned char *ibuf = urb-&gt;transfer_buffer;
-	int retval, msgCnt, start, again = 0;
-	unsigned long flags;
-
-	if (!card) {
-		err(&quot;%s - device object lost&quot;, __func__);
-		return;
-	}
-
-	spin_lock_irqsave(&amp;card-&gt;slock, flags);
-
-	if (!card-&gt;present) {
-		spin_unlock_irqrestore(&amp;card-&gt;slock, flags);
-		info(&quot;%s - no such device&quot;, __func__);
-		return;
-	}
-
-	switch (urb-&gt;status) {
-	case 0:		/* success */
-		break;
-	case -ECONNRESET:
-	case -ENOENT:
-	case -ESHUTDOWN:
-		/* urb was killed */
-		spin_unlock_irqrestore(&amp;card-&gt;slock, flags);
-		dbg(&quot;%s - read urb killed&quot;, __func__);
-		return;
-	default:
-		info(&quot;%s - nonzero urb status %d&quot;, __func__, urb-&gt;status);
-		break;
-	}
-
-	if (urb-&gt;actual_length) {
-		msgCnt = ibuf[0] &amp; ~0x80;
-		again = ibuf[0] &amp; 0x80;
-
-		/* we have a 4 byte header */
-		start = 4;
-		chan = card-&gt;chan;
-		while (msgCnt) {
-			if (!(IsBufferFull(card-&gt;chan))) {
-				start +=
-				    cpcusb_unalign_and_copy_buffy((unsigned char *)
-							  &amp;chan-&gt;buf[chan-&gt;iidx], &amp;ibuf[start]);
-
-				if (start &gt; urb-&gt;transfer_buffer_length) {
-					err(&quot;%d &gt; %d&quot;, start, urb-&gt;transfer_buffer_length);
-					break;
-				}
-
-				chan-&gt;WnR = 0;
-				chan-&gt;iidx = (chan-&gt;iidx + 1) % CPC_MSG_BUF_CNT;
-				msgCnt--;
-			} else {
-				break;
-			}
-		}
-	}
-
-	usb_fill_bulk_urb(urb, card-&gt;udev,
-			  usb_rcvbulkpipe(card-&gt;udev, card-&gt;num_bulk_in),
-			  urb-&gt;transfer_buffer,
-			  urb-&gt;transfer_buffer_length,
-			  cpcusb_read_bulk_callback, card);
-
-	retval = usb_submit_urb(urb, GFP_ATOMIC);
-
-	if (retval) {
-		err(&quot;%s - failed resubmitting read urb, error %d&quot;, __func__, retval);
-	}
-
-	spin_unlock_irqrestore(&amp;card-&gt;slock, flags);
-
-	wake_up_interruptible(card-&gt;chan-&gt;CPCWait_q);
-}
-
-/*
- * callback for bulk IN urb
- */
-static void cpcusb_write_bulk_callback(struct urb *urb)
-{
-	CPC_USB_T *card = (CPC_USB_T *) urb-&gt;context;
-	unsigned long flags;
-	int j;
-
-	spin_lock_irqsave(&amp;card-&gt;slock, flags);
-
-	/* find this urb */
-	for (j = 0; j &lt; CPC_USB_URB_CNT; j++) {
-		if (card-&gt;wrUrbs[j].urb == urb) {
-			dbg(&quot;URB found no. %d&quot;, j);
-			/* notify anyone waiting that the write has finished */
-			complete(&amp;card-&gt;wrUrbs[j].finished);
-			atomic_set(&amp;card-&gt;wrUrbs[j].busy, 0);
-			break;
-		}
-	}
-
-	switch (urb-&gt;status) {
-	case 0:		/* success */
-		break;
-	case -ECONNRESET:
-	case -ENOENT:
-	case -ESHUTDOWN:
-		/* urb was killed */
-		spin_unlock_irqrestore(&amp;card-&gt;slock, flags);
-		dbg(&quot;%s - write urb no. %d killed&quot;, __func__, j);
-		return;
-	default:
-		info(&quot;%s - nonzero urb status %d&quot;, __func__, urb-&gt;status);
-		break;
-	}
-
-	spin_unlock_irqrestore(&amp;card-&gt;slock, flags);
-
-	wake_up_interruptible(card-&gt;chan-&gt;CPCWait_q);
-}
-
-static inline int cpcusb_get_free_slot(void)
-{
-	int i;
-
-	for (i = 0; i &lt; CPC_USB_CARD_CNT; i++) {
-		if (!CPCUSB_Table[i])
-			return i;
-	}
-
-	return -1;
-}
-
-/*
- * probe function for new CPC-USB devices
- */
-static int cpcusb_probe(struct usb_interface *interface,
-			const struct usb_device_id *id)
-{
-	CPC_USB_T *card = NULL;
-	CPC_CHAN_T *chan = NULL;
-
-	struct usb_device *udev = interface_to_usbdev(interface);
-	struct usb_host_interface *iface_desc;
-	struct usb_endpoint_descriptor *endpoint;
-
-	int i, j, retval = -ENOMEM, slot;
-
-	slot = cpcusb_get_free_slot();
-	if (slot &lt; 0) {
-		info(&quot;No more devices supported&quot;);
-		return -ENOMEM;
-	}
-
-	/* allocate memory for our device state and initialize it */
-	card = kzalloc(sizeof(CPC_USB_T), GFP_KERNEL);
-	if (!card) {
-		err(&quot;Out of memory&quot;);
-		return -ENOMEM;
-	}
-	CPCUSB_Table[slot] = card;
-
-	/* allocate and initialize the channel struct */
-	card-&gt;chan = kmalloc(sizeof(CPC_CHAN_T), GFP_KERNEL);
-	if (!card-&gt;chan) {
-		kfree(card);
-		err(&quot;Out of memory&quot;);
-		return -ENOMEM;
-	}
-
-	chan = card-&gt;chan;
-	memset(chan, 0, sizeof(CPC_CHAN_T));
-	ResetBuffer(chan);
-
-	init_MUTEX(&amp;card-&gt;sem);
-	spin_lock_init(&amp;card-&gt;slock);
-
-	card-&gt;udev = udev;
-	card-&gt;interface = interface;
-	if (udev-&gt;descriptor.iSerialNumber) {
-		usb_string(udev, udev-&gt;descriptor.iSerialNumber, card-&gt;serialNumber,
-				   128);
-		info(&quot;Serial %s&quot;, card-&gt;serialNumber);
-	}
-
-	card-&gt;productId = udev-&gt;descriptor.idProduct;
-	info(&quot;Product %s&quot;,
-	     card-&gt;productId == USB_CPCUSB_LPC2119_PRODUCT_ID ?
-			 &quot;CPC-USB/ARM7&quot; : &quot;CPC-USB/M16C&quot;);
-
-	/* set up the endpoint information */
-	/* check out the endpoints */
-	/* use only the first bulk-in and bulk-out endpoints */
-	iface_desc = &amp;interface-&gt;altsetting[0];
-	for (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i) {
-		endpoint = &amp;iface_desc-&gt;endpoint[i].desc;
-
-		if (!card-&gt;num_intr_in &amp;&amp;
-		    (endpoint-&gt;bEndpointAddress &amp; USB_DIR_IN) &amp;&amp;
-		    ((endpoint-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)
-		     == USB_ENDPOINT_XFER_INT)) {
-			card-&gt;intr_in_urb = usb_alloc_urb(0, GFP_KERNEL);
-			card-&gt;num_intr_in = 1;
-
-			if (!card-&gt;intr_in_urb) {
-				err(&quot;No free urbs available&quot;);
-				goto error;
-			}
-
-			dbg(&quot;intr_in urb %d&quot;, card-&gt;num_intr_in);
-		}
-
-		if (!card-&gt;num_bulk_in &amp;&amp;
-		    (endpoint-&gt;bEndpointAddress &amp; USB_DIR_IN) &amp;&amp;
-		    ((endpoint-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)
-		     == USB_ENDPOINT_XFER_BULK)) {
-			card-&gt;num_bulk_in = 2;
-			for (j = 0; j &lt; CPC_USB_URB_CNT; j++) {
-				card-&gt;urbs[j].size = endpoint-&gt;wMaxPacketSize;
-				card-&gt;urbs[j].urb = usb_alloc_urb(0, GFP_KERNEL);
-				if (!card-&gt;urbs[j].urb) {
-					err(&quot;No free urbs available&quot;);
-					goto error;
-				}
-				card-&gt;urbs[j].buffer =
-				    usb_buffer_alloc(udev,
-						     card-&gt;urbs[j].size,
-						     GFP_KERNEL,
-						     &amp;card-&gt;urbs[j].urb-&gt;transfer_dma);
-				if (!card-&gt;urbs[j].buffer) {
-					err(&quot;Couldn't allocate bulk_in_buffer&quot;);
-					goto error;
-				}
-			}
-			info(&quot;%s - %d reading URB's allocated&quot;,
-			     __func__, CPC_USB_URB_CNT);
-		}
-
-		if (!card-&gt;num_bulk_out &amp;&amp;
-		    !(endpoint-&gt;bEndpointAddress &amp; USB_DIR_IN) &amp;&amp;
-		    ((endpoint-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)
-		     == USB_ENDPOINT_XFER_BULK)) {
-
-			card-&gt;num_bulk_out = 2;
-
-			for (j = 0; j &lt; CPC_USB_URB_CNT; j++) {
-				card-&gt;wrUrbs[j].size =
-				    endpoint-&gt;wMaxPacketSize;
-				card-&gt;wrUrbs[j].urb =
-				    usb_alloc_urb(0, GFP_KERNEL);
-				if (!card-&gt;wrUrbs[j].urb) {
-					err(&quot;No free urbs available&quot;);
-					goto error;
-				}
-				card-&gt;wrUrbs[j].buffer = usb_buffer_alloc(udev,
-							       card-&gt;wrUrbs[j].size, GFP_KERNEL,
-							       &amp;card-&gt;wrUrbs[j].urb-&gt;transfer_dma);
-
-				if (!card-&gt;wrUrbs[j].buffer) {
-					err(&quot;Couldn't allocate bulk_out_buffer&quot;);
-					goto error;
-				}
-
-				usb_fill_bulk_urb(card-&gt;wrUrbs[j].urb, udev,
-						usb_sndbulkpipe(udev, endpoint-&gt;bEndpointAddress),
-						card-&gt;wrUrbs[j].buffer,
-						card-&gt;wrUrbs[j].size,
-						cpcusb_write_bulk_callback,
-						card);
-			}
-
-			info(&quot;%s - %d writing URB's allocated&quot;, __func__, CPC_USB_URB_CNT);
-		}
-	}
-
-	if (!(card-&gt;num_bulk_in &amp;&amp; card-&gt;num_bulk_out)) {
-		err(&quot;Couldn't find both bulk-in and bulk-out endpoints&quot;);
-		goto error;
-	}
-
-	/* allow device read, write and ioctl */
-	card-&gt;present = 1;
-
-	/* we can register the device now, as it is ready */
-	usb_set_intfdata(interface, card);
-	retval = usb_register_dev(interface, &amp;cpcusb_class);
-
-	if (retval) {
-		/* something prevented us from registering this driver */
-		err(&quot;Not able to get a minor for this device.&quot;);
-		usb_set_intfdata(interface, NULL);
-		goto error;
-	}
-
-	card-&gt;chan-&gt;minor = card-&gt;minor = interface-&gt;minor;
-
-	chan-&gt;buf = vmalloc(sizeof(CPC_MSG_T) * CPC_MSG_BUF_CNT);
-	if (chan-&gt;buf == NULL) {
-		err(&quot;Out of memory&quot;);
-		retval = -ENOMEM;
-		goto error;
-	}
-	info(&quot;Allocated memory for %d messages (%lu kbytes)&quot;,
-	     CPC_MSG_BUF_CNT, (long unsigned int)(sizeof(CPC_MSG_T) * CPC_MSG_BUF_CNT) / 1000);
-	memset(chan-&gt;buf, 0, sizeof(CPC_MSG_T) * CPC_MSG_BUF_CNT);
-
-	ResetBuffer(chan);
-
-	card-&gt;chan-&gt;CPCWait_q = kmalloc(sizeof(wait_queue_head_t), GFP_KERNEL);
-	if (!card-&gt;chan-&gt;CPCWait_q) {
-		err(&quot;Out of memory&quot;);
-		retval = -ENOMEM;
-		goto error;
-	}
-	init_waitqueue_head(card-&gt;chan-&gt;CPCWait_q);
-
-	CPCUSB_Table[slot] = card;
-	card-&gt;idx = slot;
-	CPCUsbCnt++;
-
-	/* let the user know what node this device is now attached to */
-	info(&quot;Device now attached to USB-%d&quot;, card-&gt;minor);
-	return 0;
-
-error:
-	for (j = 0; j &lt; CPC_USB_URB_CNT; j++) {
-		if (card-&gt;urbs[j].buffer) {
-			usb_buffer_free(card-&gt;udev, card-&gt;urbs[j].size,
-					card-&gt;urbs[j].buffer,
-					card-&gt;urbs[j].urb-&gt;transfer_dma);
-			card-&gt;urbs[j].buffer = NULL;
-		}
-		if (card-&gt;urbs[j].urb) {
-			usb_free_urb(card-&gt;urbs[j].urb);
-			card-&gt;urbs[j].urb = NULL;
-		}
-	}
-
-	cpcusb_delete(card);
-	return retval;
-}
-
-/*
- * called by the usb core when the device is removed from the system
- */
-static void cpcusb_disconnect(struct usb_interface *interface)
-{
-	CPC_USB_T *card = NULL;
-	int minor, j;
-
-	/* prevent races with open() */
-	down(&amp;disconnect_sem);
-
-	card = usb_get_intfdata(interface);
-	usb_set_intfdata(interface, NULL);
-
-	down(&amp;card-&gt;sem);
-
-	/* prevent device read, write and ioctl */
-	card-&gt;present = 0;
-
-	minor = card-&gt;minor;
-
-	/* free all urbs and their buffers */
-	for (j = 0; j &lt; CPC_USB_URB_CNT; j++) {
-		/* terminate an ongoing write */
-		if (atomic_read(&amp;card-&gt;wrUrbs[j].busy)) {
-			usb_kill_urb(card-&gt;wrUrbs[j].urb);
-			wait_for_completion(&amp;card-&gt;wrUrbs[j].finished);
-		}
-		usb_buffer_free(card-&gt;udev, card-&gt;wrUrbs[j].size,
-				card-&gt;wrUrbs[j].buffer,
-				card-&gt;wrUrbs[j].urb-&gt;transfer_dma);
-		usb_free_urb(card-&gt;wrUrbs[j].urb);
-	}
-	info(&quot;%d write URBs freed&quot;, CPC_USB_URB_CNT);
-
-	/* free all urbs and their buffers */
-	for (j = 0; j &lt; CPC_USB_URB_CNT; j++) {
-		usb_buffer_free(card-&gt;udev, card-&gt;urbs[j].size,
-				card-&gt;urbs[j].buffer,
-				card-&gt;urbs[j].urb-&gt;transfer_dma);
-		usb_free_urb(card-&gt;urbs[j].urb);
-	}
-	info(&quot;%d read URBs freed&quot;, CPC_USB_URB_CNT);
-	usb_free_urb(card-&gt;intr_in_urb);
-
-	/* give back our minor */
-	usb_deregister_dev(interface, &amp;cpcusb_class);
-
-	up(&amp;card-&gt;sem);
-
-	/* if the device is opened, cpcusb_release will clean this up */
-	if (!card-&gt;open)
-		cpcusb_delete(card);
-	else
-		wake_up_interruptible(card-&gt;chan-&gt;CPCWait_q);
-
-	up(&amp;disconnect_sem);
-
-	CPCUsbCnt--;
-	info(&quot;USB-%d now disconnected&quot;, minor);
-}
-
-static int __init CPCUsb_Init(void)
-{
-	int result, i;
-
-	info(DRIVER_DESC &quot; v&quot; DRIVER_VERSION);
-	info(&quot;Build on &quot; __DATE__ &quot; at &quot; __TIME__);
-
-	for (i = 0; i &lt; CPC_USB_CARD_CNT; i++)
-		CPCUSB_Table[i] = 0;
-
-	/* register this driver with the USB subsystem */
-	result = usb_register(&amp;cpcusb_driver);
-	if (result) {
-		err(&quot;usb_register failed. Error number %d&quot;, result);
-		return result;
-	}
-
-	procDir = proc_mkdir(CPC_USB_PROC_DIR, NULL);
-	if (!procDir) {
-		err(&quot;Could not create proc entry&quot;);
-	} else {
-		procEntry = create_proc_read_entry(&quot;info&quot;, 0444, procDir,
-						   cpcusb_proc_read_info,
-						   NULL);
-		if (!procEntry) {
-			err(&quot;Could not create proc entry %s&quot;, CPC_USB_PROC_DIR &quot;/info&quot;);
-			remove_proc_entry(CPC_USB_PROC_DIR, NULL);
-			procDir = NULL;
-		}
-	}
-
-	return 0;
-}
-
-static void __exit CPCUsb_Exit(void)
-{
-	wait_event(rmmodWq, !atomic_read(&amp;useCount));
-
-	/* deregister this driver with the USB subsystem */
-	usb_deregister(&amp;cpcusb_driver);
-
-	if (procDir) {
-		if (procEntry)
-			remove_proc_entry(&quot;info&quot;, procDir);
-		remove_proc_entry(CPC_USB_PROC_DIR, NULL);
-	}
-}
-
-module_init(CPCUsb_Init);
-module_exit(CPCUsb_Exit);
diff --git a/drivers/staging/cpc-usb/cpc.h b/drivers/staging/cpc-usb/cpc.h
deleted file mode 100644
index ed8cb34..0000000
--- a/drivers/staging/cpc-usb/cpc.h
+++ /dev/null
@@ -1,440 +0,0 @@
-/*
- * CPC CAN Interface Definitions
- *
- * Copyright (C) 2000-2008 EMS Dr. Thomas Wuensche
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- */
-#ifndef CPC_HEADER
-#define CPC_HEADER
-
-// the maximum length of the union members within a CPC_MSG
-// this value can be defined by the customer, but has to be
-// &gt;= 64 bytes
-// however, if not defined before, we set a length of 64 byte
-#if !defined(CPC_MSG_LEN) || (CPC_MSG_LEN &lt; 64)
-#undef CPC_MSG_LEN
-#define CPC_MSG_LEN 64
-#endif
-
-// check the operating system used
-#ifdef _WIN32 // running a Windows OS
-
-// define basic types on Windows platforms
-#ifdef _MSC_VER // Visual Studio
-	typedef unsigned __int8 u8;
-	typedef unsigned __int16 u16;
-	typedef unsigned __int32 u32;
-#else // Borland Compiler
-	typedef unsigned char u8;
-	typedef unsigned short u16;
-	typedef unsigned int u32;
-#endif
-	// on Windows OS we use a byte alignment of 1
-	#pragma pack(push, 1)
-
-	// set the calling conventions for the library function calls
-	#define CALL_CONV __stdcall
-#else
-	// Kernel headers already define this types
-	#ifndef __KERNEL__
-		// define basic types
-		typedef unsigned char u8;
-		typedef unsigned short u16;
-		typedef unsigned int u32;
-	#endif
-
-	// Linux does not use this calling convention
-	#define CALL_CONV
-#endif
-
-// Transmission of events from CPC interfaces to PC can be individually
-// controlled per event type. Default state is: don't transmit
-// Control values are constructed by bit-or of Subject and Action
-// and passed to CPC_Control()
-
-// Control-Values for CPC_Control() Command Subject Selection
-#define CONTR_CAN_Message 0x04
-#define CONTR_Busload	  0x08
-#define	CONTR_CAN_State	  0x0C
-#define	CONTR_SendAck	  0x10
-#define	CONTR_Filter	  0x14
-#define CONTR_CmdQueue    0x18	// reserved, do not use
-#define CONTR_BusError    0x1C
-
-// Control Command Actions
-#define CONTR_CONT_OFF    0
-#define CONTR_CONT_ON     1
-#define CONTR_SING_ON     2
-// CONTR_SING_ON doesn't change CONTR_CONT_ON state, so it should be
-// read as: transmit at least once
-
-// defines for confirmed request
-#define DO_NOT_CONFIRM 0
-#define DO_CONFIRM     1
-
-// event flags
-#define EVENT_READ 0x01
-#define EVENT_WRITE 0x02
-
-// Messages from CPC to PC contain a message object type field.
-// The following message types are sent by CPC and can be used in
-// handlers, others should be ignored.
-#define CPC_MSG_T_RESYNC        0 // Normally to be ignored
-#define CPC_MSG_T_CAN           1 // CAN data frame
-#define CPC_MSG_T_BUSLOAD       2 // Busload message
-#define CPC_MSG_T_STRING        3 // Normally to be ignored
-#define CPC_MSG_T_CONTI         4 // Normally to be ignored
-#define CPC_MSG_T_MEM           7 // Normally not to be handled
-#define	CPC_MSG_T_RTR           8 // CAN remote frame
-#define CPC_MSG_T_TXACK	        9 // Send acknowledge
-#define CPC_MSG_T_POWERUP      10 // Power-up message
-#define	CPC_MSG_T_CMD_NO       11 // Normally to be ignored
-#define	CPC_MSG_T_CAN_PRMS     12 // Actual CAN parameters
-#define	CPC_MSG_T_ABORTED      13 // Command aborted message
-#define	CPC_MSG_T_CANSTATE     14 // CAN state message
-#define CPC_MSG_T_RESET        15 // used to reset CAN-Controller
-#define	CPC_MSG_T_XCAN         16 // XCAN data frame
-#define CPC_MSG_T_XRTR         17 // XCAN remote frame
-#define CPC_MSG_T_INFO         18 // information strings
-#define CPC_MSG_T_CONTROL      19 // used for control of interface/driver behaviour
-#define CPC_MSG_T_CONFIRM      20 // response type for confirmed requests
-#define CPC_MSG_T_OVERRUN      21 // response type for overrun conditions
-#define CPC_MSG_T_KEEPALIVE    22 // response type for keep alive conditions
-#define CPC_MSG_T_CANERROR     23 // response type for bus error conditions
-#define CPC_MSG_T_DISCONNECTED 24 // response type for a disconnected interface
-#define CPC_MSG_T_ERR_COUNTER  25 // RX/TX error counter of CAN controller
-
-#define CPC_MSG_T_FIRMWARE    100 // response type for USB firmware download
-
-// Messages from the PC to the CPC interface contain a command field
-// Most of the command types are wrapped by the library functions and have therefore
-// normally not to be used.
-// However, programmers who wish to circumvent the library and talk directly
-// to the drivers (mainly Linux programmers) can use the following
-// command types:
-
-#define CPC_CMD_T_CAN                 1	// CAN data frame
-#define CPC_CMD_T_CONTROL             3	// used for control of interface/driver behaviour
-#define	CPC_CMD_T_CAN_PRMS            6	// set CAN parameters
-#define	CPC_CMD_T_CLEARBUF            8	// clears input queue; this is depricated, use CPC_CMD_T_CLEAR_MSG_QUEUE instead
-#define	CPC_CMD_T_INQ_CAN_PARMS      11	// inquire actual CAN parameters
-#define	CPC_CMD_T_FILTER_PRMS        12	// set filter parameter
-#define	CPC_CMD_T_RTR                13	// CAN remote frame
-#define	CPC_CMD_T_CANSTATE           14	// CAN state message
-#define	CPC_CMD_T_XCAN               15	// XCAN data frame
-#define CPC_CMD_T_XRTR               16	// XCAN remote frame
-#define CPC_CMD_T_RESET              17	// used to reset CAN-Controller
-#define CPC_CMD_T_INQ_INFO           18	// miscellanous information strings
-#define CPC_CMD_T_OPEN_CHAN          19	// open a channel
-#define CPC_CMD_T_CLOSE_CHAN         20	// close a channel
-#define CPC_CMD_T_CNTBUF             21	// this is depricated, use CPC_CMD_T_INQ_MSG_QUEUE_CNT instead
-#define CPC_CMD_T_CAN_EXIT          200 // exit the CAN (disable interrupts; reset bootrate; reset output_cntr; mode = 1)
-
-#define CPC_CMD_T_INQ_MSG_QUEUE_CNT  CPC_CMD_T_CNTBUF   // inquires the count of elements in the message queue
-#define CPC_CMD_T_INQ_ERR_COUNTER    25	                // request the CAN controllers error counter
-#define	CPC_CMD_T_CLEAR_MSG_QUEUE    CPC_CMD_T_CLEARBUF // clear CPC_MSG queue
-#define	CPC_CMD_T_CLEAR_CMD_QUEUE    28	                // clear CPC_CMD queue
-#define CPC_CMD_T_FIRMWARE          100                 // reserved, must not be used
-#define CPC_CMD_T_USB_RESET         101                 // reserved, must not be used
-#define CPC_CMD_T_WAIT_NOTIFY       102                 // reserved, must not be used
-#define CPC_CMD_T_WAIT_SETUP        103                 // reserved, must not be used
-#define	CPC_CMD_T_ABORT             255                 // Normally not to be used
-
-// definitions for CPC_MSG_T_INFO
-// information sources
-#define CPC_INFOMSG_T_UNKNOWN_SOURCE 0
-#define CPC_INFOMSG_T_INTERFACE      1
-#define CPC_INFOMSG_T_DRIVER         2
-#define CPC_INFOMSG_T_LIBRARY        3
-
-// information types
-#define CPC_INFOMSG_T_UNKNOWN_TYPE   0
-#define CPC_INFOMSG_T_VERSION        1
-#define CPC_INFOMSG_T_SERIAL         2
-
-// definitions for controller types
-#define PCA82C200   1 // Philips basic CAN controller, replaced by SJA1000
-#define SJA1000     2 // Philips basic CAN controller
-#define AN82527     3 // Intel full CAN controller
-#define M16C_BASIC  4 // M16C controller running in basic CAN (not full CAN) mode
-
-// channel open error codes
-#define CPC_ERR_NO_FREE_CHANNEL            -1	// no more free space within the channel array
-#define CPC_ERR_CHANNEL_ALREADY_OPEN       -2	// the channel is already open
-#define CPC_ERR_CHANNEL_NOT_ACTIVE         -3	// access to a channel not active failed
-#define CPC_ERR_NO_DRIVER_PRESENT          -4	// no driver at the location searched by the library
-#define CPC_ERR_NO_INIFILE_PRESENT         -5	// the library could not find the inifile
-#define CPC_ERR_WRONG_PARAMETERS           -6	// wrong parameters in the inifile
-#define CPC_ERR_NO_INTERFACE_PRESENT       -7	// 1. The specified interface is not connected
-						// 2. The interface (mostly CPC-USB) was disconnected upon operation
-#define CPC_ERR_NO_MATCHING_CHANNEL        -8	// the driver couldn't find a matching channel
-#define CPC_ERR_NO_BUFFER_AVAILABLE        -9	// the driver couldn't allocate buffer for messages
-#define CPC_ERR_NO_INTERRUPT               -10	// the requested interrupt couldn't be claimed
-#define CPC_ERR_NO_MATCHING_INTERFACE      -11	// no interface type related to this channel was found
-#define CPC_ERR_NO_RESOURCES               -12	// the requested resources could not be claimed
-#define CPC_ERR_SOCKET                     -13	// error concerning TCP sockets
-
-// init error codes
-#define CPC_ERR_WRONG_CONTROLLER_TYPE      -14	// wrong CAN controller type within initialization
-#define CPC_ERR_NO_RESET_MODE              -15	// the controller could not be set into reset mode
-#define CPC_ERR_NO_CAN_ACCESS              -16	// the CAN controller could not be accessed
-
-// transmit error codes
-#define CPC_ERR_CAN_WRONG_ID               -20	// the provided CAN id is too big
-#define CPC_ERR_CAN_WRONG_LENGTH           -21	// the provided CAN length is too long
-#define CPC_ERR_CAN_NO_TRANSMIT_BUF        -22	// the transmit buffer was occupied
-#define CPC_ERR_CAN_TRANSMIT_TIMEOUT       -23	// The message could not be sent within a
-						// specified time
-
-// other error codes
-#define CPC_ERR_SERVICE_NOT_SUPPORTED      -30	// the requested service is not supported by the interface
-#define CPC_ERR_IO_TRANSFER                -31	// a transmission error down to the driver occurred
-#define CPC_ERR_TRANSMISSION_FAILED        -32	// a transmission error down to the interface occurred
-#define CPC_ERR_TRANSMISSION_TIMEOUT       -33	// a timeout occurred within transmission to the interface
-#define CPC_ERR_OP_SYS_NOT_SUPPORTED       -35	// the operating system is not supported
-#define CPC_ERR_UNKNOWN                    -40	// an unknown error ocurred (mostly IOCTL errors)
-
-#define CPC_ERR_LOADING_DLL                -50	// the library 'cpcwin.dll' could not be loaded
-#define CPC_ERR_ASSIGNING_FUNCTION         -51	// the specified function could not be assigned
-#define CPC_ERR_DLL_INITIALIZATION         -52	// the DLL was not initialized correctly
-#define CPC_ERR_MISSING_LICFILE            -55	// the file containing the licenses does not exist
-#define CPC_ERR_MISSING_LICENSE            -56	// a required license was not found
-
-// CAN state bit values. Ignore any bits not listed
-#define CPC_CAN_STATE_BUSOFF     0x80
-#define CPC_CAN_STATE_ERROR      0x40
-
-// Mask to help ignore undefined bits
-#define CPC_CAN_STATE_MASK       0xc0
-
-// CAN-Message representation in a CPC_MSG
-// Message object type is CPC_MSG_T_CAN or CPC_MSG_T_RTR
-// or CPC_MSG_T_XCAN or CPC_MSG_T_XRTR
-typedef struct CPC_CAN_MSG {
-	u32 id;
-	u8 length;
-	u8 msg[8];
-} CPC_CAN_MSG_T;
-
-
-// representation of the CAN parameters for the PCA82C200 controller
-typedef struct CPC_PCA82C200_PARAMS {
-	u8 acc_code;	// Acceptance-code for receive, Standard: 0
-	u8 acc_mask;	// Acceptance-mask for receive, Standard: 0xff (everything)
-	u8 btr0;	// Bus-timing register 0
-	u8 btr1;	// Bus-timing register 1
-	u8 outp_contr;	// Output-control register
-} CPC_PCA82C200_PARAMS_T;
-
-// representation of the CAN parameters for the SJA1000 controller
-typedef struct CPC_SJA1000_PARAMS {
-	u8 mode;	// enables single or dual acceptance filtering
-	u8 acc_code0;	// Acceptance-code for receive, Standard: 0
-	u8 acc_code1;
-	u8 acc_code2;
-	u8 acc_code3;
-	u8 acc_mask0;	// Acceptance-mask for receive, Standard: 0xff (everything)
-	u8 acc_mask1;
-	u8 acc_mask2;
-	u8 acc_mask3;
-	u8 btr0;	// Bus-timing register 0
-	u8 btr1;	// Bus-timing register 1
-	u8 outp_contr;	// Output-control register
-} CPC_SJA1000_PARAMS_T;
-
-// representation of the CAN parameters for the M16C controller
-// in basic CAN mode (means no full CAN)
-typedef struct CPC_M16C_BASIC_PARAMS {
-	u8 con0;
-	u8 con1;
-	u8 ctlr0;
-	u8 ctlr1;
-	u8 clk;
-	u8 acc_std_code0;
-	u8 acc_std_code1;
-	u8 acc_ext_code0;
-	u8 acc_ext_code1;
-	u8 acc_ext_code2;
-	u8 acc_ext_code3;
-	u8 acc_std_mask0;
-	u8 acc_std_mask1;
-	u8 acc_ext_mask0;
-	u8 acc_ext_mask1;
-	u8 acc_ext_mask2;
-	u8 acc_ext_mask3;
-} CPC_M16C_BASIC_PARAMS_T;
-
-// CAN params message representation
-typedef struct CPC_CAN_PARAMS {
-	u8 cc_type;	// represents the controller type
-	union {
-		CPC_M16C_BASIC_PARAMS_T m16c_basic;
-		CPC_SJA1000_PARAMS_T sja1000;
-		CPC_PCA82C200_PARAMS_T pca82c200;
-	} cc_params;
-} CPC_CAN_PARAMS_T;
-
-// the following structures are slightly different for Windows and Linux
-// To be able to use the 'Select' mechanism with Linux the application
-// needs to know the devices file desciptor.
-// This mechanism is not implemented within Windows and the file descriptor
-// is therefore not needed
-#ifdef _WIN32
-
-// CAN init params message representation
-typedef struct CPC_INIT_PARAMS {
-	CPC_CAN_PARAMS_T canparams;
-} CPC_INIT_PARAMS_T;
-
-#else// Linux
-
-// CHAN init params representation
-typedef struct CPC_CHAN_PARAMS {
-	int fd;
-} CPC_CHAN_PARAMS_T;
-
-// CAN init params message representation
-typedef struct CPC_INIT_PARAMS {
-	CPC_CHAN_PARAMS_T chanparams;
-	CPC_CAN_PARAMS_T canparams;
-} CPC_INIT_PARAMS_T;
-
-#endif
-
-// structure for confirmed message handling
-typedef struct CPC_CONFIRM {
-	u8 result; // error code
-} CPC_CONFIRM_T;
-
-// structure for information requests
-typedef struct CPC_INFO {
-	u8 source;                 // interface, driver or library
-	u8 type;                   // version or serial number
-	char msg[CPC_MSG_LEN - 2]; // string holding the requested information
-} CPC_INFO_T;
-
-// OVERRUN ///////////////////////////////////////
-// In general two types of overrun may occur.
-// A hardware overrun, where the CAN controller
-// lost a message, because the interrupt was
-// not handled before the next messgae comes in.
-// Or a software overrun, where i.e. a received
-// message could not be stored in the CPC_MSG
-// buffer.
-
-// After a software overrun has occurred
-// we wait until we have CPC_OVR_GAP slots
-// free in the CPC_MSG buffer.
-#define CPC_OVR_GAP               10
-
-// Two types of software overrun may occur.
-// A received CAN message or a CAN state event
-// can cause an overrun.
-// Note: A CPC_CMD which would normally store
-// its result immediately in the CPC_MSG
-// queue may fail, because the message queue is full.
-// This will not generate an overrun message, but
-// will halt command execution, until this command
-// is able to store its message in the message queue.
-#define CPC_OVR_EVENT_CAN       0x01
-#define CPC_OVR_EVENT_CANSTATE  0x02
-#define CPC_OVR_EVENT_BUSERROR  0x04
-
-// If the CAN controller lost a message
-// we indicate it with the highest bit
-// set in the count field.
-#define CPC_OVR_HW              0x80
-
-// structure for overrun conditions
-typedef struct {
-	u8 event;
-	u8 count;
-} CPC_OVERRUN_T;
-
-// CAN errors ////////////////////////////////////
-// Each CAN controller type has different
-// registers to record errors.
-// Therefor a structure containing the specific
-// errors is set up for each controller here
-
-// SJA1000 error structure
-// see the SJA1000 datasheet for detailed
-// explanation of the registers
-typedef struct CPC_SJA1000_CAN_ERROR {
-	u8 ecc;   // error capture code register
-	u8 rxerr; // RX error counter register
-	u8 txerr; // TX error counter register
-} CPC_SJA1000_CAN_ERROR_T;
-
-// M16C error structure
-// see the M16C datasheet for detailed
-// explanation of the registers
-typedef struct CPC_M16C_CAN_ERROR {
-	u8 tbd;	// to be defined
-} CPC_M16C_CAN_ERROR_T;
-
-// structure for CAN error conditions
-#define  CPC_CAN_ECODE_ERRFRAME   0x01
-typedef struct CPC_CAN_ERROR {
-	u8 ecode;
-	struct {
-		u8 cc_type; // CAN controller type
-		union {
-			CPC_SJA1000_CAN_ERROR_T sja1000;
-			CPC_M16C_CAN_ERROR_T m16c;
-		} regs;
-	} cc;
-} CPC_CAN_ERROR_T;
-
-// Structure containing RX/TX error counter.
-// This structure is used to request the
-// values of the CAN controllers TX and RX
-// error counter.
-typedef struct CPC_CAN_ERR_COUNTER {
-	u8 rx;
-	u8 tx;
-} CPC_CAN_ERR_COUNTER_T;
-
-// If this flag is set, transmissions from PC to CPC are protected against loss
-#define CPC_SECURE_TO_CPC	0x01
-
-// If this flag is set, transmissions from CPC to PC are protected against loss
-#define CPC_SECURE_TO_PC	0x02
-
-// If this flag is set, the CAN-transmit buffer is checked to be free before sending a message
-#define CPC_SECURE_SEND		0x04
-
-// If this flag is set, the transmission complete flag is checked
-// after sending a message
-// THIS IS CURRENTLY ONLY IMPLEMENTED IN THE PASSIVE INTERFACE DRIVERS
-#define CPC_SECURE_TRANSMIT	0x08
-
-// main message type used between library and application
-typedef struct CPC_MSG {
-	u8 type;	// type of message
-	u8 length;	// length of data within union 'msg'
-	u8 msgid;	// confirmation handle
-	u32 ts_sec;	// timestamp in seconds
-	u32 ts_nsec;	// timestamp in nano seconds
-	union {
-		u8 generic[CPC_MSG_LEN];
-		CPC_CAN_MSG_T canmsg;
-		CPC_CAN_PARAMS_T canparams;
-		CPC_CONFIRM_T confirmation;
-		CPC_INFO_T info;
-		CPC_OVERRUN_T overrun;
-		CPC_CAN_ERROR_T error;
-		CPC_CAN_ERR_COUNTER_T err_counter;
-		u8 busload;
-		u8 canstate;
-	} msg;
-} CPC_MSG_T;
-
-#ifdef _WIN32
-#pragma pack(pop)		// reset the byte alignment
-#endif
-
-#endif				// CPC_HEADER
diff --git a/drivers/staging/cpc-usb/cpc_int.h b/drivers/staging/cpc-usb/cpc_int.h
deleted file mode 100644
index a0d60c0..0000000
--- a/drivers/staging/cpc-usb/cpc_int.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * CPCLIB
- *
- * Copyright (C) 2000-2008 EMS Dr. Thomas Wuensche
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *
- */
-#ifndef CPC_INT_H
-#define CPC_INT_H
-
-#include &lt;linux/wait.h&gt;
-
-#define CPC_MSG_BUF_CNT	1500
-
-#define CPC_PROC_DIR &quot;driver/&quot;
-
-#undef dbg
-#undef err
-#undef info
-
-/* Use our own dbg macro */
-#define dbg(format, arg...) do { if (debug) printk( KERN_INFO format &quot;\n&quot; , ## arg); } while (0)
-#define err(format, arg...) do { printk( KERN_INFO &quot;ERROR &quot; format &quot;\n&quot; , ## arg); } while (0)
-#define info(format, arg...) do { printk( KERN_INFO format &quot;\n&quot; , ## arg); } while (0)
-
-/* Macros help using of our buffers */
-#define IsBufferFull(x)     (!(x)-&gt;WnR) &amp;&amp; ((x)-&gt;iidx == (x)-&gt;oidx)
-#define IsBufferEmpty(x)    ((x)-&gt;WnR) &amp;&amp; ((x)-&gt;iidx == (x)-&gt;oidx)
-#define IsBufferNotEmpty(x) (!(x)-&gt;WnR) || ((x)-&gt;iidx != (x)-&gt;oidx)
-#define ResetBuffer(x)      do { (x)-&gt;oidx = (x)-&gt;iidx=0; (x)-&gt;WnR = 1; } while(0);
-
-#define CPC_BufWriteAllowed ((chan-&gt;oidx != chan-&gt;iidx) || chan-&gt;WnR)
-
-typedef void (*chan_write_byte_t) (void *chan, unsigned int reg,
-				   unsigned char val);
-typedef unsigned char (*chan_read_byte_t) (void *chan, unsigned int reg);
-
-typedef struct CPC_CHAN {
-	void __iomem * canBase;	// base address of SJA1000
-	chan_read_byte_t read_byte;	// CAN controller read access routine
-	chan_write_byte_t write_byte;	// CAN controller write access routine
-	CPC_MSG_T *buf;		// buffer for CPC msg
-	unsigned int iidx;
-	unsigned int oidx;
-	unsigned int WnR;
-	unsigned int minor;
-	unsigned int locked;
-	unsigned int irqDisabled;
-
-	unsigned char cpcCtrlCANMessage;
-	unsigned char cpcCtrlCANState;
-	unsigned char cpcCtrlBUSState;
-
-	unsigned char controllerType;
-
-	unsigned long ovrTimeSec;
-	unsigned long ovrTimeNSec;
-	unsigned long ovrLockedBuffer;
-	CPC_OVERRUN_T ovr;
-
-	/* for debugging only */
-	unsigned int handledIrqs;
-	unsigned int lostMessages;
-
-	unsigned int sentStdCan;
-	unsigned int sentExtCan;
-	unsigned int sentStdRtr;
-	unsigned int sentExtRtr;
-
-	unsigned int recvStdCan;
-	unsigned int recvExtCan;
-	unsigned int recvStdRtr;
-	unsigned int recvExtRtr;
-
-	wait_queue_head_t *CPCWait_q;
-
-	void *private;
-} CPC_CHAN_T;
-
-#endif
diff --git a/drivers/staging/cpc-usb/cpcusb.h b/drivers/staging/cpc-usb/cpcusb.h
deleted file mode 100644
index e5273dd..0000000
--- a/drivers/staging/cpc-usb/cpcusb.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/* Header for CPC-USB Driver ********************
- * Copyright 1999, 2000, 2001
- *
- * Company:  EMS Dr. Thomas Wuensche
- *           Sonnenhang 3
- *           85304 Ilmmuenster
- *           Phone: +49-8441-490260
- *           Fax:   +49-8441-81860
- *           email: <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">support at ems-wuensche.com</A>
- *           WWW:   www.ems-wuensche.com
- */
-
-#ifndef CPCUSB_H
-#define CPCUSB_H
-
-#undef err
-#undef dbg
-#undef info
-
-/* Use our own dbg macro */
-#define dbg(format, arg...) do { if (debug) printk(KERN_INFO &quot;CPC-USB: &quot; format &quot;\n&quot; , ## arg); } while (0)
-#define info(format, arg...) do { printk(KERN_INFO &quot;CPC-USB: &quot; format &quot;\n&quot; , ## arg); } while (0)
-#define err(format, arg...) do { printk(KERN_INFO &quot;CPC-USB(ERROR): &quot; format &quot;\n&quot; , ## arg); } while (0)
-
-#define CPC_USB_CARD_CNT      4
-
-typedef struct CPC_USB_READ_URB {
-	unsigned char *buffer;	/* the buffer to send data */
-	size_t size;		/* the size of the send buffer */
-	struct urb *urb;	/* the urb used to send data */
-} CPC_USB_READ_URB_T;
-
-typedef struct CPC_USB_WRITE_URB {
-	unsigned char *buffer;	/* the buffer to send data */
-	size_t size;		/* the size of the send buffer */
-	struct urb *urb;	/* the urb used to send data */
-	atomic_t busy;		/* true if write urb is busy */
-	struct completion finished;	/* wait for the write to finish */
-} CPC_USB_WRITE_URB_T;
-
-#define CPC_USB_URB_CNT  10
-
-typedef struct CPC_USB {
-	struct usb_device *udev;	/* save off the usb device pointer */
-	struct usb_interface *interface;	/* the interface for this device */
-	unsigned char minor;	/* the starting minor number for this device */
-	unsigned char num_ports;	/* the number of ports this device has */
-	int num_intr_in;	/* number of interrupt in endpoints we have */
-	int num_bulk_in;	/* number of bulk in endpoints we have */
-	int num_bulk_out;	/* number of bulk out endpoints we have */
-
-	CPC_USB_READ_URB_T urbs[CPC_USB_URB_CNT];
-
-	unsigned char intr_in_buffer[4];	/* interrupt transfer buffer */
-	struct urb *intr_in_urb;	/* interrupt transfer urb */
-
-	CPC_USB_WRITE_URB_T wrUrbs[CPC_USB_URB_CNT];
-
-	int open;		/* if the port is open or not */
-	int present;		/* if the device is not disconnected */
-	struct semaphore sem;	/* locks this structure */
-
-	int free_slots;		/* free send slots of CPC-USB */
-	int idx;
-
-	spinlock_t slock;
-
-	char serialNumber[128];	/* serial number */
-	int productId;		/* product id to differ between M16C and LPC2119 */
-	CPC_CHAN_T *chan;
-} CPC_USB_T;
-
-#define CPCTable               CPCUSB_Table
-
-#define CPC_DRIVER_VERSION &quot;0.724&quot;
-#define CPC_DRIVER_SERIAL  &quot;not applicable&quot;
-
-#define OBUF_SIZE 255		// 4096
-
-/* read timeouts -- RD_NAK_TIMEOUT * RD_EXPIRE = Number of seconds */
-#define RD_NAK_TIMEOUT (10*HZ)	/* Default number of X seconds to wait */
-#define RD_EXPIRE 12		/* Number of attempts to wait X seconds */
-
-#define CPC_USB_BASE_MNR 0	/* CPC-USB start at minor 0  */
-
-#endif
diff --git a/drivers/staging/cpc-usb/sja2m16c.h b/drivers/staging/cpc-usb/sja2m16c.h
deleted file mode 100644
index 654bd3f..0000000
--- a/drivers/staging/cpc-usb/sja2m16c.h
+++ /dev/null
@@ -1,41 +0,0 @@
-#ifndef _SJA2M16C_H
-#define _SJA2M16C_H
-
-#include &quot;cpc.h&quot;
-
-#define BAUDRATE_TOLERANCE_PERCENT	1
-#define SAMPLEPOINT_TOLERANCE_PERCENT	5
-#define SAMPLEPOINT_UPPER_LIMIT		88
-
-/* M16C parameters */
-struct FIELD_C0CONR {
-	unsigned int brp:4;
-	unsigned int sam:1;
-	unsigned int pr:3;
-	unsigned int dummy:8;
-};
-struct FIELD_C1CONR {
-	unsigned int ph1:3;
-	unsigned int ph2:3;
-	unsigned int sjw:2;
-	unsigned int dummy:8;
-};
-typedef union C0CONR {
-	unsigned char c0con;
-	struct FIELD_C0CONR bc0con;
-} C0CONR_T;
-typedef union C1CONR {
-	unsigned char c1con;
-	struct FIELD_C1CONR bc1con;
-} C1CONR_T;
-
-#define SJA_TSEG1	((pParams-&gt;btr1 &amp; 0x0f)+1)
-#define SJA_TSEG2	(((pParams-&gt;btr1 &amp; 0x70)&gt;&gt;4)+1)
-#define SJA_BRP		((pParams-&gt;btr0 &amp; 0x3f)+1)
-#define SJA_SJW		((pParams-&gt;btr0 &amp; 0xc0)&gt;&gt;6)
-#define SJA_SAM		((pParams-&gt;btr1 &amp; 0x80)&gt;&gt;7)
-int baudrate_m16c(int clk, int brp, int pr, int ph1, int ph2);
-int samplepoint_m16c(int brp, int pr, int ph1, int ph2);
-int SJA1000_TO_M16C_BASIC_Params(CPC_MSG_T *pMsg);
-
-#endif
diff --git a/drivers/staging/cpc-usb/sja2m16c_2.c b/drivers/staging/cpc-usb/sja2m16c_2.c
deleted file mode 100644
index bf0230f..0000000
--- a/drivers/staging/cpc-usb/sja2m16c_2.c
+++ /dev/null
@@ -1,452 +0,0 @@
-/****************************************************************************
-*
-*      Copyright (c) 2003,2004 by EMS Dr. Thomas Wuensche
-*
-*                  - All rights reserved -
-*
-* This code is provided &quot;as is&quot; without warranty of any kind, either
-* expressed or implied, including but not limited to the liability
-* concerning the freedom from material defects, the fitness for parti-
-* cular purposes or the freedom of proprietary rights of third parties.
-*
-*****************************************************************************
-* Module name.: cpcusb
-*****************************************************************************
-* Include file: cpc.h
-*****************************************************************************
-* Project.....: Windows Driver Development Kit
-* Filename....: sja2m16c.cpp
-* Authors.....: (GU) Gerhard Uttenthaler
-*               (CS) Christian Schoett
-*****************************************************************************
-* Short descr.: converts baudrate between SJA1000 and M16C
-*****************************************************************************
-* Description.: handles the baudrate conversion from SJA1000 parameters to
-*               M16C parameters
-*****************************************************************************
-* Address     : EMS Dr. Thomas Wuensche
-*               Sonnenhang 3
-*               D-85304 Ilmmuenster
-*               Tel. : +49-8441-490260
-*               Fax. : +49-8441-81860
-*               email: <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">support at ems-wuensche.com</A>
-*****************************************************************************
-*                            History
-*****************************************************************************
-* Version  Date        Auth Remark
-*
-* 01.00    ??          GU   - initial release
-* 01.10    ??????????  CS   - adapted to fit into the USB Windows driver
-* 02.00    18.08.2004  GU   - improved the baudrate calculating algorithm
-*                           - implemented acceptance filtering
-* 02.10    10.09.2004  CS   - adapted to fit into the USB Windows driver
-*****************************************************************************
-*                            ToDo's
-*****************************************************************************
-*/
-
-/****************************************************************************/
-/*     I N C L U D E S
-*/
-#include &lt;linux/kernel.h&gt;
-#include &lt;linux/errno.h&gt;
-#include &lt;linux/init.h&gt;
-#include &lt;linux/slab.h&gt;
-#include &lt;linux/vmalloc.h&gt;
-#include &lt;linux/module.h&gt;
-#include &lt;linux/poll.h&gt;
-#include &lt;linux/smp_lock.h&gt;
-#include &lt;linux/completion.h&gt;
-#include &lt;asm/uaccess.h&gt;
-#include &lt;linux/usb.h&gt;
-
-#include &quot;cpc.h&quot;
-#include &quot;cpc_int.h&quot;
-#include &quot;cpcusb.h&quot;
-
-#include &quot;sja2m16c.h&quot;
-
-/*********************************************************************/
-int baudrate_m16c(int clk, int brp, int pr, int ph1, int ph2)
-{
-	return (16000000 / (1 &lt;&lt; clk)) / 2 / (brp + 1) / (1 + pr + 1 +
-							    ph1 + 1 + ph2 +
-							    1);
-}
-
-
-/*********************************************************************/
-int samplepoint_m16c(int brp, int pr, int ph1, int ph2)
-{
-	return (100 * (1 + pr + 1 + ph1 + 1)) / (1 + pr + 1 + ph1 + 1 +
-						  ph2 + 1);
-}
-
-
-/****************************************************************************
-* Function.....: SJA1000_TO_M16C_BASIC_Params
-*
-* Task.........: This routine converts SJA1000 CAN btr parameters into M16C
-*                parameters based on the sample point and the error. In
-*                addition it converts the acceptance filter parameters to
-*                suit the M16C parameters
-*
-* Parameters...: None
-*
-* Return values: None
-*
-* Comments.....:
-*****************************************************************************
-*                History
-*****************************************************************************
-* 19.01.2005  CS   - modifed the conversion of SJA1000 filter params into
-*                    M16C params. Due to compatibility reasons with the
-*                    older 82C200 CAN controller the SJA1000
-****************************************************************************/
-int SJA1000_TO_M16C_BASIC_Params(CPC_MSG_T * in)
-{
-	int sjaBaudrate;
-	int sjaSamplepoint;
-	int *baudrate_error;	// BRP[0..15], PR[0..7], PH1[0..7], PH2[0..7]
-	int *samplepoint_error;	// BRP[0..15], PR[0..7], PH1[0..7], PH2[0..7]
-	int baudrate_error_merk;
-	int clk, brp, pr, ph1, ph2;
-	int clk_merk, brp_merk, pr_merk, ph1_merk, ph2_merk;
-	int index;
-	unsigned char acc_code0, acc_code1, acc_code2, acc_code3;
-	unsigned char acc_mask0, acc_mask1, acc_mask2, acc_mask3;
-	CPC_MSG_T * out;
-	C0CONR_T c0con;
-	C1CONR_T c1con;
-	int tmpAccCode;
-	int tmpAccMask;
-
-	    // we have to convert the parameters into M16C parameters
-	    CPC_SJA1000_PARAMS_T * pParams;
-
-	    // check if the type is CAN parameters and if we have to convert the given params
-	    if (in-&gt;type != CPC_CMD_T_CAN_PRMS
-		|| in-&gt;msg.canparams.cc_type != SJA1000)
-		return 0;
-	pParams =
-	    (CPC_SJA1000_PARAMS_T *) &amp; in-&gt;msg.canparams.cc_params.sja1000;
-	acc_code0 = pParams-&gt;acc_code0;
-	acc_code1 = pParams-&gt;acc_code1;
-	acc_code2 = pParams-&gt;acc_code2;
-	acc_code3 = pParams-&gt;acc_code3;
-	acc_mask0 = pParams-&gt;acc_mask0;
-	acc_mask1 = pParams-&gt;acc_mask1;
-	acc_mask2 = pParams-&gt;acc_mask2;
-	acc_mask3 = pParams-&gt;acc_mask3;
-
-#ifdef _DEBUG_OUTPUT_CAN_PARAMS
-	    info(&quot;acc_code0: %2.2Xh\n&quot;, acc_code0);
-	info(&quot;acc_code1: %2.2Xh\n&quot;, acc_code1);
-	info(&quot;acc_code2: %2.2Xh\n&quot;, acc_code2);
-	info(&quot;acc_code3: %2.2Xh\n&quot;, acc_code3);
-	info(&quot;acc_mask0: %2.2Xh\n&quot;, acc_mask0);
-	info(&quot;acc_mask1: %2.2Xh\n&quot;, acc_mask1);
-	info(&quot;acc_mask2: %2.2Xh\n&quot;, acc_mask2);
-	info(&quot;acc_mask3: %2.2Xh\n&quot;, acc_mask3);
-
-#endif	/*  */
-	    if (!
-		 (baudrate_error =
-		  (int *) vmalloc(sizeof(int) * 16 * 8 * 8 * 8 * 5))) {
-		err(&quot;Could not allocate memory\n&quot;);
-		return -3;
-	}
-	if (!
-	      (samplepoint_error =
-	       (int *) vmalloc(sizeof(int) * 16 * 8 * 8 * 8 * 5))) {
-		err(&quot;Could not allocate memory\n&quot;);
-		vfree(baudrate_error);
-		return -3;
-	}
-	memset(baudrate_error, 0xff, sizeof(baudrate_error));
-	memset(samplepoint_error, 0xff, sizeof(baudrate_error));
-	sjaBaudrate =
-	    16000000 / 2 / SJA_BRP / (1 + SJA_TSEG1 + SJA_TSEG2);
-	sjaSamplepoint =
-	    100 * (1 + SJA_TSEG1) / (1 + SJA_TSEG1 + SJA_TSEG2);
-	if (sjaBaudrate == 0) {
-		vfree(baudrate_error);
-		vfree(samplepoint_error);
-		return -2;
-	}
-
-#ifdef _DEBUG_OUTPUT_CAN_PARAMS
-	    info(&quot;\nStarting SJA CAN params\n&quot;);
-	info(&quot;-------------------------\n&quot;);
-	info(&quot;TS1     : %2.2Xh TS2 : %2.2Xh\n&quot;, SJA_TSEG1, SJA_TSEG2);
-	info(&quot;BTR0    : %2.2Xh BTR1: %2.2Xh\n&quot;, pParams-&gt;btr0,
-	      pParams-&gt;btr1);
-	info(&quot;Baudrate: %d.%dkBaud\n&quot;, sjaBaudrate / 1000,
-	      sjaBaudrate % 1000);
-	info(&quot;Sample P: 0.%d\n&quot;, sjaSamplepoint);
-	info(&quot;\n&quot;);
-
-#endif	/*  */
-	    c0con.bc0con.sam = SJA_SAM;
-	c1con.bc1con.sjw = SJA_SJW;
-
-	    // calculate errors for all baudrates
-	    index = 0;
-	for (clk = 0; clk &lt; 5; clk++) {
-		for (brp = 0; brp &lt; 16; brp++) {
-			for (pr = 0; pr &lt; 8; pr++) {
-				for (ph1 = 0; ph1 &lt; 8; ph1++) {
-					for (ph2 = 0; ph2 &lt; 8; ph2++) {
-						baudrate_error[index] =
-						    100 *
-						    abs(baudrate_m16c
-							(clk, brp, pr, ph1,
-							 ph2) -
-							sjaBaudrate) /
-						    sjaBaudrate;
-						samplepoint_error[index] =
-						    abs(samplepoint_m16c
-							(brp, pr, ph1,
-							 ph2) -
-							sjaSamplepoint);
-
-#if 0
-						    info
-						    (&quot;Baudrate      : %d kBaud\n&quot;,
-						     baudrate_m16c(clk,
-								   brp, pr,
-								   ph1,
-								   ph2));
-						info
-						    (&quot;Baudrate Error: %d\n&quot;,
-						     baudrate_error
-						     [index]);
-						info
-						    (&quot;Sample P Error: %d\n&quot;,
-						     samplepoint_error
-						     [index]);
-						info
-						    (&quot;clk           : %d\n&quot;,
-						     clk);
-
-#endif	/*  */
-						    index++;
-					}
-				}
-			}
-		}
-	}
-
-	    // mark all baudrate_error entries which are outer limits
-	    index = 0;
-	for (clk = 0; clk &lt; 5; clk++) {
-		for (brp = 0; brp &lt; 16; brp++) {
-			for (pr = 0; pr &lt; 8; pr++) {
-				for (ph1 = 0; ph1 &lt; 8; ph1++) {
-					for (ph2 = 0; ph2 &lt; 8; ph2++) {
-						if ((baudrate_error[index]
-						      &gt;
-						      BAUDRATE_TOLERANCE_PERCENT)
-						     ||
-						     (samplepoint_error
-						       [index] &gt;
-						       SAMPLEPOINT_TOLERANCE_PERCENT)
-						     ||
-						     (samplepoint_m16c
-						       (brp, pr, ph1,
-							ph2) &gt;
-						       SAMPLEPOINT_UPPER_LIMIT))
-						{
-							baudrate_error
-							    [index] = -1;
-						} else
-						    if (((1 + pr + 1 +
-							  ph1 + 1 + ph2 +
-							  1) &lt; 8)
-							||
-							((1 + pr + 1 +
-							  ph1 + 1 + ph2 +
-							  1) &gt; 25)) {
-							baudrate_error
-							    [index] = -1;
-						}
-
-#if 0
-						    else {
-							info
-							    (&quot;Baudrate      : %d kBaud\n&quot;,
-							     baudrate_m16c
-							     (clk, brp, pr,
-							      ph1, ph2));
-							info
-							    (&quot;Baudrate Error: %d\n&quot;,
-							     baudrate_error
-							     [index]);
-							info
-							    (&quot;Sample P Error: %d\n&quot;,
-							     samplepoint_error
-							     [index]);
-						}
-
-#endif	/*  */
-						    index++;
-					}
-				}
-			}
-		}
-	}
-
-	    // find list of minimum of baudrate_error within unmarked entries
-	    clk_merk = brp_merk = pr_merk = ph1_merk = ph2_merk = 0;
-	baudrate_error_merk = 100;
-	index = 0;
-	for (clk = 0; clk &lt; 5; clk++) {
-		for (brp = 0; brp &lt; 16; brp++) {
-			for (pr = 0; pr &lt; 8; pr++) {
-				for (ph1 = 0; ph1 &lt; 8; ph1++) {
-					for (ph2 = 0; ph2 &lt; 8; ph2++) {
-						if (baudrate_error[index]
-						     != -1) {
-							if (baudrate_error
-							     [index] &lt;
-							     baudrate_error_merk)
-							{
-								baudrate_error_merk
-								    =
-								    baudrate_error
-								    [index];
-								brp_merk =
-								    brp;
-								pr_merk =
-								    pr;
-								ph1_merk =
-								    ph1;
-								ph2_merk =
-								    ph2;
-								clk_merk =
-								    clk;
-
-#if 0
-								    info
-								    (&quot;brp: %2.2Xh pr: %2.2Xh ph1: %2.2Xh ph2: %2.2Xh\n&quot;,
-								     brp,
-								     pr,
-								     ph1,
-								     ph2);
-								info
-								    (&quot;Baudrate      : %d kBaud\n&quot;,
-								     baudrate_m16c
-								     (clk,
-								      brp,
-								      pr,
-								      ph1,
-								      ph2));
-								info
-								    (&quot;Baudrate Error: %d\n&quot;,
-								     baudrate_error
-								     [index]);
-								info
-								    (&quot;Sample P Error: %d\n&quot;,
-								     samplepoint_error
-								     [index]);
-
-#endif	/*  */
-							}
-						}
-						index++;
-					}
-				}
-			}
-		}
-	}
-	if (baudrate_error_merk == 100) {
-		info(&quot;ERROR: Could not convert CAN init parameter\n&quot;);
-		vfree(baudrate_error);
-		vfree(samplepoint_error);
-		return -1;
-	}
-
-	    // setting m16c CAN parameter
-	    c0con.bc0con.brp = brp_merk;
-	c0con.bc0con.pr = pr_merk;
-	c1con.bc1con.ph1 = ph1_merk;
-	c1con.bc1con.ph2 = ph2_merk;
-
-#ifdef _DEBUG_OUTPUT_CAN_PARAMS
-	    info(&quot;\nResulting M16C CAN params\n&quot;);
-	info(&quot;-------------------------\n&quot;);
-	info(&quot;clk     : %2.2Xh\n&quot;, clk_merk);
-	info(&quot;ph1     : %2.2Xh ph2: %2.2Xh\n&quot;, c1con.bc1con.ph1 + 1,
-	      c1con.bc1con.ph2 + 1);
-	info(&quot;pr      : %2.2Xh brp: %2.2Xh\n&quot;, c0con.bc0con.pr + 1,
-	      c0con.bc0con.brp + 1);
-	info(&quot;sjw     : %2.2Xh sam: %2.2Xh\n&quot;, c1con.bc1con.sjw,
-	      c0con.bc0con.sam);
-	info(&quot;co1     : %2.2Xh co0: %2.2Xh\n&quot;, c1con.c1con, c0con.c0con);
-	info(&quot;Baudrate: %d.%dBaud\n&quot;,
-	       baudrate_m16c(clk_merk, c0con.bc0con.brp, c0con.bc0con.pr,
-			     c1con.bc1con.ph1, c1con.bc1con.ph2) / 1000,
-	       baudrate_m16c(clk_merk, c0con.bc0con.brp, c0con.bc0con.pr,
-			      c1con.bc1con.ph1, c1con.bc1con.ph2) % 1000);
-	info(&quot;Sample P: 0.%d\n&quot;,
-	      samplepoint_m16c(c0con.bc0con.brp, c0con.bc0con.pr,
-			       c1con.bc1con.ph1, c1con.bc1con.ph2));
-	info(&quot;\n&quot;);
-
-#endif	/*  */
-	    out = in;
-	out-&gt;type = 6;
-	out-&gt;length = sizeof(CPC_M16C_BASIC_PARAMS_T) + 1;
-	out-&gt;msg.canparams.cc_type = M16C_BASIC;
-	out-&gt;msg.canparams.cc_params.m16c_basic.con0 = c0con.c0con;
-	out-&gt;msg.canparams.cc_params.m16c_basic.con1 = c1con.c1con;
-	out-&gt;msg.canparams.cc_params.m16c_basic.ctlr0 = 0x4C;
-	out-&gt;msg.canparams.cc_params.m16c_basic.ctlr1 = 0x00;
-	out-&gt;msg.canparams.cc_params.m16c_basic.clk = clk_merk;
-	out-&gt;msg.canparams.cc_params.m16c_basic.acc_std_code0 =
-	    acc_code0;
-	out-&gt;msg.canparams.cc_params.m16c_basic.acc_std_code1 = acc_code1;
-
-//      info(&quot;code0: 0x%2.2X, code1: 0x%2.2X\n&quot;, out-&gt;msg.canparams.cc_params.m16c_basic.acc_std_code0, out-&gt;msg.canparams.cc_params.m16c_basic.acc_std_code1);
-	    tmpAccCode = (acc_code1 &gt;&gt; 5) + (acc_code0 &lt;&lt; 3);
-	out-&gt;msg.canparams.cc_params.m16c_basic.acc_std_code0 =
-	    (unsigned char) tmpAccCode;
-	out-&gt;msg.canparams.cc_params.m16c_basic.acc_std_code1 =
-	    (unsigned char) (tmpAccCode &gt;&gt; 8);
-
-//      info(&quot;code0: 0x%2.2X, code1: 0x%2.2X\n&quot;, out-&gt;msg.canparams.cc_params.m16c_basic.acc_std_code0, out-&gt;msg.canparams.cc_params.m16c_basic.acc_std_code1);
-	    out-&gt;msg.canparams.cc_params.m16c_basic.acc_std_mask0 =
-	    ~acc_mask0;
-	out-&gt;msg.canparams.cc_params.m16c_basic.acc_std_mask1 =
-	    ~acc_mask1;
-
-//      info(&quot;mask0: 0x%2.2X, mask1: 0x%2.2X\n&quot;, out-&gt;msg.canparams.cc_params.m16c_basic.acc_std_mask0, out-&gt;msg.canparams.cc_params.m16c_basic.acc_std_mask1);
-	    tmpAccMask = ((acc_mask1) &gt;&gt; 5) + ((acc_mask0) &lt;&lt; 3);
-
-//      info(&quot;tmpAccMask: 0x%4.4X\n&quot;, tmpAccMask);
-	    out-&gt;msg.canparams.cc_params.m16c_basic.acc_std_mask0 =
-	    (unsigned char) ~tmpAccMask;
-	out-&gt;msg.canparams.cc_params.m16c_basic.acc_std_mask1 =
-	    (unsigned char) ~(tmpAccMask &gt;&gt; 8);
-
-//      info(&quot;mask0: 0x%2.2X, mask1: 0x%2.2X\n&quot;, out-&gt;msg.canparams.cc_params.m16c_basic.acc_std_mask0, out-&gt;msg.canparams.cc_params.m16c_basic.acc_std_mask1);
-	    out-&gt;msg.canparams.cc_params.m16c_basic.acc_ext_code0 =
-	    (unsigned char) tmpAccCode;
-	out-&gt;msg.canparams.cc_params.m16c_basic.acc_ext_code1 =
-	    (unsigned char) (tmpAccCode &gt;&gt; 8);
-	out-&gt;msg.canparams.cc_params.m16c_basic.acc_ext_code2 = acc_code2;
-	out-&gt;msg.canparams.cc_params.m16c_basic.acc_ext_code3 = acc_code3;
-	out-&gt;msg.canparams.cc_params.m16c_basic.acc_ext_mask0 =
-	    (unsigned char) ~tmpAccMask;
-	out-&gt;msg.canparams.cc_params.m16c_basic.acc_ext_mask1 =
-	    (unsigned char) ~(tmpAccMask &gt;&gt; 8);
-	out-&gt;msg.canparams.cc_params.m16c_basic.acc_ext_mask2 =
-	    ~acc_mask2;
-	out-&gt;msg.canparams.cc_params.m16c_basic.acc_ext_mask3 =
-	    ~acc_mask3;
-	vfree(baudrate_error);
-	vfree(samplepoint_error);
-	return 0;
-}
-
-

-- 
EMS Dr. Thomas Wuensche e.K.
Sonnenhang 3
85304 Ilmmuenster
HRA Neuburg a.d. Donau, HR-Nr. 70.106
Phone: +49-8441-490260
Fax  : +49-8441-81860
<A HREF="http://www.ems-wuensche.com">http://www.ems-wuensche.com</A>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003062.html">[PATCH 0/2] ems_usb: Added support for EMS CPC-USB/ARM7 CAN interface
</A></li>
	<LI>Next message: <A HREF="003064.html">[PATCH 2/2] ems_usb: Added support for EMS CPC-USB/ARM7 CAN/USB	interface
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3063">[ date ]</a>
              <a href="thread.html#3063">[ thread ]</a>
              <a href="subject.html#3063">[ subject ]</a>
              <a href="author.html#3063">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
