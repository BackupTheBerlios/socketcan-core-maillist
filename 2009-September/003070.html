<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH v2] CAN: Add support for binary protocol to slcan
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20v2%5D%20CAN%3A%20Add%20support%20for%20binary%20protocol%20to%20slcan&In-Reply-To=%3C63b6f8d20909140956v63e1d2ffxface2f02c6df8599%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003081.html">
   <LINK REL="Next"  HREF="003073.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH v2] CAN: Add support for binary protocol to slcan</H1>
    <B>M F</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20v2%5D%20CAN%3A%20Add%20support%20for%20binary%20protocol%20to%20slcan&In-Reply-To=%3C63b6f8d20909140956v63e1d2ffxface2f02c6df8599%40mail.gmail.com%3E"
       TITLE="[PATCH v2] CAN: Add support for binary protocol to slcan">maxf59964 at googlemail.com
       </A><BR>
    <I>Mon Sep 14 18:56:06 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003081.html">[PATCH v3] at91_can
</A></li>
        <LI>Next message: <A HREF="003073.html">[PATCH v2] CAN: Add support for binary protocol to slcan
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3070">[ date ]</a>
              <a href="thread.html#3070">[ thread ]</a>
              <a href="subject.html#3070">[ subject ]</a>
              <a href="author.html#3070">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

it took longer than expected, but here is a patch to add support for
binary mode to slcan with error recovery!
Regards,

Maximilian


Patch against SVN Rev 1054:

Index: kernel/2.6/drivers/net/can/slcan.c
===================================================================
--- kernel/2.6/drivers/net/can/slcan.c	(Revision 1054)
+++ kernel/2.6/drivers/net/can/slcan.c	(Arbeitskopie)
@@ -11,6 +11,7 @@
  * slip.c Authors  : Laurence Culhane &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">loz at holmes.demon.co.uk</A>&gt;
  *                   Fred N. van Kempen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">waltje at uwalt.nl.mugnet.org</A>&gt;
  * slcan.c Author  : Oliver Hartkopp &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">oliver.hartkopp at volkswagen.de</A>&gt;
+ *                   Maximilian Falkenstein &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">maxf59964 at googlemail.com</A>&gt;
  *
  * Copyright (c) 2007-2009 Volkswagen Group Electronic Research
  *
@@ -75,13 +76,15 @@

 #include &lt;socketcan/can.h&gt;

+#if 0
 #include &lt;socketcan/can/version.h&gt; /* for RCSID. Removed by mkpatch script */
 RCSID(&quot;$Id$&quot;);
+#endif

-static __initdata const char banner[] =
-	KERN_INFO &quot;slcan: serial line CAN interface driver\n&quot;;
+static __initdata const char banner[] = KERN_INFO
+&quot;slcan: serial line CAN interface driver\n&quot;;

-MODULE_ALIAS_LDISC(N_SLCAN);
+MODULE_ALIAS_LDISC( N_SLCAN);
 MODULE_DESCRIPTION(&quot;serial line CAN interface&quot;);
 MODULE_LICENSE(&quot;GPL&quot;);
 MODULE_AUTHOR(&quot;Oliver Hartkopp &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">oliver.hartkopp at volkswagen.de</A>&gt;&quot;);
@@ -126,47 +129,73 @@
 #define SLC_CHECK_TRANSMIT
 #define SLCAN_MAGIC 0x53CA

-static int maxdev = 10;		/* MAX number of SLCAN channels;
-				   This can be overridden with
-				   insmod slcan.ko maxdev=nnn	*/
+static int maxdev = 10; /* MAX number of SLCAN channels;
+ This can be overridden with
+ insmod slcan.ko maxdev=nnn	*/
 module_param(maxdev, int, 0);
 MODULE_PARM_DESC(maxdev, &quot;Maximum number of slcan interfaces&quot;);
+/* MAX number of packets to put *
+ * into the device buffer, can  *
+ * also be overridden			*/
+static int maxack = 2;
+module_param(maxack, int, 0);
+MODULE_PARM_DESC(maxack, &quot;Maximum number of packets to put into the
device buffer, be _VERY_ careful with this!&quot;);

-/* maximum rx buffer len: extended CAN frame with timestamp */
+/* maximum rx buffer len: extended CAN frame with timestamp in ASCII format */
 #define SLC_MTU (sizeof(&quot;T1111222281122334455667788EA5F\r&quot;)+1)

 struct slcan {
-	int			magic;
+	int magic;

+
+	/* We need some extra vars for binary mode! */
+	int dnum; /* How many data bytes do we except to receive */
+	int to_ack; /* How many packets have we put into the device buffer? */
+	int rec_rcount; /* special rcount for recovery purposes */
+
+
 	/* Various fields. */
-	struct tty_struct	*tty;		/* ptr to TTY structure	     */
-	struct net_device	*dev;		/* easy for intr handling    */
-	spinlock_t		lock;
+	struct tty_struct *tty; /* ptr to TTY structure	     */
+	struct net_device *dev; /* easy for intr handling    */
+	spinlock_t lock;

+
 	/* These are pointers to the malloc()ed frame buffers. */
-	unsigned char		rbuff[SLC_MTU];	/* receiver buffer	     */
-	int			rcount;         /* received chars counter    */
-	unsigned char		xbuff[SLC_MTU];	/* transmitter buffer	     */
-	unsigned char		*xhead;         /* pointer to next XMIT byte */
-	int			xleft;          /* bytes left in XMIT queue  */
+	unsigned char rbuff[SLC_MTU]; /* receiver buffer	     */
+	int rcount; /* received chars counter    */
+	unsigned char xbuff[SLC_MTU]; /* transmitter buffer	     */
+	unsigned char *xhead; /* pointer to next XMIT byte */
+	int xleft; /* bytes left in XMIT queue  */

+
 #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
 	/* SLCAN interface statistics. */
 	struct net_device_stats stats;
 #endif

-	unsigned long		flags;		/* Flag values/ mode etc     */
+	unsigned long flags; /* Flag values/ mode etc     */
 #define SLF_INUSE		0		/* Channel in use            */
-#define SLF_ERROR		1               /* Parity, etc. error        */
+#define SLF_ERROR		1       /* Parity, etc. error        */
+#define SLF_BINENC		2		/* Do we use binary encapsulation? */
+#define SLF_EFRAME		3		/* Is the frame we are currently receiving extended */
+#define SLF_RESP		4		/* Is the next byte a response to a command */

-	unsigned char		leased;
-	dev_t			line;
-	pid_t			pid;
+
+	/* true, if we've paused the transmission of packets because the hardware	*
+	 * hasn't answered (yet).													*/
+#define SLF_PAUSED		5
+
+
+#define SLF_LOST_SYNC	6		/* true, if we don't know what's going on... */
+#define SLF_FRAME_CANDIDAT 7	/* What we're receiving looks like a frame... */
+
+	unsigned char leased;
+	dev_t line;
+	pid_t pid;
 };

 static struct net_device **slcan_devs;

-
 #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
 /* Netdevice get statistics request */
 static struct net_device_stats *slc_get_stats(struct net_device *dev)
@@ -177,9 +206,9 @@
 }
 #endif

- /************************************************************************
-  *			SLCAN ENCAPSULATION FORMAT		  	 *
-  ************************************************************************/
+/************************************************************************
+ *			SLCAN ENCAPSULATION FORMAT		  	 *
+ ************************************************************************/

 /*
  * A CAN frame has a can_id (11 bit standard frame format OR 29 bit extended
@@ -210,11 +239,19 @@
  * T12ABCDEF2AA55 : extended can_id 0x12ABCDEF, can_dlc 2, data 0xAA 0x55
  * r1230 : can_id 0x123, can_dlc 0, no data, remote transmission request
  *
+ * NEW: We also have a binary encapsulation. It's very similar to the ASCII
+ * one, except that we don't user \r \n and don't convert to ASCII. The return
+ * value is also different! As the lib on controller doesn't differ between
+ * RTR and normal frame with 0 databytes, we don't differ between 'R'
and 'T', too.
+ *
+ * Examples(Binary):
+ * t 0x01 0x23 0x00 : like t1230, can_id 0x123, can_dlc 0, no data
+ * T 0x12 0xAB 0xCD 0xEF 0x03 0xAA 0x55 : extended can_id 0x12ABCDEF,
can_dlc 2, data 0xAA 0x55
  */

- /************************************************************************
-  *			STANDARD SLCAN DECAPSULATION		  	 *
-  ************************************************************************/
+/************************************************************************
+ *			STANDARD SLCAN DECAPSULATION		  	 *
+ ************************************************************************/

 static int asc2nibble(char c)
 {
@@ -245,50 +282,82 @@
 	unsigned long ultmp;
 	char cmd = sl-&gt;rbuff[0];

-	if ((cmd != 't') &amp;&amp; (cmd != 'T') &amp;&amp; (cmd != 'r') &amp;&amp; (cmd != 'R'))
-		return;
+	if (!test_bit(SLF_BINENC, &amp;sl-&gt;flags)) {
+		if ((cmd != 't') &amp;&amp; (cmd != 'T') &amp;&amp; (cmd != 'r') &amp;&amp; (cmd != 'R'))
+			return;

-	if (cmd &amp; 0x20) /* tiny chars 'r' 't' =&gt; standard frame format */
-		dlc_pos = 4; /* dlc position tiiid */
-	else
-		dlc_pos = 9; /* dlc position Tiiiiiiiid */
+		if (cmd &amp; 0x20) /* tiny chars 'r' 't' =&gt; standard frame format */
+			dlc_pos = 4; /* dlc position tiiid */
+		else
+			dlc_pos = 9; /* dlc position Tiiiiiiiid */

-	if (!((sl-&gt;rbuff[dlc_pos] &gt;= '0') &amp;&amp; (sl-&gt;rbuff[dlc_pos] &lt; '9')))
-		return;
+		if (!((sl-&gt;rbuff[dlc_pos] &gt;= '0') &amp;&amp; (sl-&gt;rbuff[dlc_pos] &lt; '9')))
+			return;

-	cf.can_dlc = sl-&gt;rbuff[dlc_pos] - '0'; /* get can_dlc from ASCII val */
+		cf.can_dlc = sl-&gt;rbuff[dlc_pos] - '0'; /* get can_dlc from ASCII val */

-	sl-&gt;rbuff[dlc_pos] = 0; /* terminate can_id string */
+		sl-&gt;rbuff[dlc_pos] = 0; /* terminate can_id string */

+
 #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,25)
-	ultmp = simple_strtoul(sl-&gt;rbuff+1, NULL, 16);
+		ultmp = simple_strtoul(sl-&gt;rbuff+1, NULL, 16);
 #else
-	if (strict_strtoul(sl-&gt;rbuff+1, 16, &amp;ultmp))
-		return;
+		if (strict_strtoul(sl-&gt;rbuff + 1, 16, &amp;ultmp))
+			return;
 #endif
-	cf.can_id = ultmp;
+		cf.can_id = ultmp;

-	if (!(cmd &amp; 0x20)) /* NO tiny chars =&gt; extended frame format */
-		cf.can_id |= CAN_EFF_FLAG;
+		if (!(cmd &amp; 0x20)) /* NO tiny chars =&gt; extended frame format */
+			cf.can_id |= CAN_EFF_FLAG;

-	if ((cmd | 0x20) == 'r') /* RTR frame */
-		cf.can_id |= CAN_RTR_FLAG;
+		if ((cmd | 0x20) == 'r') /* RTR frame */
+			cf.can_id |= CAN_RTR_FLAG;

-	*(u64 *) (&amp;cf.data) = 0; /* clear payload */
+		*(u64 *) (&amp;cf.data) = 0; /* clear payload */

-	for (i = 0, dlc_pos++; i &lt; cf.can_dlc; i++) {
-
-		tmp = asc2nibble(sl-&gt;rbuff[dlc_pos++]);
-		if (tmp &gt; 0x0F)
+		for (i = 0, dlc_pos++; i &lt; cf.can_dlc; i++) {
+			tmp = asc2nibble(sl-&gt;rbuff[dlc_pos++]);
+			if (tmp &gt; 0x0F)
+				return;
+			cf.data[i] = (tmp &lt;&lt; 4);
+			tmp = asc2nibble(sl-&gt;rbuff[dlc_pos++]);
+			if (tmp &gt; 0x0F)
+				return;
+			cf.data[i] |= tmp;
+		}
+	} else {
+		//Binary is so much easier ;-)
+		if (cmd == 't') {
+			//Normal can frame
+			cf.can_id = (sl-&gt;rbuff[1] &lt;&lt; 8) | sl-&gt;rbuff[2];
+			cf.can_dlc = sl-&gt;rbuff[3];
+			if (cf.can_dlc &gt; 8) {
+				printk(KERN_WARNING &quot;slcan: Frame with lenght above 8, dropping!&quot;);
+				stats-&gt;rx_dropped++;
+				stats-&gt;rx_errors++;
+				return;
+			}
+			for (i = 0; i &lt; cf.can_dlc; i++)
+				cf.data[i] = sl-&gt;rbuff[4 + i];
+		} else if (cmd == 'T') {
+			//Extended can frame
+			cf.can_id = (sl-&gt;rbuff[1] &lt;&lt; 24) | (sl-&gt;rbuff[2] &lt;&lt; 16) |
(sl-&gt;rbuff[3] &lt;&lt; 8) | sl-&gt;rbuff[4];
+			cf.can_dlc = sl-&gt;rbuff[5];
+			if (cf.can_dlc &gt; 8) {
+				printk(KERN_WARNING &quot;slcan: Frame with lenght above 8, dropping!&quot;);
+				stats-&gt;rx_dropped++;
+				stats-&gt;rx_errors++;
+				return;
+			}
+			for (i = 0; i &lt; cf.can_dlc; i++)
+				cf.data[i] = sl-&gt;rbuff[6 + i];
+		} else {
+			printk(KERN_WARNING &quot;slcan: Got unknown can frame from device!&quot;);
+			stats-&gt;rx_errors++;
 			return;
-		cf.data[i] = (tmp &lt;&lt; 4);
-		tmp = asc2nibble(sl-&gt;rbuff[dlc_pos++]);
-		if (tmp &gt; 0x0F)
-			return;
-		cf.data[i] |= tmp;
+		}
 	}

-
 	skb = dev_alloc_skb(sizeof(struct can_frame));
 	if (!skb)
 		return;
@@ -297,8 +366,7 @@
 	skb-&gt;protocol = htons(ETH_P_CAN);
 	skb-&gt;pkt_type = PACKET_BROADCAST;
 	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
-	memcpy(skb_put(skb, sizeof(struct can_frame)),
-	       &amp;cf, sizeof(struct can_frame));
+	memcpy(skb_put(skb, sizeof(struct can_frame)), &amp;cf, sizeof(struct can_frame));
 	netif_rx(skb);

 	sl-&gt;dev-&gt;last_rx = jiffies;
@@ -314,29 +382,197 @@
 #else
 	struct net_device_stats *stats = &amp;sl-&gt;dev-&gt;stats;
 #endif
+	int i;
+	unsigned char nrbuff[SLC_MTU];

-	if ((s == '\r') || (s == '\a')) { /* CR or BEL ends the pdu */
-		if (!test_and_clear_bit(SLF_ERROR, &amp;sl-&gt;flags) &amp;&amp;
-		    (sl-&gt;rcount &gt; 4))  {
+	if (!test_bit(SLF_BINENC, &amp;sl-&gt;flags)) {
+		//ASCII
+		if ((s == '\r') || (s == '\a')) { /* CR or BEL ends the pdu */
+			if (!test_and_clear_bit(SLF_ERROR, &amp;sl-&gt;flags) &amp;&amp; (sl-&gt;rcount &gt; 4)) {
+				slc_bump(sl);
+			}
+			sl-&gt;rcount = 0;
+		} else {
+			if (!test_bit(SLF_ERROR, &amp;sl-&gt;flags)) {
+				if (sl-&gt;rcount &lt; SLC_MTU) {
+					sl-&gt;rbuff[sl-&gt;rcount++] = s;
+					return;
+				} else {
+					stats-&gt;rx_over_errors++;
+					set_bit(SLF_ERROR, &amp;sl-&gt;flags);
+				}
+			}
+		}
+	} else {
+		//BINARY
+		if (test_bit(SLF_LOST_SYNC, &amp;sl-&gt;flags)) {
+			//OK, complicated things first(error recovery)...
+			sl-&gt;rbuff[sl-&gt;rec_rcount] = s;
+			sl-&gt;rec_rcount++;
+
+			if (test_bit(SLF_FRAME_CANDIDAT, &amp;sl-&gt;flags)) {
+				if (!test_bit(SLF_RESP, &amp;sl-&gt;flags)) {
+					int offset = sl-&gt;rec_rcount - sl-&gt;rcount;
+					sl-&gt;rcount++;
+					if ((sl-&gt;rcount == 2 &amp;&amp; !test_bit(SLF_EFRAME, &amp;sl-&gt;flags)) |
(sl-&gt;rcount == 4 &amp;&amp; test_bit(
+							SLF_EFRAME, &amp;sl-&gt;flags))) {
+						//We've recived the last bit of the CAN id
+						if (test_bit(SLF_EFRAME, &amp;sl-&gt;flags) &amp;&amp; (((sl-&gt;rbuff[offset + 1] &lt;&lt; 24)
+								| (sl-&gt;rbuff[offset + 2] &lt;&lt; 16) | (sl-&gt;rbuff[offset + 3] &lt;&lt;
8) | sl-&gt;rbuff[offset + 4])
+								&gt; 0x1FFFFFFF) | !test_bit(SLF_EFRAME, &amp;sl-&gt;flags) &amp;&amp;
((sl-&gt;rbuff[offset + 1] &lt;&lt; 8)
+								| sl-&gt;rbuff[offset + 2]) &gt; 0x7FF) {
+							//Invalid ID
+							goto invalid;
+						}
+					} else if ((sl-&gt;rcount == 5 &amp;&amp; test_bit(SLF_EFRAME, &amp;sl-&gt;flags))
|<i> ((sl-&gt;rcount == 3) &amp;&amp; !test_bit(
</I>+							SLF_EFRAME, &amp;sl-&gt;flags))) {
+						if (s &gt; 8) //Invalid dlc
+							goto invalid;
+						else if (s == 0) {
+							goto rec_out_decaps;
+						} else {
+							sl-&gt;dnum = s;
+							return;
+						}
+					} else if (sl-&gt;dnum &gt; 0) {
+						sl-&gt;dnum--;
+						if (sl-&gt;dnum == 0) {
+							//Decaps
+							goto rec_out_decaps;
+						}
+					}
+				} else {
+					if (s &amp; 0xf0) {
+						if (s != 0xf9) {
+							/* 0xf9 means OK, everything different means error */
+							printk(KERN_WARNING &quot;%s: Command failed, retval: %X\n&quot;,
sl-&gt;dev-&gt;name, s);
+							stats-&gt;tx_errors++;
+							stats-&gt;tx_dropped++;
+						}
+						sl-&gt;to_ack--;
+						if (test_bit(SLF_PAUSED, &amp;sl-&gt;flags) &amp;&amp; (sl-&gt;to_ack &lt; maxack)) {
+							/* The device buffer is large enough for at least one
+							 * more packet, so let's wake the quere */
+							clear_bit(SLF_PAUSED, &amp;sl-&gt;flags);
+							netif_wake_queue(sl-&gt;dev);
+						}
+						clear_bit(SLF_RESP, &amp;sl-&gt;flags);
+						sl-&gt;rcount = 0;
+						sl-&gt;rec_rcount = 0;
+						clear_bit(SLF_FRAME_CANDIDAT, &amp;sl-&gt;flags);
+						clear_bit(SLF_LOST_SYNC, &amp;sl-&gt;flags);
+						return;
+					} else
+						goto invalid;
+				}
+			}
+			if (sl-&gt;rec_rcount == SLC_MTU) {
+				printk( KERN_WARNING
+				&quot;%s: Buffer full, but still havn't received a valid packet!\n&quot;,
sl-&gt;dev-&gt;name);
+				sl-&gt;rcount = 0;
+				clear_bit(SLF_FRAME_CANDIDAT, &amp;sl-&gt;flags);
+			}
+			if ((s == 't') | (s == 'T') | (s == 0xe0)) {
+				set_bit(SLF_FRAME_CANDIDAT, &amp;sl-&gt;flags);
+				if (s == 't')
+					clear_bit(SLF_EFRAME, &amp;sl-&gt;flags);
+				if (s == 'T')
+					set_bit(SLF_EFRAME, &amp;sl-&gt;flags);
+				if (s == 0xe0)
+					set_bit(SLF_RESP, &amp;sl-&gt;flags);
+				sl-&gt;rcount = 0;
+			}
+			return;
+
+			invalid: clear_bit(SLF_FRAME_CANDIDAT, &amp;sl-&gt;flags);
+			return;
+
+			rec_out_decaps:
+			//Modify buffer so that we can call slc_bump
+			for (i = 0; i &lt;= sl-&gt;rcount; i++)
+				nrbuff[i] = sl-&gt;rbuff[sl-&gt;rec_rcount - sl-&gt;rcount - 1 + i];
+			memcpy(sl-&gt;rbuff, nrbuff, sl-&gt;rcount + 1);
 			slc_bump(sl);
+			sl-&gt;rcount = 0;
+			sl-&gt;rec_rcount = 0;
+			clear_bit(SLF_FRAME_CANDIDAT, &amp;sl-&gt;flags);
+			clear_bit(SLF_LOST_SYNC, &amp;sl-&gt;flags);
+			return;
 		}
-		sl-&gt;rcount = 0;
-	} else {
-		if (!test_bit(SLF_ERROR, &amp;sl-&gt;flags))  {
-			if (sl-&gt;rcount &lt; SLC_MTU)  {
-				sl-&gt;rbuff[sl-&gt;rcount++] = s;
+
+		if (test_bit(SLF_RESP, &amp;sl-&gt;flags)) {
+			if (s != 0xf9) {
+				/* 0xf9 means OK, everything different means error */
+				printk(KERN_WARNING &quot;%s: Command failed, retval: %X\n&quot;, sl-&gt;dev-&gt;name, s);
+				stats-&gt;tx_errors++;
+				stats-&gt;tx_dropped++;
+			}
+			sl-&gt;to_ack--;
+			if (test_bit(SLF_PAUSED, &amp;sl-&gt;flags) &amp;&amp; (sl-&gt;to_ack &lt; maxack)) {
+				/* The device buffer is large enough for at least one
+				 * more packet, so let's wake the quere */
+				clear_bit(SLF_PAUSED, &amp;sl-&gt;flags);
+				netif_wake_queue(sl-&gt;dev);
+			}
+			clear_bit(SLF_RESP, &amp;sl-&gt;flags);
+			sl-&gt;rcount = 0;
+			return;
+		}
+
+		if (sl-&gt;rcount == 0) {
+			//What's coming next: a can frame, an extended can frame, or an ack/nack?
+			if (s == 't') {
+				clear_bit(SLF_EFRAME, &amp;sl-&gt;flags);
+				goto out_write;
+			} else if (s == 'T') {
+				set_bit(SLF_EFRAME, &amp;sl-&gt;flags);
+				goto out_write;
+			} else if (s == 0xe0) {
+				//ACK/NACK
+				set_bit(SLF_RESP, &amp;sl-&gt;flags);
+			} else {
+				//Unknown packet, *may* happen during hot plugging!
+				printk(KERN_WARNING &quot;slcan (dev: %s): Unknown packet(head: 0x%X),
entering lost sync mode!\n&quot;, sl-&gt;dev-&gt;name, s);
+				stats-&gt;rx_errors++;
+				sl-&gt;rec_rcount = 0;
+				sl-&gt;rcount = 0;
+				sl-&gt;rec_rcount = 0;
+				set_bit(SLF_LOST_SYNC, &amp;sl-&gt;flags);
 				return;
-			} else {
-				stats-&gt;rx_over_errors++;
-				set_bit(SLF_ERROR, &amp;sl-&gt;flags);
 			}
+		} else if ((test_bit(SLF_EFRAME, &amp;sl-&gt;flags) &amp;&amp; sl-&gt;rcount == 5) |
((!test_bit(SLF_EFRAME, &amp;sl-&gt;flags))
+				&amp;&amp; sl-&gt;rcount == 3)) {
+			//Now we're receiving the payload lenght
+			if (s == 0) {
+				//Oh, cool, a RTR; we can decapsulate it immediately
+				sl-&gt;rbuff[sl-&gt;rcount] = s;
+				goto out_decaps;
+			}
+			sl-&gt;dnum = s;
+			goto out_write;
+		} else {
+			//More data
+			sl-&gt;rbuff[sl-&gt;rcount] = s;
+			sl-&gt;rcount++;
+			sl-&gt;dnum--;
+			if (sl-&gt;dnum == 0)
+				goto out_decaps;
 		}
 	}
+	return;
+
+	out_write: sl-&gt;rbuff[sl-&gt;rcount] = s;
+	sl-&gt;rcount++;
+	return;
+
+	out_decaps: slc_bump(sl);
+	sl-&gt;rcount = 0;
+	return;
 }

- /************************************************************************
-  *			STANDARD SLCAN ENCAPSULATION		  	 *
-  ************************************************************************/
+/************************************************************************
+ *			STANDARD SLCAN ENCAPSULATION		  	 *
+ ************************************************************************/

 /* Encapsulate one can_frame and stuff into a TTY queue. */
 static void slc_encaps(struct slcan *sl, struct can_frame *cf)
@@ -349,41 +585,95 @@
 	int actual, idx, i;
 	char cmd;

-	if (cf-&gt;can_id &amp; CAN_RTR_FLAG)
-		cmd = 'R'; /* becomes 'r' in standard frame format */
-	else
-		cmd = 'T'; /* becomes 't' in standard frame format */
+	if (test_bit(SLF_BINENC, &amp;sl-&gt;flags)) {
+		uint32_t id = cf-&gt;can_id &amp; CAN_EFF_MASK;
+		uint8_t lof = 0;
+		if (cf-&gt;can_id &amp; CAN_EFF_FLAG) {
+			sl-&gt;xbuff[0] = 'T'; //Send
+			sl-&gt;xbuff[1] = (uint8_t)(id &gt;&gt; 24);
+			sl-&gt;xbuff[2] = (uint8_t)(id &gt;&gt; 16);
+			sl-&gt;xbuff[3] = (uint8_t)(id &gt;&gt; 8);
+			sl-&gt;xbuff[4] = (uint8_t) id;
+			lof = 4;
+		} else {
+			sl-&gt;xbuff[0] = 't'; //Send
+			sl-&gt;xbuff[1] = (uint8_t)(id &gt;&gt; 8);
+			sl-&gt;xbuff[2] = (uint8_t) id;
+			lof = 2;
+		}
+		sl-&gt;xbuff[lof + 1] = cf-&gt;can_dlc;
+		/* Stringterm (Reordered for C90 compatibility) */
+		sl-&gt;xbuff[lof + 2 + cf-&gt;can_dlc] = 0x00;

-	if (cf-&gt;can_id &amp; CAN_EFF_FLAG)
-		sprintf(sl-&gt;xbuff, &quot;%c%08X%d&quot;, cmd,
-			cf-&gt;can_id &amp; CAN_EFF_MASK, cf-&gt;can_dlc);
-	else
-		sprintf(sl-&gt;xbuff, &quot;%c%03X%d&quot;, cmd | 0x20,
-			cf-&gt;can_id &amp; CAN_SFF_MASK, cf-&gt;can_dlc);
+		for (i = 0; i &lt; cf-&gt;can_dlc; i++) {
+			sl-&gt;xbuff[lof + 2 + i] = cf-&gt;data[i];
+		}

-	idx = strlen(sl-&gt;xbuff);
+		/* We're going to send another packet into the device's buffer,
+		 * let's tell the receiving side that we're sending something
+		 * that's going to get a CMD_RESP. */
+		sl-&gt;to_ack++;

-	for (i = 0; i &lt; cf-&gt;can_dlc; i++)
-		sprintf(&amp;sl-&gt;xbuff[idx + 2*i], &quot;%02X&quot;, cf-&gt;data[i]);

-	DBG(&quot;ASCII frame = '%s'\n&quot;, sl-&gt;xbuff);
+		/* Flow control: The device may be busy, but able to receive
+		 * data (interrupt driven, at least in my firmware), but it
+		 * can't handle an infinite amount of data, so we have to
+		 * stop and wait for response after some packets... */
+		if (sl-&gt;to_ack &gt;= maxack)
+			set_bit(SLF_PAUSED, &amp;sl-&gt;flags);

-	strcat(sl-&gt;xbuff, &quot;\r&quot;); /* add terminating character */

-	/* Order of next two lines is *very* important.
-	 * When we are sending a little amount of data,
-	 * the transfer may be completed inside driver.write()
-	 * routine, because it's running with interrupts enabled.
-	 * In this case we *never* got WRITE_WAKEUP event,
-	 * if we did not request it before write operation.
-	 *       14 Oct 1994  Dmitry Gorodchanin.
-	 */
-	sl-&gt;tty-&gt;flags |= (1 &lt;&lt; TTY_DO_WRITE_WAKEUP);
+		/* Order of next two lines is *very* important.
+		 * When we are sending a little amount of data,
+		 * the transfer may be completed inside driver.write()
+		 * routine, because it's running with interrupts enabled.
+		 * In this case we *never* got WRITE_WAKEUP event,
+		 * if we did not request it before write operation.
+		 *       14 Oct 1994  Dmitry Gorodchanin.
+		 */
+		sl-&gt;tty-&gt;flags |= (1 &lt;&lt; TTY_DO_WRITE_WAKEUP);
 #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,26)
-	actual = sl-&gt;tty-&gt;driver-&gt;write(sl-&gt;tty, sl-&gt;xbuff, strlen(sl-&gt;xbuff));
+		actual = sl-&gt;tty-&gt;driver-&gt;write(sl-&gt;tty, sl-&gt;xbuff, (cf-&gt;can_id &amp;
CAN_EFF_FLAG ? 6 : 4)+cf-&gt;can_dlc);
 #else
-	actual = sl-&gt;tty-&gt;ops-&gt;write(sl-&gt;tty, sl-&gt;xbuff, strlen(sl-&gt;xbuff));
+		actual = sl-&gt;tty-&gt;ops-&gt;write(sl-&gt;tty, sl-&gt;xbuff, (cf-&gt;can_id &amp;
CAN_EFF_FLAG ? 6 : 4) + cf-&gt;can_dlc);
 #endif
+
+	} else {
+		if (cf-&gt;can_id &amp; CAN_RTR_FLAG)
+			cmd = 'R'; /* becomes 'r' in standard frame format */
+		else
+			cmd = 'T'; /* becomes 't' in standard frame format */
+
+		if (cf-&gt;can_id &amp; CAN_EFF_FLAG)
+			sprintf(sl-&gt;xbuff, &quot;%c%08X%d&quot;, cmd, cf-&gt;can_id &amp; CAN_EFF_MASK, cf-&gt;can_dlc);
+		else
+			sprintf(sl-&gt;xbuff, &quot;%c%03X%d&quot;, cmd | 0x20, cf-&gt;can_id &amp;
CAN_SFF_MASK, cf-&gt;can_dlc);
+
+		idx = strlen(sl-&gt;xbuff);
+
+		for (i = 0; i &lt; cf-&gt;can_dlc; i++)
+			sprintf(&amp;sl-&gt;xbuff[idx + 2 * i], &quot;%02X&quot;, cf-&gt;data[i]);
+
+		DBG(&quot;ASCII frame = '%s'\n&quot;, sl-&gt;xbuff);
+
+		strcat(sl-&gt;xbuff, &quot;\r&quot;); /* add terminating character */
+
+
+		/* Order of next two lines is *very* important.
+		 * When we are sending a little amount of data,
+		 * the transfer may be completed inside driver.write()
+		 * routine, because it's running with interrupts enabled.
+		 * In this case we *never* got WRITE_WAKEUP event,
+		 * if we did not request it before write operation.
+		 *       14 Oct 1994  Dmitry Gorodchanin.
+		 */
+		sl-&gt;tty-&gt;flags |= (1 &lt;&lt; TTY_DO_WRITE_WAKEUP);
+#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,26)
+		actual = sl-&gt;tty-&gt;driver-&gt;write(sl-&gt;tty, sl-&gt;xbuff, strlen(sl-&gt;xbuff));
+#else
+		actual = sl-&gt;tty-&gt;ops-&gt;write(sl-&gt;tty, sl-&gt;xbuff, strlen(sl-&gt;xbuff));
+#endif
+	}
 #ifdef SLC_CHECK_TRANSMIT
 	sl-&gt;dev-&gt;trans_start = jiffies;
 #endif
@@ -406,16 +696,22 @@
 	struct net_device_stats *stats = &amp;sl-&gt;dev-&gt;stats;
 #endif

+
 	/* First make sure we're connected. */
 	if (!sl || sl-&gt;magic != SLCAN_MAGIC || !netif_running(sl-&gt;dev))
 		return;

-	if (sl-&gt;xleft &lt;= 0)  {
+	if (sl-&gt;xleft &lt;= 0) {
 		/* Now serial buffer is almost free &amp; we can start
 		 * transmission of another packet */
 		stats-&gt;tx_packets++;
 		tty-&gt;flags &amp;= ~(1 &lt;&lt; TTY_DO_WRITE_WAKEUP);
-		netif_wake_queue(sl-&gt;dev);
+
+
+		/* Maybe the device isn't ready, lets check before
+		 * we try to send the next packet */
+		if (!(test_bit(SLF_BINENC, &amp;sl-&gt;flags) &amp;&amp; test_bit(SLF_PAUSED, &amp;sl-&gt;flags)))
+			netif_wake_queue(sl-&gt;dev);
 		return;
 	}

@@ -442,27 +738,25 @@
 		 *      14 Oct 1994 Dmitry Gorodchanin.
 		 */
 #ifdef SLC_CHECK_TRANSMIT
-		if (time_before(jiffies, dev-&gt;trans_start + 20 * HZ))  {
+		if (time_before(jiffies, dev-&gt;trans_start + 20 * HZ)) {
 			/* 20 sec timeout not reached */
 			goto out;
-		}
-		printk(KERN_WARNING &quot;%s: transmit timed out, %s?\n&quot;, dev-&gt;name,
+		}printk
+		(KERN_WARNING &quot;%s: transmit timed out, %s?\n&quot;, dev-&gt;name,
 #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,26)
-		       (sl-&gt;tty-&gt;driver-&gt;chars_in_buffer(sl-&gt;tty) || sl-&gt;xleft)
+				(sl-&gt;tty-&gt;driver-&gt;chars_in_buffer(sl-&gt;tty) || sl-&gt;xleft)
 #else
-		       (tty_chars_in_buffer(sl-&gt;tty) || sl-&gt;xleft)
+				(tty_chars_in_buffer(sl-&gt;tty) || sl-&gt;xleft)
 #endif
-		       ? &quot;bad line quality&quot; : &quot;driver error&quot;);
+						? &quot;bad line quality&quot; : &quot;driver error&quot;);
 		sl-&gt;xleft = 0;
 		sl-&gt;tty-&gt;flags &amp;= ~(1 &lt;&lt; TTY_DO_WRITE_WAKEUP);
 		netif_wake_queue(sl-&gt;dev);
 #endif
 	}
-out:
-	spin_unlock(&amp;sl-&gt;lock);
+	out: spin_unlock(&amp;sl-&gt;lock);
 }

-
 /******************************************
  *   Routines looking at netdevice side.
  ******************************************/
@@ -476,9 +770,10 @@
 		goto out;

 	spin_lock(&amp;sl-&gt;lock);
-	if (!netif_running(dev))  {
+	if (!netif_running(dev)) {
 		spin_unlock(&amp;sl-&gt;lock);
-		printk(KERN_WARNING &quot;%s: xmit: iface is down\n&quot;, dev-&gt;name);
+		printk
+		(KERN_WARNING &quot;%s: xmit: iface is down\n&quot;, dev-&gt;name);
 		goto out;
 	}

@@ -491,12 +786,10 @@
 	slc_encaps(sl, (struct can_frame *) skb-&gt;data); /* encaps &amp; send */
 	spin_unlock(&amp;sl-&gt;lock);

-out:
-	kfree_skb(skb);
+	out: kfree_skb(skb);
 	return 0;
 }

-
 /* Netdevice UP -&gt; DOWN routine */
 static int slc_close(struct net_device *dev)
 {
@@ -508,8 +801,8 @@
 		sl-&gt;tty-&gt;flags &amp;= ~(1 &lt;&lt; TTY_DO_WRITE_WAKEUP);
 	}
 	netif_stop_queue(dev);
-	sl-&gt;rcount   = 0;
-	sl-&gt;xleft    = 0;
+	sl-&gt;rcount = 0;
+	sl-&gt;xleft = 0;
 	spin_unlock_bh(&amp;sl-&gt;lock);

 	return 0;
@@ -523,18 +816,20 @@
 	if (sl-&gt;tty == NULL)
 		return -ENODEV;

-	sl-&gt;flags &amp;= (1 &lt;&lt; SLF_INUSE);
+	/* ARGH! Bitmasks are not always clever... */
+	//sl-&gt;flags &amp;= (1 &lt;&lt; SLF_INUSE);
+	sl-&gt;flags &amp;= (1 &lt;&lt; SLF_INUSE) | (1 &lt;&lt; SLF_BINENC);
 	netif_start_queue(dev);
 	return 0;
 }

 #if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
 static const struct net_device_ops slc_netdev_ops = {
-	.ndo_open               = slc_open,
-	.ndo_stop               = slc_close,
-	.ndo_start_xmit         = slc_xmit,
+	.ndo_open = slc_open,
+	.ndo_stop = slc_close,
+	.ndo_start_xmit = slc_xmit,
 #ifdef SLC_CHECK_TRANSMIT
-	.ndo_tx_timeout		= slc_tx_timeout,
+	.ndo_tx_timeout = slc_tx_timeout,
 #endif
 };
 #endif
@@ -545,31 +840,32 @@
 #if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
 	dev-&gt;netdev_ops = &amp;slc_netdev_ops;
 #else
-	dev-&gt;open		= slc_open;
-	dev-&gt;stop		= slc_close;
-	dev-&gt;hard_start_xmit	= slc_xmit;
+	dev-&gt;open = slc_open;
+	dev-&gt;stop = slc_close;
+	dev-&gt;hard_start_xmit = slc_xmit;
 #endif
-	dev-&gt;destructor		= free_netdev;
+	dev-&gt;destructor = free_netdev;
 #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
-	dev-&gt;get_stats		= slc_get_stats;
+	dev-&gt;get_stats = slc_get_stats;
 #endif

-	dev-&gt;hard_header_len	= 0;
-	dev-&gt;addr_len		= 0;
-	dev-&gt;tx_queue_len	= 10;
+	dev-&gt;hard_header_len = 0;
+	dev-&gt;addr_len = 0;
+	dev-&gt;tx_queue_len = 10;

-	dev-&gt;mtu		= sizeof(struct can_frame);
-	dev-&gt;type		= ARPHRD_CAN;
+	dev-&gt;mtu = sizeof(struct can_frame);
+	dev-&gt;type = ARPHRD_CAN;
 #ifdef SLC_CHECK_TRANSMIT
 #if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,28)
-	dev-&gt;tx_timeout		= slc_tx_timeout;
+	dev-&gt;tx_timeout = slc_tx_timeout;
 #endif
-	dev-&gt;watchdog_timeo	= 20*HZ;
+	dev-&gt;watchdog_timeo = 20 * HZ;
 #endif

+
 	/* New-style flags. */
-	dev-&gt;flags		= IFF_NOARP;
-	dev-&gt;features           = NETIF_F_NO_CSUM;
+	dev-&gt;flags = IFF_NOARP;
+	dev-&gt;features = NETIF_F_NO_CSUM;
 }

 /******************************************
@@ -579,7 +875,7 @@
 #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,16)
 static int slcan_receive_room(struct tty_struct *tty)
 {
-	return 65536;  /* We can handle an infinite amount of data. :-) */
+	return 65536; /* We can handle an infinite amount of data. :-) */
 }
 #endif

@@ -591,9 +887,7 @@
  * be re-entered while running but other ldisc functions may be called
  * in parallel
  */
-
-static void slcan_receive_buf(struct tty_struct *tty,
-			      const unsigned char *cp, char *fp, int count)
+static void slcan_receive_buf(struct tty_struct *tty, const unsigned
char *cp, char *fp, int count)
 {
 	struct slcan *sl = (struct slcan *) tty-&gt;disc_data;
 #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
@@ -602,10 +896,10 @@
 	struct net_device_stats *stats = &amp;sl-&gt;dev-&gt;stats;
 #endif

-	if (!sl || sl-&gt;magic != SLCAN_MAGIC ||
-	    !netif_running(sl-&gt;dev))
+	if (!sl || sl-&gt;magic != SLCAN_MAGIC || !netif_running(sl-&gt;dev))
 		return;

+
 	/* Read the characters out of the buffer */
 	while (count--) {
 		if (fp &amp;&amp; *fp++) {
@@ -628,7 +922,7 @@
 {
 	int i;
 	struct net_device *dev;
-	struct slcan	  *sl;
+	struct slcan *sl;

 	for (i = 0; i &lt; maxdev; i++) {
 		dev = slcan_devs[i];
@@ -638,12 +932,11 @@
 		sl = netdev_priv(dev);
 		if (sl-&gt;tty || sl-&gt;leased)
 			continue;
-		if (dev-&gt;flags&amp;IFF_UP)
+		if (dev-&gt;flags &amp; IFF_UP)
 			dev_close(dev);
 	}
 }

-
 /* Find a free SLCAN channel, and link in this `tty' line. */
 static struct slcan *slc_alloc(dev_t line)
 {
@@ -651,10 +944,10 @@
 	int sel = -1;
 	int score = -1;
 	struct net_device *dev = NULL;
-	struct slcan       *sl;
+	struct slcan *sl;

 	if (slcan_devs == NULL)
-		return NULL;	/* Master array missing ! */
+		return NULL; /* Master array missing ! */

 	for (i = 0; i &lt; maxdev; i++) {
 		dev = slcan_devs[i];
@@ -729,14 +1022,16 @@
 		dev = alloc_netdev(sizeof(*sl), name, slc_setup);
 		if (!dev)
 			return NULL;
-		dev-&gt;base_addr  = i;
+		dev-&gt;base_addr = i;
 	}

 	sl = netdev_priv(dev);

+
 	/* Initialize channel control data */
-	sl-&gt;magic       = SLCAN_MAGIC;
-	sl-&gt;dev	      	= dev;
+	sl-&gt;magic = SLCAN_MAGIC;
+	sl-&gt;dev = dev;
+	sl-&gt;to_ack = 0;
 	spin_lock_init(&amp;sl-&gt;lock);
 	slcan_devs[i] = dev;

@@ -752,7 +1047,6 @@
  *
  * Called in process context serialized from other ldisc calls.
  */
-
 static int slcan_open(struct tty_struct *tty)
 {
 	struct slcan *sl;
@@ -766,12 +1060,14 @@
 		return -EOPNOTSUPP;
 #endif

+
 	/* RTnetlink lock is misused here to serialize concurrent
-	   opens of slcan channels. There are better ways, but it is
-	   the simplest one.
+	 opens of slcan channels. There are better ways, but it is
+	 the simplest one.
 	 */
 	rtnl_lock();

+
 	/* Collect hanged up channels. */
 	slc_sync();

@@ -793,16 +1089,17 @@
 	sl-&gt;line = tty_devnum(tty);
 	sl-&gt;pid = current-&gt;pid;

+
 #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,16)
 	/* FIXME: already done before we were called - seems this can go */
 	if (tty-&gt;driver-&gt;flush_buffer)
-		tty-&gt;driver-&gt;flush_buffer(tty);
+	tty-&gt;driver-&gt;flush_buffer(tty);
 #endif

 	if (!test_bit(SLF_INUSE, &amp;sl-&gt;flags)) {
 		/* Perform the low-level SLCAN initialization. */
-		sl-&gt;rcount   = 0;
-		sl-&gt;xleft    = 0;
+		sl-&gt;rcount = 0;
+		sl-&gt;xleft = 0;

 		set_bit(SLF_INUSE, &amp;sl-&gt;flags);

@@ -814,42 +1111,42 @@
 	/* Done.  We have linked the TTY line to a channel. */
 	rtnl_unlock();

+
 #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,16)
-	tty-&gt;receive_room = 65536;	/* We don't flow control */
+	tty-&gt;receive_room = 65536; /* We don't flow control */
 #endif

 	return sl-&gt;dev-&gt;base_addr;

-err_free_chan:
-	sl-&gt;tty = NULL;
+	err_free_chan: sl-&gt;tty = NULL;
 	tty-&gt;disc_data = NULL;
 	clear_bit(SLF_INUSE, &amp;sl-&gt;flags);

-err_exit:
-	rtnl_unlock();
+	err_exit: rtnl_unlock();

+
 	/* Count references from TTY module */
 	return err;
 }

 /*

-  FIXME: 1,2 are fixed 3 was never true anyway.
+ FIXME: 1,2 are fixed 3 was never true anyway.

-   Let me to blame a bit.
-   1. TTY module calls this funstion on soft interrupt.
-   2. TTY module calls this function WITH MASKED INTERRUPTS!
-   3. TTY module does not notify us about line discipline
-      shutdown,
+ Let me to blame a bit.
+ 1. TTY module calls this function on soft interrupt.
+ 2. TTY module calls this function WITH MASKED INTERRUPTS!
+ 3. TTY module does not notify us about line discipline
+ shutdown,

-   Seems, now it is clean. The solution is to consider netdevice and
-   line discipline sides as two independent threads.
+ Seems, now it is clean. The solution is to consider netdevice and
+ line discipline sides as two independent threads.

-   By-product (not desired): slc? does not feel hangups and remains open.
-   It is supposed, that user level program (dip, diald, slattach...)
-   will catch SIGHUP and make the rest of work.
+ By-product (not desired): slc? does not feel hangups and remains open.
+ It is supposed, that user level program (dip, diald, slattach...)
+ will catch SIGHUP and make the rest of work.

-   I see no way to make more with current tty code. --ANK
+ I see no way to make more with current tty code. --ANK
  */

 /*
@@ -861,6 +1158,7 @@
 {
 	struct slcan *sl = (struct slcan *) tty-&gt;disc_data;

+
 	/* First make sure we're connected. */
 	if (!sl || sl-&gt;magic != SLCAN_MAGIC || sl-&gt;tty != tty)
 		return;
@@ -870,62 +1168,71 @@
 	if (!sl-&gt;leased)
 		sl-&gt;line = 0;

+
 	/* Count references from TTY module */
 }

 /* Perform I/O control on an active SLCAN channel. */
-static int slcan_ioctl(struct tty_struct *tty, struct file *file,
-		       unsigned int cmd, unsigned long arg)
+static int slcan_ioctl(struct tty_struct *tty, struct file *file,
unsigned int cmd, unsigned long arg)
 {
 	struct slcan *sl = (struct slcan *) tty-&gt;disc_data;
 	unsigned int tmp;

+
 	/* First make sure we're connected. */
 	if (!sl || sl-&gt;magic != SLCAN_MAGIC)
 		return -EINVAL;

 	switch (cmd) {
-	case SIOCGIFNAME:
-		tmp = strlen(sl-&gt;dev-&gt;name) + 1;
-		if (copy_to_user((void __user *)arg, sl-&gt;dev-&gt;name, tmp))
-			return -EFAULT;
-		return 0;
+		case SIOCGIFENCAP:
+			//Do we use binary encapsulation?
+			return sl-&gt;flags &amp; (1 &lt;&lt; SLF_BINENC);
+		case SIOCSIFENCAP:
+			//Let's modify our encapsulation!
+			if (arg &gt; 0) {
+				sl-&gt;flags |= (1 &lt;&lt; SLF_BINENC);
+				printk(KERN_INFO &quot;slcan: Now using binary encapsulation on device
%s!&quot;, sl-&gt;dev-&gt;name);
+			} else {
+				sl-&gt;flags &amp;= ~(1 &lt;&lt; SLF_BINENC);
+				printk(KERN_INFO &quot;slcan: Now using ASCII encapsulation on device
%s!&quot;, sl-&gt;dev-&gt;name);
+			}
+			return 0;
+		case SIOCGIFNAME:
+			tmp = strlen(sl-&gt;dev-&gt;name) + 1;
+			if (copy_to_user((void __user *)arg, sl-&gt;dev-&gt;name, tmp))
+				return -EFAULT;
+			return 0;

-	case SIOCSIFHWADDR:
-		return -EINVAL;
+		case SIOCSIFHWADDR:
+			return -EINVAL;

+
 #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,27)
-	/* Allow stty to read, but not set, the serial port */
-	case TCGETS:
-	case TCGETA:
-		return n_tty_ioctl(tty, file, cmd, arg);
+			/* Allow stty to read, but not set, the serial port */
+			case TCGETS:
+			case TCGETA:
+			return n_tty_ioctl(tty, file, cmd, arg);

-	default:
-		return -ENOIOCTLCMD;
+			default:
+			return -ENOIOCTLCMD;
 #else
-	default:
-		return tty_mode_ioctl(tty, file, cmd, arg);
+		default:
+			return tty_mode_ioctl(tty, file, cmd, arg);
 #endif
 	}
 }

 #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,27)
-static struct tty_ldisc	slc_ldisc = {
+static struct tty_ldisc slc_ldisc = {
 #else
 static struct tty_ldisc_ops slc_ldisc = {
 #endif
-	.owner 		= THIS_MODULE,
-	.magic 		= TTY_LDISC_MAGIC,
-	.name 		= &quot;slcan&quot;,
-	.open 		= slcan_open,
-	.close	 	= slcan_close,
-	.ioctl		= slcan_ioctl,
-	.receive_buf	= slcan_receive_buf,
+		.owner = THIS_MODULE, .magic = TTY_LDISC_MAGIC, .name = &quot;slcan&quot;,
.open = slcan_open, .close = slcan_close,
+		.ioctl = slcan_ioctl, .receive_buf = slcan_receive_buf,
 #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,16)
-	.receive_room   = slcan_receive_room,
+		.receive_room = slcan_receive_room,
 #endif
-	.write_wakeup	= slcan_write_wakeup,
-};
+		.write_wakeup = slcan_write_wakeup, };

 /************************************
  * general slcan module init/exit
@@ -936,8 +1243,11 @@
 	int status;

 	if (maxdev &lt; 4)
-		maxdev = 4; /* Sanity */
+	maxdev = 4; /* Sanity */

+	if (maxack &lt; 1)
+	maxack = 1; /* Dito */
+
 	printk(banner);
 	printk(KERN_INFO &quot;slcan: %d dynamic interface channels.\n&quot;, maxdev);

@@ -952,7 +1262,7 @@

 	/* Fill in our line protocol discipline, and register it */
 	status = tty_register_ldisc(N_SLCAN, &amp;slc_ldisc);
-	if (status != 0)  {
+	if (status != 0) {
 		printk(KERN_ERR &quot;slcan: can't register line discipline\n&quot;);
 		kfree(slcan_devs);
 	}
@@ -968,19 +1278,19 @@
 	int busy = 0;

 	if (slcan_devs == NULL)
-		return;
+	return;

 	/* First of all: check for active disciplines and hangup them.
 	 */
 	do {
 		if (busy)
-			msleep_interruptible(100);
+		msleep_interruptible(100);

 		busy = 0;
 		for (i = 0; i &lt; maxdev; i++) {
 			dev = slcan_devs[i];
 			if (!dev)
-				continue;
+			continue;
 			sl = netdev_priv(dev);
 			spin_lock_bh(&amp;sl-&gt;lock);
 			if (sl-&gt;tty) {
@@ -989,19 +1299,18 @@
 			}
 			spin_unlock_bh(&amp;sl-&gt;lock);
 		}
-	} while (busy &amp;&amp; time_before(jiffies, timeout));
+	}while (busy &amp;&amp; time_before(jiffies, timeout));

-
 	for (i = 0; i &lt; maxdev; i++) {
 		dev = slcan_devs[i];
 		if (!dev)
-			continue;
+		continue;
 		slcan_devs[i] = NULL;

 		sl = netdev_priv(dev);
 		if (sl-&gt;tty) {
 			printk(KERN_ERR &quot;%s: tty discipline still running\n&quot;,
-			       dev-&gt;name);
+					dev-&gt;name);
 			/* Intentionally leak the control block. */
 			dev-&gt;destructor = NULL;
 		}
@@ -1014,8 +1323,8 @@

 	i = tty_unregister_ldisc(N_SLCAN);
 	if (i)
-		printk(KERN_ERR &quot;slcan: can't unregister ldisc (err %d)\n&quot;, i);
+	printk(KERN_ERR &quot;slcan: can't unregister ldisc (err %d)\n&quot;, i);
 }

-module_init(slcan_init);
-module_exit(slcan_exit);
+module_init( slcan_init);
+module_exit( slcan_exit);
Index: can-utils/slcan_attach.c
===================================================================
--- can-utils/slcan_attach.c	(Revision 1054)
+++ can-utils/slcan_attach.c	(Arbeitskopie)
@@ -45,18 +45,22 @@
  *
  */

-#include &lt;stdio.h&gt;
+#include &lt;termios.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;stdint.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;unistd.h&gt;
+#include &lt;stdio.h&gt;
 #include &lt;getopt.h&gt;
 #include &lt;sys/ioctl.h&gt;
+#include &lt;sys/select.h&gt;
+#include &lt;sys/file.h&gt;

+#define BUFFERSIZE 20
 #define LDISC_N_SLCAN 17 /* default slcan line discipline since
Kernel 2.6.25 */

-void print_usage(char *prg)
-{
+void print_usage(char *prg) {
 	fprintf(stderr, &quot;\nUsage: %s [options] tty\n\n&quot;, prg);
 	fprintf(stderr, &quot;Options: -o         (send open command 'O\\r')\n&quot;);
 	fprintf(stderr, &quot;         -c         (send close command 'C\\r')\n&quot;);
@@ -64,6 +68,7 @@
 	fprintf(stderr, &quot;         -b &lt;btr&gt;   (set bit time register value)\n&quot;);
 	fprintf(stderr, &quot;         -d         (only detach line discipline)\n&quot;);
 	fprintf(stderr, &quot;         -w         (attach - wait for keypess - detach)\n&quot;);
+	fprintf(stderr, &quot;         -B         (use binary mode)\n&quot;);
 	fprintf(stderr, &quot;\nExamples:\n&quot;);
 	fprintf(stderr, &quot;slcan_attach -w -o -s6 -c /dev/ttyS1\n&quot;);
 	fprintf(stderr, &quot;slcan_attach /dev/ttyS1\n&quot;);
@@ -72,26 +77,30 @@
 	exit(1);
 }

-int main(int argc, char **argv)
-{
+int main(int argc, char **argv) {
 	int fd;
 	int ldisc = LDISC_N_SLCAN;
 	int detach = 0;
 	int waitkey = 0;
 	int send_open = 0;
 	int send_close = 0;
+	int binary = 0;
 	char *speed = NULL;
 	char *btr = NULL;
 	char buf[10];
 	char *tty;
 	int opt;

-	while ((opt = getopt(argc, argv, &quot;l:dwocs:b:?&quot;)) != -1) {
+	while ((opt = getopt(argc, argv, &quot;l:dwBocs:b:?&quot;)) != -1) {
 		switch (opt) {
 		case 'l':
 			fprintf(stderr, &quot;Ignored option '-l'\n&quot;);
 			break;

+		case 'B':
+			binary = 1;
+			break;
+
 		case 'd':
 			detach = 1;
 			break;
@@ -132,7 +141,7 @@

 	tty = argv[optind];

-	if ((fd = open (tty, O_WRONLY | O_NOCTTY)) &lt; 0) {
+	if ((fd = open(tty, O_WRONLY | O_NOCTTY)) &lt; 0) {
 		perror(tty);
 		exit(1);
 	}
@@ -154,9 +163,13 @@
 			write(fd, buf, strlen(buf));
 		}

-		if (ioctl (fd, TIOCSETD, &amp;ldisc) &lt; 0) {
+		if (ioctl(fd, TIOCSETD, &amp;ldisc) &lt; 0) {
 			perror(&quot;ioctl&quot;);
 			exit(1);
+		} else {
+			if (binary)
+				if(ioctl(fd, SIOCSIFENCAP, 1)!=0)
+					perror(&quot;ioctl2&quot;);
 		}
 	}

@@ -167,7 +180,7 @@

 	if (waitkey || detach) {
 		ldisc = N_TTY;
-		if (ioctl (fd, TIOCSETD, &amp;ldisc) &lt; 0) {
+		if (ioctl(fd, TIOCSETD, &amp;ldisc) &lt; 0) {
 			perror(&quot;ioctl&quot;);
 			exit(1);
 		}

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003081.html">[PATCH v3] at91_can
</A></li>
	<LI>Next message: <A HREF="003073.html">[PATCH v2] CAN: Add support for binary protocol to slcan
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3070">[ date ]</a>
              <a href="thread.html#3070">[ thread ]</a>
              <a href="subject.html#3070">[ subject ]</a>
              <a href="author.html#3070">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
