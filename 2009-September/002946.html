<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH] net-next:can: add TI CAN (HECC) driver
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20net-next%3Acan%3A%20add%20TI%20CAN%20%28HECC%29%20driver&In-Reply-To=%3C20090901090427.GA3199%40pengutronix.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="002947.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH] net-next:can: add TI CAN (HECC) driver</H1>
    <B>Wolfram Sang</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20net-next%3Acan%3A%20add%20TI%20CAN%20%28HECC%29%20driver&In-Reply-To=%3C20090901090427.GA3199%40pengutronix.de%3E"
       TITLE="[PATCH] net-next:can: add TI CAN (HECC) driver">w.sang at pengutronix.de
       </A><BR>
    <I>Tue Sep  1 11:04:27 CEST 2009</I>
    <P><UL>
        
        <LI>Next message: <A HREF="002947.html">[PATCH] net-next:can: add TI CAN (HECC) driver
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2946">[ date ]</a>
              <a href="thread.html#2946">[ thread ]</a>
              <a href="subject.html#2946">[ subject ]</a>
              <a href="author.html#2946">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello Anant,

On Fri, Aug 28, 2009 at 04:48:02PM +0530, Anant Gole wrote:
&gt;<i> TI HECC (High End CAN Controller) module is found on many TI devices. It has
</I>&gt;<i> 32 harwdare mailboxes with full implementation of CAN protocol version 2.0B
</I>&gt;<i> and bus speeds up to 1Mbps. The module specifications are available at TI web
</I>&gt;<i> &lt;<A HREF="http://www.ti.com">http://www.ti.com</A>&gt;.
</I>&gt;<i> 
</I>&gt;<i> This driver is tested on OMAP3517 EVM. Suspend/Resume not tested as yet.
</I>
One minor thing I found while glimpsing at the code...

&gt;<i> 
</I>&gt;<i> Signed-off-by: Anant Gole &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">anantgole at ti.com</A>&gt;
</I>&gt;<i> ---
</I>&gt;<i>  drivers/net/can/Kconfig                       |    9 +
</I>&gt;<i>  drivers/net/can/Makefile                      |    2 +
</I>&gt;<i>  drivers/net/can/ti_hecc.c                     | 1352 +++++++++++++++++++++++++
</I>&gt;<i>  include/linux/can/platform/ti_hecc_platform.h |   40 +
</I>&gt;<i>  4 files changed, 1403 insertions(+), 0 deletions(-)
</I>&gt;<i>  create mode 100644 drivers/net/can/ti_hecc.c
</I>&gt;<i>  create mode 100644 include/linux/can/platform/ti_hecc_platform.h
</I>&gt;<i> 
</I>&gt;<i> diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
</I>&gt;<i> index 30ae55d..fae62df 100644
</I>&gt;<i> --- a/drivers/net/can/Kconfig
</I>&gt;<i> +++ b/drivers/net/can/Kconfig
</I>&gt;<i> @@ -75,6 +75,15 @@ config CAN_KVASER_PCI
</I>&gt;<i>  	  This driver is for the the PCIcanx and PCIcan cards (1, 2 or
</I>&gt;<i>  	  4 channel) from Kvaser (<A HREF="http://www.kvaser.com">http://www.kvaser.com</A>).
</I>&gt;<i>  
</I>&gt;<i> +config CAN_TI_HECC
</I>&gt;<i> +        depends on CAN_DEV
</I>&gt;<i> +        tristate &quot;TI High End CAN Controller (HECC)&quot;
</I>&gt;<i> +        default N
</I>&gt;<i> +        ---help---
</I>&gt;<i> +	  This driver adds support for TI High End CAN Controller module
</I>&gt;<i> +	  found on many TI devices. The specifications of this module are
</I>&gt;<i> +	  are available from TI web (<A HREF="http://www.ti.com">http://www.ti.com</A>)
</I>&gt;<i> +
</I>&gt;<i>  config CAN_DEBUG_DEVICES
</I>&gt;<i>  	bool &quot;CAN devices debugging messages&quot;
</I>&gt;<i>  	depends on CAN
</I>&gt;<i> diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
</I>&gt;<i> index 523a941..d923512 100644
</I>&gt;<i> --- a/drivers/net/can/Makefile
</I>&gt;<i> +++ b/drivers/net/can/Makefile
</I>&gt;<i> @@ -9,4 +9,6 @@ can-dev-y			:= dev.o
</I>&gt;<i>  
</I>&gt;<i>  obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
</I>&gt;<i>  
</I>&gt;<i> +obj-$(CONFIG_CAN_TI_HECC)	+= ti_hecc.o
</I>&gt;<i> +
</I>&gt;<i>  ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
</I>&gt;<i> diff --git a/drivers/net/can/ti_hecc.c b/drivers/net/can/ti_hecc.c
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..4741b4a
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/ti_hecc.c
</I>&gt;<i> @@ -0,0 +1,1352 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * TI HECC (CAN) device driver
</I>&gt;<i> + *
</I>&gt;<i> + * This driver supports TI's HECC (High End CAN Controller module) and the
</I>&gt;<i> + * specs for the same is available at &lt;<A HREF="http://www.ti.com">http://www.ti.com</A>&gt;
</I>&gt;<i> + *
</I>&gt;<i> + * Copyright (C) 2009 Texas Instruments Incorporated - <A HREF="http://www.ti.com/">http://www.ti.com/</A>
</I>&gt;<i> + *
</I>&gt;<i> + * This program is free software; you can redistribute it and/or
</I>&gt;<i> + * modify it under the terms of the GNU General Public License as
</I>&gt;<i> + * published by the Free Software Foundation version 2.
</I>&gt;<i> + *
</I>&gt;<i> + * This program is distributed as is WITHOUT ANY WARRANTY of any
</I>&gt;<i> + * kind, whether express or implied; without even the implied warranty
</I>&gt;<i> + * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</I>&gt;<i> + * GNU General Public License for more details.
</I>&gt;<i> + *
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/module.h&gt;
</I>&gt;<i> +#include &lt;linux/init.h&gt;
</I>&gt;<i> +#include &lt;linux/kernel.h&gt;
</I>&gt;<i> +#include &lt;linux/sched.h&gt;
</I>&gt;<i> +#include &lt;linux/types.h&gt;
</I>&gt;<i> +#include &lt;linux/fcntl.h&gt;
</I>&gt;<i> +#include &lt;linux/interrupt.h&gt;
</I>&gt;<i> +#include &lt;linux/ptrace.h&gt;
</I>&gt;<i> +#include &lt;linux/string.h&gt;
</I>&gt;<i> +#include &lt;linux/errno.h&gt;
</I>&gt;<i> +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> +#include &lt;linux/if_arp.h&gt;
</I>&gt;<i> +#include &lt;linux/if_ether.h&gt;
</I>&gt;<i> +#include &lt;linux/skbuff.h&gt;
</I>&gt;<i> +#include &lt;linux/delay.h&gt;
</I>&gt;<i> +#include &lt;linux/platform_device.h&gt;
</I>&gt;<i> +#include &lt;linux/clk.h&gt;
</I>&gt;<i> +#include &lt;linux/io.h&gt;
</I>&gt;<i> +#include &lt;linux/debugfs.h&gt;
</I>&gt;<i> +#include &lt;linux/can.h&gt;
</I>&gt;<i> +#include &lt;linux/can/dev.h&gt;
</I>&gt;<i> +#include &lt;linux/can/error.h&gt;
</I>&gt;<i> +#include &lt;linux/can/platform/ti_hecc_platform.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#define DRV_NAME &quot;TI HECC&quot;
</I>&gt;<i> +#define HECC_MODULE_VERSION     &quot;0.2&quot;
</I>&gt;<i> +MODULE_VERSION(HECC_MODULE_VERSION);
</I>&gt;<i> +#define DRV_DESC &quot;TI High End CAN Controller Driver &quot; HECC_MODULE_VERSION
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_MAX_MAILBOXES	32	/* hardware mboxes - do not change */
</I>&gt;<i> +
</I>&gt;<i> +#if (CAN_ECHO_SKB_MAX &gt; 16)
</I>&gt;<i> +#define TI_HECC_MAX_TX_MBOX	16
</I>&gt;<i> +#else
</I>&gt;<i> +#define TI_HECC_MAX_TX_MBOX	CAN_ECHO_SKB_MAX
</I>&gt;<i> +#endif
</I>&gt;<i> +#define TI_HECC_MAX_RX_MBOX	(HECC_MAX_MAILBOXES - TI_HECC_MAX_TX_MBOX)
</I>&gt;<i> +
</I>&gt;<i> +#define TI_HECC_DEF_NAPI_WEIGHT	TI_HECC_MAX_RX_MBOX
</I>&gt;<i> +
</I>&gt;<i> +/* TI HECC module registers */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANME		0x0	/* Mailbox enable */
</I>&gt;<i> +#define HECC_CANMD		0x4	/* Mailbox direction */
</I>&gt;<i> +#define HECC_CANTRS		0x8	/* Transmit request set */
</I>&gt;<i> +#define HECC_CANTRR		0xC	/* Transmit request */
</I>&gt;<i> +#define HECC_CANTA		0x10	/* Transmission acknowledge */
</I>&gt;<i> +#define HECC_CANAA		0x14	/* Abort acknowledge */
</I>&gt;<i> +#define HECC_CANRMP		0x18	/* Receive message pending */
</I>&gt;<i> +#define HECC_CANRML		0x1C	/* Remote message lost */
</I>&gt;<i> +#define HECC_CANRFP		0x20	/* Remote frame pending */
</I>&gt;<i> +#define HECC_CANGAM		0x24	/* SECC only:Global acceptance mask */
</I>&gt;<i> +#define HECC_CANMC		0x28	/* Master control */
</I>&gt;<i> +#define HECC_CANBTC		0x2C	/* Bit timing configuration */
</I>&gt;<i> +#define HECC_CANES		0x30	/* Error and status */
</I>&gt;<i> +#define HECC_CANTEC		0x34	/* Transmit error counter */
</I>&gt;<i> +#define HECC_CANREC		0x38	/* Receive error counter */
</I>&gt;<i> +#define HECC_CANGIF0		0x3C	/* Global interrupt flag 0 */
</I>&gt;<i> +#define HECC_CANGIM		0x40	/* Global interrupt mask */
</I>&gt;<i> +#define HECC_CANGIF1		0x44	/* Global interrupt flag 1 */
</I>&gt;<i> +#define HECC_CANMIM		0x48	/* Mailbox interrupt mask */
</I>&gt;<i> +#define HECC_CANMIL		0x4C	/* Mailbox interrupt level */
</I>&gt;<i> +#define HECC_CANOPC		0x50	/* Overwrite protection control */
</I>&gt;<i> +#define HECC_CANTIOC		0x54	/* Transmit I/O control */
</I>&gt;<i> +#define HECC_CANRIOC		0x58	/* Receive I/O control */
</I>&gt;<i> +#define HECC_CANLNT		0x5C	/* HECC only: Local network time */
</I>&gt;<i> +#define HECC_CANTOC		0x60	/* HECC only: Time-out control */
</I>&gt;<i> +#define HECC_CANTOS		0x64	/* HECC only: Time-out status */
</I>&gt;<i> +#define HECC_CANTIOCE		0x68	/* SCC only:Enhanced TX I/O control */
</I>&gt;<i> +#define HECC_CANRIOCE		0x6C	/* SCC only:Enhanced RX I/O control */
</I>&gt;<i> +
</I>&gt;<i> +/* SCC only:Local acceptance registers */
</I>&gt;<i> +#define HECC_CANLAM0		(priv-&gt;scc_ram_offset + 0x0)
</I>&gt;<i> +#define HECC_CANLAM3		(priv-&gt;scc_ram_offset + 0xC)
</I>&gt;<i> +
</I>&gt;<i> +/* HECC only */
</I>&gt;<i> +#define HECC_CANLAM(mbxno)	(priv-&gt;hecc_ram_offset + ((mbxno) * 4))
</I>&gt;<i> +#define HECC_CANMOTS(mbxno)	(priv-&gt;hecc_ram_offset + ((mbxno) * 4) + 0x80)
</I>&gt;<i> +#define HECC_CANMOTO(mbxno)	(priv-&gt;hecc_ram_offset + ((mbxno) * 4) + 0x100)
</I>&gt;<i> +
</I>&gt;<i> +/* Mailbox registers */
</I>&gt;<i> +#define HECC_CANMID(mbxno)	(priv-&gt;mbox_offset + ((mbxno) * 0x10))
</I>&gt;<i> +#define HECC_CANMCF(mbxno)	(priv-&gt;mbox_offset + ((mbxno) * 0x10) + 0x4)
</I>&gt;<i> +#define HECC_CANMDL(mbxno)	(priv-&gt;mbox_offset + ((mbxno) * 0x10) + 0x8)
</I>&gt;<i> +#define HECC_CANMDH(mbxno)	(priv-&gt;mbox_offset + ((mbxno) * 0x10) + 0xC)
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_SET_REG		0xFFFFFFFF
</I>&gt;<i> +#define HECC_CANID_MASK		0x3FF	/* 18 bits mask for extended id's */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANMC_SCM		BIT(13)	/* SCC compat mode */
</I>&gt;<i> +#define HECC_CANMC_CCR		BIT(12)	/* Change config request */
</I>&gt;<i> +#define HECC_CANMC_PDR		BIT(11)	/* Local Power down - for sleep mode */
</I>&gt;<i> +#define HECC_CANMC_ABO		BIT(7)	/* Auto Bus On */
</I>&gt;<i> +#define HECC_CANMC_STM		BIT(6)	/* Self test mode - loopback */
</I>&gt;<i> +#define HECC_CANMC_SRES		BIT(5)	/* Software reset */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANTIOC_EN		BIT(3)	/* Enable CAN TX I/O pin */
</I>&gt;<i> +#define HECC_CANRIOC_EN		BIT(3)	/* Enable CAN RX I/O pin */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANMID_IDE		BIT(31)	/* Extended frame format */
</I>&gt;<i> +#define HECC_CANMID_AME		BIT(30)	/* Acceptance mask enable */
</I>&gt;<i> +#define HECC_CANMID_AAM		BIT(29)	/* Auto answer mode */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANES_FE		BIT(24)	/* form error */
</I>&gt;<i> +#define HECC_CANES_BE		BIT(23)	/* bit error */
</I>&gt;<i> +#define HECC_CANES_SA1		BIT(22)	/* stuck at dominant error */
</I>&gt;<i> +#define HECC_CANES_CRCE		BIT(21)	/* CRC error */
</I>&gt;<i> +#define HECC_CANES_SE		BIT(20)	/* stuff bit error */
</I>&gt;<i> +#define HECC_CANES_ACKE		BIT(19)	/* ack error */
</I>&gt;<i> +#define HECC_CANES_BO		BIT(18)	/* Bus off status */
</I>&gt;<i> +#define HECC_CANES_EP		BIT(17)	/* Error passive status */
</I>&gt;<i> +#define HECC_CANES_EW		BIT(16)	/* Error warning status */
</I>&gt;<i> +#define HECC_CANES_SMA		BIT(5)	/* suspend mode ack */
</I>&gt;<i> +#define HECC_CANES_CCE		BIT(4)	/* Change config enabled */
</I>&gt;<i> +#define HECC_CANES_PDA		BIT(3)	/* Power down mode ack */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANBTC_SAM		BIT(7)	/* sample points */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_BUS_ERROR		(HECC_CANES_FE | HECC_CANES_BE |\
</I>&gt;<i> +				HECC_CANES_CRCE | HECC_CANES_SE |\
</I>&gt;<i> +				HECC_CANES_ACKE)
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANMCF_RTR		BIT(4)	/* Remote xmit request */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANGIF_MAIF	BIT(17)	/* Message alarm interrupt */
</I>&gt;<i> +#define HECC_CANGIF_TCOIF	BIT(16) /* Timer counter overflow int */
</I>&gt;<i> +#define HECC_CANGIF_GMIF	BIT(15)	/* Global mailbox interrupt */
</I>&gt;<i> +#define HECC_CANGIF_AAIF	BIT(14)	/* Abort ack interrupt */
</I>&gt;<i> +#define HECC_CANGIF_WDIF	BIT(13)	/* Write denied interrupt */
</I>&gt;<i> +#define HECC_CANGIF_WUIF	BIT(12)	/* Wake up interrupt */
</I>&gt;<i> +#define HECC_CANGIF_RMLIF	BIT(11)	/* Receive message lost interrupt */
</I>&gt;<i> +#define HECC_CANGIF_BOIF	BIT(10)	/* Bus off interrupt */
</I>&gt;<i> +#define HECC_CANGIF_EPIF	BIT(9)	/* Error passive interrupt */
</I>&gt;<i> +#define HECC_CANGIF_WLIF	BIT(8)	/* Warning level interrupt */
</I>&gt;<i> +#define HECC_CANGIF_MBOX_MASK	0x1F	/* Mailbox number mask */
</I>&gt;<i> +#define HECC_CANGIM_I1EN	BIT(1)	/* Int line 1 enable */
</I>&gt;<i> +#define HECC_CANGIM_I0EN	BIT(0)	/* Int line 0 enable */
</I>&gt;<i> +#define HECC_CANGIM_DEF_MASK	0xFF00	/* all except maif and tcoif */
</I>&gt;<i> +#define HECC_CANGIM_SIL		BIT(2)	/* system interrupts to int line 1 */
</I>&gt;<i> +
</I>&gt;<i> +/* CAN Bittiming constants as per HECC specs */
</I>&gt;<i> +static struct can_bittiming_const ti_hecc_bittiming_const = {
</I>&gt;<i> +	.name = DRV_NAME,
</I>&gt;<i> +	.tseg1_min = 1,
</I>&gt;<i> +	.tseg1_max = 16,
</I>&gt;<i> +	.tseg2_min = 1,
</I>&gt;<i> +	.tseg2_max = 8,
</I>&gt;<i> +	.sjw_max = 4,
</I>&gt;<i> +	.brp_min = 1,
</I>&gt;<i> +	.brp_max = 256,
</I>&gt;<i> +	.brp_inc = 1,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct ti_hecc_priv {
</I>&gt;<i> +	struct can_priv can;
</I>&gt;<i> +	struct napi_struct napi;
</I>&gt;<i> +	struct net_device *ndev;
</I>&gt;<i> +	struct clk *clk;
</I>&gt;<i> +	void __iomem *base;
</I>&gt;<i> +	unsigned int scc_ram_offset;
</I>&gt;<i> +	unsigned int hecc_ram_offset;
</I>&gt;<i> +	unsigned int mbox_offset;
</I>&gt;<i> +	unsigned int int_line;
</I>&gt;<i> +	DECLARE_BITMAP(tx_free_mbx, TI_HECC_MAX_TX_MBOX);
</I>&gt;<i> +	spinlock_t tx_lock;
</I>&gt;<i> +
</I>&gt;<i> +	/* Statistics */
</I>&gt;<i> +	unsigned out_of_tx_mbox;
</I>&gt;<i> +	unsigned write_denied_cnt;
</I>&gt;<i> +	unsigned message_lost_cnt;
</I>&gt;<i> +	unsigned wake_up_cnt;
</I>&gt;<i> +	unsigned message_alarm_cnt;
</I>&gt;<i> +	unsigned timer_overflow_cnt;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static inline
</I>&gt;<i> +void hecc_write(struct ti_hecc_priv *priv, int reg, unsigned int val)
</I>&gt;<i> +{
</I>&gt;<i> +	__raw_writel(val, priv-&gt;base + reg);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline unsigned int hecc_read(struct ti_hecc_priv *priv, int reg)
</I>&gt;<i> +{
</I>&gt;<i> +	return __raw_readl(priv-&gt;base + reg);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline
</I>&gt;<i> +void hecc_set_bit(struct ti_hecc_priv *priv, int reg, unsigned bit)
</I>&gt;<i> +{
</I>&gt;<i> +	hecc_write(priv, reg, (hecc_read(priv, reg) | bit));
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline
</I>&gt;<i> +void hecc_clear_bit(struct ti_hecc_priv *priv, int reg, unsigned bit)
</I>&gt;<i> +{
</I>&gt;<i> +	hecc_write(priv, reg, (hecc_read(priv, reg) &amp; ~bit));
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline
</I>&gt;<i> +unsigned int hecc_get_bit(struct ti_hecc_priv *priv, int reg, int bit)
</I>&gt;<i> +{
</I>&gt;<i> +	return (hecc_read(priv, reg) &amp; bit) ? 1 : 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_DEBUG_FS
</I>&gt;<i> +
</I>&gt;<i> +static struct ti_hecc_priv *debug_priv;
</I>&gt;<i> +
</I>&gt;<i> +#define PRINTMBOXREG(r) seq_printf(s, &quot;%d\t%08X %08X %08X %08X %08X\n&quot;, r,\
</I>&gt;<i> +	hecc_read(debug_priv, HECC_CANMID(r)),\
</I>&gt;<i> +	hecc_read(debug_priv, HECC_CANMCF(r)),\
</I>&gt;<i> +	hecc_read(debug_priv, HECC_CANMDH(r)),\
</I>&gt;<i> +	hecc_read(debug_priv, HECC_CANMDL(r)),\
</I>&gt;<i> +	hecc_read(debug_priv, HECC_CANLAM(r)))
</I>&gt;<i> +
</I>&gt;<i> +/* Print mailbox data */
</I>&gt;<i> +static void hecc_print_mbox_regs(struct seq_file *s)
</I>&gt;<i> +{
</I>&gt;<i> +	int cnt = 0;
</I>&gt;<i> +	static struct ti_hecc_priv *priv;
</I>&gt;<i> +	priv = debug_priv;
</I>&gt;<i> +	seq_printf(s, &quot;\n--- %s %s - mailbox regs ---\n\n&quot;,
</I>&gt;<i> +		DRV_NAME, HECC_MODULE_VERSION);
</I>&gt;<i> +	seq_printf(s, &quot;MbxNo\tMID\t MCF\t  MDH\t   MDL\t   LAM\n&quot;);
</I>&gt;<i> +	seq_printf(s, &quot;-----------------------------------------------\n&quot;);
</I>&gt;<i> +	for (cnt = 0; cnt &lt; HECC_MAX_MAILBOXES; cnt++)
</I>&gt;<i> +		PRINTMBOXREG(cnt);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#define PRINTREG(d, r) seq_printf(s, &quot;%s\t%08x\n&quot;, d, hecc_read(debug_priv, r))
</I>&gt;<i> +/* Print HECC registers */
</I>&gt;<i> +static void hecc_print_regs(struct seq_file *s)
</I>&gt;<i> +{
</I>&gt;<i> +	static struct ti_hecc_priv *priv;
</I>&gt;<i> +	priv = debug_priv;
</I>&gt;<i> +
</I>&gt;<i> +	seq_printf(s, &quot;\n--- %s %s - module regs ---\n\n&quot;,
</I>&gt;<i> +		DRV_NAME, HECC_MODULE_VERSION);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANME\tMailbox Enable\t&quot;, HECC_CANME);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANMD\tMailbox Direction&quot;, HECC_CANMD);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANTRS\tTransmit request set&quot;, HECC_CANTRS);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANTRR\tTransmit request reset&quot;, HECC_CANTRR);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANTA\tTransmission ack&quot;, HECC_CANTA);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANAA\tAbort acknowledge&quot;, HECC_CANAA);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANRMP\tReceive message pending&quot;, HECC_CANRMP);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANRML\tRemote message lost&quot;, HECC_CANRML);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANRFP\tRemote frame pending&quot;, HECC_CANRFP);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANGAM (SCC) Global accept mask&quot;, HECC_CANGAM);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANMC\tMaster control\t&quot;, HECC_CANMC);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANBTC\tBit timing config&quot;, HECC_CANBTC);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANES\tError and status&quot;, HECC_CANES);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANTEC\tTransmit error counter&quot;, HECC_CANTEC);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANREC\tReceive error counter&quot;, HECC_CANREC);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANGIF0\tGlobal interrupt flag 0&quot;, HECC_CANGIF0);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANGIM\tGlobal interrupt mask&quot;, HECC_CANGIM);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANGIF1\tGlobal interrupt flag 1&quot;, HECC_CANGIF1);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANMIM\tMailbox interrupt mask&quot;, HECC_CANMIM);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANMIL\tMailbox interrupt level&quot;, HECC_CANMIL);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANOPC\tOverwrite prot control&quot;, HECC_CANOPC);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANTIOC\tTransmit I/O control&quot;, HECC_CANTIOC);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANRIOC\tReceive I/O control&quot;, HECC_CANRIOC);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANLNT (HECC) Local network time&quot;, HECC_CANLNT);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANTOC (HECC) Time-out control&quot;, HECC_CANTOC);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANTOS (HECC) Time-out status&quot;, HECC_CANTOS);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANTIOCE (SCC) Enh TX I/O ctrl&quot;, HECC_CANTIOCE);
</I>&gt;<i> +	PRINTREG(&quot;HECC_CANRIOCE (SCC) Enh RX I/O ctrl&quot;, HECC_CANRIOCE);
</I>&gt;<i> +	seq_printf(s, &quot;HECC_CANLAM0 (SCC) \t\t\t%08X\n&quot;,
</I>&gt;<i> +		hecc_read(priv, HECC_CANLAM0));
</I>&gt;<i> +	seq_printf(s, &quot;HECC_CANLAM3 (SCC) \t\t\t%08X\n&quot;,
</I>&gt;<i> +		hecc_read(priv, HECC_CANLAM3));
</I>&gt;<i> +	seq_printf(s, &quot;\n&quot;);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static char *hecc_debug_can_state[] = {
</I>&gt;<i> +	&quot;CAN_STATE_ERROR_ACTIVE&quot;,
</I>&gt;<i> +	&quot;CAN_STATE_ERROR_WARNING&quot;,
</I>&gt;<i> +	&quot;CAN_STATE_ERROR_PASSIVE&quot;,
</I>&gt;<i> +	&quot;CAN_STATE_BUS_OFF&quot;,
</I>&gt;<i> +	&quot;CAN_STATE_STOPPED&quot;,
</I>&gt;<i> +	&quot;CAN_STATE_SLEEPING&quot;,
</I>&gt;<i> +	&quot;CAN_STATE_MAX&quot;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/* Print status and statistics */
</I>&gt;<i> +static void hecc_print_status(struct seq_file *s)
</I>&gt;<i> +{
</I>&gt;<i> +	seq_printf(s, &quot;\n--- %s %s - status ---\n\n&quot;,
</I>&gt;<i> +		DRV_NAME, HECC_MODULE_VERSION);
</I>&gt;<i> +	seq_printf(s, &quot;\n--- ti_hecc status ---\n\n&quot;);
</I>&gt;<i> +	seq_printf(s, &quot;CAN state \t\t= %s\n&quot;,
</I>&gt;<i> +		hecc_debug_can_state[debug_priv-&gt;can.state]);
</I>&gt;<i> +	seq_printf(s, &quot;CAN restart_ms \t\t= %u\n&quot;, debug_priv-&gt;can.restart_ms);
</I>&gt;<i> +	seq_printf(s, &quot;CAN input clock \t= %u\n&quot;, debug_priv-&gt;can.clock.freq);
</I>&gt;<i> +	seq_printf(s, &quot;CAN Bittiming\n&quot;);
</I>&gt;<i> +	seq_printf(s, &quot;\tbitrate \t= %u\n&quot;,
</I>&gt;<i> +			debug_priv-&gt;can.bittiming.bitrate);
</I>&gt;<i> +	seq_printf(s, &quot;\tsample_point \t= %u\n&quot;,
</I>&gt;<i> +			debug_priv-&gt;can.bittiming.sample_point);
</I>&gt;<i> +	seq_printf(s, &quot;\ttq \t\t= %u\n&quot;,
</I>&gt;<i> +			debug_priv-&gt;can.bittiming.tq);
</I>&gt;<i> +	seq_printf(s, &quot;\tprop_seg \t= %u\n&quot;,
</I>&gt;<i> +			debug_priv-&gt;can.bittiming.prop_seg);
</I>&gt;<i> +	seq_printf(s, &quot;\tphase_seg1 \t= %u\n&quot;,
</I>&gt;<i> +			debug_priv-&gt;can.bittiming.phase_seg1);
</I>&gt;<i> +	seq_printf(s, &quot;\tphase_seg2 \t= %u\n&quot;,
</I>&gt;<i> +			debug_priv-&gt;can.bittiming.phase_seg2);
</I>&gt;<i> +	seq_printf(s, &quot;\tsjw \t\t= %u\n&quot;,
</I>&gt;<i> +			debug_priv-&gt;can.bittiming.sjw);
</I>&gt;<i> +	seq_printf(s, &quot;\tbrp \t\t= %u\n&quot;,
</I>&gt;<i> +			debug_priv-&gt;can.bittiming.brp);
</I>&gt;<i> +	seq_printf(s, &quot;CAN Bittiming Constants\n&quot;);
</I>&gt;<i> +	seq_printf(s, &quot;\ttseg1 min-max \t= %u-%u\n&quot;,
</I>&gt;<i> +			debug_priv-&gt;can.bittiming_const-&gt;tseg1_min,
</I>&gt;<i> +			debug_priv-&gt;can.bittiming_const-&gt;tseg1_max);
</I>&gt;<i> +	seq_printf(s, &quot;\ttseg2 min-max \t= %u-%u\n&quot;,
</I>&gt;<i> +			debug_priv-&gt;can.bittiming_const-&gt;tseg2_min,
</I>&gt;<i> +			debug_priv-&gt;can.bittiming_const-&gt;tseg2_max);
</I>&gt;<i> +	seq_printf(s, &quot;\tsjw_max \t= %u\n&quot;,
</I>&gt;<i> +			debug_priv-&gt;can.bittiming_const-&gt;sjw_max);
</I>&gt;<i> +	seq_printf(s, &quot;\tbrp min-max \t= %u-%u\n&quot;,
</I>&gt;<i> +			debug_priv-&gt;can.bittiming_const-&gt;brp_min,
</I>&gt;<i> +			debug_priv-&gt;can.bittiming_const-&gt;brp_max);
</I>&gt;<i> +	seq_printf(s, &quot;\tbrp_inc \t= %u\n&quot;,
</I>&gt;<i> +			debug_priv-&gt;can.bittiming_const-&gt;brp_inc);
</I>&gt;<i> +	seq_printf(s, &quot;CAN out of TX mbox\t= %d\n&quot;,
</I>&gt;<i> +		debug_priv-&gt;out_of_tx_mbox);
</I>&gt;<i> +	seq_printf(s, &quot;CAN write denied cnt \t= %d\n&quot;,
</I>&gt;<i> +		debug_priv-&gt;write_denied_cnt);
</I>&gt;<i> +	seq_printf(s, &quot;CAN message lost cnt \t= %d\n&quot;,
</I>&gt;<i> +		debug_priv-&gt;message_lost_cnt);
</I>&gt;<i> +	seq_printf(s, &quot;CAN wake up cnt \t= %d\n&quot;, debug_priv-&gt;wake_up_cnt);
</I>&gt;<i> +	seq_printf(s, &quot;CAN message alarm cnt \t= %d\n&quot;,
</I>&gt;<i> +		debug_priv-&gt;message_alarm_cnt);
</I>&gt;<i> +	seq_printf(s, &quot;CAN timer overflow cnt\t= %d\n&quot;,
</I>&gt;<i> +		debug_priv-&gt;timer_overflow_cnt);
</I>&gt;<i> +	/* CAN statistics */
</I>&gt;<i> +	seq_printf(s, &quot;CAN stats bus error \t= %d\n&quot;,
</I>&gt;<i> +		debug_priv-&gt;can.can_stats.bus_error);
</I>&gt;<i> +	seq_printf(s, &quot;CAN stats error warning\t= %d\n&quot;,
</I>&gt;<i> +		debug_priv-&gt;can.can_stats.error_warning);
</I>&gt;<i> +	seq_printf(s, &quot;CAN stats error passive\t= %d\n&quot;,
</I>&gt;<i> +		debug_priv-&gt;can.can_stats.error_passive);
</I>&gt;<i> +	seq_printf(s, &quot;CAN stats bus off\t= %d\n&quot;,
</I>&gt;<i> +		debug_priv-&gt;can.can_stats.bus_off);
</I>&gt;<i> +	seq_printf(s, &quot;CAN stats arbitration lost= %d\n&quot;,
</I>&gt;<i> +		debug_priv-&gt;can.can_stats.arbitration_lost);
</I>&gt;<i> +	seq_printf(s, &quot;CAN stats restarts\t= %d\n&quot;,
</I>&gt;<i> +		debug_priv-&gt;can.can_stats.restarts);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/** Toggle HECC Self-Test i.e loopback bit
</I>&gt;<i> + * INFO: Reading this debug variable toggles the loopback status on the device.
</I>&gt;<i> + * This is done to simplify the debug function to set looback
</I>&gt;<i> + */
</I>&gt;<i> +static int hecc_debug_loopback(struct seq_file *s)
</I>&gt;<i> +{
</I>&gt;<i> +	static int toggle;
</I>&gt;<i> +
</I>&gt;<i> +	/* Put module in self test mode i.e. loopback */
</I>&gt;<i> +	if (toggle) {
</I>&gt;<i> +		seq_printf(s, &quot;In Self Test Mode (loopback)\n&quot;);
</I>&gt;<i> +		hecc_set_bit(debug_priv, HECC_CANMC, HECC_CANMC_STM);
</I>&gt;<i> +		toggle = 0;
</I>&gt;<i> +	} else {
</I>&gt;<i> +		seq_printf(s, &quot;Out of Self Test Mode (NO loopback)\n&quot;);
</I>&gt;<i> +		hecc_clear_bit(debug_priv, HECC_CANMC, HECC_CANMC_STM);
</I>&gt;<i> +		toggle = 1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int hecc_debug_show(struct seq_file *s, void *unused)
</I>&gt;<i> +{
</I>&gt;<i> +	void (*func)(struct seq_file *) = s-&gt;private;
</I>&gt;<i> +	func(s);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int hecc_debug_open(struct inode *inode, struct file *file)
</I>&gt;<i> +{
</I>&gt;<i> +	return single_open(file, hecc_debug_show, inode-&gt;i_private);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/* HECC debug operations */
</I>&gt;<i> +static const struct file_operations hecc_debug_fops = {
</I>&gt;<i> +	.open		= hecc_debug_open,
</I>&gt;<i> +	.read		= seq_read,
</I>&gt;<i> +	.llseek		= seq_lseek,
</I>&gt;<i> +	.release	= single_release,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static struct dentry *hecc_dir;
</I>&gt;<i> +static unsigned int hecc_debug_state;
</I>&gt;<i> +
</I>&gt;<i> +static int hecc_debug_init(struct ti_hecc_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	debug_priv = priv;
</I>&gt;<i> +
</I>&gt;<i> +	hecc_dir = debugfs_create_dir(&quot;ti_hecc&quot;, NULL);
</I>&gt;<i> +	if (IS_ERR(hecc_dir)) {
</I>&gt;<i> +		int err = PTR_ERR(hecc_dir);
</I>&gt;<i> +		hecc_dir = NULL;
</I>&gt;<i> +		return err;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	debugfs_create_file(&quot;ti_hecc_regs&quot;, S_IRUGO,
</I>&gt;<i> +			hecc_dir, &amp;hecc_print_regs, &amp;hecc_debug_fops);
</I>&gt;<i> +	debugfs_create_file(&quot;ti_hecc_mbox_regs&quot;, S_IRUGO,
</I>&gt;<i> +			hecc_dir, &amp;hecc_print_mbox_regs, &amp;hecc_debug_fops);
</I>&gt;<i> +	debugfs_create_file(&quot;ti_hecc_status&quot;, S_IRUGO,
</I>&gt;<i> +			hecc_dir, &amp;hecc_print_status, &amp;hecc_debug_fops);
</I>&gt;<i> +	debugfs_create_file(&quot;ti_hecc_loopback&quot;, S_IRUGO,
</I>&gt;<i> +			hecc_dir, &amp;hecc_debug_loopback, &amp;hecc_debug_fops);
</I>&gt;<i> +	debugfs_create_u32(&quot;ti_hecc_debug&quot;, S_IWUGO,
</I>&gt;<i> +			hecc_dir, &amp;hecc_debug_state);
</I>&gt;<i> +	debugfs_create_u32(&quot;ti_hecc_bittiming&quot;, S_IWUGO,
</I>&gt;<i> +			hecc_dir, &amp;debug_priv-&gt;can.bittiming.bitrate);
</I>&gt;<i> +	debugfs_create_u32(&quot;ti_hecc_restart_ms&quot;, S_IWUGO,
</I>&gt;<i> +			hecc_dir, &amp;debug_priv-&gt;can.restart_ms);
</I>&gt;<i> +	debugfs_create_u32(&quot;prop_seg&quot;, S_IWUGO,
</I>&gt;<i> +			hecc_dir, &amp;debug_priv-&gt;can.bittiming.prop_seg);
</I>&gt;<i> +	debugfs_create_u32(&quot;phase_seg2&quot;, S_IWUGO,
</I>&gt;<i> +			hecc_dir, &amp;debug_priv-&gt;can.bittiming.phase_seg2);
</I>&gt;<i> +	debugfs_create_u32(&quot;phase_seg1&quot;, S_IWUGO,
</I>&gt;<i> +			hecc_dir, &amp;debug_priv-&gt;can.bittiming.phase_seg1);
</I>&gt;<i> +	debugfs_create_u32(&quot;brp&quot;, S_IWUGO,
</I>&gt;<i> +			hecc_dir, &amp;debug_priv-&gt;can.bittiming.brp);
</I>&gt;<i> +	debugfs_create_u32(&quot;sjw&quot;, S_IWUGO,
</I>&gt;<i> +			hecc_dir, &amp;debug_priv-&gt;can.bittiming.sjw);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void hecc_debug_exit(void)
</I>&gt;<i> +{
</I>&gt;<i> +	if (hecc_dir)
</I>&gt;<i> +		debugfs_remove_recursive(hecc_dir);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#endif /* CONFIG_DEBUG_FS */
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_get_state(const struct net_device *ndev,
</I>&gt;<i> +	enum can_state *state)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	*state = priv-&gt;can.state;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_set_bittiming(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct can_bittiming *bit_timing = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> +	unsigned int can_btc = 0;
</I>&gt;<i> +
</I>&gt;<i> +	can_btc = ((bit_timing-&gt;phase_seg2 - 1) &amp; 0x7);
</I>&gt;<i> +	can_btc |= (((bit_timing-&gt;phase_seg1 + bit_timing-&gt;prop_seg - 1)
</I>&gt;<i> +			&amp; 0xF) &lt;&lt; 3);
</I>&gt;<i> +	if (bit_timing-&gt;brp &gt; 4)
</I>&gt;<i> +		can_btc |= HECC_CANBTC_SAM;
</I>&gt;<i> +	can_btc |= (((bit_timing-&gt;sjw - 1) &amp; 0x3) &lt;&lt; 8);
</I>&gt;<i> +	can_btc |= (((bit_timing-&gt;brp - 1) &amp; 0xFF) &lt;&lt; 16);
</I>&gt;<i> +
</I>&gt;<i> +	/* ERM being set to 0 by default meaning resync at falling edge */
</I>&gt;<i> +
</I>&gt;<i> +	hecc_write(priv, HECC_CANBTC, can_btc);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * ti_hecc_reset: Reset HECC module and set bit timings
</I>&gt;<i> + *
</I>&gt;<i> + * Resets HECC by writing to change config request bit and then sets
</I>&gt;<i> + * bit-timing registers in the module to enable the module for operation
</I>&gt;<i> + */
</I>&gt;<i> +static void ti_hecc_reset(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +#define HECC_CCE_WAIT_COUNT	1000
</I>&gt;<i> +	unsigned int cnt;
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	dev_dbg(ndev-&gt;dev.parent, &quot;resetting hecc ...\n&quot;);
</I>&gt;<i> +
</I>&gt;<i> +	hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_SRES);
</I>&gt;<i> +
</I>&gt;<i> +	/* if change control request not enabled */
</I>&gt;<i> +	if (!hecc_get_bit(priv, HECC_CANES, HECC_CANES_CCE)) {
</I>&gt;<i> +		/* Set change control request and wait till enabled */
</I>&gt;<i> +		hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
</I>&gt;<i> +
</I>&gt;<i> +		/* INFO: It has been observed that at times CCE bit may not be
</I>&gt;<i> +		 * set and hw seems to be ok even if this bit is not set so
</I>&gt;<i> +		 * timing out with a large counter to respect the specs
</I>&gt;<i> +		 */
</I>&gt;<i> +		cnt = HECC_CCE_WAIT_COUNT;
</I>&gt;<i> +		while (!hecc_get_bit(priv, HECC_CANES, HECC_CANES_CCE)) {
</I>&gt;<i> +			--cnt;
</I>&gt;<i> +			if (0 == cnt) {
</I>&gt;<i> +				dev_info(ndev-&gt;dev.parent,
</I>&gt;<i> +					&quot;timing out on CCE after reset\n&quot;);
</I>&gt;<i> +				break;
</I>&gt;<i> +			}
</I>&gt;<i> +			if (printk_ratelimit())
</I>&gt;<i> +				dev_dbg(ndev-&gt;dev.parent,
</I>&gt;<i> +					&quot;waiting CCE after reset\n&quot;);
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Set bit timing on the device */
</I>&gt;<i> +	ti_hecc_set_bittiming(priv-&gt;ndev);
</I>&gt;<i> +
</I>&gt;<i> +	/* Clear CCR (and CANMC register) and wait for CCE = 0 enable */
</I>&gt;<i> +	hecc_write(priv, HECC_CANMC, 0);
</I>&gt;<i> +
</I>&gt;<i> +	/* INFO: CAN net stack handles bus off and hence disabling auto bus on
</I>&gt;<i> +	hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_ABO);
</I>&gt;<i> +	*/
</I>&gt;<i> +
</I>&gt;<i> +	/* Wait till CCE bit clears */
</I>&gt;<i> +	/* INFO: It has been observed that at times CCE bit may not be
</I>&gt;<i> +	 * set and hw seems to be ok even if this bit is not set so
</I>&gt;<i> +	 * timing out with a large counter to respect the specs
</I>&gt;<i> +	 */
</I>&gt;<i> +	cnt = HECC_CCE_WAIT_COUNT;
</I>&gt;<i> +	while (hecc_get_bit(priv, HECC_CANES, HECC_CANES_CCE)) {
</I>&gt;<i> +		--cnt;
</I>&gt;<i> +		if (0 == cnt) {
</I>&gt;<i> +			dev_info(ndev-&gt;dev.parent,
</I>&gt;<i> +				&quot;timing out on CCE after bittiming\n&quot;);
</I>&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +		if (printk_ratelimit())
</I>&gt;<i> +			dev_dbg(ndev-&gt;dev.parent,
</I>&gt;<i> +				&quot;waiting CCE after bittiming\n&quot;);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Enable TX and RX I/O Control pins */
</I>&gt;<i> +	hecc_write(priv, HECC_CANTIOC, HECC_CANTIOC_EN);
</I>&gt;<i> +	hecc_write(priv, HECC_CANRIOC, HECC_CANRIOC_EN);
</I>&gt;<i> +
</I>&gt;<i> +	/* Clear registers for clean operation */
</I>&gt;<i> +	hecc_write(priv, HECC_CANTA, HECC_SET_REG);
</I>&gt;<i> +	hecc_write(priv, HECC_CANRMP, HECC_SET_REG);
</I>&gt;<i> +	hecc_write(priv, HECC_CANGIF0, HECC_SET_REG);
</I>&gt;<i> +	hecc_write(priv, HECC_CANGIF1, HECC_SET_REG);
</I>&gt;<i> +	hecc_write(priv, HECC_CANME, 0);
</I>&gt;<i> +	hecc_write(priv, HECC_CANMD, 0);
</I>&gt;<i> +
</I>&gt;<i> +	/* SCC compat mode NOT supported (and not needed too) */
</I>&gt;<i> +	hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_SCM);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * ti_hecc_start: Starts HECC module
</I>&gt;<i> + *
</I>&gt;<i> + * If CAN state is not stopped, reset the module, init bit timings
</I>&gt;<i> + * and start the device for operation
</I>&gt;<i> + */
</I>&gt;<i> +static void ti_hecc_start(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	int cnt, mbxno;
</I>&gt;<i> +
</I>&gt;<i> +	ti_hecc_reset(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	bitmap_zero(priv-&gt;tx_free_mbx, TI_HECC_MAX_TX_MBOX);
</I>&gt;<i> +
</I>&gt;<i> +	/* Enable local and global acceptance mask registers */
</I>&gt;<i> +	hecc_write(priv, HECC_CANGAM, HECC_SET_REG);
</I>&gt;<i> +	hecc_write(priv, HECC_CANLAM0, HECC_SET_REG);
</I>&gt;<i> +	hecc_write(priv, HECC_CANLAM3, HECC_SET_REG);
</I>&gt;<i> +
</I>&gt;<i> +	/* Prepare configured mailboxes to receive messages */
</I>&gt;<i> +	for (cnt = 0; cnt &lt; TI_HECC_MAX_RX_MBOX; cnt++) {
</I>&gt;<i> +		mbxno = (HECC_MAX_MAILBOXES - 1 - cnt);
</I>&gt;<i> +		hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +		hecc_write(priv, HECC_CANMID(mbxno), HECC_CANMID_AME);
</I>&gt;<i> +		hecc_write(priv, HECC_CANLAM(mbxno), HECC_SET_REG);
</I>&gt;<i> +		hecc_set_bit(priv, HECC_CANMD, (1 &lt;&lt; mbxno));
</I>&gt;<i> +		hecc_set_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +		hecc_set_bit(priv, HECC_CANMIM, (1 &lt;&lt; mbxno));
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Prevent message over-write &amp; Enable interrupts */
</I>&gt;<i> +	hecc_write(priv, HECC_CANTRS, 0);
</I>&gt;<i> +	hecc_write(priv, HECC_CANOPC, HECC_SET_REG);
</I>&gt;<i> +	if (priv-&gt;int_line) {
</I>&gt;<i> +		hecc_write(priv, HECC_CANMIL, HECC_SET_REG);
</I>&gt;<i> +		hecc_write(priv, HECC_CANGIM, (HECC_CANGIM_DEF_MASK |
</I>&gt;<i> +			HECC_CANGIM_I1EN | HECC_CANGIM_SIL));
</I>&gt;<i> +	} else {
</I>&gt;<i> +		hecc_write(priv, HECC_CANMIL, 0);
</I>&gt;<i> +		hecc_write(priv, HECC_CANGIM,
</I>&gt;<i> +			(HECC_CANGIM_DEF_MASK | HECC_CANGIM_I0EN));
</I>&gt;<i> +	}
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void ti_hecc_stop(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	/* Disable interrupts and disable mailboxes */
</I>&gt;<i> +	hecc_write(priv, HECC_CANGIM, 0);
</I>&gt;<i> +	hecc_write(priv, HECC_CANMIM, 0);
</I>&gt;<i> +	hecc_write(priv, HECC_CANME, 0);
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_do_set_mode(struct net_device *ndev, enum can_mode mode)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	int ret = 0;
</I>&gt;<i> +
</I>&gt;<i> +	switch (mode) {
</I>&gt;<i> +	case CAN_MODE_SLEEP:
</I>&gt;<i> +		dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;device going to sleep\n&quot;);
</I>&gt;<i> +		if (netif_running(ndev)) {
</I>&gt;<i> +			netif_stop_queue(ndev);
</I>&gt;<i> +			netif_device_detach(ndev);
</I>&gt;<i> +			/* Put HECC in low power mode */
</I>&gt;<i> +			hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_PDR);
</I>&gt;<i> +		}
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_SLEEPING;
</I>&gt;<i> +		break;
</I>&gt;<i> +	case CAN_MODE_STOP:
</I>&gt;<i> +		dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;device stopping\n&quot;);
</I>&gt;<i> +		ti_hecc_stop(ndev);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case CAN_MODE_START:
</I>&gt;<i> +		dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;device (re)starting\n&quot;);
</I>&gt;<i> +		++priv-&gt;can.can_stats.restarts;
</I>&gt;<i> +		ti_hecc_start(ndev);
</I>&gt;<i> +		if (netif_queue_stopped(ndev))
</I>&gt;<i> +			netif_wake_queue(ndev);
</I>&gt;<i> +		break;
</I>&gt;<i> +	default:
</I>&gt;<i> +		ret = -EOPNOTSUPP;
</I>&gt;<i> +		break;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return ret;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_xmit(struct sk_buff *skb, struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> +	u32 mbxno = 0;
</I>&gt;<i> +	u32 data;
</I>&gt;<i> +	unsigned long flags;
</I>&gt;<i> +
</I>&gt;<i> +	/* Find the first mailbox that is free for xmit */
</I>&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;tx_lock, flags);
</I>&gt;<i> +	mbxno = find_first_zero_bit(priv-&gt;tx_free_mbx, TI_HECC_MAX_TX_MBOX);
</I>&gt;<i> +	if (mbxno == TI_HECC_MAX_TX_MBOX) {
</I>&gt;<i> +		netif_stop_queue(ndev);
</I>&gt;<i> +		if (printk_ratelimit())
</I>&gt;<i> +			dev_err(priv-&gt;ndev-&gt;dev.parent,
</I>&gt;<i> +				&quot;Out of TX buffers ...\n&quot;);
</I>&gt;<i> +		spin_unlock_irqrestore(&amp;priv-&gt;tx_lock, flags);
</I>&gt;<i> +		return NETDEV_TX_BUSY;
</I>&gt;<i> +
</I>&gt;<i> +	}
</I>&gt;<i> +	set_bit(mbxno, priv-&gt;tx_free_mbx);
</I>&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;tx_lock, flags);
</I>&gt;<i> +
</I>&gt;<i> +	/* Prepare mailbox for transmission */
</I>&gt;<i> +	hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +	data = cf-&gt;can_dlc &amp; 0xF;
</I>&gt;<i> +	if (cf-&gt;can_id &amp; CAN_RTR_FLAG) /* Remote transmission request */
</I>&gt;<i> +		data |= HECC_CANMCF_RTR;
</I>&gt;<i> +	hecc_write(priv, HECC_CANMCF(mbxno), data);
</I>&gt;<i> +	if (cf-&gt;can_id &amp; CAN_EFF_FLAG) { /* Extended frame format */
</I>&gt;<i> +		data = ((cf-&gt;can_id &amp; CAN_EFF_MASK) | HECC_CANMID_IDE);
</I>&gt;<i> +	} else { /* Standard frame format */
</I>&gt;<i> +		data = ((cf-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; 18);
</I>&gt;<i> +	}
</I>&gt;<i> +	hecc_write(priv, HECC_CANMID(mbxno), data);
</I>&gt;<i> +	data = (cf-&gt;data[0] &lt;&lt; 24) | (cf-&gt;data[1] &lt;&lt; 16) |
</I>&gt;<i> +			(cf-&gt;data[2] &lt;&lt; 8) | cf-&gt;data[3];
</I>&gt;<i> +	hecc_write(priv, HECC_CANMDL(mbxno), data);
</I>&gt;<i> +	if (cf-&gt;can_dlc &gt; 4) {
</I>&gt;<i> +		data = (cf-&gt;data[4] &lt;&lt; 24) | (cf-&gt;data[5] &lt;&lt; 16) |
</I>&gt;<i> +			(cf-&gt;data[6] &lt;&lt; 8) | cf-&gt;data[7];
</I>&gt;<i> +		hecc_write(priv, HECC_CANMDH(mbxno), data);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_DEBUG_FS
</I>&gt;<i> +	if (hecc_debug_state) {
</I>&gt;<i> +		printk(KERN_ERR &quot;Mbxno=%d, CANMID=%08X, CANMCF=%08X,&quot; \
</I>&gt;<i> +			&quot; CANMDH=%08X, CANMDL=%08X\n&quot;, mbxno,
</I>&gt;<i> +			hecc_read(priv, HECC_CANMID(mbxno)),
</I>&gt;<i> +			hecc_read(priv, HECC_CANMCF(mbxno)),
</I>&gt;<i> +			hecc_read(priv, HECC_CANMDH(mbxno)),
</I>&gt;<i> +			hecc_read(priv, HECC_CANMDL(mbxno)));
</I>&gt;<i> +		printk(KERN_INFO &quot;HECC_TX: %02X, %02X, %02X, %02X, %02X,&quot; \
</I>&gt;<i> +			&quot; %02X, %02X, %02X\n&quot;,
</I>&gt;<i> +			cf-&gt;data[0], cf-&gt;data[1], cf-&gt;data[2], cf-&gt;data[3],
</I>&gt;<i> +			cf-&gt;data[4], cf-&gt;data[5], cf-&gt;data[6], cf-&gt;data[7]);
</I>&gt;<i> +	}
</I>&gt;<i> +#endif /* CONFIG_DEBUG_FS */
</I>&gt;<i> +
</I>&gt;<i> +	/* Enable interrupt for mbox and start transmission */
</I>&gt;<i> +	hecc_clear_bit(priv, HECC_CANMD, (1 &lt;&lt; mbxno));
</I>&gt;<i> +	hecc_set_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +	hecc_set_bit(priv, HECC_CANMIM, (1 &lt;&lt; mbxno));
</I>&gt;<i> +	hecc_set_bit(priv, HECC_CANTRS, (1 &lt;&lt; mbxno));
</I>&gt;<i> +
</I>&gt;<i> +	stats-&gt;tx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +	ndev-&gt;trans_start = jiffies;
</I>&gt;<i> +	can_put_echo_skb(skb, ndev, mbxno);
</I>&gt;<i> +
</I>&gt;<i> +	return NETDEV_TX_OK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_rx_pkt(struct ti_hecc_priv *priv, int mbxno)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device_stats *stats = &amp;priv-&gt;ndev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	u32 data;
</I>&gt;<i> +
</I>&gt;<i> +	skb = dev_alloc_skb(sizeof(struct can_frame));
</I>&gt;<i> +	if (!skb) {
</I>&gt;<i> +		if (printk_ratelimit())
</I>&gt;<i> +			dev_err(priv-&gt;ndev-&gt;dev.parent,
</I>&gt;<i> +				&quot;dev_alloc_skb() failed\n&quot;);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>&gt;<i> +	skb-&gt;dev = priv-&gt;ndev;
</I>&gt;<i> +	skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;<i> +	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
</I>&gt;<i> +
</I>&gt;<i> +	cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
</I>&gt;<i> +	memset(cf, 0, sizeof(struct can_frame));
</I>&gt;<i> +	data = hecc_read(priv, HECC_CANMID(mbxno));
</I>&gt;<i> +	if (data &amp; HECC_CANMID_IDE)
</I>&gt;<i> +		cf-&gt;can_id = (data &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
</I>&gt;<i> +	else
</I>&gt;<i> +		cf-&gt;can_id = ((data &gt;&gt; 18) &amp; CAN_SFF_MASK);
</I>&gt;<i> +	data = hecc_read(priv, HECC_CANMCF(mbxno));
</I>&gt;<i> +	if (data &amp; HECC_CANMCF_RTR)
</I>&gt;<i> +		cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> +	cf-&gt;can_dlc = data &amp; 0xF;
</I>&gt;<i> +	data = hecc_read(priv, HECC_CANMDL(mbxno));
</I>&gt;<i> +	/* The below statements are for readability sake */
</I>&gt;<i> +	cf-&gt;data[0] = ((data &amp; 0xFF000000) &gt;&gt; 24);
</I>&gt;<i> +	cf-&gt;data[1] = ((data &amp; 0xFF0000) &gt;&gt; 16);
</I>&gt;<i> +	cf-&gt;data[2] = ((data &amp; 0xFF00) &gt;&gt; 8);
</I>&gt;<i> +	cf-&gt;data[3] = (data &amp; 0xFF);
</I>&gt;<i> +	if (cf-&gt;can_dlc &gt; 4) {
</I>&gt;<i> +		data = hecc_read(priv, HECC_CANMDH(mbxno));
</I>&gt;<i> +		cf-&gt;data[4] = ((data &amp; 0xFF000000) &gt;&gt; 24);
</I>&gt;<i> +		cf-&gt;data[5] = ((data &amp; 0xFF0000) &gt;&gt; 16);
</I>&gt;<i> +		cf-&gt;data[6] = ((data &amp; 0xFF00) &gt;&gt; 8);
</I>&gt;<i> +		cf-&gt;data[7] = (data &amp; 0xFF);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_DEBUG_FS
</I>&gt;<i> +	if (hecc_debug_state) {
</I>&gt;<i> +		printk(KERN_ERR &quot;Mbxno=%d, CANMID=%08X, CANMCF=%08X,&quot; \
</I>&gt;<i> +			&quot; CANMDH=%08X, CANMDL=%08X\n&quot;, mbxno,
</I>&gt;<i> +			hecc_read(priv, HECC_CANMID(mbxno)),
</I>&gt;<i> +			hecc_read(priv, HECC_CANMCF(mbxno)),
</I>&gt;<i> +			hecc_read(priv, HECC_CANMDH(mbxno)),
</I>&gt;<i> +			hecc_read(priv, HECC_CANMDL(mbxno)));
</I>&gt;<i> +		printk(KERN_INFO &quot;HECC_RX: %02X, %02X, %02X, %02X, %02X,&quot;\
</I>&gt;<i> +			&quot; %02X, %02X, %02X\n&quot;,
</I>&gt;<i> +			cf-&gt;data[0], cf-&gt;data[1], cf-&gt;data[2], cf-&gt;data[3],
</I>&gt;<i> +			cf-&gt;data[4], cf-&gt;data[5], cf-&gt;data[6], cf-&gt;data[7]);
</I>&gt;<i> +	}
</I>&gt;<i> +#endif /* CONFIG_DEBUG_FS */
</I>&gt;<i> +
</I>&gt;<i> +	/* prepare mailbox for next receive */
</I>&gt;<i> +	hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +	hecc_write(priv, HECC_CANMID(mbxno), HECC_CANMID_AME);
</I>&gt;<i> +	hecc_write(priv, HECC_CANLAM(mbxno), HECC_SET_REG);
</I>&gt;<i> +	hecc_set_bit(priv, HECC_CANMD, (1 &lt;&lt; mbxno));
</I>&gt;<i> +	hecc_set_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +
</I>&gt;<i> +	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +	netif_rx(skb);
</I>&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;<i> +	priv-&gt;ndev-&gt;last_rx = jiffies;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_rx_poll(struct napi_struct *napi, int quota)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = napi-&gt;dev;
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	int num_pkts = 0;
</I>&gt;<i> +	unsigned long pending_pkts;
</I>&gt;<i> +	int mbxno;
</I>&gt;<i> +
</I>&gt;<i> +	if (!netif_running(ndev))
</I>&gt;<i> +		return 0;
</I>&gt;<i> +
</I>&gt;<i> +	pending_pkts = hecc_read(priv, HECC_CANRMP);
</I>&gt;<i> +	while (pending_pkts &amp;&amp; (num_pkts &lt; quota)) {
</I>&gt;<i> +		mbxno = find_first_bit(&amp;pending_pkts, HECC_MAX_MAILBOXES);
</I>&gt;<i> +		if (mbxno == HECC_MAX_MAILBOXES) {
</I>&gt;<i> +			dev_info(priv-&gt;ndev-&gt;dev.parent,
</I>&gt;<i> +				&quot;Reached max mailboxes. No rx pkts\n&quot;);
</I>&gt;<i> +			return num_pkts;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		if (ti_hecc_rx_pkt(priv, mbxno) &lt; 0)
</I>&gt;<i> +			return num_pkts;
</I>&gt;<i> +
</I>&gt;<i> +		clear_bit(mbxno, &amp;pending_pkts);
</I>&gt;<i> +		hecc_set_bit(priv, HECC_CANRMP, (1 &lt;&lt; mbxno));
</I>&gt;<i> +		++num_pkts;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Enable packet interrupt if all pkts are handled */
</I>&gt;<i> +	if (0 == hecc_read(priv, HECC_CANRMP)) {
</I>&gt;<i> +		napi_complete(napi);
</I>&gt;<i> +		/* Re-enable RX mailbox interrupts */
</I>&gt;<i> +		mbxno = hecc_read(priv, HECC_CANMIM);
</I>&gt;<i> +		mbxno |= (~((1 &lt;&lt; TI_HECC_MAX_TX_MBOX) - 1));
</I>&gt;<i> +		hecc_write(priv, HECC_CANMIM, mbxno);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return num_pkts;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * ti_hecc_error: TI HECC error routine
</I>&gt;<i> + *
</I>&gt;<i> + * Handles HECC error - handles error condition and send a packet up the stack
</I>&gt;<i> + */
</I>&gt;<i> +static int
</I>&gt;<i> +ti_hecc_error(struct net_device *ndev, int int_status, int err_status)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	int data;
</I>&gt;<i> +
</I>&gt;<i> +	/* propogate the error condition to the can stack */
</I>&gt;<i> +	skb = dev_alloc_skb(sizeof(struct can_frame));
</I>&gt;<i> +	if (!skb) {
</I>&gt;<i> +		if (printk_ratelimit())
</I>&gt;<i> +			dev_err(priv-&gt;ndev-&gt;dev.parent,
</I>&gt;<i> +				&quot;dev_alloc_skb() failed in err processing\n&quot;);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>&gt;<i> +	skb-&gt;dev = ndev;
</I>&gt;<i> +	skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;<i> +	cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
</I>&gt;<i> +	memset(cf, 0, sizeof(struct can_frame));
</I>&gt;<i> +	cf-&gt;can_id = CAN_ERR_FLAG;
</I>&gt;<i> +	cf-&gt;can_dlc = CAN_ERR_DLC;
</I>&gt;<i> +
</I>&gt;<i> +	if (int_status &amp; HECC_CANGIF_RMLIF) { /* Message lost interrupt */
</I>&gt;<i> +		data = hecc_read(priv, HECC_CANRML);
</I>&gt;<i> +		hecc_write(priv, HECC_CANRML, data);
</I>&gt;<i> +		++priv-&gt;message_lost_cnt;
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +		cf-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
</I>&gt;<i> +		stats-&gt;rx_over_errors++;
</I>&gt;<i> +		stats-&gt;rx_errors++;
</I>&gt;<i> +		dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;Message lost interrupt\n&quot;);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (int_status &amp; HECC_CANGIF_WLIF) { /* warning level int */
</I>&gt;<i> +		if (0 == (int_status &amp; HECC_CANGIF_BOIF)) {
</I>&gt;<i> +			priv-&gt;can.state = CAN_STATE_ERROR_WARNING;
</I>&gt;<i> +			++priv-&gt;can.can_stats.error_warning;
</I>&gt;<i> +			cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +			if (hecc_read(priv, HECC_CANTEC) &gt; 96)
</I>&gt;<i> +				cf-&gt;data[1] |= CAN_ERR_CRTL_TX_WARNING;
</I>&gt;<i> +			if (hecc_read(priv, HECC_CANREC) &gt; 96)
</I>&gt;<i> +				cf-&gt;data[1] |= CAN_ERR_CRTL_RX_WARNING;
</I>&gt;<i> +		}
</I>&gt;<i> +		hecc_set_bit(priv, HECC_CANES, HECC_CANES_EW);
</I>&gt;<i> +		dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;Error Warning interrupt\n&quot;);
</I>&gt;<i> +		hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (int_status &amp; HECC_CANGIF_EPIF) { /* error passive int */
</I>&gt;<i> +		if (0 == (int_status &amp; HECC_CANGIF_BOIF)) {
</I>&gt;<i> +			priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> +			++priv-&gt;can.can_stats.error_passive;
</I>&gt;<i> +			cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +			if (hecc_read(priv, HECC_CANTEC) &gt; 127)
</I>&gt;<i> +				cf-&gt;data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
</I>&gt;<i> +			if (hecc_read(priv, HECC_CANREC) &gt; 127)
</I>&gt;<i> +				cf-&gt;data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> +		}
</I>&gt;<i> +		hecc_set_bit(priv, HECC_CANES, HECC_CANES_EP);
</I>&gt;<i> +		dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;Error passive interrupt\n&quot;);
</I>&gt;<i> +		hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Need to check busoff condition in error status register too to
</I>&gt;<i> +	 * ensure warning interrupts don't hog the system
</I>&gt;<i> +	 */
</I>&gt;<i> +	if (int_status &amp; HECC_CANGIF_BOIF) {
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> +		hecc_set_bit(priv, HECC_CANES, HECC_CANES_BO);
</I>&gt;<i> +		dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;Bus Off interrupt\n&quot;);
</I>&gt;<i> +		hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
</I>&gt;<i> +		can_bus_off(ndev);
</I>&gt;<i> +		/* Disable all interrupts in bus-off to avoid int hog */
</I>&gt;<i> +		hecc_write(priv, HECC_CANGIM, 0);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (err_status &amp; HECC_CANES_BO) {
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> +		hecc_set_bit(priv, HECC_CANES, HECC_CANES_BO);
</I>&gt;<i> +		dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;Bus Off condition\n&quot;);
</I>&gt;<i> +		hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
</I>&gt;<i> +		can_bus_off(ndev);
</I>&gt;<i> +		/* Disable all interrupts in bus-off to avoid int hog */
</I>&gt;<i> +		hecc_write(priv, HECC_CANGIM, 0);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (err_status &amp; HECC_BUS_ERROR) {
</I>&gt;<i> +		++priv-&gt;can.can_stats.bus_error;
</I>&gt;<i> +		cf-&gt;can_id |= (CAN_ERR_BUSERROR | CAN_ERR_PROT);
</I>&gt;<i> +		cf-&gt;data[2] |= CAN_ERR_PROT_UNSPEC;
</I>&gt;<i> +		if (err_status &amp; HECC_CANES_FE) {
</I>&gt;<i> +			hecc_set_bit(priv, HECC_CANES, HECC_CANES_FE);
</I>&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;<i> +		}
</I>&gt;<i> +		if (err_status &amp; HECC_CANES_BE) {
</I>&gt;<i> +			hecc_set_bit(priv, HECC_CANES, HECC_CANES_BE);
</I>&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
</I>&gt;<i> +		}
</I>&gt;<i> +		if (err_status &amp; HECC_CANES_SE) {
</I>&gt;<i> +			hecc_set_bit(priv, HECC_CANES, HECC_CANES_SE);
</I>&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;<i> +		}
</I>&gt;<i> +		if (err_status &amp; HECC_CANES_CRCE) {
</I>&gt;<i> +			hecc_set_bit(priv, HECC_CANES, HECC_CANES_CRCE);
</I>&gt;<i> +			cf-&gt;data[2] |= (CAN_ERR_PROT_LOC_CRC_SEQ |
</I>&gt;<i> +					CAN_ERR_PROT_LOC_CRC_DEL);
</I>&gt;<i> +		}
</I>&gt;<i> +		if (err_status &amp; HECC_CANES_ACKE) {
</I>&gt;<i> +			hecc_set_bit(priv, HECC_CANES, HECC_CANES_ACKE);
</I>&gt;<i> +			cf-&gt;data[2] |= (CAN_ERR_PROT_LOC_ACK |
</I>&gt;<i> +					CAN_ERR_PROT_LOC_ACK_DEL);
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	netif_receive_skb(skb);
</I>&gt;<i> +	ndev-&gt;last_rx = jiffies;
</I>&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;<i> +	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * ti_hecc_interrupt: TI HECC interrupt routine
</I>&gt;<i> + *
</I>&gt;<i> + * Handles HECC interrupts - disables interrupt if receive pkts that will
</I>&gt;<i> + * be enabled when rx pkts are compelte (napi_complete is done)
</I>&gt;<i> + */
</I>&gt;<i> +static irqreturn_t ti_hecc_interrupt(int irq, void *dev_id)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = (struct net_device *)dev_id;
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	unsigned int int_status;
</I>&gt;<i> +	unsigned long ack;
</I>&gt;<i> +	int mbxno;
</I>&gt;<i> +	unsigned long flags;
</I>&gt;<i> +
</I>&gt;<i> +	if (priv-&gt;int_line)
</I>&gt;<i> +		int_status = hecc_read(priv, HECC_CANGIF1);
</I>&gt;<i> +	else
</I>&gt;<i> +		int_status = hecc_read(priv, HECC_CANGIF0);
</I>&gt;<i> +
</I>&gt;<i> +	if (0 == int_status)
</I>&gt;<i> +		return IRQ_NONE;
</I>&gt;<i> +
</I>&gt;<i> +	/* Handle message alarm interrupt */
</I>&gt;<i> +	if (int_status &amp; HECC_CANGIF_MAIF) {
</I>&gt;<i> +		++priv-&gt;message_alarm_cnt;
</I>&gt;<i> +		dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;Message alarm interrupt\n&quot;);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Handle local network timer counter overflow interrupt */
</I>&gt;<i> +	if (int_status &amp; HECC_CANGIF_TCOIF) {
</I>&gt;<i> +		++priv-&gt;timer_overflow_cnt;
</I>&gt;<i> +		dev_info(priv-&gt;ndev-&gt;dev.parent,
</I>&gt;<i> +			&quot;Local network timer counter overflow interrupt\n&quot;);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Handle write denied interrupt */
</I>&gt;<i> +	if (int_status &amp; HECC_CANGIF_WDIF) {
</I>&gt;<i> +		++priv-&gt;write_denied_cnt;
</I>&gt;<i> +		dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;Write denied interrupt\n&quot;);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Handle wake up interrupt */
</I>&gt;<i> +	if (int_status &amp; HECC_CANGIF_WUIF) {
</I>&gt;<i> +		++priv-&gt;wake_up_cnt;
</I>&gt;<i> +		dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;Wake up interrupt\n&quot;);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	ti_hecc_error(ndev, int_status, hecc_read(priv, HECC_CANES));
</I>&gt;<i> +
</I>&gt;<i> +	/* Handle Abort acknowledge interrupt */
</I>&gt;<i> +	if (int_status &amp; HECC_CANGIF_AAIF) {
</I>&gt;<i> +		ack = hecc_read(priv, HECC_CANAA);
</I>&gt;<i> +		while (ack) {
</I>&gt;<i> +			mbxno = find_first_bit(&amp;ack, HECC_MAX_MAILBOXES);
</I>&gt;<i> +			if (mbxno == HECC_MAX_MAILBOXES) {
</I>&gt;<i> +				break;
</I>&gt;<i> +			} else {
</I>&gt;<i> +				clear_bit(mbxno, &amp;ack);
</I>&gt;<i> +				/* release echo pkt &amp; update counters */
</I>&gt;<i> +				hecc_set_bit(priv, HECC_CANAA, (1 &lt;&lt; mbxno));
</I>&gt;<i> +				hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +				/* FIXME: since net-next tree's dev.h does not
</I>&gt;<i> +				 * include can_free_echo_skb() doing equivalent
</I>&gt;<i> +				 * of can_free_echo_skb(ndev, mbxno);
</I>&gt;<i> +				 */
</I>&gt;<i> +				if (priv-&gt;can.echo_skb[mbxno]) {
</I>&gt;<i> +					kfree_skb(priv-&gt;can.echo_skb[mbxno]);
</I>&gt;<i> +					priv-&gt;can.echo_skb[mbxno] = NULL;
</I>&gt;<i> +				}
</I>&gt;<i> +				if (netif_queue_stopped(ndev))
</I>&gt;<i> +					netif_wake_queue(ndev);
</I>&gt;<i> +				spin_lock_irqsave(&amp;priv-&gt;tx_lock, flags);
</I>&gt;<i> +				clear_bit(mbxno, priv-&gt;tx_free_mbx);
</I>&gt;<i> +				spin_unlock_irqrestore(&amp;priv-&gt;tx_lock, flags);
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Handle mailbox interrupt */
</I>&gt;<i> +	if (int_status &amp; HECC_CANGIF_GMIF) {
</I>&gt;<i> +		ack = hecc_read(priv, HECC_CANTA);
</I>&gt;<i> +		while (ack) {
</I>&gt;<i> +			mbxno = find_first_bit(&amp;ack, HECC_MAX_MAILBOXES);
</I>&gt;<i> +			if (mbxno == HECC_MAX_MAILBOXES) {
</I>&gt;<i> +				break;
</I>&gt;<i> +			} else {
</I>&gt;<i> +				clear_bit(mbxno, &amp;ack);
</I>&gt;<i> +				hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +				hecc_set_bit(priv, HECC_CANTA, (1 &lt;&lt; mbxno));
</I>&gt;<i> +				skb = priv-&gt;can.echo_skb[mbxno];
</I>&gt;<i> +				cf = (struct can_frame *) (skb-&gt;data);
</I>&gt;<i> +				can_get_echo_skb(ndev, mbxno);
</I>&gt;<i> +				stats-&gt;tx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +				spin_lock_irqsave(&amp;priv-&gt;tx_lock, flags);
</I>&gt;<i> +				clear_bit(mbxno, priv-&gt;tx_free_mbx);
</I>&gt;<i> +				spin_unlock_irqrestore(&amp;priv-&gt;tx_lock, flags);
</I>&gt;<i> +				stats-&gt;tx_packets++;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +		if (netif_queue_stopped(ndev))
</I>&gt;<i> +			netif_wake_queue(ndev);
</I>&gt;<i> +
</I>&gt;<i> +		/* Disable RX mailbox interrupts and let NAPI reenable them */
</I>&gt;<i> +		ack = hecc_read(priv, HECC_CANMIM);
</I>&gt;<i> +		ack &amp;= ((1 &lt;&lt; TI_HECC_MAX_TX_MBOX) - 1);
</I>&gt;<i> +		hecc_write(priv, HECC_CANMIM, ack);
</I>&gt;<i> +		napi_schedule(&amp;priv-&gt;napi);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* clear all interrupt conditions - read back to avoid spurious ints */
</I>&gt;<i> +	if (priv-&gt;int_line) {
</I>&gt;<i> +		hecc_write(priv, HECC_CANGIF1, HECC_SET_REG);
</I>&gt;<i> +		int_status = hecc_read(priv, HECC_CANGIF1);
</I>&gt;<i> +	} else {
</I>&gt;<i> +		hecc_write(priv, HECC_CANGIF0, HECC_SET_REG);
</I>&gt;<i> +		int_status = hecc_read(priv, HECC_CANGIF0);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return IRQ_HANDLED;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/* NOTE: yet to test suspend/resume */
</I>&gt;<i> +static int ti_hecc_suspend(struct platform_device *pdev, pm_message_t state)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = platform_get_drvdata(pdev);
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	if (netif_running(ndev)) {
</I>&gt;<i> +		netif_stop_queue(ndev);
</I>&gt;<i> +		netif_device_detach(ndev);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_PDR);
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_SLEEPING;
</I>&gt;<i> +	clk_disable(priv-&gt;clk);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/* NOTE: yet to test suspend/resume */
</I>&gt;<i> +static int ti_hecc_resume(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = platform_get_drvdata(pdev);
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	clk_enable(priv-&gt;clk);
</I>&gt;<i> +	hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_PDR);
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +	if (netif_running(ndev)) {
</I>&gt;<i> +		netif_device_attach(ndev);
</I>&gt;<i> +		netif_start_queue(ndev);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_open(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	int err;
</I>&gt;<i> +
</I>&gt;<i> +	dev_info(ndev-&gt;dev.parent, &quot;opening device\n&quot;);
</I>&gt;<i> +
</I>&gt;<i> +	if (request_irq(ndev-&gt;irq, ti_hecc_interrupt, IRQF_DISABLED,
</I>&gt;<i> +				ndev-&gt;name, ndev)) {
</I>&gt;<i> +		dev_err(ndev-&gt;dev.parent, &quot;error requesting interrupt\n&quot;);
</I>&gt;<i> +		return -EAGAIN;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Open common can device */
</I>&gt;<i> +	err = open_candev(ndev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(ndev-&gt;dev.parent, &quot;open_candev() failed %08X\n&quot;, err);
</I>&gt;<i> +		return err;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Initialize device and start net queue */
</I>&gt;<i> +	spin_lock_init(&amp;priv-&gt;tx_lock);
</I>&gt;<i> +
</I>&gt;<i> +	clk_enable(priv-&gt;clk);
</I>&gt;<i> +	ti_hecc_start(ndev);
</I>&gt;<i> +	napi_enable(&amp;priv-&gt;napi);
</I>&gt;<i> +	netif_start_queue(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_close(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	dev_info(ndev-&gt;dev.parent, &quot;closing device\n&quot;);
</I>&gt;<i> +	napi_disable(&amp;priv-&gt;napi);
</I>&gt;<i> +	netif_stop_queue(ndev);
</I>&gt;<i> +	ti_hecc_stop(ndev);
</I>&gt;<i> +	free_irq(ndev-&gt;irq, ndev);
</I>&gt;<i> +	clk_disable(priv-&gt;clk);
</I>&gt;<i> +	close_candev(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static const struct net_device_ops ti_hecc_netdev_ops = {
</I>&gt;<i> +	.ndo_open		= ti_hecc_open,
</I>&gt;<i> +	.ndo_stop		= ti_hecc_close,
</I>&gt;<i> +	.ndo_start_xmit		= ti_hecc_xmit,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_probe(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = (struct net_device *)0;
</I>&gt;<i> +	struct ti_hecc_priv *priv;
</I>&gt;<i> +	struct ti_hecc_platform_data *pdata;
</I>&gt;<i> +	struct resource *mem, *irq;
</I>&gt;<i> +	void __iomem *addr;
</I>&gt;<i> +	int err;
</I>&gt;<i> +
</I>&gt;<i> +	printk(KERN_INFO DRV_NAME &quot; probing devices...\n&quot;);
</I>&gt;<i> +	pdata = pdev-&gt;dev.platform_data;
</I>&gt;<i> +	if (!pdata) {
</I>&gt;<i> +		printk(KERN_ERR &quot;No platform data available - exiting\n&quot;);
</I>&gt;<i> +		return -ENODEV;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;<i> +	if (!mem) {
</I>&gt;<i> +		printk(KERN_ERR &quot;no mem resource?\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_exit;
</I>&gt;<i> +	}
</I>&gt;<i> +	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
</I>&gt;<i> +	if (!irq) {
</I>&gt;<i> +		printk(KERN_ERR &quot;no irq resource?\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_exit;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (!request_mem_region(mem-&gt;start, (mem-&gt;end - mem-&gt;start) + 1,
</I>
Use resource_size(mem).

&gt;<i> +		pdev-&gt;name)) {
</I>&gt;<i> +		printk(KERN_ERR &quot;HECC region already claimed\n&quot;);
</I>&gt;<i> +		err = -EBUSY;
</I>&gt;<i> +		goto probe_exit;
</I>&gt;<i> +	}
</I>&gt;<i> +	addr = ioremap(mem-&gt;start, mem-&gt;end - mem-&gt;start + 1);
</I>
ditto

&gt;<i> +	if (!addr) {
</I>&gt;<i> +		printk(KERN_ERR &quot;ioremap failed\n&quot;);
</I>&gt;<i> +		err = -ENOMEM;
</I>&gt;<i> +		goto probe_exit_free_region;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	ndev = alloc_candev(sizeof(struct ti_hecc_priv));
</I>&gt;<i> +	if (!ndev) {
</I>&gt;<i> +		printk(KERN_ERR &quot;alloc_candev failed\n&quot;);
</I>&gt;<i> +		err = -ENOMEM;
</I>&gt;<i> +		goto probe_exit_iounmap;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	priv = netdev_priv(ndev);
</I>&gt;<i> +	priv-&gt;ndev = ndev;
</I>&gt;<i> +	priv-&gt;base = addr;
</I>&gt;<i> +	priv-&gt;scc_ram_offset = pdata-&gt;scc_ram_offset;
</I>&gt;<i> +	priv-&gt;hecc_ram_offset = pdata-&gt;hecc_ram_offset;
</I>&gt;<i> +	priv-&gt;mbox_offset = pdata-&gt;mbox_offset;
</I>&gt;<i> +	priv-&gt;int_line = pdata-&gt;int_line;
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.bittiming_const	= &amp;ti_hecc_bittiming_const;
</I>&gt;<i> +	priv-&gt;can.do_set_bittiming	= ti_hecc_set_bittiming;
</I>&gt;<i> +	priv-&gt;can.do_set_mode		= ti_hecc_do_set_mode;
</I>&gt;<i> +	priv-&gt;can.do_get_state		= ti_hecc_get_state;
</I>&gt;<i> +
</I>&gt;<i> +	ndev-&gt;irq = irq-&gt;start;
</I>&gt;<i> +	ndev-&gt;flags |= IFF_ECHO;
</I>&gt;<i> +	platform_set_drvdata(pdev, ndev);
</I>&gt;<i> +	SET_NETDEV_DEV(ndev, &amp;pdev-&gt;dev);
</I>&gt;<i> +	ndev-&gt;netdev_ops = &amp;ti_hecc_netdev_ops;
</I>&gt;<i> +
</I>&gt;<i> +	/* Note: clk name would change using hecc_vbusp_ck temporarily */
</I>&gt;<i> +	priv-&gt;clk = clk_get(&amp;pdev-&gt;dev, &quot;hecc_vbusp_ck&quot;);
</I>&gt;<i> +	if (IS_ERR(priv-&gt;clk)) {
</I>&gt;<i> +		dev_err(ndev-&gt;dev.parent, &quot;no clock available\n&quot;);
</I>&gt;<i> +		err = PTR_ERR(priv-&gt;clk);
</I>&gt;<i> +		priv-&gt;clk = NULL;
</I>&gt;<i> +		goto probe_exit_candev;
</I>&gt;<i> +	}
</I>&gt;<i> +	priv-&gt;can.clock.freq = clk_get_rate(priv-&gt;clk);
</I>&gt;<i> +	netif_napi_add(ndev, &amp;priv-&gt;napi, ti_hecc_rx_poll,
</I>&gt;<i> +			TI_HECC_DEF_NAPI_WEIGHT);
</I>&gt;<i> +
</I>&gt;<i> +	err = register_candev(ndev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(ndev-&gt;dev.parent, &quot;register_candev() failed\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_exit_clk;
</I>&gt;<i> +	}
</I>&gt;<i> +	dev_info(ndev-&gt;dev.parent, &quot;regs=%p, irq=%d\n&quot;,
</I>&gt;<i> +		priv-&gt;base, (unsigned int) ndev-&gt;irq);
</I>&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_DEBUG_FS
</I>&gt;<i> +	hecc_debug_init(priv);
</I>&gt;<i> +#endif
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +probe_exit_clk:
</I>&gt;<i> +	clk_put(priv-&gt;clk);
</I>&gt;<i> +probe_exit_candev:
</I>&gt;<i> +	free_candev(ndev);
</I>&gt;<i> +probe_exit_iounmap:
</I>&gt;<i> +	iounmap(addr);
</I>&gt;<i> +probe_exit_free_region:
</I>&gt;<i> +	release_mem_region(mem-&gt;start, mem-&gt;end - mem-&gt;start + 1);
</I>
ditto

&gt;<i> +probe_exit:
</I>&gt;<i> +	dev_err(ndev-&gt;dev.parent, &quot;probe error = %08X\n&quot;, err);
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int __devexit ti_hecc_remove(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct resource *res;
</I>&gt;<i> +	struct net_device *ndev = platform_get_drvdata(pdev);
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_DEBUG_FS
</I>&gt;<i> +	hecc_debug_exit();
</I>&gt;<i> +#endif /* CONFIG_DEBUG_FS */
</I>&gt;<i> +
</I>&gt;<i> +	clk_put(priv-&gt;clk);
</I>&gt;<i> +	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;<i> +	iounmap(priv-&gt;base);
</I>&gt;<i> +	release_mem_region(res-&gt;start, res-&gt;end - res-&gt;start + 1);
</I>
ditto

&gt;<i> +	unregister_candev(ndev);
</I>&gt;<i> +	free_candev(ndev);
</I>&gt;<i> +	platform_set_drvdata(pdev, NULL);
</I>&gt;<i> +	dev_info(ndev-&gt;dev.parent, &quot;driver removed\n&quot;);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/* TI HECC netdevice driver: platform driver structure */
</I>&gt;<i> +static struct platform_driver ti_hecc_driver = {
</I>&gt;<i> +	.driver = {
</I>&gt;<i> +		.name    = &quot;ti_hecc&quot;,
</I>&gt;<i> +		.owner   = THIS_MODULE,
</I>&gt;<i> +	},
</I>&gt;<i> +	.probe = ti_hecc_probe,
</I>&gt;<i> +	.remove = __devexit_p(ti_hecc_remove),
</I>&gt;<i> +	.suspend = ti_hecc_suspend,
</I>&gt;<i> +	.resume = ti_hecc_resume,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int __init ti_hecc_init_driver(void)
</I>&gt;<i> +{
</I>&gt;<i> +	printk(KERN_INFO DRV_DESC &quot;\n&quot;);
</I>&gt;<i> +	return platform_driver_register(&amp;ti_hecc_driver);
</I>&gt;<i> +}
</I>&gt;<i> +module_init(ti_hecc_init_driver);
</I>&gt;<i> +
</I>&gt;<i> +static void __exit ti_hecc_exit_driver(void)
</I>&gt;<i> +{
</I>&gt;<i> +	printk(KERN_INFO DRV_DESC &quot; :Exit\n&quot;);
</I>&gt;<i> +	platform_driver_unregister(&amp;ti_hecc_driver);
</I>&gt;<i> +}
</I>&gt;<i> +module_exit(ti_hecc_exit_driver);
</I>&gt;<i> +
</I>&gt;<i> +MODULE_AUTHOR(&quot;Anant Gole &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">anantgole at ti.com</A>&gt;&quot;);
</I>&gt;<i> +MODULE_LICENSE(&quot;GPL v2&quot;);
</I>&gt;<i> +MODULE_DESCRIPTION(DRV_DESC);
</I>&gt;<i> diff --git a/include/linux/can/platform/ti_hecc_platform.h b/include/linux/can/platform/ti_hecc_platform.h
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..4a57daf
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/include/linux/can/platform/ti_hecc_platform.h
</I>&gt;<i> @@ -0,0 +1,40 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * TI HECC (High End CAN Controller) driver platform header
</I>&gt;<i> + *
</I>&gt;<i> + * Copyright (C) 2009 Texas Instruments Incorporated - <A HREF="http://www.ti.com/">http://www.ti.com/</A>
</I>&gt;<i> + *
</I>&gt;<i> + * This program is free software; you can redistribute it and/or
</I>&gt;<i> + * modify it under the terms of the GNU General Public License as
</I>&gt;<i> + * published by the Free Software Foundation version 2.
</I>&gt;<i> + *
</I>&gt;<i> + * This program is distributed as is WITHOUT ANY WARRANTY of any
</I>&gt;<i> + * kind, whether express or implied; without even the implied warranty
</I>&gt;<i> + * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</I>&gt;<i> + * GNU General Public License for more details.
</I>&gt;<i> + *
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * struct hecc_platform_data - HECC Platform Data
</I>&gt;<i> + *
</I>&gt;<i> + * @scc_hecc_offset:	mostly 0 - should really never change
</I>&gt;<i> + * @scc_ram_offset:	SCC RAM offset
</I>&gt;<i> + * @hecc_ram_offset:	HECC RAM offset
</I>&gt;<i> + * @mbox_offset:	Mailbox RAM offset
</I>&gt;<i> + * @int_line:		Interrupt line to use - 0 or 1
</I>&gt;<i> + * @version:		version for future use
</I>&gt;<i> + *
</I>&gt;<i> + * Platform data structure to get all platform specific settings.
</I>&gt;<i> + * this structure also accounts the fact that the IP may have different
</I>&gt;<i> + * RAM and mailbox offsets for different SOC's
</I>&gt;<i> + */
</I>&gt;<i> +struct ti_hecc_platform_data {
</I>&gt;<i> +	unsigned int scc_hecc_offset;
</I>&gt;<i> +	unsigned int scc_ram_offset;
</I>&gt;<i> +	unsigned int hecc_ram_offset;
</I>&gt;<i> +	unsigned int mbox_offset;
</I>&gt;<i> +	unsigned int int_line;
</I>&gt;<i> +	unsigned int version;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> -- 
</I>&gt;<i> 1.6.2.4
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Socketcan-core mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">Socketcan-core at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">https://lists.berlios.de/mailman/listinfo/socketcan-core</A>
</I>
Regards,

   Wolfram

-- 
Pengutronix e.K.                           | Wolfram Sang                |
Industrial Linux Solutions                 | <A HREF="http://www.pengutronix.de/">http://www.pengutronix.de/</A>  |
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 197 bytes
Desc: Digital signature
URL: &lt;<A HREF="https://lists.berlios.de/pipermail/socketcan-core/attachments/20090901/d45566a7/attachment.pgp">https://lists.berlios.de/pipermail/socketcan-core/attachments/20090901/d45566a7/attachment.pgp</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="002947.html">[PATCH] net-next:can: add TI CAN (HECC) driver
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2946">[ date ]</a>
              <a href="thread.html#2946">[ thread ]</a>
              <a href="subject.html#2946">[ subject ]</a>
              <a href="author.html#2946">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
