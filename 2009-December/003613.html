<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH] add the driver for Analog Devices Blackfin on-chip CAN 	controllers
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-December/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20add%20the%20driver%20for%20Analog%20Devices%20Blackfin%20on-chip%20CAN%20%0A%09controllers&In-Reply-To=%3C3c17e3570912081954m6019a638w9aa19ca8a88cc3a%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003611.html">
   <LINK REL="Next"  HREF="003614.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH] add the driver for Analog Devices Blackfin on-chip CAN 	controllers</H1>
    <B>Barry Song</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20add%20the%20driver%20for%20Analog%20Devices%20Blackfin%20on-chip%20CAN%20%0A%09controllers&In-Reply-To=%3C3c17e3570912081954m6019a638w9aa19ca8a88cc3a%40mail.gmail.com%3E"
       TITLE="[PATCH] add the driver for Analog Devices Blackfin on-chip CAN 	controllers">21cnbao at gmail.com
       </A><BR>
    <I>Wed Dec  9 04:54:47 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003611.html">r1095 autotools patch
</A></li>
        <LI>Next message: <A HREF="003614.html">[PATCH] add the driver for Analog Devices Blackfin on-chip CAN	controllers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3613">[ date ]</a>
              <a href="thread.html#3613">[ thread ]</a>
              <a href="subject.html#3613">[ subject ]</a>
              <a href="author.html#3613">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, Nov 12, 2009 at 8:36 PM, Wolfgang Grandegger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">wg at grandegger.com</A>&gt; wrote:
&gt;<i> Hello,
</I>&gt;<i>
</I>&gt;<i> as mentioned, for kernel inclusion you need to prepare patches for David
</I>&gt;<i> Millers &quot;net-next-2.6&quot; GIT tree, which you can get as shown below:
</I>&gt;<i>
</I>&gt;<i> $ git clone \
</I>&gt;<i> &#160;<A HREF="git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6.git">git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6.git</A>
</I>&gt;<i>
</I>&gt;<i> The patch should then be sent to the netdev mailing list with CC to the
</I>&gt;<i> Socketcan-core and other related mailing lists.
</I>&gt;<i>
</I>&gt;<i> Furthermore, your patch should be checked with checkpatch.pl to find the
</I>&gt;<i> obvious coding style violations. Many lines are too long. More details
</I>&gt;<i> about the coding style requirements can be found in the kernel
</I>&gt;<i> &quot;Documentation/CodingStyle&quot; file. Other general comment:
</I>&gt;<i>
</I>&gt;<i> - please use &quot;static inline functions&quot; in favor of macro definitions.
</I>&gt;<i> - the &quot;static inline functions&quot; should be short (just a few lines) and
</I>&gt;<i> &#160;the name should be in lowercase.
</I>&gt;<i> - please use #defines or enums for constants.
</I>&gt;<i> - please check if structures for the register layout results in better
</I>&gt;<i> &#160;code, as discussed.
</I>&gt;<i> - please remove extensive debugging output mainly useful for
</I>&gt;<i> &#160;development.
</I>&gt;<i> - in the kernel, please use u8 in favor of uint8_t, and the same for the
</I>&gt;<i> &#160;other types.
</I>&gt;<i>
</I>&gt;<i> More comments inline...
</I>&gt;<i>
</I>&gt;<i> Barry Song wrote:
</I>&gt;&gt;<i> Signed-off-by: Barry Song &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">21cnbao at gmail.com</A>&gt;
</I>&gt;&gt;<i> Signed-off-by: Heinz-J&#252;rgen Oertel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">oe at port.de</A>&gt;
</I>&gt;<i>
</I>&gt;<i> Hm, the german &quot;umlaut&quot; makes trouble here.
</I>&gt;<i>
</I>&gt;&gt;<i> ---
</I>&gt;&gt;<i> &#160;drivers/net/can/Kconfig &#160; &#160;| &#160; 10 +
</I>&gt;&gt;<i> &#160;drivers/net/can/Makefile &#160; | &#160; &#160;1 +
</I>&gt;&gt;<i> &#160;drivers/net/can/bfin-can.c | &#160;674 ++++++++++++++++++++++++++++++++++++++++++++
</I>&gt;&gt;<i> &#160;drivers/net/can/bfin-can.h | &#160;162 +++++++++++
</I>&gt;&gt;<i> &#160;4 files changed, 847 insertions(+), 0 deletions(-)
</I>&gt;&gt;<i> &#160;create mode 100644 drivers/net/can/bfin-can.c
</I>&gt;&gt;<i> &#160;create mode 100644 drivers/net/can/bfin-can.h
</I>&gt;<i>
</I>&gt;<i> Some times ago we agreed to use underscores for driver names, therefore
</I>&gt;<i> s/bfin-can/bfin_can/.
</I>&gt;<i>
</I>&gt;&gt;<i> diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
</I>&gt;&gt;<i> index df32c10..be305c5 100644
</I>&gt;&gt;<i> --- a/drivers/net/can/Kconfig
</I>&gt;&gt;<i> +++ b/drivers/net/can/Kconfig
</I>&gt;&gt;<i> @@ -95,6 +95,16 @@ config CAN_AT91
</I>&gt;&gt;<i> &#160; &#160; &#160; ---help---
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; This is a driver for the SoC CAN controller in Atmel's AT91SAM9263.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> +config CAN_BFIN
</I>&gt;&gt;<i> + &#160; &#160; depends on CAN_DEV &amp;&amp; (BF534 || BF536 || BF537 || BF538 || BF539 || BF54x)
</I>&gt;&gt;<i> + &#160; &#160; tristate &quot;Analog Devices Blackfin on-chip CAN&quot;
</I>&gt;&gt;<i> + &#160; &#160; ---help---
</I>&gt;&gt;<i> + &#160; &#160; &#160; Driver for the Analog Devices Blackfin on-chip CAN controllers
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; &#160; To compile this driver as a module, choose M here: the
</I>&gt;&gt;<i> + &#160; &#160; &#160; module will be called bfin-can.
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> &#160;config CAN_DEBUG_DEVICES
</I>&gt;&gt;<i> &#160; &#160; &#160; bool &quot;CAN devices debugging messages&quot;
</I>&gt;&gt;<i> &#160; &#160; &#160; depends on CAN
</I>&gt;&gt;<i> diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
</I>&gt;&gt;<i> index 0dea627..72618b0 100644
</I>&gt;&gt;<i> --- a/drivers/net/can/Makefile
</I>&gt;&gt;<i> +++ b/drivers/net/can/Makefile
</I>&gt;&gt;<i> @@ -11,5 +11,6 @@ obj-y &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; += usb/
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &#160;obj-$(CONFIG_CAN_SJA1000) &#160; &#160;+= sja1000/
</I>&gt;&gt;<i> &#160;obj-$(CONFIG_CAN_AT91) &#160; &#160; &#160; &#160; &#160; &#160; &#160; += at91_can.o
</I>&gt;&gt;<i> +obj-$(CONFIG_CAN_BFIN) &#160; &#160; &#160; &#160; &#160; &#160; &#160; += bfin-can.o
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &#160;ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
</I>&gt;&gt;<i> diff --git a/drivers/net/can/bfin-can.c b/drivers/net/can/bfin-can.c
</I>&gt;&gt;<i> new file mode 100644
</I>&gt;&gt;<i> index 0000000..c2ad42e
</I>&gt;&gt;<i> --- /dev/null
</I>&gt;&gt;<i> +++ b/drivers/net/can/bfin-can.c
</I>&gt;&gt;<i> @@ -0,0 +1,674 @@
</I>&gt;&gt;<i> +/*
</I>&gt;&gt;<i> + * Blackfin On-Chip CAN Driver
</I>&gt;&gt;<i> + *
</I>&gt;&gt;<i> + * Copyright 2004-2009 Analog Devices Inc.
</I>&gt;&gt;<i> + *
</I>&gt;&gt;<i> + * Enter bugs at <A HREF="http://blackfin.uclinux.org/">http://blackfin.uclinux.org/</A>
</I>&gt;&gt;<i> + *
</I>&gt;&gt;<i> + * Licensed under the GPL-2 or later.
</I>&gt;<i>
</I>&gt;<i> Please replace the above line with the usual GPL vX bla bla.
</I>&gt;<i>
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#include &lt;linux/module.h&gt;
</I>&gt;&gt;<i> +#include &lt;linux/init.h&gt;
</I>&gt;&gt;<i> +#include &lt;linux/kernel.h&gt;
</I>&gt;&gt;<i> +#include &lt;linux/types.h&gt;
</I>&gt;&gt;<i> +#include &lt;linux/interrupt.h&gt;
</I>&gt;&gt;<i> +#include &lt;linux/errno.h&gt;
</I>&gt;&gt;<i> +#include &lt;linux/netdevice.h&gt;
</I>&gt;&gt;<i> +#include &lt;linux/skbuff.h&gt;
</I>&gt;&gt;<i> +#include &lt;linux/platform_device.h&gt;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#include &lt;linux/can.h&gt;
</I>&gt;&gt;<i> +#include &lt;linux/can/dev.h&gt;
</I>&gt;&gt;<i> +#include &lt;linux/can/error.h&gt;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#include &lt;asm/portmux.h&gt;
</I>&gt;&gt;<i> +#include &quot;bfin-can.h&quot;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define DRV_NAME &quot;bfin_can&quot;
</I>&gt;<i>
</I>&gt;<i> The driver name should match the file name.
</I>&gt;<i>
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static struct can_bittiming_const bfin_can_bittiming_const = {
</I>&gt;&gt;<i> + &#160; &#160; .name = DRV_NAME,
</I>&gt;&gt;<i> + &#160; &#160; .tseg1_min = 1,
</I>&gt;&gt;<i> + &#160; &#160; .tseg1_max = 16,
</I>&gt;&gt;<i> + &#160; &#160; .tseg2_min = 1,
</I>&gt;&gt;<i> + &#160; &#160; .tseg2_max = 8,
</I>&gt;&gt;<i> + &#160; &#160; .sjw_max = 4,
</I>&gt;&gt;<i> + &#160; &#160; /* Although the BRP field can be set to any value, it is recommended
</I>&gt;&gt;<i> + &#160; &#160; &#160;* that the value be greater than or equal to 4, as restrictions
</I>&gt;&gt;<i> + &#160; &#160; &#160;* apply to the bit timing configuration when BRP is less than 4.
</I>&gt;&gt;<i> + &#160; &#160; &#160;*/
</I>&gt;&gt;<i> + &#160; &#160; .brp_min = 4,
</I>&gt;&gt;<i> + &#160; &#160; .brp_max = 1024,
</I>&gt;&gt;<i> + &#160; &#160; .brp_inc = 1,
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static int bfin_can_set_bittiming(struct net_device *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;<i> + &#160; &#160; struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
</I>&gt;&gt;<i> + &#160; &#160; u16 clk, timing;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; clk = bt-&gt;brp - 1;
</I>&gt;<i>
</I>&gt;<i> Do you need an extra variable here?
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; timing = ((bt-&gt;sjw - 1) &lt;&lt; 8) | (bt-&gt;prop_seg + bt-&gt;phase_seg1 - 1) |
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; ((bt-&gt;phase_seg2 - 1) &lt;&lt; 4);
</I>&gt;<i>
</I>&gt;<i> Consider using #defines for the constants, here and in many other places.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; /*
</I>&gt;&gt;<i> + &#160; &#160; &#160;* If the SAM bit is set, the input signal is oversampled three times at the SCLK rate.
</I>&gt;&gt;<i> + &#160; &#160; &#160;*/
</I>&gt;&gt;<i> + &#160; &#160; if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; timing |= SAM;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_CLOCK, clk);
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_TIMING, timing);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; dev_info(dev-&gt;dev.parent,
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &quot;setting can bitrate:%d brp:%d prop_seg:%d phase_seg1:%d phase_seg2:%d\n&quot;,
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; bt-&gt;bitrate, bt-&gt;brp, bt-&gt;prop_seg, bt-&gt;phase_seg1, bt-&gt;phase_seg2);
</I>&gt;<i>
</I>&gt;<i> Please remove as &quot;ip -d link show canX&quot; will list the values. Instead add
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;dev_info(dev-&gt;dev.parent, &quot;setting clk=%d timing=%#x\n&quot;, ....);
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; return 0;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static void bfin_can_set_reset_mode(struct net_device *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;<i> + &#160; &#160; int i;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; dev_dbg(dev-&gt;dev.parent, &quot;%s enter\n&quot;, __func__);
</I>&gt;<i>
</I>&gt;<i> Please remove this and similar lines below.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; /* disable interrupts */
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_MBIM1, 0);
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_MBIM2, 0);
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_GIM, 0);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* reset can and enter configuration mode */
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_CONTROL, SRS | CCR);
</I>&gt;&gt;<i> + &#160; &#160; SSYNC();
</I>&gt;<i>
</I>&gt;<i> I'm just curious. Why do you need a &quot;SSYNC&quot;. And where is SRS or CCR
</I>&gt;<i> defined?
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_CONTROL, CCR);
</I>&gt;&gt;<i> + &#160; &#160; SSYNC();
</I>&gt;&gt;<i> + &#160; &#160; while (!(CAN_READ_CTRL(priv, OFFSET_CONTROL) &amp; CCA))
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; continue;
</I>&gt;<i>
</I>&gt;<i> Please implement a timeout with a defined delay per loop, e.g.
</I>&gt;<i> udelay(10). Does it take long?
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; /*
</I>&gt;&gt;<i> + &#160; &#160; &#160;* All mailbox configurations are marked as inactive
</I>&gt;&gt;<i> + &#160; &#160; &#160;* by writing to CAN Mailbox Configuration Registers 1 and 2
</I>&gt;&gt;<i> + &#160; &#160; &#160;* For all bits: 0 - Mailbox disabled, 1 - Mailbox enabled
</I>&gt;&gt;<i> + &#160; &#160; &#160;*/
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_MC1, 0);
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_MC2, 0);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* Set Mailbox Direction */
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_MD1, 0xFFFF); &#160;/* mailbox 1-16 are RX */
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_MD2, 0); &#160; &#160; &#160; /* mailbox 17-32 are TX */
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* RECEIVE_STD_CHL */
</I>&gt;&gt;<i> + &#160; &#160; for (i = 0; i &lt; 2; i++) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_OID(priv, RECEIVE_STD_CHL + i, 0);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_ID0(priv, RECEIVE_STD_CHL, 0);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_DLC(priv, RECEIVE_STD_CHL + i, 0);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_AMH(priv, RECEIVE_STD_CHL + i, 0x1FFF);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_AML(priv, RECEIVE_STD_CHL + i, 0xFFFF);
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* RECEIVE_EXT_CHL */
</I>&gt;&gt;<i> + &#160; &#160; for (i = 0; i &lt; 2; i++) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_XOID(priv, RECEIVE_EXT_CHL + i, 0);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_DLC(priv, RECEIVE_EXT_CHL + i, 0);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_AMH(priv, RECEIVE_EXT_CHL + i, 0x1FFF);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_AML(priv, RECEIVE_EXT_CHL + i, 0xFFFF);
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_MC2, 1 &lt;&lt; (TRANSMIT_CHL - 16));
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_MC1, (1 &lt;&lt; RECEIVE_STD_CHL) + (1 &lt;&lt; RECEIVE_EXT_CHL));
</I>&gt;&gt;<i> + &#160; &#160; SSYNC();
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static void bfin_can_set_normal_mode(struct net_device *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; dev_dbg(dev-&gt;dev.parent, &quot;%s enter\n&quot;, __func__);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* leave configuration mode */
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_CONTROL, CAN_READ_CTRL(priv, OFFSET_CONTROL) &amp; ~CCR);
</I>&gt;&gt;<i> + &#160; &#160; while (CAN_READ_CTRL(priv, OFFSET_STATUS) &amp; CCA)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; continue;
</I>&gt;<i>
</I>&gt;<i> Ditto, see above.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; /* clear _All_ &#160;tx and rx interrupts */
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_MBTIF1, 0xFFFF);
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_MBTIF2, 0xFFFF);
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_MBRIF1, 0xFFFF);
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_MBRIF2, 0xFFFF);
</I>&gt;&gt;<i> + &#160; &#160; /* clear global interrupt status register */
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_GIS, 0x7FF); /* overwrites with '1' */
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* Initialize Interrupts
</I>&gt;<i>
</I>&gt;<i> Please use:
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;/*
</I>&gt;<i> &#160; &#160; &#160; &#160; * Initialize Interrupts
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; &#160;* - set bits in the mailbox interrupt mask register
</I>&gt;&gt;<i> + &#160; &#160; &#160;* - global interrupt mask
</I>&gt;&gt;<i> + &#160; &#160; &#160;*/
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_MBIM1, (1 &lt;&lt; RECEIVE_STD_CHL) + (1 &lt;&lt; RECEIVE_EXT_CHL));
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_MBIM2, 1 &lt;&lt; (TRANSMIT_CHL - 16));
</I>&gt;<i>
</I>&gt;<i> In general, you could use the kernel's BIT() for the shift operations.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_GIM, EPIM | BOIM | RMLIM);
</I>&gt;&gt;<i> + &#160; &#160; SSYNC();
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static void bfin_can_start(struct net_device *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; dev_dbg(dev-&gt;dev.parent, &quot;%s enter\n&quot;, __func__);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* leave reset mode */
</I>&gt;&gt;<i> + &#160; &#160; if (priv-&gt;can.state != CAN_STATE_STOPPED)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; bfin_can_set_reset_mode(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* leave reset mode */
</I>&gt;&gt;<i> + &#160; &#160; bfin_can_set_normal_mode(dev);
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static int bfin_can_set_mode(struct net_device *dev, enum can_mode mode)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; dev_dbg(dev-&gt;dev.parent, &quot;%s enter\n&quot;, __func__);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; switch (mode) {
</I>&gt;&gt;<i> + &#160; &#160; case CAN_MODE_START:
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; bfin_can_start(dev);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; if (netif_queue_stopped(dev))
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; netif_wake_queue(dev);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; break;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; default:
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; return -EOPNOTSUPP;
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; return 0;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/*
</I>&gt;&gt;<i> + * transmit a CAN message
</I>&gt;&gt;<i> + * message layout in the sk_buff should be like this:
</I>&gt;&gt;<i> + * xx xx xx xx &#160; &#160; &#160; &#160;ff &#160; &#160; &#160;ll &#160; 00 11 22 33 44 55 66 77
</I>&gt;&gt;<i> + * [ &#160;can-id ] [flags] [len] [can data (up to 8 bytes]
</I>&gt;&gt;<i> + */
</I>&gt;<i>
</I>&gt;<i> Please remove the lines above (even if they are as well in the SJA1000
</I>&gt;<i> driver).
</I>&gt;<i>
</I>&gt;&gt;<i> +static int bfin_can_start_xmit(struct sk_buff *skb, struct net_device *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;<i> + &#160; &#160; struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;&gt;<i> + &#160; &#160; struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;&gt;<i> + &#160; &#160; uint8_t dlc;
</I>&gt;<i>
</I>&gt;<i> s/uint8_t/u8, see general comments.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; canid_t id;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; dev_dbg(dev-&gt;dev.parent, &quot;%s enter\n&quot;, __func__);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; netif_stop_queue(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; dlc = cf-&gt;can_dlc;
</I>&gt;&gt;<i> + &#160; &#160; id = cf-&gt;can_id;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* fill id and data length code */
</I>&gt;&gt;<i> + &#160; &#160; if (id &amp; CAN_EFF_FLAG) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; if (id &amp; CAN_RTR_FLAG)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_XOID_RTR(priv, TRANSMIT_CHL, id);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; else
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_XOID(priv, TRANSMIT_CHL, id);
</I>&gt;&gt;<i> + &#160; &#160; } else {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; if (id &amp; CAN_RTR_FLAG)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_OID_RTR(priv, TRANSMIT_CHL, id);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; else
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_OID(priv, TRANSMIT_CHL, id);
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; BFIN_CAN_WRITE_MSG(priv, TRANSMIT_CHL, cf-&gt;data, dlc);
</I>&gt;<i>
</I>&gt;<i> Use a better name, e.g. bfin_can_write_data (or payload).
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_DLC(priv, TRANSMIT_CHL, dlc);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; stats-&gt;tx_bytes += dlc;
</I>&gt;<i>
</I>&gt;<i> Please increase that counter when TX is done. You should also increment
</I>&gt;<i> stats-&gt;tx_packets there.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; dev-&gt;trans_start = jiffies;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; can_put_echo_skb(skb, dev, 0);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* set transmit request */
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_TRS2, 1 &lt;&lt; (TRANSMIT_CHL - 16));
</I>&gt;&gt;<i> + &#160; &#160; return 0;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* Our watchdog timed out. Called by the up layer */
</I>&gt;&gt;<i> +static void bfin_can_timeout(struct net_device *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; dev_dbg(dev-&gt;dev.parent, &quot;%s enter\n&quot;, __func__);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* We can accept TX packets again */
</I>&gt;&gt;<i> + &#160; &#160; dev-&gt;trans_start = jiffies;
</I>&gt;&gt;<i> + &#160; &#160; netif_wake_queue(dev);
</I>&gt;&gt;<i> +}
</I>&gt;<i>
</I>&gt;<i> Please remove the TX watchdog. We don't need it.
</I>&gt;<i>
</I>&gt;&gt;<i> +static void bfin_can_rx(struct net_device *dev, uint16_t isrc)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;<i> + &#160; &#160; struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;&gt;<i> + &#160; &#160; struct can_frame *cf;
</I>&gt;&gt;<i> + &#160; &#160; struct sk_buff *skb;
</I>&gt;&gt;<i> + &#160; &#160; canid_t id;
</I>&gt;&gt;<i> + &#160; &#160; uint8_t dlc;
</I>&gt;&gt;<i> + &#160; &#160; int obj;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; dev_dbg(dev-&gt;dev.parent, &quot;%s enter\n&quot;, __func__);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; skb = dev_alloc_skb(sizeof(struct can_frame));
</I>&gt;<i>
</I>&gt;<i> Please use alloc_can_skb() making various lines below obsolete.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; if (skb == NULL)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; return;
</I>&gt;&gt;<i> + &#160; &#160; skb-&gt;dev = dev;
</I>&gt;&gt;<i> + &#160; &#160; skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* get id and data length code */
</I>&gt;&gt;<i> + &#160; &#160; if (isrc &amp; (1 &lt;&lt; RECEIVE_EXT_CHL)) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; /* extended frame format (EFF) */
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; id = CAN_READ_XOID(priv, RECEIVE_EXT_CHL);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; id |= CAN_EFF_FLAG;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; obj = RECEIVE_EXT_CHL;
</I>&gt;&gt;<i> + &#160; &#160; } else {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; /* standard frame format (SFF) */
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; id = CAN_READ_OID(priv, RECEIVE_STD_CHL);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; obj = RECEIVE_STD_CHL;
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> + &#160; &#160; if (CAN_READ_ID1(priv, obj) &amp; RTR)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; id |= CAN_RTR_FLAG;
</I>&gt;&gt;<i> + &#160; &#160; dlc = CAN_READ_DLC(priv, obj);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; cf = (struct can_frame *)skb_put(skb, sizeof(*cf));
</I>&gt;&gt;<i> + &#160; &#160; memset(cf, 0, sizeof(struct can_frame));
</I>&gt;&gt;<i> + &#160; &#160; cf-&gt;can_id = id;
</I>&gt;&gt;<i> + &#160; &#160; cf-&gt;can_dlc = dlc;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; BFIN_CAN_READ_MSG(priv, obj, cf-&gt;data, dlc);
</I>&gt;<i>
</I>&gt;<i> See comment about the name above.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; netif_rx(skb);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; dev-&gt;last_rx = jiffies;
</I>&gt;<i>
</I>&gt;<i> Not needed any more.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; stats-&gt;rx_packets++;
</I>&gt;&gt;<i> + &#160; &#160; stats-&gt;rx_bytes += dlc;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static int bfin_can_err(struct net_device *dev, uint16_t isrc, uint16_t status)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;<i> + &#160; &#160; struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;&gt;<i> + &#160; &#160; struct can_frame *cf;
</I>&gt;&gt;<i> + &#160; &#160; struct sk_buff *skb;
</I>&gt;&gt;<i> + &#160; &#160; enum can_state state = priv-&gt;can.state;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; dev_dbg(dev-&gt;dev.parent, &quot;%s enter\n&quot;, __func__);
</I>&gt;&gt;<i> +
</I>&gt;<i>
</I>&gt;<i> Please use alloc_can_err_skb() making various lines below obsolete.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; skb = dev_alloc_skb(sizeof(struct can_frame));
</I>&gt;&gt;<i> + &#160; &#160; if (skb == NULL)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; return -ENOMEM;
</I>&gt;&gt;<i> + &#160; &#160; skb-&gt;dev = dev;
</I>&gt;&gt;<i> + &#160; &#160; skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;&gt;<i> + &#160; &#160; cf = (struct can_frame *)skb_put(skb, sizeof(*cf));
</I>&gt;&gt;<i> + &#160; &#160; memset(cf, 0, sizeof(struct can_frame));
</I>&gt;&gt;<i> + &#160; &#160; cf-&gt;can_id = CAN_ERR_FLAG;
</I>&gt;&gt;<i> + &#160; &#160; cf-&gt;can_dlc = CAN_ERR_DLC;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; if (isrc &amp; RMLIS) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; /* data overrun interrupt */
</I>&gt;<i>
</I>&gt;<i> Redundant comment?
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; dev_dbg(dev-&gt;dev.parent, &quot;data overrun interrupt\n&quot;);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; cf-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; stats-&gt;rx_over_errors++;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; stats-&gt;rx_errors++;
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> + &#160; &#160; if (isrc &amp; BOIS) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; dev_dbg(dev-&gt;dev.parent, &quot;bus-off mode interrupt\n&quot;);
</I>&gt;<i>
</I>&gt;<i> Please remove line above as in all other cases.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; state = CAN_STATE_BUS_OFF;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; can_bus_off(dev);
</I>&gt;<i>
</I>&gt;<i> Does the BFIN CAN controller recover from bus-off automatically?
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> + &#160; &#160; if (isrc &amp; EPIS) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; /* error passive interrupt */
</I>&gt;<i>
</I>&gt;<i> Redundant comment?
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; dev_dbg(dev-&gt;dev.parent, &quot;error passive interrupt\n&quot;);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> + &#160; &#160; if ((isrc &amp; EWTIS) || (isrc &amp; EWRIS)) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; dev_dbg(dev-&gt;dev.parent, &quot;Error Warning Transmit/Receive Interrupt\n&quot;);
</I>&gt;<i>
</I>&gt;<i> Message in lowercase as above?
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; state = CAN_STATE_ERROR_WARNING;
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; if (state != priv-&gt;can.state &amp;&amp; (state == CAN_STATE_ERROR_WARNING ||
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; state == CAN_STATE_ERROR_PASSIVE)) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; uint16_t cec = CAN_READ_CTRL(priv, OFFSET_CEC);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; uint8_t rxerr = cec;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; uint8_t txerr = cec &gt;&gt; 8;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Please add an empty line here.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; if (state == CAN_STATE_ERROR_WARNING) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; priv-&gt;can.can_stats.error_warning++;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; cf-&gt;data[1] = (txerr &gt; rxerr) ?
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; CAN_ERR_CRTL_TX_WARNING :
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; CAN_ERR_CRTL_RX_WARNING;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; } else {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; priv-&gt;can.can_stats.error_passive++;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; cf-&gt;data[1] = (txerr &gt; rxerr) ?
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; CAN_ERR_CRTL_TX_PASSIVE :
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; }
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; if (status) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; priv-&gt;can.can_stats.bus_error++;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; if (status &amp; BEF)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; else if (status &amp; FER)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; else if (status &amp; SER)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; else
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; cf-&gt;data[2] |= CAN_ERR_PROT_UNSPEC;
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; priv-&gt;can.state = state;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; netif_rx(skb);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; dev-&gt;last_rx = jiffies;
</I>&gt;<i>
</I>&gt;<i> Please remove.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; stats-&gt;rx_packets++;
</I>&gt;&gt;<i> + &#160; &#160; stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; return 0;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +irqreturn_t bfin_can_interrupt(int irq, void *dev_id)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; struct net_device *dev = dev_id;
</I>&gt;&gt;<i> + &#160; &#160; struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;<i> + &#160; &#160; struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;&gt;<i> + &#160; &#160; uint16_t status, isrc;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; dev_dbg(dev-&gt;dev.parent, &quot;%s enter, irq num:%d\n&quot;, __func__, irq);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; if ((irq == priv-&gt;tx_irq) &amp;&amp; CAN_READ_CTRL(priv, OFFSET_MBTIF2)) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; /* transmission complete interrupt */
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_MBTIF2, 0xFFFF);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; stats-&gt;tx_packets++;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; can_get_echo_skb(dev, 0);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; netif_wake_queue(dev);
</I>&gt;&gt;<i> + &#160; &#160; } else if ((irq == priv-&gt;rx_irq) &amp;&amp; CAN_READ_CTRL(priv, OFFSET_MBRIF1)) {
</I>&gt;<i>
</I>&gt;<i> This and the following &quot;else if&quot; cases will be checked, even if &quot;irq ==
</I>&gt;<i> priv-&gt;tx_irq&quot;. A switch statement seems more appropriate to me.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; /* receive interrupt */
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; isrc = CAN_READ_CTRL(priv, OFFSET_MBRIF1);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_MBRIF1, 0xFFFF);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; bfin_can_rx(dev, isrc);
</I>&gt;&gt;<i> + &#160; &#160; } else if ((irq == priv-&gt;err_irq) &amp;&amp; CAN_READ_CTRL(priv, OFFSET_GIS)) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; /* error interrupt */
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; isrc = CAN_READ_CTRL(priv, OFFSET_GIS);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; status = CAN_READ_CTRL(priv, OFFSET_ESR);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_GIS, 0x7FF);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; bfin_can_err(dev, isrc, status);
</I>&gt;&gt;<i> + &#160; &#160; } else
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; return IRQ_NONE;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; return IRQ_HANDLED;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static int bfin_can_open(struct net_device *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; int err;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* set chip into reset mode */
</I>&gt;&gt;<i> + &#160; &#160; bfin_can_set_reset_mode(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* common open */
</I>&gt;&gt;<i> + &#160; &#160; err = open_candev(dev);
</I>&gt;&gt;<i> + &#160; &#160; if (err)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; return err;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* init and start chi */
</I>&gt;<i>
</I>&gt;<i> s/chi/chip/ ?
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; bfin_can_start(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; netif_start_queue(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; return 0;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static int bfin_can_close(struct net_device *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; netif_stop_queue(dev);
</I>&gt;&gt;<i> + &#160; &#160; bfin_can_set_reset_mode(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; close_candev(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; return 0;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +struct net_device *alloc_bfin_candev(void)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; struct net_device *dev;
</I>&gt;&gt;<i> + &#160; &#160; struct bfin_can_priv *priv;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; dev = alloc_candev(sizeof(*priv));
</I>&gt;&gt;<i> + &#160; &#160; if (!dev)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; return NULL;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; priv = netdev_priv(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; priv-&gt;dev = dev;
</I>&gt;&gt;<i> + &#160; &#160; priv-&gt;can.bittiming_const = &amp;bfin_can_bittiming_const;
</I>&gt;&gt;<i> + &#160; &#160; priv-&gt;can.do_set_bittiming = bfin_can_set_bittiming;
</I>&gt;&gt;<i> + &#160; &#160; priv-&gt;can.do_set_mode = bfin_can_set_mode;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; return dev;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +void free_bfin_candev(struct net_device *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; free_candev(dev);
</I>&gt;&gt;<i> +}
</I>&gt;<i>
</I>&gt;<i> Please re-think if the two helper functions are really useful. At least
</I>&gt;<i> add &quot;static&quot; and &quot;__devinit&quot; or &quot;__devexit&quot;
</I>&gt;<i>
</I>&gt;&gt;<i> +static const struct net_device_ops bfin_can_netdev_ops = {
</I>&gt;&gt;<i> + &#160; &#160; .ndo_open &#160; &#160; &#160; &#160; &#160; &#160; &#160; = bfin_can_open,
</I>&gt;&gt;<i> + &#160; &#160; .ndo_stop &#160; &#160; &#160; &#160; &#160; &#160; &#160; = bfin_can_close,
</I>&gt;&gt;<i> + &#160; &#160; .ndo_start_xmit &#160; &#160; &#160; &#160; = bfin_can_start_xmit,
</I>&gt;&gt;<i> + &#160; &#160; .ndo_tx_timeout &#160; &#160; &#160; &#160; = bfin_can_timeout,
</I>&gt;<i>
</I>&gt;<i> Please remove .ndo_tx_timeout.
</I>&gt;<i>
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +int register_bfin_candev(struct net_device *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; dev-&gt;flags |= IFF_ECHO; /* we support local echo */
</I>&gt;&gt;<i> + &#160; &#160; dev-&gt;netdev_ops = &amp;bfin_can_netdev_ops;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; bfin_can_set_reset_mode(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; return register_candev(dev);
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +void unregister_bfin_candev(struct net_device *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; bfin_can_set_reset_mode(dev);
</I>&gt;&gt;<i> + &#160; &#160; unregister_candev(dev);
</I>&gt;&gt;<i> +}
</I>&gt;<i>
</I>&gt;<i> Please re-think if the two helper functions are really useful. At least
</I>&gt;<i> add &quot;static&quot; and &quot;__devinit&quot; or &quot;__devexit&quot;
</I>&gt;<i>
</I>&gt;&gt;<i> +static int __devinit bfin_can_probe(struct platform_device *pdev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; int err;
</I>&gt;&gt;<i> + &#160; &#160; struct net_device *dev;
</I>&gt;&gt;<i> + &#160; &#160; struct bfin_can_priv *priv;
</I>&gt;&gt;<i> + &#160; &#160; struct resource *res_mem, *rx_irq, *tx_irq, *err_irq;
</I>&gt;&gt;<i> + &#160; &#160; unsigned short *pdata;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; pdata = pdev-&gt;dev.platform_data;
</I>&gt;&gt;<i> + &#160; &#160; if (!pdata) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; dev_err(&amp;pdev-&gt;dev, &quot;No platform data provided!\n&quot;);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; err = -ENODEV;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; goto exit;
</I>&gt;<i>
</I>&gt;<i> &quot;return -ENODEV;&quot; would be fine here?
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;&gt;<i> + &#160; &#160; rx_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
</I>&gt;&gt;<i> + &#160; &#160; tx_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 1);
</I>&gt;&gt;<i> + &#160; &#160; err_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 2);
</I>&gt;&gt;<i> + &#160; &#160; if (!res_mem || !rx_irq || !tx_irq || !err_irq) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; err = -ENODEV;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; goto exit;
</I>&gt;<i>
</I>&gt;<i> Ditto.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; if (!request_mem_region(res_mem-&gt;start, resource_size(res_mem),
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; dev_name(&amp;pdev-&gt;dev))) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; err = -EBUSY;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; goto exit;
</I>&gt;<i>
</I>&gt;<i> Ditto.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* request peripheral pins */
</I>&gt;&gt;<i> + &#160; &#160; err = peripheral_request_list(pdata, dev_name(&amp;pdev-&gt;dev));
</I>&gt;&gt;<i> + &#160; &#160; if (err)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; goto exit_mem_release;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; dev = alloc_bfin_candev();
</I>&gt;&gt;<i> + &#160; &#160; if (!dev) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; err = -ENOMEM;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; goto exit_peri_pin_free;
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; /* register interrupt handler */
</I>&gt;&gt;<i> + &#160; &#160; err = request_irq(rx_irq-&gt;start, &amp;bfin_can_interrupt, 0,
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &quot;bfin-can-rx&quot;, (void *)dev);
</I>&gt;&gt;<i> + &#160; &#160; if (err)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; goto exit_candev_free;
</I>&gt;&gt;<i> + &#160; &#160; err = request_irq(tx_irq-&gt;start, &amp;bfin_can_interrupt, 0,
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &quot;bfin-can-tx&quot;, (void *)dev);
</I>&gt;&gt;<i> + &#160; &#160; if (err)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; goto exit_rx_irq_free;
</I>&gt;&gt;<i> + &#160; &#160; err = request_irq(err_irq-&gt;start, &amp;bfin_can_interrupt, 0,
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &quot;bfin-can-err&quot;, (void *)dev);
</I>&gt;&gt;<i> + &#160; &#160; if (err)
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; goto exit_tx_irq_free;
</I>&gt;<i>
</I>&gt;<i> Usually the interrupts are requested in the open function. Any reason
</I>&gt;<i> why it's done that early?
</I>&gt;<i>
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; priv = netdev_priv(dev);
</I>&gt;&gt;<i> + &#160; &#160; priv-&gt;membase = res_mem-&gt;start;
</I>&gt;&gt;<i> + &#160; &#160; priv-&gt;rx_irq = rx_irq-&gt;start;
</I>&gt;&gt;<i> + &#160; &#160; priv-&gt;tx_irq = tx_irq-&gt;start;
</I>&gt;&gt;<i> + &#160; &#160; priv-&gt;err_irq = err_irq-&gt;start;
</I>&gt;&gt;<i> + &#160; &#160; priv-&gt;pin_list = pdata;
</I>&gt;&gt;<i> + &#160; &#160; priv-&gt;can.clock.freq = get_sclk();
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; dev_set_drvdata(&amp;pdev-&gt;dev, dev);
</I>&gt;&gt;<i> + &#160; &#160; SET_NETDEV_DEV(dev, &amp;pdev-&gt;dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; err = register_bfin_candev(dev);
</I>&gt;&gt;<i> + &#160; &#160; if (err) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; dev_err(&amp;pdev-&gt;dev, &quot;registering failed (err=%d)\n&quot;, err);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; goto exit_err_irq_free;
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; dev_info(&amp;pdev-&gt;dev, &quot;%s device registered (reg_base=%p, rx_irq=%d, tx_irq=%d, err_irq=%d, sclk=%d)\n&quot;,
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; DRV_NAME, (void *)priv-&gt;membase, priv-&gt;rx_irq, priv-&gt;tx_irq, priv-&gt;err_irq,
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; priv-&gt;can.clock.freq);
</I>&gt;&gt;<i> + &#160; &#160; return 0;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +exit_err_irq_free:
</I>&gt;&gt;<i> + &#160; &#160; free_irq(err_irq-&gt;start, dev);
</I>&gt;&gt;<i> +exit_tx_irq_free:
</I>&gt;&gt;<i> + &#160; &#160; free_irq(tx_irq-&gt;start, dev);
</I>&gt;&gt;<i> +exit_rx_irq_free:
</I>&gt;&gt;<i> + &#160; &#160; free_irq(rx_irq-&gt;start, dev);
</I>&gt;&gt;<i> +exit_candev_free:
</I>&gt;&gt;<i> + &#160; &#160; free_bfin_candev(dev);
</I>&gt;&gt;<i> +exit_peri_pin_free:
</I>&gt;&gt;<i> + &#160; &#160; peripheral_free_list(pdata);
</I>&gt;&gt;<i> +exit_mem_release:
</I>&gt;&gt;<i> + &#160; &#160; release_mem_region(res_mem-&gt;start, resource_size(res_mem));
</I>&gt;&gt;<i> +exit:
</I>&gt;&gt;<i> + &#160; &#160; return err;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static int __devexit bfin_can_remove(struct platform_device *pdev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; struct net_device *dev = dev_get_drvdata(&amp;pdev-&gt;dev);
</I>&gt;&gt;<i> + &#160; &#160; struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;<i> + &#160; &#160; struct resource *res;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; unregister_bfin_candev(dev);
</I>&gt;&gt;<i> + &#160; &#160; dev_set_drvdata(&amp;pdev-&gt;dev, NULL);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;&gt;<i> + &#160; &#160; release_mem_region(res-&gt;start, resource_size(res));
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; free_irq(priv-&gt;rx_irq, dev);
</I>&gt;&gt;<i> + &#160; &#160; free_irq(priv-&gt;tx_irq, dev);
</I>&gt;&gt;<i> + &#160; &#160; free_irq(priv-&gt;err_irq, dev);
</I>&gt;&gt;<i> + &#160; &#160; peripheral_free_list(priv-&gt;pin_list);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; free_bfin_candev(dev);
</I>&gt;&gt;<i> + &#160; &#160; return 0;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#ifdef CONFIG_PM
</I>&gt;&gt;<i> +static int bfin_can_suspend(struct platform_device *pdev, pm_message_t mesg)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; struct net_device *dev = dev_get_drvdata(&amp;pdev-&gt;dev);
</I>&gt;&gt;<i> + &#160; &#160; struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; if (netif_running(dev)) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; /* enter sleep mode */
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_CONTROL,
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; CAN_READ_CTRL(priv, OFFSET_CONTROL) | SMR);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; SSYNC();
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; while (!(CAN_READ_CTRL(priv, OFFSET_INTR) &amp; SMACK))
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; continue;
</I>&gt;<i>
</I>&gt;<i> Timeout?
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; return 0;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static int bfin_can_resume(struct platform_device *pdev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; struct net_device *dev = dev_get_drvdata(&amp;pdev-&gt;dev);
</I>&gt;&gt;<i> + &#160; &#160; struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; if (netif_running(dev)) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; /* leave sleep mode */
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_CTRL(priv, OFFSET_INTR, 0);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; SSYNC();
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; return 0;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +#else
</I>&gt;&gt;<i> +#define bfin_can_suspend NULL
</I>&gt;&gt;<i> +#define bfin_can_resume NULL
</I>&gt;&gt;<i> +#endif &#160; &#160; &#160; /* CONFIG_PM */
</I>&gt;<i>
</I>&gt;<i> Does suspend/resume work properly?
</I>&gt;<i>
</I>&gt;&gt;<i> +static struct platform_driver bfin_can_driver = {
</I>&gt;&gt;<i> + &#160; &#160; .probe = bfin_can_probe,
</I>&gt;&gt;<i> + &#160; &#160; .remove = __devexit_p(bfin_can_remove),
</I>&gt;&gt;<i> + &#160; &#160; .suspend = bfin_can_suspend,
</I>&gt;&gt;<i> + &#160; &#160; .resume = bfin_can_resume,
</I>&gt;&gt;<i> + &#160; &#160; .driver = {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; .name = DRV_NAME,
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; .owner = THIS_MODULE,
</I>&gt;&gt;<i> + &#160; &#160; },
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static int __init bfin_can_init(void)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; return platform_driver_register(&amp;bfin_can_driver);
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +module_init(bfin_can_init);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static void __exit bfin_can_exit(void)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; platform_driver_unregister(&amp;bfin_can_driver);
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +module_exit(bfin_can_exit);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +MODULE_AUTHOR(&quot;Barry Song &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">21cnbao at gmail.com</A>&gt;&quot;);
</I>&gt;&gt;<i> +MODULE_LICENSE(&quot;GPL&quot;);
</I>&gt;&gt;<i> +MODULE_DESCRIPTION(&quot;Blackfin on-chip CAN netdevice driver&quot;);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> diff --git a/drivers/net/can/bfin-can.h b/drivers/net/can/bfin-can.h
</I>&gt;&gt;<i> new file mode 100644
</I>&gt;&gt;<i> index 0000000..ec74168
</I>&gt;&gt;<i> --- /dev/null
</I>&gt;&gt;<i> +++ b/drivers/net/can/bfin-can.h
</I>&gt;<i>
</I>&gt;<i> If the header file and the .c gets smaller, please consider merging it
</I>&gt;<i> into the .c file.
</I>&gt;<i>
</I>&gt;&gt;<i> @@ -0,0 +1,162 @@
</I>&gt;&gt;<i> +/*
</I>&gt;&gt;<i> + * Blackfin On-Chip CAN Driver
</I>&gt;&gt;<i> + *
</I>&gt;&gt;<i> + * Copyright 2004-2009 Analog Devices Inc.
</I>&gt;&gt;<i> + *
</I>&gt;&gt;<i> + * Enter bugs at <A HREF="http://blackfin.uclinux.org/">http://blackfin.uclinux.org/</A>
</I>&gt;&gt;<i> + *
</I>&gt;&gt;<i> + * Licensed under the GPL-2 or later.
</I>&gt;<i>
</I>&gt;<i> See above.
</I>&gt;<i>
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#ifndef __BLACKFIN_CAN_H
</I>&gt;&gt;<i> +#define __BLACKFIN_CAN_H
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#include &lt;asm/io.h&gt;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/*
</I>&gt;&gt;<i> + * bfin can private data
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +struct bfin_can_priv {
</I>&gt;&gt;<i> + &#160; &#160; struct can_priv can; &#160; &#160;/* must be the first member */
</I>&gt;&gt;<i> + &#160; &#160; struct sk_buff *echo_skb;
</I>&gt;<i>
</I>&gt;<i> Seems not be be used anywhere? It's the same in sja1000.h! Will need to
</I>&gt;<i> fix that.
</I>echo_skb is used in can_put_echo_skb() and can_get_echo_skb(), example:
void can_get_echo_skb(struct net_device *dev, int idx)
{
        struct can_priv *priv = netdev_priv(dev);

        if (priv-&gt;echo_skb[idx]) {
                netif_rx(priv-&gt;echo_skb[idx]);
                priv-&gt;echo_skb[idx] = NULL;
        }
}
EXPORT_SYMBOL_GPL(can_get_echo_skb);

&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; struct net_device *dev;
</I>&gt;&gt;<i> + &#160; &#160; u32 membase;
</I>&gt;<i>
</I>&gt;<i> Please use &quot;void __iomem *membase&quot; and proper accessor functions for
</I>&gt;<i> I/O, e.g. iowrite16 or bfin_write16 and friends.
</I>&gt;<i>
</I>&gt;&gt;<i> + &#160; &#160; int rx_irq;
</I>&gt;&gt;<i> + &#160; &#160; int tx_irq;
</I>&gt;&gt;<i> + &#160; &#160; int err_irq;
</I>&gt;&gt;<i> + &#160; &#160; unsigned short *pin_list;
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/*
</I>&gt;&gt;<i> + * registers offset
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +#define OFFSET_MB_MASK &#160; &#160; &#160; &#160; &#160; &#160; &#160;0x100
</I>&gt;&gt;<i> +#define OFFSET_MASK_AML &#160; &#160; &#160; &#160; &#160; &#160; 0x0
</I>&gt;&gt;<i> +#define OFFSET_MASK_AMH &#160; &#160; &#160; &#160; &#160; &#160; 0x4
</I>&gt;&gt;<i> +#define OFFSET_MB_OBJ &#160; &#160; &#160; &#160; &#160; &#160; &#160; 0x200
</I>&gt;&gt;<i> +#define OFFSET_OBJ_DATA &#160; &#160; &#160; &#160; &#160; &#160; 0x0
</I>&gt;&gt;<i> +#define OFFSET_OBJ_DLC &#160; &#160; &#160; &#160; &#160; &#160; &#160;0x10
</I>&gt;&gt;<i> +#define OFFSET_OBJ_ID0 &#160; &#160; &#160; &#160; &#160; &#160; &#160;0x18
</I>&gt;&gt;<i> +#define OFFSET_OBJ_ID1 &#160; &#160; &#160; &#160; &#160; &#160; &#160;0x1C
</I>&gt;&gt;<i> +#define OFFSET_CLOCK &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;0x80
</I>&gt;&gt;<i> +#define OFFSET_TIMING &#160; &#160; &#160; &#160; &#160; &#160; &#160; 0x84
</I>&gt;&gt;<i> +#define OFFSET_STATUS &#160; &#160; &#160; &#160; &#160; &#160; &#160; 0x8C
</I>&gt;&gt;<i> +#define OFFSET_CEC &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;0x90
</I>&gt;&gt;<i> +#define OFFSET_GIS &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;0x94
</I>&gt;&gt;<i> +#define OFFSET_GIM &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;0x98
</I>&gt;&gt;<i> +#define OFFSET_CONTROL &#160; &#160; &#160; &#160; &#160; &#160; &#160;0xA0
</I>&gt;&gt;<i> +#define OFFSET_INTR &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; 0xA4
</I>&gt;&gt;<i> +#define OFFSET_ESR &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;0xB4
</I>&gt;&gt;<i> +#define OFFSET_MBIM1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;0x28
</I>&gt;&gt;<i> +#define OFFSET_MBIM2 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;0x68
</I>&gt;&gt;<i> +#define OFFSET_MC1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;0x0
</I>&gt;&gt;<i> +#define OFFSET_MC2 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;0x40
</I>&gt;&gt;<i> +#define OFFSET_MD1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;0x4
</I>&gt;&gt;<i> +#define OFFSET_MD2 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;0x44
</I>&gt;&gt;<i> +#define OFFSET_TRS2 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; 0x48
</I>&gt;&gt;<i> +#define OFFSET_MBTIF1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; 0x20
</I>&gt;&gt;<i> +#define OFFSET_MBTIF2 &#160; &#160; &#160; &#160; &#160; &#160; &#160; 0x60
</I>&gt;&gt;<i> +#define OFFSET_MBRIF1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; 0x24
</I>&gt;&gt;<i> +#define OFFSET_MBRIF2 &#160; &#160; &#160; &#160; &#160; &#160; &#160; 0x64
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define can_membase(priv) &#160;\
</I>&gt;&gt;<i> + &#160; &#160; ((priv)-&gt;membase)
</I>&gt;&gt;<i> +#define can_channel_membase(priv, channel) \
</I>&gt;&gt;<i> + &#160; &#160; ((priv)-&gt;membase + OFFSET_MB_OBJ + ((channel) &lt;&lt; 5))
</I>&gt;&gt;<i> +#define can_mask_membase(priv, channel) &#160;\
</I>&gt;&gt;<i> + &#160; &#160; ((priv)-&gt;membase + OFFSET_MB_MASK + ((channel) &lt;&lt; 3))
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/*
</I>&gt;&gt;<i> + * read/write CAN registers and messages
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +#define CAN_WRITE_REG(val, addr) \
</I>&gt;&gt;<i> + &#160; &#160; writew((val), (u16 *)(addr))
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CAN_READ_REG(addr) \
</I>&gt;&gt;<i> + &#160; &#160; readw((u16 *)(addr))
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CAN_WRITE_CTRL(priv, off, val) \
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_REG(val, can_membase((priv)) + (off))
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CAN_READ_CTRL(priv, off) \
</I>&gt;&gt;<i> + &#160; &#160; CAN_READ_REG(can_membase((priv)) + (off))
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CAN_WRITE_AML(priv, channel, aml) \
</I>&gt;&gt;<i> + &#160; &#160; (CAN_WRITE_REG((aml), can_mask_membase(priv, channel) + OFFSET_MASK_AML))
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CAN_WRITE_AMH(priv, channel, amh) \
</I>&gt;&gt;<i> + &#160; &#160; (CAN_WRITE_REG((amh), can_mask_membase(priv, channel) + OFFSET_MASK_AMH))
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CAN_WRITE_DLC(priv, channel, length) \
</I>&gt;&gt;<i> + &#160; &#160; (CAN_WRITE_REG((length), can_channel_membase(priv, channel) + OFFSET_OBJ_DLC))
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CAN_READ_DLC(priv, channel) \
</I>&gt;&gt;<i> + &#160; &#160; (CAN_READ_REG(can_channel_membase((priv), (channel)) + OFFSET_OBJ_DLC))
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CAN_READ_OID(priv, channel) \
</I>&gt;&gt;<i> + &#160; &#160; ((CAN_READ_REG(can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID1) &amp; 0x1ffc) &gt;&gt; 2)
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CAN_READ_XOID(priv, channel) \
</I>&gt;&gt;<i> + &#160; &#160; (((CAN_READ_REG(can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID1) &amp; 0x1fff) &lt;&lt; 16) \
</I>&gt;&gt;<i> + &#160; &#160; &#160;+ ((CAN_READ_REG(can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID0))))
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CAN_READ_ID1(priv, channel) \
</I>&gt;&gt;<i> + &#160; &#160; (CAN_READ_REG(can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID1))
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CAN_WRITE_ID0(priv, channel, val) \
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_REG((val), can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID0)
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CAN_WRITE_OID(priv, channel, id) \
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_REG(((id) &lt;&lt; 2) | AME, can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID1)
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CAN_WRITE_XOID(priv, channel, id) &#160;\
</I>&gt;&gt;<i> + &#160; &#160; do { \
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_REG((id), can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID0); \
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_REG((((id) &amp; 0x1FFF0000) &gt;&gt; 16) + IDE + AME, \
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID1); \
</I>&gt;&gt;<i> + &#160; &#160; } while (0)
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CAN_WRITE_OID_RTR(priv, channel, id) \
</I>&gt;&gt;<i> + &#160; &#160; CAN_WRITE_REG(((id) &lt;&lt; 2) | RTR | AME, can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID1)
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CAN_WRITE_XOID_RTR(priv, channel, id) &#160;\
</I>&gt;&gt;<i> + &#160; &#160; do { \
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_REG((id), can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID0); \
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_REG((((id) &amp; 0x1FFF0000) &gt;&gt; 16) + IDE + RTR + AME, \
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID1); \
</I>&gt;&gt;<i> + &#160; &#160; } while (0)
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +inline void BFIN_CAN_WRITE_MSG(struct bfin_can_priv *priv, int channel, u8 *data, int dlc)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; int i;
</I>&gt;&gt;<i> + &#160; &#160; u16 val;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; for (i = 0; i &lt; 8; i += 2) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; val = ((7 - i) &lt; dlc ? (data[7 - i]) : 0) +
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ((6 - i) &lt; dlc ? (data[6 - i] &lt;&lt; 8) : 0);
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; CAN_WRITE_REG(val, can_channel_membase((priv), (channel)) + OFFSET_OBJ_DATA + (i &lt;&lt; 1));
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +inline void BFIN_CAN_READ_MSG(struct bfin_can_priv *priv, int channel, u8 *data, int dlc)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> + &#160; &#160; int i;
</I>&gt;&gt;<i> + &#160; &#160; u16 val;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> + &#160; &#160; for (i = 0; i &lt; 8; i += 2) {
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; val = CAN_READ_REG(can_channel_membase((priv), (channel)) + OFFSET_OBJ_DATA + (i &lt;&lt; 1));
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; data[7 - i] = (7 - i) &lt; dlc ? val : 0;
</I>&gt;&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; data[6 - i] = (6 - i) &lt; dlc ? (val &gt;&gt; 8) : 0;
</I>&gt;&gt;<i> + &#160; &#160; }
</I>&gt;&gt;<i> +}
</I>&gt;<i>
</I>&gt;<i> See my general comments about using marco definition functions. The last
</I>&gt;<i> two functions are definetely too large to be inlined. Also please use
</I>&gt;<i> &quot;static inline ...&quot;.
</I>&gt;<i>
</I>&gt;<i> Thanks for your contribution.
</I>&gt;<i>
</I>&gt;<i> Wolfgang.
</I>&gt;<i>
</I>&gt;<i>
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003611.html">r1095 autotools patch
</A></li>
	<LI>Next message: <A HREF="003614.html">[PATCH] add the driver for Analog Devices Blackfin on-chip CAN	controllers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3613">[ date ]</a>
              <a href="thread.html#3613">[ thread ]</a>
              <a href="subject.html#3613">[ subject ]</a>
              <a href="author.html#3613">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
