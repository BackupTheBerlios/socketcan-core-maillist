<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH] add the driver for Analog Devices Blackfin on-chip CAN	controllers
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-November/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20add%20the%20driver%20for%20Analog%20Devices%20Blackfin%20on-chip%20CAN%0A%09controllers&In-Reply-To=%3C4AF905B8.6040104%40ems-wuensche.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003425.html">
   <LINK REL="Next"  HREF="003427.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH] add the driver for Analog Devices Blackfin on-chip CAN	controllers</H1>
    <B>Sebastian Haas</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20add%20the%20driver%20for%20Analog%20Devices%20Blackfin%20on-chip%20CAN%0A%09controllers&In-Reply-To=%3C4AF905B8.6040104%40ems-wuensche.com%3E"
       TITLE="[PATCH] add the driver for Analog Devices Blackfin on-chip CAN	controllers">haas at ems-wuensche.com
       </A><BR>
    <I>Tue Nov 10 07:18:32 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003425.html">[PATCH] add the driver for Analog Devices Blackfin on-chip CAN	controllers
</A></li>
        <LI>Next message: <A HREF="003427.html">[PATCH] add the driver for Analog Devices Blackfin on-chip CAN 	controllers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3426">[ date ]</a>
              <a href="thread.html#3426">[ thread ]</a>
              <a href="subject.html#3426">[ subject ]</a>
              <a href="author.html#3426">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Barry,

I'm sure Wolfgang will do a review, but let me also put some notes to 
your patch.

2 things right at the beginning. Please remove the debug outputs (e.g. 
entering specific functions). I would also recommend to put the contents 
of bfin-can.h into the bfin-can.c. You should rename bfin-can.c to 
bfin_can.c to match your drivers' name and the naming scheme of the 
other SocketCAN drivers.

I found a lot of comments like:
/*
  * ...
  */
Please convert to /* ... */ where possible, these should save some lines.

Please have a look at the other drivers how they handle register access. 
You hide a lot of access logic within macros.

Sebastian

Barry Song schrieb:
&gt;<i> Signed-off-by: Barry Song &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">21cnbao at gmail.com</A>&gt;
</I>&gt;<i> Signed-off-by: Heinz-J&#195;&#338;rgen Oertel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">oe at port.de</A>&gt;
</I>&gt;<i> ---
</I>&gt;<i>  drivers/net/can/Kconfig    |   10 +
</I>&gt;<i>  drivers/net/can/Makefile   |    1 +
</I>&gt;<i>  drivers/net/can/bfin-can.c |  674 ++++++++++++++++++++++++++++++++++++++++++++
</I>&gt;<i>  drivers/net/can/bfin-can.h |  162 +++++++++++
</I>&gt;<i>  4 files changed, 847 insertions(+), 0 deletions(-)
</I>&gt;<i>  create mode 100644 drivers/net/can/bfin-can.c
</I>&gt;<i>  create mode 100644 drivers/net/can/bfin-can.h
</I>&gt;<i> 
</I>&gt;<i> diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
</I>&gt;<i> index df32c10..be305c5 100644
</I>&gt;<i> --- a/drivers/net/can/Kconfig
</I>&gt;<i> +++ b/drivers/net/can/Kconfig
</I>&gt;<i> @@ -95,6 +95,16 @@ config CAN_AT91
</I>&gt;<i>  	---help---
</I>&gt;<i>  	  This is a driver for the SoC CAN controller in Atmel's AT91SAM9263.
</I>&gt;<i>  
</I>&gt;<i> +config CAN_BFIN
</I>&gt;<i> +	depends on CAN_DEV &amp;&amp; (BF534 || BF536 || BF537 || BF538 || BF539 || BF54x)
</I>&gt;<i> +	tristate &quot;Analog Devices Blackfin on-chip CAN&quot;
</I>&gt;<i> +	---help---
</I>&gt;<i> +	  Driver for the Analog Devices Blackfin on-chip CAN controllers
</I>&gt;<i> +
</I>&gt;<i> +	  To compile this driver as a module, choose M here: the
</I>&gt;<i> +	  module will be called bfin-can.
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i>  config CAN_DEBUG_DEVICES
</I>&gt;<i>  	bool &quot;CAN devices debugging messages&quot;
</I>&gt;<i>  	depends on CAN
</I>&gt;<i> diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
</I>&gt;<i> index 0dea627..72618b0 100644
</I>&gt;<i> --- a/drivers/net/can/Makefile
</I>&gt;<i> +++ b/drivers/net/can/Makefile
</I>&gt;<i> @@ -11,5 +11,6 @@ obj-y				+= usb/
</I>&gt;<i>  
</I>&gt;<i>  obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
</I>&gt;<i>  obj-$(CONFIG_CAN_AT91)		+= at91_can.o
</I>&gt;<i> +obj-$(CONFIG_CAN_BFIN)	        += bfin-can.o
</I>&gt;<i>  
</I>&gt;<i>  ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
</I>&gt;<i> diff --git a/drivers/net/can/bfin-can.c b/drivers/net/can/bfin-can.c
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..c2ad42e
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/bfin-can.c
</I>&gt;<i> @@ -0,0 +1,674 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * Blackfin On-Chip CAN Driver
</I>&gt;<i> + *
</I>&gt;<i> + * Copyright 2004-2009 Analog Devices Inc.
</I>&gt;<i> + *
</I>&gt;<i> + * Enter bugs at <A HREF="http://blackfin.uclinux.org/">http://blackfin.uclinux.org/</A>
</I>&gt;<i> + *
</I>&gt;<i> + * Licensed under the GPL-2 or later.
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/module.h&gt;
</I>&gt;<i> +#include &lt;linux/init.h&gt;
</I>&gt;<i> +#include &lt;linux/kernel.h&gt;
</I>&gt;<i> +#include &lt;linux/types.h&gt;
</I>&gt;<i> +#include &lt;linux/interrupt.h&gt;
</I>&gt;<i> +#include &lt;linux/errno.h&gt;
</I>&gt;<i> +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> +#include &lt;linux/skbuff.h&gt;
</I>&gt;<i> +#include &lt;linux/platform_device.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/can.h&gt;
</I>&gt;<i> +#include &lt;linux/can/dev.h&gt;
</I>&gt;<i> +#include &lt;linux/can/error.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;asm/portmux.h&gt;
</I>&gt;<i> +#include &quot;bfin-can.h&quot;
</I>&gt;<i> +
</I>&gt;<i> +#define DRV_NAME &quot;bfin_can&quot;
</I>&gt;<i> +
</I>&gt;<i> +static struct can_bittiming_const bfin_can_bittiming_const = {
</I>&gt;<i> +	.name = DRV_NAME,
</I>&gt;<i> +	.tseg1_min = 1,
</I>&gt;<i> +	.tseg1_max = 16,
</I>&gt;<i> +	.tseg2_min = 1,
</I>&gt;<i> +	.tseg2_max = 8,
</I>&gt;<i> +	.sjw_max = 4,
</I>&gt;<i> +	/* Although the BRP field can be set to any value, it is recommended
</I>&gt;<i> +	 * that the value be greater than or equal to 4, as restrictions
</I>&gt;<i> +	 * apply to the bit timing configuration when BRP is less than 4.
</I>&gt;<i> +	 */
</I>&gt;<i> +	.brp_min = 4,
</I>&gt;<i> +	.brp_max = 1024,
</I>&gt;<i> +	.brp_inc = 1,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int bfin_can_set_bittiming(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> +	u16 clk, timing;
</I>&gt;<i> +
</I>&gt;<i> +	clk = bt-&gt;brp - 1;
</I>&gt;<i> +	timing = ((bt-&gt;sjw - 1) &lt;&lt; 8) | (bt-&gt;prop_seg + bt-&gt;phase_seg1 - 1) |
</I>&gt;<i> +		((bt-&gt;phase_seg2 - 1) &lt;&lt; 4);
</I>&gt;<i> +
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * If the SAM bit is set, the input signal is oversampled three times at the SCLK rate.
</I>&gt;<i> +	 */
</I>&gt;<i> +	if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES)
</I>&gt;<i> +		timing |= SAM;
</I>&gt;<i> +
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_CLOCK, clk);
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_TIMING, timing);
</I>&gt;<i> +
</I>&gt;<i> +	dev_info(dev-&gt;dev.parent,
</I>&gt;<i> +			&quot;setting can bitrate:%d brp:%d prop_seg:%d phase_seg1:%d phase_seg2:%d\n&quot;,
</I>&gt;<i> +			bt-&gt;bitrate, bt-&gt;brp, bt-&gt;prop_seg, bt-&gt;phase_seg1, bt-&gt;phase_seg2);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void bfin_can_set_reset_mode(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	int i;
</I>&gt;<i> +
</I>&gt;<i> +	dev_dbg(dev-&gt;dev.parent, &quot;%s enter\n&quot;, __func__);
</I>&gt;<i> +
</I>&gt;<i> +	/* disable interrupts */
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_MBIM1, 0);
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_MBIM2, 0);
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_GIM, 0);
</I>&gt;<i> +
</I>&gt;<i> +	/* reset can and enter configuration mode */
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_CONTROL, SRS | CCR);
</I>&gt;<i> +	SSYNC();
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_CONTROL, CCR);
</I>&gt;<i> +	SSYNC();
</I>&gt;<i> +	while (!(CAN_READ_CTRL(priv, OFFSET_CONTROL) &amp; CCA))
</I>&gt;<i> +		continue;
</I>&gt;<i> +
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * All mailbox configurations are marked as inactive
</I>&gt;<i> +	 * by writing to CAN Mailbox Configuration Registers 1 and 2
</I>&gt;<i> +	 * For all bits: 0 - Mailbox disabled, 1 - Mailbox enabled
</I>&gt;<i> +	 */
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_MC1, 0);
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_MC2, 0);
</I>&gt;<i> +
</I>&gt;<i> +	/* Set Mailbox Direction */
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_MD1, 0xFFFF);  /* mailbox 1-16 are RX */
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_MD2, 0);       /* mailbox 17-32 are TX */
</I>&gt;<i> +
</I>&gt;<i> +	/* RECEIVE_STD_CHL */
</I>&gt;<i> +	for (i = 0; i &lt; 2; i++) {
</I>&gt;<i> +		CAN_WRITE_OID(priv, RECEIVE_STD_CHL + i, 0);
</I>&gt;<i> +		CAN_WRITE_ID0(priv, RECEIVE_STD_CHL, 0);
</I>&gt;<i> +		CAN_WRITE_DLC(priv, RECEIVE_STD_CHL + i, 0);
</I>&gt;<i> +		CAN_WRITE_AMH(priv, RECEIVE_STD_CHL + i, 0x1FFF);
</I>&gt;<i> +		CAN_WRITE_AML(priv, RECEIVE_STD_CHL + i, 0xFFFF);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* RECEIVE_EXT_CHL */
</I>&gt;<i> +	for (i = 0; i &lt; 2; i++) {
</I>&gt;<i> +		CAN_WRITE_XOID(priv, RECEIVE_EXT_CHL + i, 0);
</I>&gt;<i> +		CAN_WRITE_DLC(priv, RECEIVE_EXT_CHL + i, 0);
</I>&gt;<i> +		CAN_WRITE_AMH(priv, RECEIVE_EXT_CHL + i, 0x1FFF);
</I>&gt;<i> +		CAN_WRITE_AML(priv, RECEIVE_EXT_CHL + i, 0xFFFF);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_MC2, 1 &lt;&lt; (TRANSMIT_CHL - 16));
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_MC1, (1 &lt;&lt; RECEIVE_STD_CHL) + (1 &lt;&lt; RECEIVE_EXT_CHL));
</I>&gt;<i> +	SSYNC();
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void bfin_can_set_normal_mode(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> +
</I>&gt;<i> +	dev_dbg(dev-&gt;dev.parent, &quot;%s enter\n&quot;, __func__);
</I>&gt;<i> +
</I>&gt;<i> +	/* leave configuration mode */
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_CONTROL, CAN_READ_CTRL(priv, OFFSET_CONTROL) &amp; ~CCR);
</I>&gt;<i> +	while (CAN_READ_CTRL(priv, OFFSET_STATUS) &amp; CCA)
</I>&gt;<i> +		continue;
</I>&gt;<i> +
</I>&gt;<i> +	/* clear _All_  tx and rx interrupts */
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_MBTIF1, 0xFFFF);
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_MBTIF2, 0xFFFF);
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_MBRIF1, 0xFFFF);
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_MBRIF2, 0xFFFF);
</I>&gt;<i> +	/* clear global interrupt status register */
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_GIS, 0x7FF); /* overwrites with '1' */
</I>&gt;<i> +
</I>&gt;<i> +	/* Initialize Interrupts
</I>&gt;<i> +	 * - set bits in the mailbox interrupt mask register
</I>&gt;<i> +	 * - global interrupt mask
</I>&gt;<i> +	 */
</I>&gt;<i> +
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_MBIM1, (1 &lt;&lt; RECEIVE_STD_CHL) + (1 &lt;&lt; RECEIVE_EXT_CHL));
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_MBIM2, 1 &lt;&lt; (TRANSMIT_CHL - 16));
</I>&gt;<i> +
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_GIM, EPIM | BOIM | RMLIM);
</I>&gt;<i> +	SSYNC();
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static void bfin_can_start(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> +
</I>&gt;<i> +	dev_dbg(dev-&gt;dev.parent, &quot;%s enter\n&quot;, __func__);
</I>&gt;<i> +
</I>&gt;<i> +	/* leave reset mode */
</I>&gt;<i> +	if (priv-&gt;can.state != CAN_STATE_STOPPED)
</I>&gt;<i> +		bfin_can_set_reset_mode(dev);
</I>&gt;<i> +
</I>&gt;<i> +	/* leave reset mode */
</I>&gt;<i> +	bfin_can_set_normal_mode(dev);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int bfin_can_set_mode(struct net_device *dev, enum can_mode mode)
</I>&gt;<i> +{
</I>&gt;<i> +	dev_dbg(dev-&gt;dev.parent, &quot;%s enter\n&quot;, __func__);
</I>&gt;<i> +
</I>&gt;<i> +	switch (mode) {
</I>&gt;<i> +	case CAN_MODE_START:
</I>&gt;<i> +		bfin_can_start(dev);
</I>&gt;<i> +		if (netif_queue_stopped(dev))
</I>&gt;<i> +			netif_wake_queue(dev);
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	default:
</I>&gt;<i> +		return -EOPNOTSUPP;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * transmit a CAN message
</I>&gt;<i> + * message layout in the sk_buff should be like this:
</I>&gt;<i> + * xx xx xx xx	 ff	 ll   00 11 22 33 44 55 66 77
</I>&gt;<i> + * [  can-id ] [flags] [len] [can data (up to 8 bytes]
</I>&gt;<i> + */
</I>&gt;<i> +static int bfin_can_start_xmit(struct sk_buff *skb, struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> +	uint8_t dlc;
</I>&gt;<i> +	canid_t id;
</I>&gt;<i> +
</I>&gt;<i> +	dev_dbg(dev-&gt;dev.parent, &quot;%s enter\n&quot;, __func__);
</I>&gt;<i> +
</I>&gt;<i> +	netif_stop_queue(dev);
</I>&gt;<i> +
</I>&gt;<i> +	dlc = cf-&gt;can_dlc;
</I>&gt;<i> +	id = cf-&gt;can_id;
</I>&gt;<i> +
</I>&gt;<i> +	/* fill id and data length code */
</I>&gt;<i> +	if (id &amp; CAN_EFF_FLAG) {
</I>&gt;<i> +		if (id &amp; CAN_RTR_FLAG)
</I>&gt;<i> +			CAN_WRITE_XOID_RTR(priv, TRANSMIT_CHL, id);
</I>&gt;<i> +		else
</I>&gt;<i> +			CAN_WRITE_XOID(priv, TRANSMIT_CHL, id);
</I>&gt;<i> +	} else {
</I>&gt;<i> +		if (id &amp; CAN_RTR_FLAG)
</I>&gt;<i> +			CAN_WRITE_OID_RTR(priv, TRANSMIT_CHL, id);
</I>&gt;<i> +		else
</I>&gt;<i> +			CAN_WRITE_OID(priv, TRANSMIT_CHL, id);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	BFIN_CAN_WRITE_MSG(priv, TRANSMIT_CHL, cf-&gt;data, dlc);
</I>That is the only place where you use this inline function, save some 
lines by inlining it explicit and remove the inline function BFIN_...

&gt;<i> +
</I>&gt;<i> +	CAN_WRITE_DLC(priv, TRANSMIT_CHL, dlc);
</I>&gt;<i> +
</I>&gt;<i> +	stats-&gt;tx_bytes += dlc;
</I>&gt;<i> +	dev-&gt;trans_start = jiffies;
</I>&gt;<i> +
</I>&gt;<i> +	can_put_echo_skb(skb, dev, 0);
</I>&gt;<i> +
</I>&gt;<i> +	/* set transmit request */
</I>&gt;<i> +	CAN_WRITE_CTRL(priv, OFFSET_TRS2, 1 &lt;&lt; (TRANSMIT_CHL - 16));
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/* Our watchdog timed out. Called by the up layer */
</I>&gt;<i> +static void bfin_can_timeout(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	dev_dbg(dev-&gt;dev.parent, &quot;%s enter\n&quot;, __func__);
</I>&gt;<i> +
</I>&gt;<i> +	/* We can accept TX packets again */
</I>&gt;<i> +	dev-&gt;trans_start = jiffies;
</I>&gt;<i> +	netif_wake_queue(dev);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void bfin_can_rx(struct net_device *dev, uint16_t isrc)
</I>&gt;<i> +{
</I>&gt;<i> +	struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	canid_t id;
</I>&gt;<i> +	uint8_t dlc;
</I>&gt;<i> +	int obj;
</I>&gt;<i> +
</I>&gt;<i> +	dev_dbg(dev-&gt;dev.parent, &quot;%s enter\n&quot;, __func__);
</I>&gt;<i> +
</I>&gt;<i> +	skb = dev_alloc_skb(sizeof(struct can_frame));
</I>Use alloc_can_skb() please.

&gt;<i> +	if (skb == NULL)
</I>&gt;<i> +		return;
</I>
&gt;<i> +	skb-&gt;dev = dev;
</I>&gt;<i> +	skb-&gt;protocol = htons(ETH_P_CAN);
</I>No longer needed when using alloc_can_skb().

&gt;<i> +
</I>&gt;<i> +	/* get id and data length code */
</I>&gt;<i> +	if (isrc &amp; (1 &lt;&lt; RECEIVE_EXT_CHL)) {
</I>&gt;<i> +		/* extended frame format (EFF) */
</I>&gt;<i> +		id = CAN_READ_XOID(priv, RECEIVE_EXT_CHL);
</I>This is the only point where you use this macro, why dont you read 
directly and remove the macro.

&gt;<i> +		id |= CAN_EFF_FLAG;
</I>&gt;<i> +		obj = RECEIVE_EXT_CHL;
</I>&gt;<i> +	} else {
</I>&gt;<i> +		/* standard frame format (SFF) */
</I>&gt;<i> +		id = CAN_READ_OID(priv, RECEIVE_STD_CHL);
</I>Dito.

&gt;<i> +		obj = RECEIVE_STD_CHL;
</I>&gt;<i> +	}
</I>Empty line.

&gt;<i> +	if (CAN_READ_ID1(priv, obj) &amp; RTR)
</I>&gt;<i> +		id |= CAN_RTR_FLAG;
</I>&gt;<i> +	dlc = CAN_READ_DLC(priv, obj);
</I>&gt;<i> +
</I>&gt;<i> +	cf = (struct can_frame *)skb_put(skb, sizeof(*cf));
</I>&gt;<i> +	memset(cf, 0, sizeof(struct can_frame));
</I>Not needed as well.

&gt;<i> +	cf-&gt;can_id = id;
</I>&gt;<i> +	cf-&gt;can_dlc = dlc;
</I>&gt;<i> +
</I>&gt;<i> +	BFIN_CAN_READ_MSG(priv, obj, cf-&gt;data, dlc);
</I>That is the only place where you use this inline function, save some 
lines by inlining it explicit and remove the inline function BFIN_...

&gt;<i> +	netif_rx(skb);
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;last_rx = jiffies;
</I>This is no longer needed as of 2.6.30 I think. See also next function.

&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;<i> +	stats-&gt;rx_bytes += dlc;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int bfin_can_err(struct net_device *dev, uint16_t isrc, uint16_t status)
</I>&gt;<i> +{
</I>&gt;<i> +	struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	enum can_state state = priv-&gt;can.state;
</I>&gt;<i> +
</I>&gt;<i> +	dev_dbg(dev-&gt;dev.parent, &quot;%s enter\n&quot;, __func__);
</I>&gt;<i> +
</I>&gt;<i> +	skb = dev_alloc_skb(sizeof(struct can_frame));
</I>Use alloc_can_err_skb() please.

&gt;<i> +	if (skb == NULL)
</I>&gt;<i> +		return -ENOMEM;
</I>
&gt;<i> +	skb-&gt;dev = dev;
</I>&gt;<i> +	skb-&gt;protocol = htons(ETH_P_CAN);
</I>Done in alloc_can_err_skb().

&gt;<i> +	cf = (struct can_frame *)skb_put(skb, sizeof(*cf));
</I>
&gt;<i> +	memset(cf, 0, sizeof(struct can_frame));
</I>&gt;<i> +	cf-&gt;can_id = CAN_ERR_FLAG;
</I>&gt;<i> +	cf-&gt;can_dlc = CAN_ERR_DLC;
</I>Done in alloc_can_err_skb().

&gt;<i> +	if (isrc &amp; RMLIS) {
</I>&gt;<i> +		/* data overrun interrupt */
</I>&gt;<i> +		dev_dbg(dev-&gt;dev.parent, &quot;data overrun interrupt\n&quot;);
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +		cf-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
</I>&gt;<i> +		stats-&gt;rx_over_errors++;
</I>&gt;<i> +		stats-&gt;rx_errors++;
</I>&gt;<i> +	}
</I>Empty line please.

&gt;<i> +	if (isrc &amp; BOIS) {
</I>&gt;<i> +		dev_dbg(dev-&gt;dev.parent, &quot;bus-off mode interrupt\n&quot;);
</I>&gt;<i> +
</I>&gt;<i> +		state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> +		can_bus_off(dev);
</I>&gt;<i> +	}
</I>Dito.

&gt;<i> +	if (isrc &amp; EPIS) {
</I>&gt;<i> +		/* error passive interrupt */
</I>&gt;<i> +		dev_dbg(dev-&gt;dev.parent, &quot;error passive interrupt\n&quot;);
</I>&gt;<i> +		state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> +	}
</I>Dito.

&gt;<i> +	if ((isrc &amp; EWTIS) || (isrc &amp; EWRIS)) {
</I>&gt;<i> +		dev_dbg(dev-&gt;dev.parent, &quot;Error Warning Transmit/Receive Interrupt\n&quot;);
</I>&gt;<i> +		state = CAN_STATE_ERROR_WARNING;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (state != priv-&gt;can.state &amp;&amp; (state == CAN_STATE_ERROR_WARNING ||
</I>&gt;<i> +				state == CAN_STATE_ERROR_PASSIVE)) {
</I>&gt;<i> +		uint16_t cec = CAN_READ_CTRL(priv, OFFSET_CEC);
</I>&gt;<i> +		uint8_t rxerr = cec;
</I>&gt;<i> +		uint8_t txerr = cec &gt;&gt; 8;
</I>Dito.

&gt;<i> +		cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +		if (state == CAN_STATE_ERROR_WARNING) {
</I>&gt;<i> +			priv-&gt;can.can_stats.error_warning++;
</I>&gt;<i> +			cf-&gt;data[1] = (txerr &gt; rxerr) ?
</I>&gt;<i> +				CAN_ERR_CRTL_TX_WARNING :
</I>&gt;<i> +				CAN_ERR_CRTL_RX_WARNING;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			priv-&gt;can.can_stats.error_passive++;
</I>&gt;<i> +			cf-&gt;data[1] = (txerr &gt; rxerr) ?
</I>&gt;<i> +				CAN_ERR_CRTL_TX_PASSIVE :
</I>&gt;<i> +				CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (status) {
</I>&gt;<i> +		priv-&gt;can.can_stats.bus_error++;
</I>&gt;<i> +
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
</I>&gt;<i> +
</I>&gt;<i> +		if (status &amp; BEF)
</I>&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
</I>&gt;<i> +		else if (status &amp; FER)
</I>&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;<i> +		else if (status &amp; SER)
</I>&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;<i> +		else
</I>&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_UNSPEC;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.state = state;
</I>&gt;<i> +
</I>&gt;<i> +	netif_rx(skb);
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;last_rx = jiffies;
</I>No longer needed.

&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;<i> +	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +irqreturn_t bfin_can_interrupt(int irq, void *dev_id)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *dev = dev_id;
</I>&gt;<i> +	struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> +	uint16_t status, isrc;
</I>&gt;<i> +
</I>&gt;<i> +	dev_dbg(dev-&gt;dev.parent, &quot;%s enter, irq num:%d\n&quot;, __func__, irq);
</I>&gt;<i> +
</I>&gt;<i> +	if ((irq == priv-&gt;tx_irq) &amp;&amp; CAN_READ_CTRL(priv, OFFSET_MBTIF2)) {
</I>Is the additional paranthesis really necessary?

&gt;<i> +		/* transmission complete interrupt */
</I>&gt;<i> +		CAN_WRITE_CTRL(priv, OFFSET_MBTIF2, 0xFFFF);
</I>&gt;<i> +		stats-&gt;tx_packets++;
</I>&gt;<i> +		can_get_echo_skb(dev, 0);
</I>&gt;<i> +		netif_wake_queue(dev);
</I>&gt;<i> +	} else if ((irq == priv-&gt;rx_irq) &amp;&amp; CAN_READ_CTRL(priv, OFFSET_MBRIF1)) {
</I>Dito.

&gt;<i> +		/* receive interrupt */
</I>&gt;<i> +		isrc = CAN_READ_CTRL(priv, OFFSET_MBRIF1);
</I>&gt;<i> +		CAN_WRITE_CTRL(priv, OFFSET_MBRIF1, 0xFFFF);
</I>&gt;<i> +		bfin_can_rx(dev, isrc);
</I>&gt;<i> +	} else if ((irq == priv-&gt;err_irq) &amp;&amp; CAN_READ_CTRL(priv, OFFSET_GIS)) {
</I>Dito.

&gt;<i> +		/* error interrupt */
</I>&gt;<i> +		isrc = CAN_READ_CTRL(priv, OFFSET_GIS);
</I>&gt;<i> +		status = CAN_READ_CTRL(priv, OFFSET_ESR);
</I>&gt;<i> +		CAN_WRITE_CTRL(priv, OFFSET_GIS, 0x7FF);
</I>&gt;<i> +		bfin_can_err(dev, isrc, status);
</I>&gt;<i> +	} else
</I>&gt;<i> +		return IRQ_NONE;
</I>&gt;<i> +
</I>&gt;<i> +	return IRQ_HANDLED;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int bfin_can_open(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	int err;
</I>&gt;<i> +
</I>&gt;<i> +	/* set chip into reset mode */
</I>&gt;<i> +	bfin_can_set_reset_mode(dev);
</I>&gt;<i> +
</I>&gt;<i> +	/* common open */
</I>&gt;<i> +	err = open_candev(dev);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		return err;
</I>&gt;<i> +
</I>&gt;<i> +	/* init and start chi */
</I>&gt;<i> +	bfin_can_start(dev);
</I>&gt;<i> +
</I>&gt;<i> +	netif_start_queue(dev);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int bfin_can_close(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	netif_stop_queue(dev);
</I>&gt;<i> +	bfin_can_set_reset_mode(dev);
</I>&gt;<i> +
</I>&gt;<i> +	close_candev(dev);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +struct net_device *alloc_bfin_candev(void)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *dev;
</I>&gt;<i> +	struct bfin_can_priv *priv;
</I>&gt;<i> +
</I>&gt;<i> +	dev = alloc_candev(sizeof(*priv));
</I>Why not sizeof(struct bfin_can_priv)? Reads better, right?

&gt;<i> +	if (!dev)
</I>&gt;<i> +		return NULL;
</I>&gt;<i> +
</I>&gt;<i> +	priv = netdev_priv(dev);
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;dev = dev;
</I>&gt;<i> +	priv-&gt;can.bittiming_const = &amp;bfin_can_bittiming_const;
</I>&gt;<i> +	priv-&gt;can.do_set_bittiming = bfin_can_set_bittiming;
</I>&gt;<i> +	priv-&gt;can.do_set_mode = bfin_can_set_mode;
</I>&gt;<i> +
</I>&gt;<i> +	return dev;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +void free_bfin_candev(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	free_candev(dev);
</I>&gt;<i> +}
</I>If this is the only thing, this function will ever do remove it and call 
free_candev directly in your code.

&gt;<i> +static const struct net_device_ops bfin_can_netdev_ops = {
</I>&gt;<i> +	.ndo_open               = bfin_can_open,
</I>&gt;<i> +	.ndo_stop               = bfin_can_close,
</I>&gt;<i> +	.ndo_start_xmit         = bfin_can_start_xmit,
</I>&gt;<i> +	.ndo_tx_timeout         = bfin_can_timeout,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +int register_bfin_candev(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	dev-&gt;flags |= IFF_ECHO;	/* we support local echo */
</I>&gt;<i> +	dev-&gt;netdev_ops = &amp;bfin_can_netdev_ops;
</I>&gt;<i> +
</I>&gt;<i> +	bfin_can_set_reset_mode(dev);
</I>&gt;<i> +
</I>&gt;<i> +	return register_candev(dev);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +void unregister_bfin_candev(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	bfin_can_set_reset_mode(dev);
</I>&gt;<i> +	unregister_candev(dev);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int __devinit bfin_can_probe(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	int err;
</I>&gt;<i> +	struct net_device *dev;
</I>&gt;<i> +	struct bfin_can_priv *priv;
</I>&gt;<i> +	struct resource *res_mem, *rx_irq, *tx_irq, *err_irq;
</I>&gt;<i> +	unsigned short *pdata;
</I>&gt;<i> +
</I>&gt;<i> +	pdata = pdev-&gt;dev.platform_data;
</I>&gt;<i> +	if (!pdata) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;No platform data provided!\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto exit;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;<i> +	rx_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
</I>&gt;<i> +	tx_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 1);
</I>&gt;<i> +	err_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 2);
</I>&gt;<i> +	if (!res_mem || !rx_irq || !tx_irq || !err_irq) {
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto exit;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (!request_mem_region(res_mem-&gt;start, resource_size(res_mem),
</I>&gt;<i> +				dev_name(&amp;pdev-&gt;dev))) {
</I>&gt;<i> +		err = -EBUSY;
</I>&gt;<i> +		goto exit;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* request peripheral pins */
</I>&gt;<i> +	err = peripheral_request_list(pdata, dev_name(&amp;pdev-&gt;dev));
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		goto exit_mem_release;
</I>&gt;<i> +
</I>&gt;<i> +	dev = alloc_bfin_candev();
</I>&gt;<i> +	if (!dev) {
</I>&gt;<i> +		err = -ENOMEM;
</I>&gt;<i> +		goto exit_peri_pin_free;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* register interrupt handler */
</I>&gt;<i> +	err = request_irq(rx_irq-&gt;start, &amp;bfin_can_interrupt, 0,
</I>&gt;<i> +			&quot;bfin-can-rx&quot;, (void *)dev);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		goto exit_candev_free;
</I>&gt;<i> +	err = request_irq(tx_irq-&gt;start, &amp;bfin_can_interrupt, 0,
</I>&gt;<i> +			&quot;bfin-can-tx&quot;, (void *)dev);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		goto exit_rx_irq_free;
</I>&gt;<i> +	err = request_irq(err_irq-&gt;start, &amp;bfin_can_interrupt, 0,
</I>&gt;<i> +			&quot;bfin-can-err&quot;, (void *)dev);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		goto exit_tx_irq_free;
</I>&gt;<i> +
</I>&gt;<i> +	priv = netdev_priv(dev);
</I>&gt;<i> +	priv-&gt;membase = res_mem-&gt;start;
</I>&gt;<i> +	priv-&gt;rx_irq = rx_irq-&gt;start;
</I>&gt;<i> +	priv-&gt;tx_irq = tx_irq-&gt;start;
</I>&gt;<i> +	priv-&gt;err_irq = err_irq-&gt;start;
</I>&gt;<i> +	priv-&gt;pin_list = pdata;
</I>&gt;<i> +	priv-&gt;can.clock.freq = get_sclk();
</I>&gt;<i> +
</I>&gt;<i> +	dev_set_drvdata(&amp;pdev-&gt;dev, dev);
</I>&gt;<i> +	SET_NETDEV_DEV(dev, &amp;pdev-&gt;dev);
</I>&gt;<i> +
</I>&gt;<i> +	err = register_bfin_candev(dev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;registering failed (err=%d)\n&quot;, err);
</I>&gt;<i> +		goto exit_err_irq_free;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	dev_info(&amp;pdev-&gt;dev, &quot;%s device registered (reg_base=%p, rx_irq=%d, tx_irq=%d, err_irq=%d, sclk=%d)\n&quot;,
</I>&gt;<i> +			DRV_NAME, (void *)priv-&gt;membase, priv-&gt;rx_irq, priv-&gt;tx_irq, priv-&gt;err_irq,
</I>&gt;<i> +			priv-&gt;can.clock.freq);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +exit_err_irq_free:
</I>&gt;<i> +	free_irq(err_irq-&gt;start, dev);
</I>&gt;<i> +exit_tx_irq_free:
</I>&gt;<i> +	free_irq(tx_irq-&gt;start, dev);
</I>&gt;<i> +exit_rx_irq_free:
</I>&gt;<i> +	free_irq(rx_irq-&gt;start, dev);
</I>&gt;<i> +exit_candev_free:
</I>&gt;<i> +	free_bfin_candev(dev);
</I>&gt;<i> +exit_peri_pin_free:
</I>&gt;<i> +	peripheral_free_list(pdata);
</I>&gt;<i> +exit_mem_release:
</I>&gt;<i> +	release_mem_region(res_mem-&gt;start, resource_size(res_mem));
</I>&gt;<i> +exit:
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int __devexit bfin_can_remove(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *dev = dev_get_drvdata(&amp;pdev-&gt;dev);
</I>&gt;<i> +	struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct resource *res;
</I>&gt;<i> +
</I>&gt;<i> +	unregister_bfin_candev(dev);
</I>&gt;<i> +	dev_set_drvdata(&amp;pdev-&gt;dev, NULL);
</I>&gt;<i> +
</I>&gt;<i> +	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;<i> +	release_mem_region(res-&gt;start, resource_size(res));
</I>&gt;<i> +
</I>&gt;<i> +	free_irq(priv-&gt;rx_irq, dev);
</I>&gt;<i> +	free_irq(priv-&gt;tx_irq, dev);
</I>&gt;<i> +	free_irq(priv-&gt;err_irq, dev);
</I>&gt;<i> +	peripheral_free_list(priv-&gt;pin_list);
</I>&gt;<i> +
</I>&gt;<i> +	free_bfin_candev(dev);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_PM
</I>&gt;<i> +static int bfin_can_suspend(struct platform_device *pdev, pm_message_t mesg)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *dev = dev_get_drvdata(&amp;pdev-&gt;dev);
</I>&gt;<i> +	struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> +
</I>&gt;<i> +	if (netif_running(dev)) {
</I>&gt;<i> +		/* enter sleep mode */
</I>&gt;<i> +		CAN_WRITE_CTRL(priv, OFFSET_CONTROL,
</I>&gt;<i> +			CAN_READ_CTRL(priv, OFFSET_CONTROL) | SMR);
</I>&gt;<i> +		SSYNC();
</I>&gt;<i> +		while (!(CAN_READ_CTRL(priv, OFFSET_INTR) &amp; SMACK))
</I>&gt;<i> +			continue;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int bfin_can_resume(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *dev = dev_get_drvdata(&amp;pdev-&gt;dev);
</I>&gt;<i> +	struct bfin_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> +
</I>&gt;<i> +	if (netif_running(dev)) {
</I>&gt;<i> +		/* leave sleep mode */
</I>&gt;<i> +		CAN_WRITE_CTRL(priv, OFFSET_INTR, 0);
</I>&gt;<i> +		SSYNC();
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +#else
</I>&gt;<i> +#define bfin_can_suspend NULL
</I>&gt;<i> +#define bfin_can_resume NULL
</I>&gt;<i> +#endif	/* CONFIG_PM */
</I>&gt;<i> +
</I>&gt;<i> +static struct platform_driver bfin_can_driver = {
</I>&gt;<i> +	.probe = bfin_can_probe,
</I>&gt;<i> +	.remove = __devexit_p(bfin_can_remove),
</I>&gt;<i> +	.suspend = bfin_can_suspend,
</I>&gt;<i> +	.resume = bfin_can_resume,
</I>&gt;<i> +	.driver = {
</I>&gt;<i> +		.name = DRV_NAME,
</I>&gt;<i> +		.owner = THIS_MODULE,
</I>&gt;<i> +	},
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int __init bfin_can_init(void)
</I>&gt;<i> +{
</I>&gt;<i> +	return platform_driver_register(&amp;bfin_can_driver);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +module_init(bfin_can_init);
</I>&gt;<i> +
</I>&gt;<i> +static void __exit bfin_can_exit(void)
</I>&gt;<i> +{
</I>&gt;<i> +	platform_driver_unregister(&amp;bfin_can_driver);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +module_exit(bfin_can_exit);
</I>&gt;<i> +
</I>&gt;<i> +MODULE_AUTHOR(&quot;Barry Song &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">21cnbao at gmail.com</A>&gt;&quot;);
</I>&gt;<i> +MODULE_LICENSE(&quot;GPL&quot;);
</I>&gt;<i> +MODULE_DESCRIPTION(&quot;Blackfin on-chip CAN netdevice driver&quot;);
</I>&gt;<i> +
</I>&gt;<i> diff --git a/drivers/net/can/bfin-can.h b/drivers/net/can/bfin-can.h
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..ec74168
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/bfin-can.h
</I>&gt;<i> @@ -0,0 +1,162 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * Blackfin On-Chip CAN Driver
</I>&gt;<i> + *
</I>&gt;<i> + * Copyright 2004-2009 Analog Devices Inc.
</I>&gt;<i> + *
</I>&gt;<i> + * Enter bugs at <A HREF="http://blackfin.uclinux.org/">http://blackfin.uclinux.org/</A>
</I>&gt;<i> + *
</I>&gt;<i> + * Licensed under the GPL-2 or later.
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#ifndef __BLACKFIN_CAN_H
</I>&gt;<i> +#define __BLACKFIN_CAN_H
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;asm/io.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * bfin can private data
</I>&gt;<i> + */
</I>&gt;<i> +struct bfin_can_priv {
</I>&gt;<i> +	struct can_priv can;	/* must be the first member */
</I>&gt;<i> +	struct sk_buff *echo_skb;
</I>&gt;<i> +	struct net_device *dev;
</I>&gt;<i> +	u32 membase;
</I>I would convert it to &quot;u16 *&quot; and remove the whole CAN_READ/WRITE_REG stuff.

&gt;<i> +	int rx_irq;
</I>&gt;<i> +	int tx_irq;
</I>&gt;<i> +	int err_irq;
</I>&gt;<i> +	unsigned short *pin_list;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * registers offset
</I>&gt;<i> + */
</I>&gt;<i> +#define OFFSET_MB_MASK              0x100
</I>&gt;<i> +#define OFFSET_MASK_AML             0x0
</I>&gt;<i> +#define OFFSET_MASK_AMH             0x4
</I>&gt;<i> +#define OFFSET_MB_OBJ               0x200
</I>&gt;<i> +#define OFFSET_OBJ_DATA             0x0
</I>&gt;<i> +#define OFFSET_OBJ_DLC              0x10
</I>&gt;<i> +#define OFFSET_OBJ_ID0              0x18
</I>&gt;<i> +#define OFFSET_OBJ_ID1              0x1C
</I>&gt;<i> +#define OFFSET_CLOCK                0x80
</I>&gt;<i> +#define OFFSET_TIMING               0x84
</I>&gt;<i> +#define OFFSET_STATUS               0x8C
</I>&gt;<i> +#define OFFSET_CEC                  0x90
</I>&gt;<i> +#define OFFSET_GIS                  0x94
</I>&gt;<i> +#define OFFSET_GIM                  0x98
</I>&gt;<i> +#define OFFSET_CONTROL              0xA0
</I>&gt;<i> +#define OFFSET_INTR                 0xA4
</I>&gt;<i> +#define OFFSET_ESR                  0xB4
</I>&gt;<i> +#define OFFSET_MBIM1                0x28
</I>&gt;<i> +#define OFFSET_MBIM2                0x68
</I>&gt;<i> +#define OFFSET_MC1                  0x0
</I>&gt;<i> +#define OFFSET_MC2                  0x40
</I>&gt;<i> +#define OFFSET_MD1                  0x4
</I>&gt;<i> +#define OFFSET_MD2                  0x44
</I>&gt;<i> +#define OFFSET_TRS2                 0x48
</I>&gt;<i> +#define OFFSET_MBTIF1               0x20
</I>&gt;<i> +#define OFFSET_MBTIF2               0x60
</I>&gt;<i> +#define OFFSET_MBRIF1               0x24
</I>&gt;<i> +#define OFFSET_MBRIF2               0x64
</I>&gt;<i> +
</I>&gt;<i> +#define can_membase(priv)  \
</I>&gt;<i> +	((priv)-&gt;membase)
</I>&gt;<i> +#define can_channel_membase(priv, channel) \
</I>&gt;<i> +	((priv)-&gt;membase + OFFSET_MB_OBJ + ((channel) &lt;&lt; 5))
</I>&gt;<i> +#define can_mask_membase(priv, channel)  \
</I>&gt;<i> +	((priv)-&gt;membase + OFFSET_MB_MASK + ((channel) &lt;&lt; 3))
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * read/write CAN registers and messages
</I>&gt;<i> + */
</I>&gt;<i> +#define CAN_WRITE_REG(val, addr) \
</I>&gt;<i> +	writew((val), (u16 *)(addr))
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_READ_REG(addr) \
</I>&gt;<i> +	readw((u16 *)(addr))
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_WRITE_CTRL(priv, off, val) \
</I>&gt;<i> +	CAN_WRITE_REG(val, can_membase((priv)) + (off))
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_READ_CTRL(priv, off) \
</I>&gt;<i> +	CAN_READ_REG(can_membase((priv)) + (off))
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_WRITE_AML(priv, channel, aml) \
</I>&gt;<i> +	(CAN_WRITE_REG((aml), can_mask_membase(priv, channel) + OFFSET_MASK_AML))
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_WRITE_AMH(priv, channel, amh) \
</I>&gt;<i> +	(CAN_WRITE_REG((amh), can_mask_membase(priv, channel) + OFFSET_MASK_AMH))
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_WRITE_DLC(priv, channel, length) \
</I>&gt;<i> +	(CAN_WRITE_REG((length), can_channel_membase(priv, channel) + OFFSET_OBJ_DLC))
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_READ_DLC(priv, channel) \
</I>&gt;<i> +	(CAN_READ_REG(can_channel_membase((priv), (channel)) + OFFSET_OBJ_DLC))
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_READ_OID(priv, channel) \
</I>&gt;<i> +	((CAN_READ_REG(can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID1) &amp; 0x1ffc) &gt;&gt; 2)
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_READ_XOID(priv, channel) \
</I>&gt;<i> +	(((CAN_READ_REG(can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID1) &amp; 0x1fff) &lt;&lt; 16) \
</I>&gt;<i> +	 + ((CAN_READ_REG(can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID0))))
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_READ_ID1(priv, channel) \
</I>&gt;<i> +	(CAN_READ_REG(can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID1))
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_WRITE_ID0(priv, channel, val) \
</I>&gt;<i> +	CAN_WRITE_REG((val), can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID0)
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_WRITE_OID(priv, channel, id) \
</I>&gt;<i> +	CAN_WRITE_REG(((id) &lt;&lt; 2) | AME, can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID1)
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_WRITE_XOID(priv, channel, id)  \
</I>&gt;<i> +	do { \
</I>&gt;<i> +		CAN_WRITE_REG((id), can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID0); \
</I>&gt;<i> +		CAN_WRITE_REG((((id) &amp; 0x1FFF0000) &gt;&gt; 16) + IDE + AME, \
</I>&gt;<i> +				can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID1); \
</I>&gt;<i> +	} while (0)
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_WRITE_OID_RTR(priv, channel, id) \
</I>&gt;<i> +	CAN_WRITE_REG(((id) &lt;&lt; 2) | RTR | AME, can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID1)
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_WRITE_XOID_RTR(priv, channel, id)  \
</I>&gt;<i> +	do { \
</I>&gt;<i> +		CAN_WRITE_REG((id), can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID0); \
</I>&gt;<i> +		CAN_WRITE_REG((((id) &amp; 0x1FFF0000) &gt;&gt; 16) + IDE + RTR + AME, \
</I>&gt;<i> +				can_channel_membase((priv), (channel)) + OFFSET_OBJ_ID1); \
</I>&gt;<i> +	} while (0)
</I>&gt;<i> +
</I>
Function are lower case.
&gt;<i> +inline void BFIN_CAN_WRITE_MSG(struct bfin_can_priv *priv, int channel, u8 *data, int dlc)
</I>&gt;<i> +{
</I>&gt;<i> +	int i;
</I>&gt;<i> +	u16 val;
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; 8; i += 2) {
</I>&gt;<i> +		val = ((7 - i) &lt; dlc ? (data[7 - i]) : 0) +
</I>&gt;<i> +			((6 - i) &lt; dlc ? (data[6 - i] &lt;&lt; 8) : 0);
</I>&gt;<i> +		CAN_WRITE_REG(val, can_channel_membase((priv), (channel)) + OFFSET_OBJ_DATA + (i &lt;&lt; 1));
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>
Function are lower case.
&gt;<i> +inline void BFIN_CAN_READ_MSG(struct bfin_can_priv *priv, int channel, u8 *data, int dlc)
</I>&gt;<i> +{
</I>&gt;<i> +	int i;
</I>&gt;<i> +	u16 val;
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; 8; i += 2) {
</I>&gt;<i> +		val = CAN_READ_REG(can_channel_membase((priv), (channel)) + OFFSET_OBJ_DATA + (i &lt;&lt; 1));
</I>&gt;<i> +		data[7 - i] = (7 - i) &lt; dlc ? val : 0;
</I>&gt;<i> +		data[6 - i] = (6 - i) &lt; dlc ? (val &gt;&gt; 8) : 0;
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * transmit and receive channels
</I>&gt;<i> + */
</I>&gt;<i> +#define TRANSMIT_CHL		24
</I>&gt;<i> +#define RECEIVE_STD_CHL 	0
</I>&gt;<i> +#define RECEIVE_EXT_CHL 	4
</I>&gt;<i> +#define RECEIVE_RTR_CHL 	8
</I>&gt;<i> +#define RECEIVE_EXT_RTR_CHL 	12
</I>&gt;<i> +
</I>&gt;<i> +#endif 		/* __BLACKFIN_CAN_H */
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Socketcan-core mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">Socketcan-core at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">https://lists.berlios.de/mailman/listinfo/socketcan-core</A>
</I>-- 
EMS Dr. Thomas Wuensche e.K.
Sonnenhang 3
85304 Ilmmuenster
HRA Neuburg a.d. Donau, HR-Nr. 70.106
Phone: +49-8441-490260
Fax  : +49-8441-81860
<A HREF="http://www.ems-wuensche.com">http://www.ems-wuensche.com</A>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003425.html">[PATCH] add the driver for Analog Devices Blackfin on-chip CAN	controllers
</A></li>
	<LI>Next message: <A HREF="003427.html">[PATCH] add the driver for Analog Devices Blackfin on-chip CAN 	controllers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3426">[ date ]</a>
              <a href="thread.html#3426">[ thread ]</a>
              <a href="subject.html#3426">[ subject ]</a>
              <a href="author.html#3426">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
