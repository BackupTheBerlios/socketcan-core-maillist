<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH V3] net-next:can: add TI CAN (HECC) driver
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20V3%5D%20net-next%3Acan%3A%20add%20TI%20CAN%20%28HECC%29%20driver&In-Reply-To=%3C4ABA4020.4090107%40grandegger.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003170.html">
   <LINK REL="Next"  HREF="003173.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH V3] net-next:can: add TI CAN (HECC) driver</H1>
    <B>Wolfgang Grandegger</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20V3%5D%20net-next%3Acan%3A%20add%20TI%20CAN%20%28HECC%29%20driver&In-Reply-To=%3C4ABA4020.4090107%40grandegger.com%3E"
       TITLE="[PATCH V3] net-next:can: add TI CAN (HECC) driver">wg at grandegger.com
       </A><BR>
    <I>Wed Sep 23 17:34:56 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003170.html">[PATCH V3] net-next:can: add TI CAN (HECC) driver
</A></li>
        <LI>Next message: <A HREF="003173.html">[PATCH V3] net-next:can: add TI CAN (HECC) driver
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3171">[ date ]</a>
              <a href="thread.html#3171">[ thread ]</a>
              <a href="subject.html#3171">[ subject ]</a>
              <a href="author.html#3171">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Anant,

here is my quick review.

Anant Gole wrote:
&gt;<i> TI HECC (High End CAN Controller) module is found on many TI devices. It
</I>&gt;<i> has 32 hardware mailboxes with full implemtation of CAN protocol 2.0B
</I>&gt;<i> with bus speeds up to 1Mbps. Specifications of the module are available
</I>&gt;<i> at TI web &lt;<A HREF="http://www.ti.com">http://www.ti.com</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> Signed-off-by: Anant Gole &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">anantgole at ti.com</A>&gt;
</I>&gt;<i> ---
</I>&gt;<i>  drivers/net/can/Kconfig              |    7 +
</I>&gt;<i>  drivers/net/can/Makefile             |    1 +
</I>&gt;<i>  drivers/net/can/ti_hecc.c            | 1002 ++++++++++++++++++++++++++++++++++
</I>&gt;<i>  include/linux/can/platform/ti_hecc.h |   40 ++
</I>&gt;<i>  4 files changed, 1050 insertions(+), 0 deletions(-)
</I>&gt;<i>  create mode 100644 drivers/net/can/ti_hecc.c
</I>&gt;<i>  create mode 100644 include/linux/can/platform/ti_hecc.h
</I>&gt;<i> 
</I>&gt;<i> diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
</I>&gt;<i> index 0900743..77523af 100644
</I>&gt;<i> --- a/drivers/net/can/Kconfig
</I>&gt;<i> +++ b/drivers/net/can/Kconfig
</I>&gt;<i> @@ -82,6 +82,13 @@ config CAN_KVASER_PCI
</I>&gt;<i>  	  This driver is for the the PCIcanx and PCIcan cards (1, 2 or
</I>&gt;<i>  	  4 channel) from Kvaser (<A HREF="http://www.kvaser.com">http://www.kvaser.com</A>).
</I>&gt;<i>  
</I>&gt;<i> +config CAN_TI_HECC
</I>&gt;<i> +	depends on CAN_DEV
</I>&gt;<i> +	tristate &quot;TI High End CAN Controller&quot;
</I>&gt;<i> +	---help---
</I>&gt;<i> +	  Driver for TI HECC (High End CAN Controller) module found on many
</I>&gt;<i> +	  TI devices. The device specifications are available from www.ti.com
</I>&gt;<i> +
</I>&gt;<i>  config CAN_DEBUG_DEVICES
</I>&gt;<i>  	bool &quot;CAN devices debugging messages&quot;
</I>&gt;<i>  	depends on CAN
</I>&gt;<i> diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
</I>&gt;<i> index 523a941..45d42dc 100644
</I>&gt;<i> --- a/drivers/net/can/Makefile
</I>&gt;<i> +++ b/drivers/net/can/Makefile
</I>&gt;<i> @@ -8,5 +8,6 @@ obj-$(CONFIG_CAN_DEV)		+= can-dev.o
</I>&gt;<i>  can-dev-y			:= dev.o
</I>&gt;<i>  
</I>&gt;<i>  obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
</I>&gt;<i> +obj-$(CONFIG_CAN_TI_HECC)	+= ti_hecc.o
</I>
Die Patch will fail because two more drivers have been accepted for
net-next-2.6. They should show up soon.

&gt;<i>  ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
</I>&gt;<i> diff --git a/drivers/net/can/ti_hecc.c b/drivers/net/can/ti_hecc.c
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..0d3cbe1
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/ti_hecc.c
</I>&gt;<i> @@ -0,0 +1,1002 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * TI HECC (CAN) device driver
</I>&gt;<i> + *
</I>&gt;<i> + * This driver supports TI's HECC (High End CAN Controller module) and the
</I>&gt;<i> + * specs for the same is available at &lt;<A HREF="http://www.ti.com">http://www.ti.com</A>&gt;
</I>&gt;<i> + *
</I>&gt;<i> + * Copyright (C) 2009 Texas Instruments Incorporated - <A HREF="http://www.ti.com/">http://www.ti.com/</A>
</I>&gt;<i> + *
</I>&gt;<i> + * This program is free software; you can redistribute it and/or
</I>&gt;<i> + * modify it under the terms of the GNU General Public License as
</I>&gt;<i> + * published by the Free Software Foundation version 2.
</I>&gt;<i> + *
</I>&gt;<i> + * This program is distributed as is WITHOUT ANY WARRANTY of any
</I>&gt;<i> + * kind, whether express or implied; without even the implied warranty
</I>&gt;<i> + * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</I>&gt;<i> + * GNU General Public License for more details.
</I>&gt;<i> + *
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * Your platform definitions should specify module ram offsets and interrupt
</I>&gt;<i> + * number to use as follows:
</I>&gt;<i> + *
</I>&gt;<i> + * static struct ti_hecc_platform_data omap3517_evm_hecc_pdata = {
</I>&gt;<i> + *         .scc_hecc_offset        = 0,
</I>&gt;<i> + *         .scc_ram_offset         = 0x3000,
</I>&gt;<i> + *         .hecc_ram_offset        = 0x3000,
</I>&gt;<i> + *         .mbox_offset            = 0x2000,
</I>&gt;<i> + *         .int_line               = 0,
</I>&gt;<i> + *         .revision               = 1,
</I>&gt;<i> + * };
</I>&gt;<i> + *
</I>&gt;<i> + * Please see include/can/platform/ti_hecc.h for description of above fields
</I>&gt;<i> + *
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/module.h&gt;
</I>&gt;<i> +#include &lt;linux/init.h&gt;
</I>&gt;<i> +#include &lt;linux/kernel.h&gt;
</I>&gt;<i> +#include &lt;linux/sched.h&gt;
</I>&gt;<i> +#include &lt;linux/types.h&gt;
</I>&gt;<i> +#include &lt;linux/fcntl.h&gt;
</I>&gt;<i> +#include &lt;linux/interrupt.h&gt;
</I>&gt;<i> +#include &lt;linux/ptrace.h&gt;
</I>&gt;<i> +#include &lt;linux/string.h&gt;
</I>&gt;<i> +#include &lt;linux/errno.h&gt;
</I>&gt;<i> +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> +#include &lt;linux/if_arp.h&gt;
</I>&gt;<i> +#include &lt;linux/if_ether.h&gt;
</I>&gt;<i> +#include &lt;linux/skbuff.h&gt;
</I>&gt;<i> +#include &lt;linux/delay.h&gt;
</I>&gt;<i> +#include &lt;linux/platform_device.h&gt;
</I>&gt;<i> +#include &lt;linux/clk.h&gt;
</I>&gt;<i> +#include &lt;linux/io.h&gt;
</I>&gt;<i> +#include &lt;linux/debugfs.h&gt;
</I>
Do you still use debugfs? Maybe some more #include's could be removed,
e.g. ptrace.h.

&gt;<i> +#include &lt;linux/can.h&gt;
</I>&gt;<i> +#include &lt;linux/can/dev.h&gt;
</I>&gt;<i> +#include &lt;linux/can/error.h&gt;
</I>&gt;<i> +#include &lt;linux/can/platform/ti_hecc.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#define DRV_NAME &quot;ti_hecc&quot;
</I>&gt;<i> +#define HECC_MODULE_VERSION     &quot;0.4&quot;
</I>&gt;<i> +MODULE_VERSION(HECC_MODULE_VERSION);
</I>&gt;<i> +#define DRV_DESC &quot;TI High End CAN Controller Driver &quot; HECC_MODULE_VERSION
</I>&gt;<i> +
</I>&gt;<i> +/* TX / RX Mailbox Configuration */
</I>&gt;<i> +#define HECC_MAX_MAILBOXES	32	/* hardware mboxes - do not change */
</I>&gt;<i> +#define MAX_TX_PRIO		0x3F	/* hardware value - do not change */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_MAX_TX_MBOX	4
</I>&gt;<i> +#define HECC_MAX_RX_MBOX	(HECC_MAX_MAILBOXES - HECC_MAX_TX_MBOX)
</I>&gt;<i> +
</I>&gt;<i> +#if (HECC_MAX_TX_MBOX &gt; CAN_ECHO_SKB_MAX)
</I>&gt;<i> +#error &quot;HECC: MAX TX mailboxes should be equal or less than CAN_ECHO_SKB_MAX&quot;
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +/* Important Note: TX mailbox configuration
</I>
Please write:

/*
 * Important Note: TX mailbox configuration

&gt;<i> + * TX mailboxes should be restricted to the number of SKB buffers to avoid
</I>&gt;<i> + * maintaining SKB buffers separately. TX mailboxes should be a power of 2
</I>&gt;<i> + * for the mailbox logic to work.  Top mailbox numbers are reserved for RX
</I>&gt;<i> + * and lower mailboxes for TX.
</I>&gt;<i> + *
</I>&gt;<i> + * HECC_MAX_TX_MBOX	HECC_MB_TX_SHIFT
</I>&gt;<i> + * 4 (default)		2
</I>&gt;<i> + * 8			3
</I>&gt;<i> + * 16			4
</I>&gt;<i> + */
</I>&gt;<i> +#define HECC_MB_TX_SHIFT	2 /* as per table above */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_TX_PRIO_SHIFT	(HECC_MB_TX_SHIFT)
</I>&gt;<i> +#define HECC_TX_PRIO_MASK	(0x3f &lt;&lt; HECC_MB_TX_SHIFT)
</I>&gt;<i> +#define HECC_TX_MB_MASK		(HECC_MAX_TX_MBOX - 1)
</I>&gt;<i> +#define HECC_TX_MASK ((HECC_MAX_TX_MBOX - 1) | HECC_TX_PRIO_MASK)
</I>
Would be nice to aligned the line above as well.

&gt;<i> +#define HECC_TX_MBOX_MASK	(~((1 &lt;&lt; HECC_MAX_TX_MBOX) - 1))
</I>&gt;<i> +#define HECC_DEF_NAPI_WEIGHT	HECC_MAX_RX_MBOX
</I>&gt;<i> +
</I>&gt;<i> +/* Important Note: RX mailboxes are further logically split into two - main
</I>&gt;<i> + * and buffer mailboxes. The goal is to get all packets into main mailboxes
</I>&gt;<i> + * as driven by mailbox number and receive priority (higher to lower) and
</I>&gt;<i> + * buffer mailboxes are used to receive pkts while main mailboxes are being
</I>&gt;<i> + * processed. This ensures in-order packet reception.
</I>&gt;<i> + *
</I>&gt;<i> + * Here are the recommended values for buffer mailbox. Note that RX mailboxes
</I>&gt;<i> + * start after TX mailboxes:
</I>&gt;<i> + *
</I>&gt;<i> + * HECC_MAX_RX_MBOX		HECC_RX_BUFFER_MBOX	No of buffer mailboxes
</I>&gt;<i> + * 28				12			8
</I>&gt;<i> + * 16				20			4
</I>&gt;<i> + */
</I>&gt;<i> +#define HECC_RX_BUFFER_MBOX	12 /* as per table above */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_RX_FIRST_MBOX	(HECC_MAX_MAILBOXES - 1)
</I>&gt;<i> +#define HECC_RX_HIGH_MBOX_MASK	(~((1 &lt;&lt; HECC_RX_BUFFER_MBOX) - 1))
</I>&gt;<i> +
</I>&gt;<i> +/* TI HECC module registers */
</I>&gt;<i> +#define HECC_CANME		0x0	/* Mailbox enable */
</I>&gt;<i> +#define HECC_CANMD		0x4	/* Mailbox direction */
</I>&gt;<i> +#define HECC_CANTRS		0x8	/* Transmit request set */
</I>&gt;<i> +#define HECC_CANTRR		0xC	/* Transmit request */
</I>&gt;<i> +#define HECC_CANTA		0x10	/* Transmission acknowledge */
</I>&gt;<i> +#define HECC_CANAA		0x14	/* Abort acknowledge */
</I>&gt;<i> +#define HECC_CANRMP		0x18	/* Receive message pending */
</I>&gt;<i> +#define HECC_CANRML		0x1C	/* Remote message lost */
</I>&gt;<i> +#define HECC_CANRFP		0x20	/* Remote frame pending */
</I>&gt;<i> +#define HECC_CANGAM		0x24	/* SECC only:Global acceptance mask */
</I>&gt;<i> +#define HECC_CANMC		0x28	/* Master control */
</I>&gt;<i> +#define HECC_CANBTC		0x2C	/* Bit timing configuration */
</I>&gt;<i> +#define HECC_CANES		0x30	/* Error and status */
</I>&gt;<i> +#define HECC_CANTEC		0x34	/* Transmit error counter */
</I>&gt;<i> +#define HECC_CANREC		0x38	/* Receive error counter */
</I>&gt;<i> +#define HECC_CANGIF0		0x3C	/* Global interrupt flag 0 */
</I>&gt;<i> +#define HECC_CANGIM		0x40	/* Global interrupt mask */
</I>&gt;<i> +#define HECC_CANGIF1		0x44	/* Global interrupt flag 1 */
</I>&gt;<i> +#define HECC_CANMIM		0x48	/* Mailbox interrupt mask */
</I>&gt;<i> +#define HECC_CANMIL		0x4C	/* Mailbox interrupt level */
</I>&gt;<i> +#define HECC_CANOPC		0x50	/* Overwrite protection control */
</I>&gt;<i> +#define HECC_CANTIOC		0x54	/* Transmit I/O control */
</I>&gt;<i> +#define HECC_CANRIOC		0x58	/* Receive I/O control */
</I>&gt;<i> +#define HECC_CANLNT		0x5C	/* HECC only: Local network time */
</I>&gt;<i> +#define HECC_CANTOC		0x60	/* HECC only: Time-out control */
</I>&gt;<i> +#define HECC_CANTOS		0x64	/* HECC only: Time-out status */
</I>&gt;<i> +#define HECC_CANTIOCE		0x68	/* SCC only:Enhanced TX I/O control */
</I>&gt;<i> +#define HECC_CANRIOCE		0x6C	/* SCC only:Enhanced RX I/O control */
</I>&gt;<i> +
</I>&gt;<i> +/* SCC only:Local acceptance registers */
</I>&gt;<i> +#define HECC_CANLAM0		(priv-&gt;scc_ram_offset + 0x0)
</I>&gt;<i> +#define HECC_CANLAM3		(priv-&gt;scc_ram_offset + 0xC)
</I>&gt;<i> +
</I>&gt;<i> +/* HECC only */
</I>&gt;<i> +#define HECC_CANLAM(mbxno)	(priv-&gt;hecc_ram_offset + ((mbxno) * 4))
</I>&gt;<i> +#define HECC_CANMOTS(mbxno)	(priv-&gt;hecc_ram_offset + ((mbxno) * 4) + 0x80)
</I>&gt;<i> +#define HECC_CANMOTO(mbxno)	(priv-&gt;hecc_ram_offset + ((mbxno) * 4) + 0x100)
</I>&gt;<i> +
</I>&gt;<i> +/* Mailbox registers */
</I>&gt;<i> +#define HECC_CANMID(mbxno)	(priv-&gt;mbox_offset + ((mbxno) * 0x10))
</I>&gt;<i> +#define HECC_CANMCF(mbxno)	(priv-&gt;mbox_offset + ((mbxno) * 0x10) + 0x4)
</I>&gt;<i> +#define HECC_CANMDL(mbxno)	(priv-&gt;mbox_offset + ((mbxno) * 0x10) + 0x8)
</I>&gt;<i> +#define HECC_CANMDH(mbxno)	(priv-&gt;mbox_offset + ((mbxno) * 0x10) + 0xC)
</I>
The above macros require that the name &quot;priv&quot; is declared. They are used
as shown below,

  hecc_write(priv, HECC_CANMDH(mbxno), val);

which is not really transparent. Either add the argument &quot;priv&quot; to the
macro definition, or even better, introduce inline function for
read/write of mailbox registers, e.g. hecc_mbox_read().

&gt;<i> +
</I>&gt;<i> +#define HECC_SET_REG		0xFFFFFFFF
</I>&gt;<i> +#define HECC_CANID_MASK		0x3FF	/* 18 bits mask for extended id's */
</I>&gt;<i> +#define HECC_CCE_WAIT_COUNT     100	/* Wait for ~1 sec for CCE bit */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANMC_SCM		BIT(13)	/* SCC compat mode */
</I>&gt;<i> +#define HECC_CANMC_CCR		BIT(12)	/* Change config request */
</I>&gt;<i> +#define HECC_CANMC_PDR		BIT(11)	/* Local Power down - for sleep mode */
</I>&gt;<i> +#define HECC_CANMC_ABO		BIT(7)	/* Auto Bus On */
</I>&gt;<i> +#define HECC_CANMC_STM		BIT(6)	/* Self test mode - loopback */
</I>&gt;<i> +#define HECC_CANMC_SRES		BIT(5)	/* Software reset */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANTIOC_EN		BIT(3)	/* Enable CAN TX I/O pin */
</I>&gt;<i> +#define HECC_CANRIOC_EN		BIT(3)	/* Enable CAN RX I/O pin */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANMID_IDE		BIT(31)	/* Extended frame format */
</I>&gt;<i> +#define HECC_CANMID_AME		BIT(30)	/* Acceptance mask enable */
</I>&gt;<i> +#define HECC_CANMID_AAM		BIT(29)	/* Auto answer mode */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANES_FE		BIT(24)	/* form error */
</I>&gt;<i> +#define HECC_CANES_BE		BIT(23)	/* bit error */
</I>&gt;<i> +#define HECC_CANES_SA1		BIT(22)	/* stuck at dominant error */
</I>&gt;<i> +#define HECC_CANES_CRCE		BIT(21)	/* CRC error */
</I>&gt;<i> +#define HECC_CANES_SE		BIT(20)	/* stuff bit error */
</I>&gt;<i> +#define HECC_CANES_ACKE		BIT(19)	/* ack error */
</I>&gt;<i> +#define HECC_CANES_BO		BIT(18)	/* Bus off status */
</I>&gt;<i> +#define HECC_CANES_EP		BIT(17)	/* Error passive status */
</I>&gt;<i> +#define HECC_CANES_EW		BIT(16)	/* Error warning status */
</I>&gt;<i> +#define HECC_CANES_SMA		BIT(5)	/* suspend mode ack */
</I>&gt;<i> +#define HECC_CANES_CCE		BIT(4)	/* Change config enabled */
</I>&gt;<i> +#define HECC_CANES_PDA		BIT(3)	/* Power down mode ack */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANBTC_SAM		BIT(7)	/* sample points */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_BUS_ERROR		(HECC_CANES_FE | HECC_CANES_BE |\
</I>&gt;<i> +				HECC_CANES_CRCE | HECC_CANES_SE |\
</I>&gt;<i> +				HECC_CANES_ACKE)
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANMCF_RTR		BIT(4)	/* Remote xmit request */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANGIF_MAIF	BIT(17)	/* Message alarm interrupt */
</I>&gt;<i> +#define HECC_CANGIF_TCOIF	BIT(16) /* Timer counter overflow int */
</I>&gt;<i> +#define HECC_CANGIF_GMIF	BIT(15)	/* Global mailbox interrupt */
</I>&gt;<i> +#define HECC_CANGIF_AAIF	BIT(14)	/* Abort ack interrupt */
</I>&gt;<i> +#define HECC_CANGIF_WDIF	BIT(13)	/* Write denied interrupt */
</I>&gt;<i> +#define HECC_CANGIF_WUIF	BIT(12)	/* Wake up interrupt */
</I>&gt;<i> +#define HECC_CANGIF_RMLIF	BIT(11)	/* Receive message lost interrupt */
</I>&gt;<i> +#define HECC_CANGIF_BOIF	BIT(10)	/* Bus off interrupt */
</I>&gt;<i> +#define HECC_CANGIF_EPIF	BIT(9)	/* Error passive interrupt */
</I>&gt;<i> +#define HECC_CANGIF_WLIF	BIT(8)	/* Warning level interrupt */
</I>&gt;<i> +#define HECC_CANGIF_MBOX_MASK	0x1F	/* Mailbox number mask */
</I>&gt;<i> +#define HECC_CANGIM_I1EN	BIT(1)	/* Int line 1 enable */
</I>&gt;<i> +#define HECC_CANGIM_I0EN	BIT(0)	/* Int line 0 enable */
</I>&gt;<i> +#define HECC_CANGIM_DEF_MASK	0x700	/* only busoff/warning/passive */
</I>&gt;<i> +#define HECC_CANGIM_SIL		BIT(2)	/* system interrupts to int line 1 */
</I>&gt;<i> +
</I>&gt;<i> +/* CAN Bittiming constants as per HECC specs */
</I>&gt;<i> +static struct can_bittiming_const ti_hecc_bittiming_const = {
</I>&gt;<i> +	.name = DRV_NAME,
</I>&gt;<i> +	.tseg1_min = 1,
</I>&gt;<i> +	.tseg1_max = 16,
</I>&gt;<i> +	.tseg2_min = 1,
</I>&gt;<i> +	.tseg2_max = 8,
</I>&gt;<i> +	.sjw_max = 4,
</I>&gt;<i> +	.brp_min = 1,
</I>&gt;<i> +	.brp_max = 256,
</I>&gt;<i> +	.brp_inc = 1,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct ti_hecc_priv {
</I>&gt;<i> +	struct can_priv can;	/* MUST be first member/field */
</I>&gt;<i> +	struct napi_struct napi;
</I>&gt;<i> +	struct net_device *ndev;
</I>&gt;<i> +	struct clk *clk;
</I>&gt;<i> +	void __iomem *base;
</I>&gt;<i> +	u32 scc_ram_offset;
</I>&gt;<i> +	u32 hecc_ram_offset;
</I>&gt;<i> +	u32 mbox_offset;
</I>&gt;<i> +	u32 int_line;
</I>&gt;<i> +	spinlock_t mbox_lock; /* CANME register needs protection */
</I>&gt;<i> +	u32 tx_head;
</I>&gt;<i> +	u32 tx_tail;
</I>&gt;<i> +	u32 rx_next;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static inline int get_tx_head_mb(struct ti_hecc_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	return priv-&gt;tx_head &amp; HECC_TX_MB_MASK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline int get_tx_tail_mb(struct ti_hecc_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	return priv-&gt;tx_tail &amp; HECC_TX_MB_MASK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline int get_tx_head_prio(struct ti_hecc_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	return (priv-&gt;tx_head &gt;&gt; HECC_TX_PRIO_SHIFT) &amp; 0x3F;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline
</I>&gt;<i> +void hecc_write(struct ti_hecc_priv *priv, int reg, u32 val)
</I>&gt;<i> +{
</I>&gt;<i> +	__raw_writel(val, priv-&gt;base + reg);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline u32 hecc_read(struct ti_hecc_priv *priv, int reg)
</I>&gt;<i> +{
</I>&gt;<i> +	return __raw_readl(priv-&gt;base + reg);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline
</I>&gt;<i> +void hecc_set_bit(struct ti_hecc_priv *priv, int reg, unsigned bit)
</I>&gt;<i> +{
</I>&gt;<i> +	hecc_write(priv, reg, (hecc_read(priv, reg) | bit));
</I>&gt;<i> +}
</I>
I would expect the argument bit to be the bit number, but actually it's
a mask which is applied.

&gt;<i> +static inline
</I>&gt;<i> +void hecc_clear_bit(struct ti_hecc_priv *priv, int reg, unsigned bit)
</I>&gt;<i> +{
</I>&gt;<i> +	hecc_write(priv, reg, (hecc_read(priv, reg) &amp; ~bit));
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline
</I>&gt;<i> +u32 hecc_get_bit(struct ti_hecc_priv *priv, int reg, int bit)
</I>

Please use a consistant style for breaking the lines of function
declarations...

&gt;<i> +{
</I>&gt;<i> +	return (hecc_read(priv, reg) &amp; bit) ? 1 : 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_get_state(const struct net_device *ndev,
</I>&gt;<i> +	enum can_state *state)
</I>
... I personally prefer this one.

&gt;<i> +{
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	*state = priv-&gt;can.state;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_set_btc(struct ti_hecc_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	struct can_bittiming *bit_timing = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> +	u32 can_btc = 0;
</I>
I think there is no need to pre-set the variable above.

&gt;<i> +
</I>&gt;<i> +	can_btc = ((bit_timing-&gt;phase_seg2 - 1) &amp; 0x7);
</I>&gt;<i> +	can_btc |= (((bit_timing-&gt;phase_seg1 + bit_timing-&gt;prop_seg - 1)
</I>&gt;<i> +			&amp; 0xF) &lt;&lt; 3);
</I>&gt;<i> +	if ((bit_timing-&gt;brp &gt; 4) &amp;&amp;
</I>&gt;<i> +		(priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES))
</I>&gt;<i> +			can_btc |= HECC_CANBTC_SAM;
</I>
It would be nice to print a warning if triple sampling could not be set
due to hardware restrictions.

&gt;<i> +	can_btc |= (((bit_timing-&gt;sjw - 1) &amp; 0x3) &lt;&lt; 8);
</I>&gt;<i> +	can_btc |= (((bit_timing-&gt;brp - 1) &amp; 0xFF) &lt;&lt; 16);
</I>&gt;<i> +
</I>&gt;<i> +	/* ERM being set to 0 by default meaning resync at falling edge */
</I>&gt;<i> +
</I>&gt;<i> +	hecc_write(priv, HECC_CANBTC, can_btc);
</I>&gt;<i> +	dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;setting CANBTC=%#x\n&quot;, can_btc);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void ti_hecc_reset(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 cnt;
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	dev_dbg(ndev-&gt;dev.parent, &quot;resetting hecc ...\n&quot;);
</I>&gt;<i> +	hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_SRES);
</I>&gt;<i> +
</I>&gt;<i> +	/* Set change control request and wait till enabled */
</I>&gt;<i> +	hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
</I>&gt;<i> +
</I>&gt;<i> +	/* INFO: It has been observed that at times CCE bit may not be
</I>&gt;<i> +	 * set and hw seems to be ok even if this bit is not set so
</I>&gt;<i> +	 * timing out with a timing of 1ms to respect the specs
</I>&gt;<i> +	 */
</I>&gt;<i> +	cnt = HECC_CCE_WAIT_COUNT;
</I>&gt;<i> +	while (!hecc_get_bit(priv, HECC_CANES, HECC_CANES_CCE) &amp;&amp; (0 != cnt)) {
</I>&gt;<i> +		--cnt;
</I>&gt;<i> +		udelay(10);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Note: On HECC, BTC can be programmed only in initialization mode, so
</I>&gt;<i> +	 * it is expected that the can bittiming parameters are set via ip
</I>&gt;<i> +	 * utility before the device is opened
</I>&gt;<i> +	 */
</I>&gt;<i> +	ti_hecc_set_btc(priv);
</I>&gt;<i> +
</I>&gt;<i> +	/* Clear CCR (and CANMC register) and wait for CCE = 0 enable */
</I>&gt;<i> +	hecc_write(priv, HECC_CANMC, 0);
</I>&gt;<i> +
</I>&gt;<i> +	/* INFO: CAN net stack handles bus off and hence disabling auto-bus-on
</I>&gt;<i> +	 * hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_ABO);
</I>&gt;<i> +	 */
</I>&gt;<i> +
</I>&gt;<i> +	/* INFO: It has been observed that at times CCE bit may not be
</I>&gt;<i> +	 * set and hw seems to be ok even if this bit is not set so
</I>&gt;<i> +	 */
</I>&gt;<i> +	cnt = HECC_CCE_WAIT_COUNT;
</I>&gt;<i> +	while (hecc_get_bit(priv, HECC_CANES, HECC_CANES_CCE) &amp;&amp; (0 != cnt)) {
</I>&gt;<i> +		--cnt;
</I>&gt;<i> +		udelay(10);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Enable TX and RX I/O Control pins */
</I>&gt;<i> +	hecc_write(priv, HECC_CANTIOC, HECC_CANTIOC_EN);
</I>&gt;<i> +	hecc_write(priv, HECC_CANRIOC, HECC_CANRIOC_EN);
</I>&gt;<i> +
</I>&gt;<i> +	/* Clear registers for clean operation */
</I>&gt;<i> +	hecc_write(priv, HECC_CANTA, HECC_SET_REG);
</I>&gt;<i> +	hecc_write(priv, HECC_CANRMP, HECC_SET_REG);
</I>&gt;<i> +	hecc_write(priv, HECC_CANGIF0, HECC_SET_REG);
</I>&gt;<i> +	hecc_write(priv, HECC_CANGIF1, HECC_SET_REG);
</I>&gt;<i> +	hecc_write(priv, HECC_CANME, 0);
</I>&gt;<i> +	hecc_write(priv, HECC_CANMD, 0);
</I>&gt;<i> +
</I>&gt;<i> +	/* SCC compat mode NOT supported (and not needed too) */
</I>&gt;<i> +	hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_SCM);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void ti_hecc_start(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	int cnt, mbxno;
</I>&gt;<i> +
</I>&gt;<i> +	/* put HECC in initialization mode and set btc */
</I>&gt;<i> +	ti_hecc_reset(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;tx_head = priv-&gt;tx_tail = HECC_TX_MASK;
</I>&gt;<i> +	priv-&gt;rx_next = HECC_RX_FIRST_MBOX;
</I>&gt;<i> +
</I>&gt;<i> +	/* Enable local and global acceptance mask registers */
</I>&gt;<i> +	hecc_write(priv, HECC_CANGAM, HECC_SET_REG);
</I>&gt;<i> +	hecc_write(priv, HECC_CANLAM0, HECC_SET_REG);
</I>&gt;<i> +	hecc_write(priv, HECC_CANLAM3, HECC_SET_REG);
</I>&gt;<i> +
</I>&gt;<i> +	/* Prepare configured mailboxes to receive messages */
</I>&gt;<i> +	for (cnt = 0; cnt &lt; HECC_MAX_RX_MBOX; cnt++) {
</I>&gt;<i> +		mbxno = (HECC_MAX_MAILBOXES - 1 - cnt);
</I>&gt;<i> +		hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +		hecc_write(priv, HECC_CANMID(mbxno), HECC_CANMID_AME);
</I>&gt;<i> +		hecc_write(priv, HECC_CANLAM(mbxno), HECC_SET_REG);
</I>&gt;<i> +		hecc_set_bit(priv, HECC_CANMD, (1 &lt;&lt; mbxno));
</I>&gt;<i> +		hecc_set_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +		hecc_set_bit(priv, HECC_CANMIM, (1 &lt;&lt; mbxno));
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Prevent message over-write &amp; Enable interrupts */
</I>&gt;<i> +	hecc_write(priv, HECC_CANOPC, HECC_SET_REG);
</I>&gt;<i> +	if (priv-&gt;int_line) {
</I>&gt;<i> +		hecc_write(priv, HECC_CANMIL, HECC_SET_REG);
</I>&gt;<i> +		hecc_write(priv, HECC_CANGIM, (HECC_CANGIM_DEF_MASK |
</I>&gt;<i> +			HECC_CANGIM_I1EN | HECC_CANGIM_SIL));
</I>&gt;<i> +	} else {
</I>&gt;<i> +		hecc_write(priv, HECC_CANMIL, 0);
</I>&gt;<i> +		hecc_write(priv, HECC_CANGIM,
</I>&gt;<i> +			(HECC_CANGIM_DEF_MASK | HECC_CANGIM_I0EN));
</I>&gt;<i> +	}
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void ti_hecc_stop(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	/* Disable interrupts and disable mailboxes */
</I>&gt;<i> +	hecc_write(priv, HECC_CANGIM, 0);
</I>&gt;<i> +	hecc_write(priv, HECC_CANMIM, 0);
</I>&gt;<i> +	hecc_write(priv, HECC_CANME, 0);
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_do_set_mode(struct net_device *ndev, enum can_mode mode)
</I>&gt;<i> +{
</I>&gt;<i> +	int ret = 0;
</I>&gt;<i> +
</I>&gt;<i> +	switch (mode) {
</I>&gt;<i> +	case CAN_MODE_START:
</I>&gt;<i> +		ti_hecc_start(ndev);
</I>&gt;<i> +		netif_wake_queue(ndev);
</I>&gt;<i> +		break;
</I>&gt;<i> +	default:
</I>&gt;<i> +		ret = -EOPNOTSUPP;
</I>&gt;<i> +		break;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return ret;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>
/* ?

&gt;<i> + * ti_hecc_xmit: HECC Transmit
</I>&gt;<i> + *
</I>&gt;<i> + * The transmit mailboxes start from 0 to HECC_MAX_TX_MBOX. In HECC the
</I>&gt;<i> + * priority of the mailbox for tranmission is dependent upon priority setting
</I>&gt;<i> + * field in mailbox registers. The mailbox with highest value in priority field
</I>&gt;<i> + * is transmitted first. Only when two mailboxes have the same value in
</I>&gt;<i> + * priority field the highest numbered mailbox is transmitted first.
</I>&gt;<i> + *
</I>&gt;<i> + * To utilize the HECC priority feature as described above we start with the
</I>&gt;<i> + * highest numbered mailbox with highest priority level and move on to the next
</I>&gt;<i> + * mailbox with the same priority level and so on. Once we loop through all the
</I>&gt;<i> + * transmit mailboxes we choose the next priority level (lower) and so on
</I>&gt;<i> + * until we reach the lowest priority level on the lowest numbered mailbox
</I>&gt;<i> + * when we stop transmission until all mailboxes are transmitted and then
</I>&gt;<i> + * restart at highest numbered mailbox with highest priority.
</I>&gt;<i> + *
</I>&gt;<i> + * Two counters (head and tail) are used to track the next mailbox to transmit
</I>&gt;<i> + * and to track the echo buffer for already transmitted mailbox. The queue
</I>&gt;<i> + * is stopped when all the mailboxes are busy or when there is a priority
</I>&gt;<i> + * value roll-over happens.
</I>&gt;<i> + */
</I>&gt;<i> +static netdev_tx_t ti_hecc_xmit(struct sk_buff *skb, struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> +	u32 mbxno = 0;
</I>&gt;<i> +	u32 data;
</I>&gt;<i> +	unsigned long flags;
</I>&gt;<i> +
</I>&gt;<i> +	mbxno = get_tx_head_mb(priv);
</I>&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;mbox_lock, flags);
</I>&gt;<i> +	if (unlikely(hecc_read(priv, HECC_CANME) &amp; (1 &lt;&lt; mbxno))) {
</I>&gt;<i> +		spin_unlock_irqrestore(&amp;priv-&gt;mbox_lock, flags);
</I>&gt;<i> +		netif_stop_queue(ndev);
</I>&gt;<i> +		dev_err(priv-&gt;ndev-&gt;dev.parent,
</I>&gt;<i> +			&quot;BUG: TX mbox not ready tx_head=%08X, tx_tail=%08X\n&quot;,
</I>&gt;<i> +			priv-&gt;tx_head, priv-&gt;tx_tail);
</I>&gt;<i> +		return NETDEV_TX_BUSY;
</I>
Can this happen? Will the hardware recover from the error?

&gt;<i> +	}
</I>&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;mbox_lock, flags);
</I>&gt;<i> +
</I>&gt;<i> +	/* Prepare mailbox for transmission */
</I>&gt;<i> +	data = cf-&gt;can_dlc &amp; 0xF;
</I>&gt;<i> +	if (cf-&gt;can_id &amp; CAN_RTR_FLAG) /* Remote transmission request */
</I>&gt;<i> +		data |= HECC_CANMCF_RTR;
</I>&gt;<i> +	data |= (get_tx_head_prio(priv) &lt;&lt; 8);
</I>&gt;<i> +	hecc_write(priv, HECC_CANMCF(mbxno), data);
</I>&gt;<i> +
</I>&gt;<i> +	if (cf-&gt;can_id &amp; CAN_EFF_FLAG) /* Extended frame format */
</I>&gt;<i> +		data = ((cf-&gt;can_id &amp; CAN_EFF_MASK) | HECC_CANMID_IDE);
</I>&gt;<i> +	else /* Standard frame format */
</I>&gt;<i> +		data = ((cf-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; 18);
</I>&gt;<i> +	hecc_write(priv, HECC_CANMID(mbxno), data);
</I>&gt;<i> +	hecc_write(priv, HECC_CANMDL(mbxno),
</I>&gt;<i> +		be32_to_cpu(*(u32 *)(cf-&gt;data + 0)));
</I>
Please remove &quot;+ 0&quot;.

&gt;<i> +	if (cf-&gt;can_dlc &gt; 4) {
</I>&gt;<i> +		hecc_write(priv, HECC_CANMDH(mbxno),
</I>&gt;<i> +			be32_to_cpu(*(u32 *)(cf-&gt;data + 4)));
</I>&gt;<i> +	} else {
</I>&gt;<i> +		*(u32 *)(cf-&gt;data + 4) = 0;
</I>&gt;<i> +	}
</I>&gt;<i> +	can_put_echo_skb(skb, ndev, mbxno);
</I>&gt;<i> +
</I>&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;mbox_lock, flags);
</I>&gt;<i> +	--priv-&gt;tx_head;
</I>&gt;<i> +	if ((hecc_read(priv, HECC_CANME) &amp; (1 &lt;&lt; get_tx_head_mb(priv))) ||
</I>&gt;<i> +		(priv-&gt;tx_head &amp; HECC_TX_MASK) == HECC_TX_MASK) {
</I>&gt;<i> +		netif_stop_queue(ndev);
</I>&gt;<i> +	}
</I>&gt;<i> +	hecc_set_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;mbox_lock, flags);
</I>&gt;<i> +
</I>&gt;<i> +	hecc_clear_bit(priv, HECC_CANMD, (1 &lt;&lt; mbxno));
</I>&gt;<i> +	hecc_set_bit(priv, HECC_CANMIM, (1 &lt;&lt; mbxno));
</I>&gt;<i> +	hecc_write(priv, HECC_CANTRS, (1 &lt;&lt; mbxno));
</I>&gt;<i> +
</I>&gt;<i> +	return NETDEV_TX_OK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_rx_pkt(struct ti_hecc_priv *priv, int mbxno)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device_stats *stats = &amp;priv-&gt;ndev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	u32 data;
</I>&gt;<i> +	unsigned long flags;
</I>&gt;<i> +
</I>&gt;<i> +	skb = dev_alloc_skb(sizeof(struct can_frame));
</I>
Please use netdev_alloc_skb(priv-&gt;ndev, ....) making ...

&gt;<i> +	if (!skb) {
</I>&gt;<i> +		if (printk_ratelimit())
</I>&gt;<i> +			dev_err(priv-&gt;ndev-&gt;dev.parent,
</I>&gt;<i> +				&quot;dev_alloc_skb() failed\n&quot;);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>&gt;<i> +	skb-&gt;dev = priv-&gt;ndev;
</I>
... the line above obsolete.

&gt;<i> +	skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;<i> +	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
</I>&gt;<i> +
</I>&gt;<i> +	cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
</I>&gt;<i> +	data = hecc_read(priv, HECC_CANMID(mbxno));
</I>&gt;<i> +	if (data &amp; HECC_CANMID_IDE)
</I>&gt;<i> +		cf-&gt;can_id = (data &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
</I>&gt;<i> +	else
</I>&gt;<i> +		cf-&gt;can_id = ((data &gt;&gt; 18) &amp; CAN_SFF_MASK);
</I>&gt;<i> +	data = hecc_read(priv, HECC_CANMCF(mbxno));
</I>&gt;<i> +	if (data &amp; HECC_CANMCF_RTR)
</I>&gt;<i> +		cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> +	cf-&gt;can_dlc = data &amp; 0xF;
</I>&gt;<i> +	data = hecc_read(priv, HECC_CANMDL(mbxno));
</I>&gt;<i> +	*(u32 *)(cf-&gt;data + 0) = cpu_to_be32(data);
</I>
Please remove &quot;+ 0&quot;.

&gt;<i> +	if (cf-&gt;can_dlc &gt; 4) {
</I>&gt;<i> +		data = hecc_read(priv, HECC_CANMDH(mbxno));
</I>&gt;<i> +		*(u32 *)(cf-&gt;data + 4) = cpu_to_be32(data);
</I>&gt;<i> +	} else {
</I>&gt;<i> +		*(u32 *)(cf-&gt;data + 4) = 0;
</I>&gt;<i> +	}
</I>&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;mbox_lock, flags);
</I>&gt;<i> +	hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +	hecc_write(priv, HECC_CANRMP, (1 &lt;&lt; mbxno));
</I>&gt;<i> +	/* enable mailbox only if it is part of rx buffer mailboxes */
</I>&gt;<i> +	if (priv-&gt;rx_next &lt; HECC_RX_BUFFER_MBOX)
</I>&gt;<i> +		hecc_set_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;mbox_lock, flags);
</I>&gt;<i> +
</I>&gt;<i> +	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +	netif_receive_skb(skb);
</I>&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>
/* ?

&gt;<i> + * ti_hecc_rx_poll - HECC receive pkts
</I>&gt;<i> + *
</I>&gt;<i> + * The receive mailboxes start from highest numbered mailbox till last xmit
</I>&gt;<i> + * mailbox. On CAN frame reception the hardware places the data into highest
</I>&gt;<i> + * numbered mailbox that matches the CAN ID filter. Since all receive mailboxes
</I>&gt;<i> + * have same filtering (ALL CAN frames) packets will arrive in the highest
</I>&gt;<i> + * available RX mailbox and we need to ensure in-order packet reception.
</I>&gt;<i> + *
</I>&gt;<i> + * To ensure the packets are received in the right order we logically divide
</I>&gt;<i> + * the RX mailboxes into main and buffer mailboxes. Packets are received as per
</I>&gt;<i> + * mailbox priotity (higher to lower) in the main bank and once it is full we
</I>&gt;<i> + * disable further reception into main mailboxes. While the main mailboxes are
</I>&gt;<i> + * processed in NAPI, further packets are received in buffer mailboxes.
</I>&gt;<i> + *
</I>&gt;<i> + * We maintain a RX next mailbox counter to process packets and once all main
</I>&gt;<i> + * mailboxe packets are passed to the upper stack we enable all of them but
</I>&gt;<i> + * continue to process packets received in buffer mailboxes. With each packet
</I>&gt;<i> + * received from buffer mailbox we enable it immediately so as to handle the
</I>&gt;<i> + * overflow from higher mailboxes.
</I>&gt;<i> + */
</I>&gt;<i> +static int ti_hecc_rx_poll(struct napi_struct *napi, int quota)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = napi-&gt;dev;
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	u32 num_pkts = 0;
</I>&gt;<i> +	u32 mbxno, mbx_mask;
</I>&gt;<i> +	unsigned long pending_pkts, flags;
</I>&gt;<i> +
</I>&gt;<i> +	if (!netif_running(ndev))
</I>&gt;<i> +		return 0;
</I>&gt;<i> +
</I>&gt;<i> +	while ((pending_pkts = hecc_read(priv, HECC_CANRMP)) &amp;&amp;
</I>&gt;<i> +		(num_pkts &lt; quota)) {
</I>&gt;<i> +		mbx_mask = BIT(priv-&gt;rx_next); /* next rx mailbox to process */
</I>&gt;<i> +		if (mbx_mask &amp; pending_pkts) {
</I>&gt;<i> +			if (ti_hecc_rx_pkt(priv, priv-&gt;rx_next) &lt; 0)
</I>&gt;<i> +				return num_pkts;
</I>&gt;<i> +			++num_pkts;
</I>&gt;<i> +		} else if (priv-&gt;rx_next &gt; HECC_RX_BUFFER_MBOX) {
</I>&gt;<i> +				break; /* pkt not received yet */
</I>&gt;<i> +		}
</I>&gt;<i> +		--priv-&gt;rx_next;
</I>&gt;<i> +		if (priv-&gt;rx_next == HECC_RX_BUFFER_MBOX) {
</I>&gt;<i> +			/* enable high bank mailboxes */
</I>&gt;<i> +			spin_lock_irqsave(&amp;priv-&gt;mbox_lock, flags);
</I>&gt;<i> +			mbx_mask = hecc_read(priv, HECC_CANME);
</I>&gt;<i> +			mbx_mask |= HECC_RX_HIGH_MBOX_MASK;
</I>&gt;<i> +			hecc_write(priv, HECC_CANME, mbx_mask);
</I>&gt;<i> +			spin_unlock_irqrestore(&amp;priv-&gt;mbox_lock, flags);
</I>&gt;<i> +		} else if (priv-&gt;rx_next == (HECC_MAX_TX_MBOX - 1)) {
</I>&gt;<i> +				priv-&gt;rx_next = HECC_RX_FIRST_MBOX;
</I>&gt;<i> +				break;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Enable packet interrupt if all pkts are handled */
</I>&gt;<i> +	if (0 == hecc_read(priv, HECC_CANRMP)) {
</I>
You seem to be a friend of this style. I personally find

        if (hecc_read(priv, HECC_CANRMP) == 0)  or
        if (!hecc_read(priv, HECC_CANRMP))

more readable. But it's not a real requirement, AFAIK.

&gt;<i> +		napi_complete(napi);
</I>&gt;<i> +		/* Re-enable RX mailbox interrupts */
</I>&gt;<i> +		mbxno = hecc_read(priv, HECC_CANMIM);
</I>&gt;<i> +		mbxno |= HECC_TX_MBOX_MASK;
</I>&gt;<i> +		hecc_write(priv, HECC_CANMIM, mbxno);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return num_pkts;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int
</I>&gt;<i> +ti_hecc_error(struct net_device *ndev, int int_status, int err_status)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +
</I>&gt;<i> +	/* propogate the error condition to the can stack */
</I>&gt;<i> +	skb = dev_alloc_skb(sizeof(struct can_frame));
</I>
See above.

&gt;<i> +	if (!skb) {
</I>&gt;<i> +		if (printk_ratelimit())
</I>&gt;<i> +			dev_err(priv-&gt;ndev-&gt;dev.parent,
</I>&gt;<i> +				&quot;dev_alloc_skb() failed in err processing\n&quot;);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>&gt;<i> +	skb-&gt;dev = ndev;
</I>&gt;<i> +	skb-&gt;protocol = htons(ETH_P_CAN);
</I>
Please add:

	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;

&gt;<i> +	cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
</I>&gt;<i> +	memset(cf, 0, sizeof(struct can_frame));
</I>&gt;<i> +	cf-&gt;can_id = CAN_ERR_FLAG;
</I>&gt;<i> +	cf-&gt;can_dlc = CAN_ERR_DLC;
</I>&gt;<i> +
</I>&gt;<i> +	if (int_status &amp; HECC_CANGIF_WLIF) { /* warning level int */
</I>&gt;<i> +		if (0 == (int_status &amp; HECC_CANGIF_BOIF)) {
</I>&gt;<i> +			priv-&gt;can.state = CAN_STATE_ERROR_WARNING;
</I>&gt;<i> +			++priv-&gt;can.can_stats.error_warning;
</I>&gt;<i> +			cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +			if (hecc_read(priv, HECC_CANTEC) &gt; 96)
</I>&gt;<i> +				cf-&gt;data[1] |= CAN_ERR_CRTL_TX_WARNING;
</I>&gt;<i> +			if (hecc_read(priv, HECC_CANREC) &gt; 96)
</I>&gt;<i> +				cf-&gt;data[1] |= CAN_ERR_CRTL_RX_WARNING;
</I>&gt;<i> +		}
</I>&gt;<i> +		hecc_set_bit(priv, HECC_CANES, HECC_CANES_EW);
</I>&gt;<i> +		dev_dbg(priv-&gt;ndev-&gt;dev.parent, &quot;Error Warning interrupt\n&quot;);
</I>&gt;<i> +		hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (int_status &amp; HECC_CANGIF_EPIF) { /* error passive int */
</I>&gt;<i> +		if (0 == (int_status &amp; HECC_CANGIF_BOIF)) {
</I>&gt;<i> +			priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> +			++priv-&gt;can.can_stats.error_passive;
</I>&gt;<i> +			cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +			if (hecc_read(priv, HECC_CANTEC) &gt; 127)
</I>&gt;<i> +				cf-&gt;data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
</I>&gt;<i> +			if (hecc_read(priv, HECC_CANREC) &gt; 127)
</I>&gt;<i> +				cf-&gt;data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> +		}
</I>&gt;<i> +		hecc_set_bit(priv, HECC_CANES, HECC_CANES_EP);
</I>&gt;<i> +		dev_dbg(priv-&gt;ndev-&gt;dev.parent, &quot;Error passive interrupt\n&quot;);
</I>&gt;<i> +		hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Need to check busoff condition in error status register too to
</I>&gt;<i> +	 * ensure warning interrupts don't hog the system
</I>&gt;<i> +	 */
</I>&gt;<i> +	if ((int_status &amp; HECC_CANGIF_BOIF) || (err_status &amp; HECC_CANES_BO)) {
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> +		hecc_set_bit(priv, HECC_CANES, HECC_CANES_BO);
</I>&gt;<i> +		hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
</I>&gt;<i> +		can_bus_off(ndev);
</I>&gt;<i> +		/* Disable all interrupts in bus-off to avoid int hog */
</I>&gt;<i> +		hecc_write(priv, HECC_CANGIM, 0);
</I>
The interrupts should problable be disabled before can_bus_off() is
called (which may start a timer to schedule recovery).

&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (err_status &amp; HECC_BUS_ERROR) {
</I>&gt;<i> +		++priv-&gt;can.can_stats.bus_error;
</I>&gt;<i> +		cf-&gt;can_id |= (CAN_ERR_BUSERROR | CAN_ERR_PROT);
</I>&gt;<i> +		cf-&gt;data[2] |= CAN_ERR_PROT_UNSPEC;
</I>&gt;<i> +		if (err_status &amp; HECC_CANES_FE) {
</I>&gt;<i> +			hecc_set_bit(priv, HECC_CANES, HECC_CANES_FE);
</I>&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;<i> +		}
</I>&gt;<i> +		if (err_status &amp; HECC_CANES_BE) {
</I>&gt;<i> +			hecc_set_bit(priv, HECC_CANES, HECC_CANES_BE);
</I>&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
</I>&gt;<i> +		}
</I>&gt;<i> +		if (err_status &amp; HECC_CANES_SE) {
</I>&gt;<i> +			hecc_set_bit(priv, HECC_CANES, HECC_CANES_SE);
</I>&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;<i> +		}
</I>&gt;<i> +		if (err_status &amp; HECC_CANES_CRCE) {
</I>&gt;<i> +			hecc_set_bit(priv, HECC_CANES, HECC_CANES_CRCE);
</I>&gt;<i> +			cf-&gt;data[2] |= (CAN_ERR_PROT_LOC_CRC_SEQ |
</I>&gt;<i> +					CAN_ERR_PROT_LOC_CRC_DEL);
</I>&gt;<i> +		}
</I>&gt;<i> +		if (err_status &amp; HECC_CANES_ACKE) {
</I>&gt;<i> +			hecc_set_bit(priv, HECC_CANES, HECC_CANES_ACKE);
</I>&gt;<i> +			cf-&gt;data[2] |= (CAN_ERR_PROT_LOC_ACK |
</I>&gt;<i> +					CAN_ERR_PROT_LOC_ACK_DEL);
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	netif_receive_skb(skb);
</I>&gt;<i> +	ndev-&gt;last_rx = jiffies;
</I>
Please remove the line above. It's not needed any more.

&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;<i> +	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static irqreturn_t ti_hecc_interrupt(int irq, void *dev_id)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = (struct net_device *)dev_id;
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> +	u32 mbxno, int_status, err_status;
</I>&gt;<i> +	unsigned long ack, flags;
</I>&gt;<i> +
</I>&gt;<i> +	int_status = hecc_read(priv,
</I>&gt;<i> +		((priv-&gt;int_line) ? HECC_CANGIF1 : HECC_CANGIF0));
</I>&gt;<i> +
</I>&gt;<i> +	if (0 == int_status)
</I>&gt;<i> +		return IRQ_NONE;
</I>&gt;<i> +
</I>&gt;<i> +	err_status = hecc_read(priv, HECC_CANES);
</I>&gt;<i> +	if (err_status &amp; (HECC_BUS_ERROR | HECC_CANES_BO |
</I>&gt;<i> +		HECC_CANES_EP | HECC_CANES_EW))
</I>&gt;<i> +			ti_hecc_error(ndev, int_status, err_status);
</I>&gt;<i> +
</I>&gt;<i> +	if (int_status &amp; HECC_CANGIF_GMIF) {
</I>&gt;<i> +		while ((priv-&gt;tx_tail - priv-&gt;tx_head) &gt; 0) {
</I>&gt;<i> +			mbxno = get_tx_tail_mb(priv);
</I>&gt;<i> +			if (!((1 &lt;&lt; mbxno) &amp; hecc_read(priv, HECC_CANTA)))
</I>&gt;<i> +				break;
</I>&gt;<i> +			hecc_clear_bit(priv, HECC_CANMIM, (1 &lt;&lt; mbxno));
</I>&gt;<i> +			hecc_write(priv, HECC_CANTA, (1 &lt;&lt; mbxno));
</I>&gt;<i> +			spin_lock_irqsave(&amp;priv-&gt;mbox_lock, flags);
</I>&gt;<i> +			hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +			spin_unlock_irqrestore(&amp;priv-&gt;mbox_lock, flags);
</I>&gt;<i> +			stats-&gt;tx_bytes += (hecc_read(priv, HECC_CANMCF(mbxno))
</I>&gt;<i> +						&amp; 0xF);
</I>&gt;<i> +			stats-&gt;tx_packets++;
</I>&gt;<i> +			can_get_echo_skb(ndev, mbxno);
</I>&gt;<i> +			--priv-&gt;tx_tail;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		/* restart queue if wrap-up or if queue stalled on last pkt */
</I>&gt;<i> +		if (((priv-&gt;tx_head == priv-&gt;tx_tail) &amp;&amp;
</I>&gt;<i> +		((priv-&gt;tx_head &amp; HECC_TX_MASK) != HECC_TX_MASK)) ||
</I>&gt;<i> +		(((priv-&gt;tx_tail &amp; HECC_TX_MASK) == HECC_TX_MASK) &amp;&amp;
</I>&gt;<i> +		((priv-&gt;tx_head &amp; HECC_TX_MASK) == HECC_TX_MASK)))
</I>&gt;<i> +			netif_wake_queue(ndev);
</I>&gt;<i> +
</I>&gt;<i> +		/* Disable RX mailbox interrupts and let NAPI reenable them */
</I>&gt;<i> +		if (hecc_read(priv, HECC_CANRMP)) {
</I>&gt;<i> +			ack = hecc_read(priv, HECC_CANMIM);
</I>&gt;<i> +			ack &amp;= ((1 &lt;&lt; HECC_MAX_TX_MBOX) - 1);
</I>&gt;<i> +			hecc_write(priv, HECC_CANMIM, ack);
</I>&gt;<i> +			napi_schedule(&amp;priv-&gt;napi);
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* clear all interrupt conditions - read back to avoid spurious ints */
</I>&gt;<i> +	if (priv-&gt;int_line) {
</I>&gt;<i> +		hecc_write(priv, HECC_CANGIF1, HECC_SET_REG);
</I>&gt;<i> +		int_status = hecc_read(priv, HECC_CANGIF1);
</I>&gt;<i> +	} else {
</I>&gt;<i> +		hecc_write(priv, HECC_CANGIF0, HECC_SET_REG);
</I>&gt;<i> +		int_status = hecc_read(priv, HECC_CANGIF0);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return IRQ_HANDLED;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_open(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	int err;
</I>&gt;<i> +
</I>&gt;<i> +	err = request_irq(ndev-&gt;irq, ti_hecc_interrupt, IRQF_DISABLED,
</I>&gt;<i> +				ndev-&gt;name, ndev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(ndev-&gt;dev.parent, &quot;error requesting interrupt\n&quot;);
</I>&gt;<i> +		return err;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Open common can device */
</I>&gt;<i> +	err = open_candev(ndev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(ndev-&gt;dev.parent, &quot;open_candev() failed %08X\n&quot;, err);
</I>&gt;<i> +		free_irq(ndev-&gt;irq, ndev);
</I>&gt;<i> +		return err;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	clk_enable(priv-&gt;clk);
</I>&gt;<i> +	ti_hecc_start(ndev);
</I>&gt;<i> +	napi_enable(&amp;priv-&gt;napi);
</I>&gt;<i> +	netif_start_queue(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_close(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	netif_stop_queue(ndev);
</I>&gt;<i> +	napi_disable(&amp;priv-&gt;napi);
</I>&gt;<i> +	ti_hecc_stop(ndev);
</I>&gt;<i> +	free_irq(ndev-&gt;irq, ndev);
</I>&gt;<i> +	clk_disable(priv-&gt;clk);
</I>&gt;<i> +	close_candev(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static const struct net_device_ops ti_hecc_netdev_ops = {
</I>&gt;<i> +	.ndo_open		= ti_hecc_open,
</I>&gt;<i> +	.ndo_stop		= ti_hecc_close,
</I>&gt;<i> +	.ndo_start_xmit		= ti_hecc_xmit,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_probe(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = (struct net_device *)0;
</I>&gt;<i> +	struct ti_hecc_priv *priv;
</I>&gt;<i> +	struct ti_hecc_platform_data *pdata;
</I>&gt;<i> +	struct resource *mem, *irq;
</I>&gt;<i> +	void __iomem *addr;
</I>&gt;<i> +	int err;
</I>&gt;<i> +
</I>&gt;<i> +	pdata = pdev-&gt;dev.platform_data;
</I>&gt;<i> +	if (!pdata) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;No platform data - exiting\n&quot;);
</I>
s/- exiting//

&gt;<i> +		return -ENODEV;
</I>
Here you use &quot;return&quot;, and below &quot;goto probe_exit&quot;;

&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;<i> +	if (!mem) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;no mem resources???\n&quot;);
</I>
Please remove &quot;???&quot;

&gt;<i> +		err = -ENODEV;
</I>
Pre-setting err would also save some lines.

&gt;<i> +		goto probe_exit;
</I>&gt;<i> +	}
</I>&gt;<i> +	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
</I>&gt;<i> +	if (!irq) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;no irq resourc???\n&quot;);
</I>
Ditto.

&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_exit;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (!request_mem_region(mem-&gt;start, resource_size(mem), pdev-&gt;name)) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;HECC region already claimed\n&quot;);
</I>&gt;<i> +		err = -EBUSY;
</I>&gt;<i> +		goto probe_exit;
</I>&gt;<i> +	}
</I>&gt;<i> +	addr = ioremap(mem-&gt;start, resource_size(mem));
</I>&gt;<i> +	if (!addr) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;ioremap failed\n&quot;);
</I>&gt;<i> +		err = -ENOMEM;
</I>&gt;<i> +		goto probe_exit_free_region;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	ndev = alloc_candev(sizeof(struct ti_hecc_priv));
</I>&gt;<i> +	if (!ndev) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;alloc_candev failed\n&quot;);
</I>&gt;<i> +		err = -ENOMEM;
</I>&gt;<i> +		goto probe_exit_iounmap;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	priv = netdev_priv(ndev);
</I>&gt;<i> +	priv-&gt;ndev = ndev;
</I>&gt;<i> +	priv-&gt;base = addr;
</I>&gt;<i> +	priv-&gt;scc_ram_offset = pdata-&gt;scc_ram_offset;
</I>&gt;<i> +	priv-&gt;hecc_ram_offset = pdata-&gt;hecc_ram_offset;
</I>&gt;<i> +	priv-&gt;mbox_offset = pdata-&gt;mbox_offset;
</I>&gt;<i> +	priv-&gt;int_line = pdata-&gt;int_line;
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.bittiming_const = &amp;ti_hecc_bittiming_const;
</I>&gt;<i> +	priv-&gt;can.do_set_mode = ti_hecc_do_set_mode;
</I>&gt;<i> +	priv-&gt;can.do_get_state = ti_hecc_get_state;
</I>&gt;<i> +
</I>&gt;<i> +	ndev-&gt;irq = irq-&gt;start;
</I>&gt;<i> +	ndev-&gt;flags |= IFF_ECHO;
</I>&gt;<i> +	platform_set_drvdata(pdev, ndev);
</I>&gt;<i> +	SET_NETDEV_DEV(ndev, &amp;pdev-&gt;dev);
</I>&gt;<i> +	ndev-&gt;netdev_ops = &amp;ti_hecc_netdev_ops;
</I>&gt;<i> +
</I>&gt;<i> +	/* Note: clk name would change using hecc_vbusp_ck temporarily */
</I>&gt;<i> +	priv-&gt;clk = clk_get(&amp;pdev-&gt;dev, &quot;hecc_vbusp_ck&quot;);
</I>&gt;<i> +	if (IS_ERR(priv-&gt;clk)) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;no clock available\n&quot;);
</I>&gt;<i> +		err = PTR_ERR(priv-&gt;clk);
</I>&gt;<i> +		priv-&gt;clk = NULL;
</I>&gt;<i> +		goto probe_exit_candev;
</I>&gt;<i> +	}
</I>&gt;<i> +	priv-&gt;can.clock.freq = clk_get_rate(priv-&gt;clk);
</I>&gt;<i> +	netif_napi_add(ndev, &amp;priv-&gt;napi, ti_hecc_rx_poll,
</I>&gt;<i> +			HECC_DEF_NAPI_WEIGHT);
</I>&gt;<i> +
</I>&gt;<i> +	err = register_candev(ndev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;register_candev() failed\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto probe_exit_clk;
</I>&gt;<i> +	}
</I>&gt;<i> +	dev_info(&amp;pdev-&gt;dev, &quot;device registered (reg_base=%p, irq=%u)\n&quot;,
</I>&gt;<i> +		priv-&gt;base, (u32) ndev-&gt;irq);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +probe_exit_clk:
</I>&gt;<i> +	clk_put(priv-&gt;clk);
</I>&gt;<i> +probe_exit_candev:
</I>&gt;<i> +	free_candev(ndev);
</I>&gt;<i> +probe_exit_iounmap:
</I>&gt;<i> +	iounmap(addr);
</I>&gt;<i> +probe_exit_free_region:
</I>&gt;<i> +	release_mem_region(mem-&gt;start, resource_size(mem));
</I>&gt;<i> +probe_exit:
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>[snip]

Wolfgang.

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003170.html">[PATCH V3] net-next:can: add TI CAN (HECC) driver
</A></li>
	<LI>Next message: <A HREF="003173.html">[PATCH V3] net-next:can: add TI CAN (HECC) driver
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3171">[ date ]</a>
              <a href="thread.html#3171">[ thread ]</a>
              <a href="subject.html#3171">[ subject ]</a>
              <a href="author.html#3171">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
