<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH v2] cc770: driver for the Bosch CC770 and the Intel AN82527
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20v2%5D%20cc770%3A%20driver%20for%20the%20Bosch%20CC770%20and%20the%20Intel%20AN82527&In-Reply-To=%3C4A447E1C.20605%40grandegger.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002755.html">
   <LINK REL="Next"  HREF="002758.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH v2] cc770: driver for the Bosch CC770 and the Intel AN82527</H1>
    <B>Wolfgang Grandegger</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20v2%5D%20cc770%3A%20driver%20for%20the%20Bosch%20CC770%20and%20the%20Intel%20AN82527&In-Reply-To=%3C4A447E1C.20605%40grandegger.com%3E"
       TITLE="[PATCH v2] cc770: driver for the Bosch CC770 and the Intel AN82527">wg at grandegger.com
       </A><BR>
    <I>Fri Jun 26 09:51:56 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002755.html">[PATCH] cc770-isa: legacy driver for CC770/i82725 on the ISA bus
</A></li>
        <LI>Next message: <A HREF="002758.html">[PATCH v2] cc770: driver for the Bosch CC770 and the Intel AN82527
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2756">[ date ]</a>
              <a href="thread.html#2756">[ thread ]</a>
              <a href="subject.html#2756">[ subject ]</a>
              <a href="author.html#2756">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This patch adds a Socket-CAN driver for the Bosch CC770 and the Intel
AN82527 CAN controllers. Intel stopped production of the AN82527 a few
years ago. The CC770 is a compatible CAN controller from Bosch with
bugs being fixed and some improvements in the functionality, mainly:

1. RX and TX error counters are readable.
2. Support of silent (listen-only) mode.
3. Message object 15 can receive all types of frames, also RTR and EFF.

Details are available from Bosch's &quot;CC770_Product_Info_2007-01.pdf&quot;,
which explains in detail the compatibility between the CC770 and the
82527. This driver use the additional functionality 3. on real CC770
devices. Unfortunately, the CC770 does still not store the message
identifier of the received remote transmission request frame and
therefore it's set to 0.

The driver is derived from the old Socket-CAN i82527 driver in
&quot;drivers/net/can/old/i82527&quot;.

Note: This driver reveals a limitation on how to configure the frame
type received by the message object 15. Currently, we do not have an
interface to set controller specific properties. Therefore, the
option can currently be selected globally by the module parameter
&quot;msgobj_eff&quot;.

Signed-off-by: Wolfgang Grandegger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">wg at grandegger.com</A>&gt;
---
 kernel/2.6/drivers/net/can/Kconfig        |   21 
 kernel/2.6/drivers/net/can/Makefile       |    2 
 kernel/2.6/drivers/net/can/cc770/Makefile |   24 
 kernel/2.6/drivers/net/can/cc770/cc770.c  |  936 ++++++++++++++++++++++++++++++
 kernel/2.6/drivers/net/can/cc770/cc770.h  |  247 +++++++
 5 files changed, 1230 insertions(+)

Index: netlink/kernel/2.6/drivers/net/can/cc770/cc770.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ netlink/kernel/2.6/drivers/net/can/cc770/cc770.h	2009-06-26 09:30:04.050278821 +0200
@@ -0,0 +1,247 @@
+/*
+ * $Id:  $
+ *
+ * cc770.h - Bosch CC770 and Intel AN82527 network device driver
+ *
+ * Copyright (C) 2009 Wolfgang Grandegger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">wg at grandegger.com</A>&gt;
+ *
+ * Derived from the old Socket-CAN i82527 driver:
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License (&quot;GPL&quot;) version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">socketcan-users at lists.berlios.de</A>&gt;
+ */
+
+#ifndef CC770_DEV_H
+#define CC770_DEV_H
+
+#include &lt;socketcan/can/dev.h&gt;
+
+struct cc770_msgobj {
+	u8 ctrl0;
+	u8 ctrl1;
+	u8 id[4];
+	u8 config;
+	u8 data[8];
+	u8 dontuse;		/* padding */
+} __attribute__ ((packed));
+
+struct cc770_regs {
+	union {
+		struct cc770_msgobj msgobj[16]; /* Message object 1..15 */
+		struct {
+			u8 control;		/* Control Register */
+			u8 status;		/* Status Register */
+			u8 cpu_interface;	/* CPU Interface Register */
+			u8 dontuse1;
+			u8 high_speed_read[2];	/* High Speed Read */
+			u8 global_mask_std[2];	/* Standard Global Mask */
+			u8 global_mask_ext[4];	/* Extended Global Mask */
+			u8 msg15_mask[4];	/* Message 15 Mask */
+			u8 dontuse2[15];
+			u8 clkout;		/* Clock Out Register */
+			u8 dontuse3[15];
+			u8 bus_config;		/* Bus Configuration Register */
+			u8 dontuse4[15];
+			u8 bit_timing_0;	/* Bit Timing Register byte 0 */
+			u8 dontuse5[15];
+			u8 bit_timing_1;	/* Bit Timing Register byte 1 */
+			u8 dontuse6[15];
+			u8 interrupt;		/* Interrupt Register */
+			u8 dontuse7[15];
+			u8 rx_error_counter;	/* Receive Error Counter */
+			u8 dontuse8[15];
+			u8 tx_error_counter;	/* Transmit Error Counter */
+			u8 dontuse9[31];
+			u8 p1_conf;
+			u8 dontuse10[15];
+			u8 p2_conf;
+			u8 dontuse11[15];
+			u8 p1_in;
+			u8 dontuse12[15];
+			u8 p2_in;
+			u8 dontuse13[15];
+			u8 p1_out;
+			u8 dontuse14[15];
+			u8 p2_out;
+			u8 dontuse15[15];
+			u8 serial_reset_addr;
+		};
+	};
+} __attribute__ ((packed));
+
+/* Control Register (0x00) */
+#define CTRL_INI	0x01	/* Initialization */
+#define CTRL_IE		0x02	/* Interrupt Enable */
+#define CTRL_SIE	0x04	/* Status Interrupt Enable */
+#define CTRL_EIE	0x08	/* Error Interrupt Enable */
+#define CTRL_EAF	0x20	/* Enable additional functions */
+#define CTRL_CCE	0x40	/* Change Configuration Enable */
+
+/* Status Register (0x01) */
+#define STAT_LEC_STUFF	0x01	/* Stuff error */
+#define STAT_LEC_FORM	0x02	/* Form error */
+#define STAT_LEC_ACK	0x03	/* Acknowledgement error */
+#define STAT_LEC_BIT1	0x04	/* Bit1 error */
+#define STAT_LEC_BIT0	0x05	/* Bit0 error */
+#define STAT_LEC_CRC	0x06	/* CRC error */
+#define STAT_LEC_MASK	0x07	/* Last Error Code mask */
+#define STAT_TXOK	0x08	/* Transmit Message Successfully */
+#define STAT_RXOK	0x10	/* Receive Message Successfully */
+#define STAT_WAKE	0x20	/* Wake Up Status */
+#define STAT_WARN	0x40	/* Warning Status */
+#define STAT_BOFF	0x80	/* Bus Off Status */
+
+/* CPU Interface Register (0x02) */
+#define CPUIF_CEN	0x01	/* Clock Out Enable */
+#define CPUIF_MUX	0x04	/* Multiplex */
+#define CPUIF_SLP	0x08	/* Sleep */
+#define CPUIF_PWD	0x10	/* Power Down Mode */
+#define CPUIF_DMC	0x20	/* Divide Memory Clock */
+#define CPUIF_DSC	0x40	/* Divide System Clock */
+#define CPUIF_RST	0x80	/* Hardware Reset Status */
+
+/* Clock Out Register (0x1f) */
+#define CLKOUT_CD_MASK  0x0f	/* Clock Divider mask */
+#define CLKOUT_SL_MASK	0x30	/* Slew Rate mask */
+#define CLKOUT_SL_SHIFT	4
+
+/* Bus Configuration Register (0x2f) */
+#define BUSCFG_DR0	0x01	/* Disconnect RX0 Input / Select RX input */
+#define BUSCFG_DR1	0x02	/* Disconnect RX1 Input / Silent mode */
+#define BUSCFG_DT1	0x08	/* Disconnect TX1 Output */
+#define BUSCFG_POL	0x20	/* Polarity dominant or recessive */
+#define BUSCFG_CBY	0x40	/* Input Comparator Bypass */
+
+/* Message Control Register 0 (Base Address + 0x0) */
+#define INTPND_RES	0x01	/* No Interrupt pending */
+#define INTPND_SET	0x02	/* Interrupt pending */
+#define INTPND_UNC	0x03
+#define RXIE_RES	0x04	/* Receive Interrupt Disable */
+#define RXIE_SET	0x08	/* Receive Interrupt Enable */
+#define RXIE_UNC	0x0c
+#define TXIE_RES	0x10	/* Transmit Interrupt Disable */
+#define TXIE_SET	0x20	/* Transmit Interrupt Enable */
+#define TXIE_UNC	0x30
+#define MSGVAL_RES	0x40	/* Message Invalid */
+#define MSGVAL_SET	0x80	/* Message Valid */
+#define MSGVAL_UNC	0xc0
+
+/* Message Control Register 1 (Base Address + 0x01) */
+#define NEWDAT_RES	0x01	/* No New Data */
+#define NEWDAT_SET	0x02	/* New Data */
+#define NEWDAT_UNC	0x03
+#define MSGLST_RES	0x04	/* No Message Lost */
+#define MSGLST_SET	0x08	/* Message Lost */
+#define MSGLST_UNC	0x0c
+#define CPUUPD_RES	0x04	/* No CPU Updating */
+#define CPUUPD_SET	0x08	/* CPU Updating */
+#define CPUUPD_UNC	0x0c
+#define TXRQST_RES	0x10	/* No Transmission Request */
+#define TXRQST_SET	0x20	/* Transmission Request */
+#define TXRQST_UNC	0x30
+#define RMTPND_RES	0x40	/* No Remote Request Pending */
+#define RMTPND_SET	0x80	/* Remote Request Pending */
+#define RMTPND_UNC	0xc0
+
+/* Message Configuration Register (Base Address + 0x06) */
+#define MSGCFG_XTD	0x04	/* Extended Identifier */
+#define MSGCFG_DIR	0x08	/* Direction is Transmit */
+
+#define MSGOBJ_FIRST	1
+#define MSGOBJ_LAST	15
+
+#define CC770_IO_SIZE	0x100
+#define CC770_MAX_IRQ	20	/* max. number of interrupts handled in ISR */
+
+#define cc770_read_reg(priv, member)					\
+	priv-&gt;read_reg(priv, offsetof(struct cc770_regs, member))
+
+#define cc770_write_reg(priv, member, value)				\
+	priv-&gt;write_reg(priv, offsetof(struct cc770_regs, member), value)
+
+/*
+ * Message objects and flags used by this driver
+ */
+#define CC770_OBJ_FLAG_RX  0x01
+#define CC770_OBJ_FLAG_RTR 0x02
+#define CC770_OBJ_FLAG_EFF 0x04
+
+enum {
+	CC770_OBJ_RX0 = 0,	/* for receiving normal messages */
+	CC770_OBJ_RX1,		/* for receiving normal messages */
+	CC770_OBJ_RX_RTR0,	/* for receiving remote transmission requests */
+	CC770_OBJ_RX_RTR1,	/* for receiving remote transmission requests */
+	CC770_OBJ_TX,		/* for sending messages */
+	CC770_OBJ_MAX
+};
+
+#define obj2msgobj(o)	(MSGOBJ_LAST - (o)) /* message object 11..15 */
+
+/*
+ * CC770 private data structure
+ */
+struct cc770_priv {
+	struct can_priv can;	/* must be the first member */
+	int open_time;
+	struct sk_buff *echo_skb;
+
+	/* the lower-layer is responsible for appropriate locking */
+	u8 (*read_reg)(const struct cc770_priv *priv, int reg);
+	void (*write_reg)(const struct cc770_priv *priv, int reg, u8 val);
+	void (*pre_irq)(const struct cc770_priv *priv);
+	void (*post_irq)(const struct cc770_priv *priv);
+
+	void *priv;		/* for board-specific data */
+	struct net_device *dev;
+
+	void __iomem *reg_base;	/* ioremap'ed address to registers */
+	unsigned long irq_flags;	/* for request_irq() */
+
+	unsigned char obj_flags[CC770_OBJ_MAX];
+	u8 control_normal_mode;	/* Control register for normal mode */
+	u8 cpu_interface;	/* CPU interface register */
+	u8 clkout;		/* Clock out register */
+	u8 bus_config;		/* Bus conffiguration register */
+};
+
+struct net_device *alloc_cc770dev(int sizeof_priv);
+void free_cc770dev(struct net_device *dev);
+int register_cc770dev(struct net_device *dev);
+void unregister_cc770dev(struct net_device *dev);
+
+#endif /* CC770_DEV_H */
Index: netlink/kernel/2.6/drivers/net/can/Makefile
===================================================================
--- netlink.orig/kernel/2.6/drivers/net/can/Makefile	2009-06-25 22:02:36.000000000 +0200
+++ netlink/kernel/2.6/drivers/net/can/Makefile	2009-06-26 09:30:04.101158686 +0200
@@ -13,6 +13,7 @@
 export CONFIG_CAN_DEV=m
 #export CONFIG_CAN_SJA1000_OLD=m
 #export CONFIG_CAN_I82527_OLD=m
+export CONFIG_CAN_CC770=m
 export CONFIG_CAN_SJA1000=m
 export CONFIG_CAN_SJA1000_PLATFORM=m
 export CONFIG_CAN_EMS_PCI=m
@@ -37,6 +38,7 @@
 can-dev-y			:= dev.o
 can-dev-$(CONFIG_CAN_DEV_SYSFS) += sysfs.o
 
+obj-$(CONFIG_CAN_CC770)		+= cc770/
 obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
 obj-$(CONFIG_CAN_SOFTING)	+= softing/
 obj-$(CONFIG_CAN_MSCAN)		+= mscan/
Index: netlink/kernel/2.6/drivers/net/can/Kconfig
===================================================================
--- netlink.orig/kernel/2.6/drivers/net/can/Kconfig	2009-06-25 22:02:36.000000000 +0200
+++ netlink/kernel/2.6/drivers/net/can/Kconfig	2009-06-26 09:48:07.067969713 +0200
@@ -70,6 +70,13 @@
 	  files &quot;tq&quot;, &quot;prop_seg&quot;, &quot;phase_seg1&quot;, &quot;phase_seg2&quot; and &quot;sjw&quot;.
 	  If unsure, say Y.
 
+config CAN_CC770
+	depends on HAS_IOMEM &amp;&amp; CAN_DEV
+	tristate &quot;Bosch CC770 and Intel AN82527&quot;
+	---help---
+	  Driver for the Bosch CC770 and the compatible Intel AN82527
+	  CAN controllers.
+
 config CAN_SJA1000
 	depends on CAN_DEV
 	tristate &quot;Philips SJA1000&quot;
@@ -173,10 +180,24 @@
 	depends on CAN_DEV
 	---help---
 	  generic softing CAN cards
+	  Sofing CAN cards come with 1 or 2 physical busses.
+	  The API of the card does not allow fine control per bus, but
+	  controls the 2 busses on the card together.
+	  As such, some actions (start/stop/busoff recovery) on 1 bus
+	  must bring down the other bus too temporarily.
+	  You have been warned.
+	  This driver is written on safe on 64bit, but not on big endian.
 
 config CAN_SOFTING_CS
 	tristate &quot;Softing CAN pcmcia cards&quot;
 	depends on CAN_SOFTING &amp;&amp; PCMCIA
+	---help---
+	  Support for PCMCIA cards from Softing Gmbh &amp; some cards
+	  from Vector Gmbh.
+	  You need firmware for these, which you can get at
+	  <A HREF="http://developer.berlios.de/projects/socketcan/">http://developer.berlios.de/projects/socketcan/</A>
+	  This version of the driver is written against
+	  firmware version 4.6
 
 config CAN_MSCAN
 	depends on CAN_DEV &amp;&amp; (PPC || M68K || M68KNOMMU)
Index: netlink/kernel/2.6/drivers/net/can/cc770/cc770.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ netlink/kernel/2.6/drivers/net/can/cc770/cc770.c	2009-06-26 09:45:23.595969970 +0200
@@ -0,0 +1,936 @@
+/*
+ * $Id:  $
+ *
+ * cc770.c - Bosch CC770 and Intel AN82527 network device driver
+ *
+ * Copyright (C) 2009 Wolfgang Grandegger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">wg at grandegger.com</A>&gt;
+ *
+ * Derived from the old Socket-CAN i82527 driver:
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License (&quot;GPL&quot;) version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">socketcan-users at lists.berlios.de</A>&gt;
+ */
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/version.h&gt;
+#include &lt;linux/sched.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/fcntl.h&gt;
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/ptrace.h&gt;
+#include &lt;linux/string.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/netdevice.h&gt;
+#include &lt;linux/if_arp.h&gt;
+#include &lt;linux/if_ether.h&gt;
+#include &lt;linux/skbuff.h&gt;
+#include &lt;linux/delay.h&gt;
+
+#include &lt;socketcan/can.h&gt;
+#include &lt;socketcan/can/dev.h&gt;
+#include &lt;socketcan/can/error.h&gt;
+#include &lt;socketcan/can/dev.h&gt;
+
+#include &quot;cc770.h&quot;
+
+#include &lt;socketcan/can/version.h&gt;	/* for RCSID. Removed by mkpatch script */
+#define DRV_NAME  &quot;cc770&quot;
+
+MODULE_AUTHOR(&quot;Wolfgang Grandegger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">wg at grandegger.com</A>&gt;&quot;);
+MODULE_LICENSE(&quot;GPL v2&quot;);
+MODULE_DESCRIPTION(DRV_NAME &quot;CAN netdevice driver&quot;);
+
+/*
+ * The message objects 1..14 can be used for TX and RX while the message
+ * objects 15 is optimized for RX. It has a shadow register for reliable
+ * data receiption under heavy bus load. Therefore it makes sense to use
+ * this message object for the needed use case. The frame type (EFF/SFF)
+ * for the message object 15 can be defined via kernel module parameter
+ * &quot;msgobj15_eff&quot;. If not equal 0, it will receive 29-bit EFF frames,
+ * otherwise 11 bit SFF messages.
+ */
+static int msgobj15_eff;
+module_param(msgobj15_eff, int, S_IRUGO);
+MODULE_PARM_DESC(msgobj15_eff, &quot;Extended 29-bit frames for message object 15 &quot;
+		 &quot;(default: 11-bit standard frames)&quot;);
+
+static int i82527_compat;
+module_param(i82527_compat, int, S_IRUGO);
+MODULE_PARM_DESC(i82527_compat, &quot;Strict Intel 82527 comptibility mode&quot;);
+
+/*
+ * This driver uses the last 5 message objects 11..15. The definitions
+ * and structure below allows to configure and assign them to the real
+ * message object.
+ */
+static unsigned char cc770_obj_flags[CC770_OBJ_MAX] = {
+	[CC770_OBJ_RX0]     = CC770_OBJ_FLAG_RX,
+	[CC770_OBJ_RX1]     = CC770_OBJ_FLAG_RX | CC770_OBJ_FLAG_EFF,
+	[CC770_OBJ_RX_RTR0] = CC770_OBJ_FLAG_RX | CC770_OBJ_FLAG_RTR,
+	[CC770_OBJ_RX_RTR1] = CC770_OBJ_FLAG_RX | CC770_OBJ_FLAG_RTR |
+			      CC770_OBJ_FLAG_EFF,
+	[CC770_OBJ_TX]      = 0,
+};
+
+static struct can_bittiming_const cc770_bittiming_const = {
+	.name = DRV_NAME,
+	.tseg1_min = 1,
+	.tseg1_max = 16,
+	.tseg2_min = 1,
+	.tseg2_max = 8,
+	.sjw_max = 4,
+	.brp_min = 1,
+	.brp_max = 64,
+	.brp_inc = 1,
+};
+
+static inline int intid2obj(unsigned int intid)
+{
+	if (intid == 2)
+		return 0;
+	else
+		return MSGOBJ_LAST + 2 - intid;
+}
+
+static void enable_all_objs(const struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+	u8 msgcfg;
+	unsigned char obj_flags;
+	unsigned int o, mo;
+
+	for (o = 0; o &lt;  CC770_OBJ_MAX; o++) {
+		obj_flags = priv-&gt;obj_flags[o];
+		mo = obj2msgobj(o);
+
+		if (obj_flags &amp; CC770_OBJ_FLAG_RX) {
+			/*
+			 * We don't need extra objects for RTR and EFF if
+			 * the additional CC770 functions are enabled.
+			 */
+			if (priv-&gt;control_normal_mode &amp; CTRL_EAF) {
+				if (o &gt; 0)
+					continue;
+				dev_dbg(ND2D(dev), &quot;Message object %d for &quot;
+					&quot;RX data, RTR, SFF and EFF\n&quot;, mo);
+			} else {
+				dev_dbg(ND2D(dev),
+					&quot;Message object %d for RX %s %s\n&quot;, mo,
+					obj_flags &amp; CC770_OBJ_FLAG_RTR ?
+					&quot;RTR&quot; : &quot;data&quot;,
+					obj_flags &amp; CC770_OBJ_FLAG_EFF ?
+					  &quot;EFF&quot; : &quot;SFF&quot;);
+			}
+
+			if (obj_flags &amp; CC770_OBJ_FLAG_EFF)
+				msgcfg = MSGCFG_XTD;
+			else
+				msgcfg = 0;
+			if (obj_flags &amp; CC770_OBJ_FLAG_RTR)
+				msgcfg |= MSGCFG_DIR;
+
+			cc770_write_reg(priv, msgobj[mo].config, msgcfg);
+			cc770_write_reg(priv, msgobj[mo].ctrl0,
+					MSGVAL_SET | TXIE_RES |
+					RXIE_SET | INTPND_RES);
+
+			if (obj_flags &amp; CC770_OBJ_FLAG_RTR)
+				cc770_write_reg(priv, msgobj[mo].ctrl1,
+						NEWDAT_RES | CPUUPD_SET |
+						TXRQST_RES | RMTPND_RES);
+			else
+				cc770_write_reg(priv, msgobj[mo].ctrl1,
+						NEWDAT_RES | MSGLST_RES |
+						TXRQST_RES | RMTPND_RES);
+		} else {
+			dev_dbg(ND2D(dev), &quot;Message object %d for &quot;
+				&quot;TX data, RTR, SFF and EFF\n&quot;, mo);
+
+			cc770_write_reg(priv, msgobj[mo].ctrl1,
+					RMTPND_RES | TXRQST_RES |
+					CPUUPD_RES | NEWDAT_RES);
+			cc770_write_reg(priv, msgobj[mo].ctrl0,
+					MSGVAL_RES | TXIE_RES |
+					RXIE_RES | INTPND_RES);
+		}
+	}
+}
+
+static void disable_all_objs(const struct cc770_priv *priv)
+{
+	int o, mo;
+
+	for (o = 0; o &lt;  CC770_OBJ_MAX; o++) {
+		mo = obj2msgobj(o);
+
+		if (priv-&gt;obj_flags[o] &amp; CC770_OBJ_FLAG_RX) {
+			if (o &gt; 0 &amp;&amp;
+			    priv-&gt;control_normal_mode &amp; CTRL_EAF)
+				continue;
+
+			cc770_write_reg(priv, msgobj[mo].ctrl1,
+					NEWDAT_RES | MSGLST_RES |
+					TXRQST_RES | RMTPND_RES);
+			cc770_write_reg(priv, msgobj[mo].ctrl0,
+					MSGVAL_RES | TXIE_RES |
+					RXIE_RES | INTPND_RES);
+		} else {
+			/* Clear message object for send */
+			cc770_write_reg(priv, msgobj[mo].ctrl1,
+					RMTPND_RES | TXRQST_RES |
+					CPUUPD_RES | NEWDAT_RES);
+			cc770_write_reg(priv, msgobj[mo].ctrl0,
+					MSGVAL_RES | TXIE_RES |
+					RXIE_RES | INTPND_RES);
+		}
+	}
+}
+
+static void set_reset_mode(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+
+	/* Enable configuration and puts chip in bus-off, disable interrupts */
+	cc770_write_reg(priv, control, CTRL_CCE | CTRL_INI);
+
+	priv-&gt;can.state = CAN_STATE_STOPPED;
+
+	/* Clear interrupts */
+	cc770_read_reg(priv, interrupt);
+
+	/* Clear status register */
+	cc770_write_reg(priv, status, 0);
+
+	/* Disable all used message objects */
+	disable_all_objs(priv);
+}
+
+static void set_normal_mode(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+
+	/* Clear interrupts */
+	cc770_read_reg(priv, interrupt);
+
+	/* Clear status register and pre-set last error code */
+	cc770_write_reg(priv, status, STAT_LEC_MASK);
+
+	/* Enable all used message objects*/
+	enable_all_objs(dev);
+
+	/*
+	 * Clear bus-off, interrupts only for errors,
+	 * not for status change
+	 */
+	cc770_write_reg(priv, control, priv-&gt;control_normal_mode);
+
+	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
+}
+
+static void chipset_init(struct cc770_priv *priv)
+{
+	int mo, id, data;
+
+	/* Enable configuration and put chip in bus-off, disable interrupts */
+	cc770_write_reg(priv, control, (CTRL_CCE | CTRL_INI));
+
+	/* Check if this chip is a CC770 supporting additional functions */
+	if (cc770_read_reg(priv, control) &amp; CTRL_EAF)
+		priv-&gt;control_normal_mode |= CTRL_EAF;
+
+	/* Set CLKOUT divider and slew rates */
+	cc770_write_reg(priv, clkout, priv-&gt;clkout);
+
+	/* Configure CPU interface / CLKOUT enable */
+	cc770_write_reg(priv, cpu_interface, priv-&gt;cpu_interface | CPUIF_CEN);
+
+	/* Set bus configuration  */
+	cc770_write_reg(priv, bus_config, priv-&gt;bus_config);
+
+	/* Clear interrupts */
+	cc770_read_reg(priv, interrupt);
+
+	/* Clear status register */
+	cc770_write_reg(priv, status, 0);
+
+	/* Clear and invalidate message objects */
+	for (mo = MSGOBJ_FIRST; mo &lt;= MSGOBJ_LAST; mo++) {
+		cc770_write_reg(priv, msgobj[mo].ctrl0,
+				INTPND_UNC | RXIE_RES |
+				TXIE_RES | MSGVAL_RES);
+		cc770_write_reg(priv, msgobj[mo].ctrl0,
+				INTPND_RES | RXIE_RES |
+				TXIE_RES | MSGVAL_RES);
+		cc770_write_reg(priv, msgobj[mo].ctrl1,
+				NEWDAT_RES | MSGLST_RES |
+				TXRQST_RES | RMTPND_RES);
+		for (data = 0; data &lt; 8; data++)
+			cc770_write_reg(priv, msgobj[mo].data[data], 0);
+		for (id = 0; id &lt; 4; id++)
+			cc770_write_reg(priv, msgobj[mo].id[id], 0);
+		cc770_write_reg(priv, msgobj[mo].config, 0);
+	}
+
+	/* Set all global ID masks to &quot;don't care&quot; */
+	cc770_write_reg(priv, global_mask_std[0], 0);
+	cc770_write_reg(priv, global_mask_std[1], 0);
+	cc770_write_reg(priv, global_mask_ext[0], 0);
+	cc770_write_reg(priv, global_mask_ext[1], 0);
+	cc770_write_reg(priv, global_mask_ext[2], 0);
+	cc770_write_reg(priv, global_mask_ext[3], 0);
+
+}
+
+static int cc770_probe_chip(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+
+	/* Enable configuration, put chip in bus-off, disable ints */
+	cc770_write_reg(priv, control, CTRL_CCE | CTRL_EAF | CTRL_INI);
+	/* Configure cpu interface / CLKOUT disable */
+	cc770_write_reg(priv, cpu_interface, priv-&gt;cpu_interface);
+
+	/*
+	 * Check if hardware reset is still inactive or maybe there
+	 * is no chip in this address space
+	 */
+	if (cc770_read_reg(priv, cpu_interface) &amp; CPUIF_RST) {
+		dev_info(ND2D(dev), &quot;probing @0x%p failed (reset)\n&quot;,
+			 priv-&gt;reg_base);
+		return 0;
+	}
+
+	/* Write and read back test pattern */
+	cc770_write_reg(priv, msgobj[1].data[1], 0x25);
+	cc770_write_reg(priv, msgobj[2].data[3], 0x52);
+	cc770_write_reg(priv, msgobj[10].data[6], 0xc3);
+	if ((cc770_read_reg(priv, msgobj[1].data[1]) != 0x25) ||
+	    (cc770_read_reg(priv, msgobj[2].data[3]) != 0x52) ||
+	    (cc770_read_reg(priv, msgobj[10].data[6]) != 0xc3)) {
+		dev_info(ND2D(dev), &quot;probing @0x%p failed (pattern)\n&quot;,
+			 priv-&gt;reg_base);
+		return 0;
+	}
+
+	/* Check if this chip is a CC770 supporting additional functions */
+	if (cc770_read_reg(priv, control) &amp; CTRL_EAF)
+		priv-&gt;control_normal_mode |= CTRL_EAF;
+
+	return 1;
+}
+
+static void cc770_start(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+
+	/* leave reset mode */
+	if (priv-&gt;can.state != CAN_STATE_STOPPED)
+		set_reset_mode(dev);
+
+	/* leave reset mode */
+	set_normal_mode(dev);
+}
+
+static int cc770_set_mode(struct net_device *dev, enum can_mode mode)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+
+	if (!priv-&gt;open_time)
+		return -EINVAL;
+
+	switch (mode) {
+	case CAN_MODE_START:
+		cc770_start(dev);
+		if (netif_queue_stopped(dev))
+			netif_wake_queue(dev);
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int cc770_set_bittiming(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+	struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
+	u8 btr0, btr1;
+
+	btr0 = ((bt-&gt;brp - 1) &amp; 0x3f) | (((bt-&gt;sjw - 1) &amp; 0x3) &lt;&lt; 6);
+	btr1 = ((bt-&gt;prop_seg + bt-&gt;phase_seg1 - 1) &amp; 0xf) |
+		(((bt-&gt;phase_seg2 - 1) &amp; 0x7) &lt;&lt; 4);
+	if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES)
+		btr1 |= 0x80;
+
+	dev_info(ND2D(dev),
+		 &quot;setting BTR0=0x%02x BTR1=0x%02x\n&quot;, btr0, btr1);
+
+	cc770_write_reg(priv, bit_timing_0, btr0);
+	cc770_write_reg(priv, bit_timing_1, btr1);
+
+	return 0;
+}
+
+static int cc770_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+#endif
+	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
+	unsigned int mo = obj2msgobj(CC770_OBJ_TX);
+	u8 dlc, rtr;
+	u32 id;
+	int i;
+
+	if ((cc770_read_reg(priv,
+			    msgobj[mo].ctrl1) &amp; TXRQST_UNC) == TXRQST_SET) {
+		dev_err(ND2D(dev), &quot;TX register is still occupied!\n&quot;);
+		return NETDEV_TX_BUSY;
+	}
+
+	netif_stop_queue(dev);
+
+	dlc = cf-&gt;can_dlc;
+	id = cf-&gt;can_id;
+	if (cf-&gt;can_id &amp; CAN_RTR_FLAG)
+		rtr = 0;
+	else
+		rtr = MSGCFG_DIR;
+	cc770_write_reg(priv, msgobj[mo].ctrl1,
+			RMTPND_RES | TXRQST_RES | CPUUPD_SET | NEWDAT_RES);
+	cc770_write_reg(priv, msgobj[mo].ctrl0,
+			MSGVAL_SET | TXIE_SET | RXIE_RES | INTPND_RES);
+	if (id &amp; CAN_EFF_FLAG) {
+		id &amp;= CAN_EFF_MASK;
+		cc770_write_reg(priv, msgobj[mo].config,
+				(dlc &lt;&lt; 4) + rtr + MSGCFG_XTD);
+		cc770_write_reg(priv, msgobj[mo].id[3],
+				(id &lt;&lt; 3) &amp; 0xFFU);
+		cc770_write_reg(priv, msgobj[mo].id[2],
+				(id &gt;&gt; 5) &amp; 0xFFU);
+		cc770_write_reg(priv, msgobj[mo].id[1],
+				(id &gt;&gt; 13) &amp; 0xFFU);
+		cc770_write_reg(priv, msgobj[mo].id[0],
+				(id &gt;&gt; 21) &amp; 0xFFU);
+	} else {
+		id &amp;= CAN_SFF_MASK;
+		cc770_write_reg(priv, msgobj[mo].config,
+				(dlc &lt;&lt; 4) + rtr);
+		cc770_write_reg(priv, msgobj[mo].id[0],
+				(id &gt;&gt; 3) &amp; 0xFFU);
+		cc770_write_reg(priv, msgobj[mo].id[1],
+				(id &lt;&lt; 5) &amp; 0xFFU);
+	}
+
+	dlc &amp;= 0x0f;		/* restore length only */
+	for (i = 0; i &lt; dlc; i++)
+		cc770_write_reg(priv, msgobj[mo].data[i], cf-&gt;data[i]);
+
+	cc770_write_reg(priv, msgobj[mo].ctrl1,
+			RMTPND_RES | TXRQST_SET | CPUUPD_RES | NEWDAT_UNC);
+
+	stats-&gt;tx_bytes += dlc;
+	dev-&gt;trans_start = jiffies;
+
+	can_put_echo_skb(skb, dev, 0);
+
+	/*
+	 * HM: We had some cases of repeated IRQs so make sure the
+	 * INT is acknowledged I know it's already further up, but
+	 * doing again fixed the issue
+	 */
+	cc770_write_reg(priv, msgobj[mo].ctrl0,
+			MSGVAL_UNC | TXIE_UNC | RXIE_UNC | INTPND_RES);
+
+	return NETDEV_TX_OK;
+}
+
+static void cc770_rx(struct net_device *dev, unsigned int mo, u8 ctrl1)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+#endif
+	struct can_frame *cf;
+	struct sk_buff *skb;
+	u8 config, dlc;
+	u32 id;
+	int i;
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (skb == NULL)
+		return;
+	skb-&gt;dev = dev;
+	skb-&gt;protocol = htons(ETH_P_CAN);
+
+	cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
+	config = cc770_read_reg(priv, msgobj[mo].config);
+
+	if (ctrl1 &amp; RMTPND_SET) {
+		/*
+		 * Unfortunately, the chip does not store the real message
+		 * identifier of the received remote transmission request
+		 * frame. Therefore we set it to 0.
+		 */
+		cf-&gt;can_id = CAN_RTR_FLAG;
+		if (config &amp; MSGCFG_XTD)
+			cf-&gt;can_id |= CAN_EFF_FLAG;
+		cf-&gt;can_dlc = 0;
+	} else {
+		if (config &amp; MSGCFG_XTD) {
+			id = cc770_read_reg(priv, msgobj[mo].id[3]);
+			id |= cc770_read_reg(priv, msgobj[mo].id[2]) &lt;&lt; 8;
+			id |= cc770_read_reg(priv, msgobj[mo].id[1]) &lt;&lt; 16;
+			id |= cc770_read_reg(priv, msgobj[mo].id[0]) &lt;&lt; 24;
+			id &gt;&gt;= 3;
+			id |= CAN_EFF_FLAG;
+		} else {
+			id = cc770_read_reg(priv, msgobj[mo].id[1]);
+			id |= cc770_read_reg(priv, msgobj[mo].id[0]) &lt;&lt; 8;
+			id &gt;&gt;= 5;
+		}
+
+		dlc = (config &amp; 0xf0) &gt;&gt; 4; /* strip length code */
+		if (dlc &gt; 8)
+			dlc = 8;	/* limit count to 8 bytes */
+
+		cf-&gt;can_id = id;
+		cf-&gt;can_dlc = dlc;
+		for (i = 0; i &lt; dlc; i++)
+			cf-&gt;data[i] = cc770_read_reg(priv, msgobj[mo].data[i]);
+	}
+	netif_rx(skb);
+
+	dev-&gt;last_rx = jiffies;
+	stats-&gt;rx_packets++;
+	stats-&gt;rx_bytes += cf-&gt;can_dlc;
+}
+
+static int cc770_err(struct net_device *dev, u8 status)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+#endif
+	struct can_frame *cf;
+	struct sk_buff *skb;
+	u8 lec;
+
+	dev_dbg(ND2D(dev), &quot;status interrupt (%#x)\n&quot;, status);
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (skb == NULL)
+		return -ENOMEM;
+	skb-&gt;dev = dev;
+	skb-&gt;protocol = htons(ETH_P_CAN);
+	cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
+	memset(cf, 0, sizeof(struct can_frame));
+	cf-&gt;can_id = CAN_ERR_FLAG;
+	cf-&gt;can_dlc = CAN_ERR_DLC;
+
+	if (status &amp; STAT_BOFF) {
+		/* Disable interrupts */
+		cc770_write_reg(priv, control, CTRL_INI);
+		cf-&gt;can_id |= CAN_ERR_BUSOFF;
+		priv-&gt;can.state = CAN_STATE_BUS_OFF;
+		can_bus_off(dev);
+	} else if (status &amp; STAT_WARN) {
+		cf-&gt;can_id |= CAN_ERR_CRTL;
+		cf-&gt;data[1] = CAN_ERR_CRTL_RX_WARNING | CAN_ERR_CRTL_TX_WARNING;
+		priv-&gt;can.state = CAN_STATE_ERROR_WARNING;
+		priv-&gt;can.can_stats.error_warning++;
+	}
+
+	lec = status &amp; STAT_LEC_MASK;
+	if (lec &lt; 7 &amp;&amp; lec &gt; 0) {
+		if (lec == STAT_LEC_ACK) {
+			cf-&gt;can_id |= CAN_ERR_ACK;
+		} else {
+			cf-&gt;can_id |= CAN_ERR_PROT;
+			switch (lec) {
+			case STAT_LEC_STUFF:
+				cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
+				break;
+			case STAT_LEC_FORM:
+				cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
+				break;
+			case STAT_LEC_BIT1:
+				cf-&gt;data[2] |= CAN_ERR_PROT_BIT1;
+				break;
+			case STAT_LEC_BIT0:
+				cf-&gt;data[2] |= CAN_ERR_PROT_BIT0;
+				break;
+			case STAT_LEC_CRC:
+				cf-&gt;data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;
+				break;
+			}
+		}
+	}
+
+	netif_rx(skb);
+
+	dev-&gt;last_rx = jiffies;
+	stats-&gt;rx_packets++;
+	stats-&gt;rx_bytes += cf-&gt;can_dlc;
+
+	return 0;
+}
+
+static int cc770_status_interrupt(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+	u8 status;
+
+	status = cc770_read_reg(priv, status);
+	/* Reset the status register including RXOK and TXOK */
+	cc770_write_reg(priv, status, STAT_LEC_MASK);
+
+	if (status &amp; (STAT_WARN | STAT_BOFF) ||
+	    (status &amp; STAT_LEC_MASK) != STAT_LEC_MASK) {
+		cc770_err(dev, status);
+		return status &amp; STAT_BOFF;
+	}
+
+	return 0;
+}
+
+static void cc770_rx_interrupt(struct net_device *dev, unsigned int o)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+#endif
+	unsigned int mo = obj2msgobj(o);
+	u8 ctrl1;
+
+	while (1) {
+		ctrl1 = cc770_read_reg(priv, msgobj[mo].ctrl1);
+
+		if (!(ctrl1 &amp; NEWDAT_SET))  {
+			/* Check for RTR if additional functions are enabled */
+			if (priv-&gt;control_normal_mode &amp; CTRL_EAF) {
+				if (!(cc770_read_reg(priv, msgobj[mo].ctrl0) &amp;
+				      INTPND_SET))
+					break;
+			} else {
+				break;
+			}
+		}
+
+		if (ctrl1 &amp; MSGLST_SET) {
+			stats-&gt;rx_over_errors++;
+			stats-&gt;rx_errors++;
+		}
+		if (mo &lt; MSGOBJ_LAST)
+			cc770_write_reg(priv, msgobj[mo].ctrl1,
+					NEWDAT_RES | MSGLST_RES |
+					TXRQST_UNC | RMTPND_UNC);
+		cc770_rx(dev, mo, ctrl1);
+
+		cc770_write_reg(priv, msgobj[mo].ctrl0,
+				MSGVAL_SET | TXIE_RES |
+				RXIE_SET | INTPND_RES);
+		cc770_write_reg(priv, msgobj[mo].ctrl1,
+				NEWDAT_RES | MSGLST_RES |
+				TXRQST_RES | RMTPND_RES);
+	}
+}
+
+static void cc770_rtr_interrupt(struct net_device *dev, unsigned int o)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+	unsigned int mo = obj2msgobj(o);
+	u8 ctrl0, ctrl1;
+
+	while (1) {
+		ctrl0 = cc770_read_reg(priv, msgobj[mo].ctrl0);
+		if (!(ctrl0 &amp; INTPND_SET))
+			break;
+
+		ctrl1 = cc770_read_reg(priv, msgobj[mo].ctrl1);
+		cc770_rx(dev, mo, ctrl1);
+
+		cc770_write_reg(priv, msgobj[mo].ctrl0,
+				MSGVAL_SET | TXIE_RES |
+				RXIE_SET | INTPND_RES);
+		cc770_write_reg(priv, msgobj[mo].ctrl1,
+				NEWDAT_RES | CPUUPD_SET |
+				TXRQST_RES | RMTPND_RES);
+	}
+}
+
+static void cc770_tx_interrupt(struct net_device *dev, unsigned int o)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
+	struct net_device_stats *stats = can_get_stats(dev);
+#else
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+#endif
+	unsigned int mo = obj2msgobj(o);
+
+	/* Nothing more to send, switch off interrupts */
+	cc770_write_reg(priv, msgobj[mo].ctrl0,
+			MSGVAL_RES | TXIE_RES | RXIE_RES | INTPND_RES);
+	/*
+	 * We had some cases of repeated IRQ so make sure the
+	 * INT is acknowledged
+	 */
+	cc770_write_reg(priv, msgobj[mo].ctrl0,
+			MSGVAL_UNC | TXIE_UNC | RXIE_UNC | INTPND_RES);
+
+	stats-&gt;tx_packets++;
+	can_get_echo_skb(dev, 0);
+	netif_wake_queue(dev);
+}
+
+#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,19)
+irqreturn_t cc770_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+#else
+irqreturn_t cc770_interrupt(int irq, void *dev_id)
+#endif
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct cc770_priv *priv = netdev_priv(dev);
+	u8 intid;
+	int o, n = 0;
+
+	/* Shared interrupts and IRQ off? */
+	if (priv-&gt;can.state == CAN_STATE_STOPPED)
+		return IRQ_NONE;
+
+	if (priv-&gt;pre_irq)
+		priv-&gt;pre_irq(priv);
+
+	while (n &lt; CC770_MAX_IRQ) {
+		/* Read the highest pending interrupt request */
+		intid = cc770_read_reg(priv, interrupt);
+		if (!intid)
+			break;
+		n++;
+
+		if (intid == 1) {
+			/* Exit in case of bus-off */
+			if (cc770_status_interrupt(dev))
+				break;
+		} else {
+			o = intid2obj(intid);
+
+			if (o &gt;= CC770_OBJ_MAX) {
+				dev_err(ND2D(dev),
+					&quot;Unexpected interrupt id %d\n&quot;, intid);
+				continue;
+			}
+
+			if (priv-&gt;obj_flags[o] &amp; CC770_OBJ_FLAG_RTR)
+				cc770_rtr_interrupt(dev, o);
+			else if (priv-&gt;obj_flags[o] &amp; CC770_OBJ_FLAG_RX)
+				cc770_rx_interrupt(dev, o);
+			else
+				cc770_tx_interrupt(dev, o);
+		}
+	}
+
+	if (priv-&gt;post_irq)
+		priv-&gt;post_irq(priv);
+
+	if (n &gt;= CC770_MAX_IRQ)
+		dev_dbg(ND2D(dev), &quot;%d messages handled in ISR&quot;, n);
+
+	return (n) ? IRQ_HANDLED : IRQ_NONE;
+}
+
+static int cc770_open(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+	int err;
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	/* common open */
+	err = open_candev(dev);
+	if (err)
+		return err;
+
+	err = request_irq(dev-&gt;irq, &amp;cc770_interrupt, priv-&gt;irq_flags,
+			  dev-&gt;name, (void *)dev);
+	if (err) {
+		close_candev(dev);
+		return -EAGAIN;
+	}
+
+#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
+	/* clear statistics */
+	memset(&amp;priv-&gt;can.net_stats, 0, sizeof(priv-&gt;can.net_stats));
+#endif
+
+	/* init and start chip */
+	cc770_start(dev);
+	priv-&gt;open_time = jiffies;
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int cc770_close(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+
+	netif_stop_queue(dev);
+	set_reset_mode(dev);
+
+	close_candev(dev);
+
+	priv-&gt;open_time = 0;
+
+	return 0;
+}
+
+struct net_device *alloc_cc770dev(int sizeof_priv)
+{
+	struct net_device *dev;
+	struct cc770_priv *priv;
+
+	dev = alloc_candev(sizeof(struct cc770_priv) + sizeof_priv);
+	if (!dev)
+		return NULL;
+
+	priv = netdev_priv(dev);
+
+	priv-&gt;dev = dev;
+	priv-&gt;can.bittiming_const = &amp;cc770_bittiming_const;
+	priv-&gt;can.do_set_bittiming = cc770_set_bittiming;
+	priv-&gt;can.do_set_mode = cc770_set_mode;
+
+	memcpy(priv-&gt;obj_flags, cc770_obj_flags, sizeof(cc770_obj_flags));
+
+	if (sizeof_priv)
+		priv-&gt;priv = (void *)priv + sizeof(struct cc770_priv);
+
+	return dev;
+}
+EXPORT_SYMBOL_GPL(alloc_cc770dev);
+
+void free_cc770dev(struct net_device *dev)
+{
+	free_candev(dev);
+}
+EXPORT_SYMBOL_GPL(free_cc770dev);
+
+#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
+static const struct net_device_ops cc770_netdev_ops = {
+	.ndo_open               = cc770_open,
+	.ndo_stop               = cc770_close,
+	.ndo_start_xmit         = cc770_start_xmit,
+};
+#endif
+
+int register_cc770dev(struct net_device *dev)
+{
+	struct cc770_priv *priv = netdev_priv(dev);
+
+	if (!cc770_probe_chip(dev))
+		return -ENODEV;
+
+#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
+	dev-&gt;netdev_ops = &amp;cc770_netdev_ops;
+#else
+	dev-&gt;open = cc770_open;
+	dev-&gt;stop = cc770_close;
+	dev-&gt;hard_start_xmit = cc770_start_xmit;
+#endif
+
+	dev-&gt;flags |= IFF_ECHO;	/* we support local echo */
+
+	/* Should we use additional functions? */
+	if (!i82527_compat &amp;&amp; priv-&gt;control_normal_mode &amp; CTRL_EAF) {
+		priv-&gt;control_normal_mode = CTRL_IE | CTRL_EAF | CTRL_EIE;
+		dev_dbg(ND2D(dev), &quot;i82527 mode with additional functions\n&quot;);
+	} else {
+		priv-&gt;control_normal_mode = CTRL_IE | CTRL_EIE;
+		dev_dbg(ND2D(dev), &quot;strict i82527 compatibility mode\n&quot;);
+	}
+
+	chipset_init(priv);
+	set_reset_mode(dev);
+
+	return register_candev(dev);
+}
+EXPORT_SYMBOL_GPL(register_cc770dev);
+
+void unregister_cc770dev(struct net_device *dev)
+{
+	set_reset_mode(dev);
+	unregister_candev(dev);
+}
+EXPORT_SYMBOL_GPL(unregister_cc770dev);
+
+static __init int cc770_init(void)
+{
+	if (msgobj15_eff) {
+		cc770_obj_flags[CC770_OBJ_RX0] |= CC770_OBJ_FLAG_EFF;
+		cc770_obj_flags[CC770_OBJ_RX1] &amp;= ~CC770_OBJ_FLAG_EFF;
+	}
+
+	printk(KERN_INFO &quot;%s CAN netdevice driver\n&quot;, DRV_NAME);
+
+	return 0;
+}
+
+module_init(cc770_init);
+
+static __exit void cc770_exit(void)
+{
+	printk(KERN_INFO &quot;%s: driver removed\n&quot;, DRV_NAME);
+}
+module_exit(cc770_exit);
Index: netlink/kernel/2.6/drivers/net/can/cc770/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ netlink/kernel/2.6/drivers/net/can/cc770/Makefile	2009-06-26 09:48:07.068970135 +0200
@@ -0,0 +1,24 @@
+#
+#  $Id: Makefile 443 2007-07-25 11:41:27Z hartkopp $
+#
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+
+obj-$(CONFIG_CAN_CC770) += cc770.o
+
+ifeq ($(CONFIG_CAN_DEBUG_DEVICES),y)
+	EXTRA_CFLAGS += -DDEBUG
+endif
+
+endif

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002755.html">[PATCH] cc770-isa: legacy driver for CC770/i82725 on the ISA bus
</A></li>
	<LI>Next message: <A HREF="002758.html">[PATCH v2] cc770: driver for the Bosch CC770 and the Intel AN82527
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2756">[ date ]</a>
              <a href="thread.html#2756">[ thread ]</a>
              <a href="subject.html#2756">[ subject ]</a>
              <a href="author.html#2756">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
