<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH] [at91_can] add NAPI support fix error and bus off handling
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20%5Bat91_can%5D%20add%20NAPI%20support%20fix%20error%20and%20bus%20off%20handling&In-Reply-To=%3Cmailman.27.1331738151.11849.socketcan-core%40lists.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003086.html">
   <LINK REL="Next"  HREF="003088.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH] [at91_can] add NAPI support fix error and bus off handling</H1>
    <B>Marc Kleine-Budde</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20%5Bat91_can%5D%20add%20NAPI%20support%20fix%20error%20and%20bus%20off%20handling&In-Reply-To=%3Cmailman.27.1331738151.11849.socketcan-core%40lists.berlios.de%3E"
       TITLE="[PATCH] [at91_can] add NAPI support fix error and bus off handling">mkl at pengutronix.de
       </A><BR>
    <I>Tue Sep 15 16:02:07 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003086.html">[PATCH 2/2] ems_usb: Added support for EMS CPC-USB/ARM7 CAN/USB	interface
</A></li>
        <LI>Next message: <A HREF="003088.html">[PATCH v4] at91_can
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3090">[ date ]</a>
              <a href="thread.html#3090">[ thread ]</a>
              <a href="subject.html#3090">[ subject ]</a>
              <a href="author.html#3090">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This patch updates the at91_can driver it features:
- NAPI for rx and error packages
  (tx and state changes stay in irq handler)
- implemented bus off and errror handling conforming to the
  Linux CAN API

Signed-off-by: Marc Kleine-Budde &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">mkl at pengutronix.de</A>&gt;
---
 drivers/net/can/at91_can.c | 1132 ++++++++++++++++++++++----------------------
 1 files changed, 574 insertions(+), 558 deletions(-)

diff --git a/drivers/net/can/at91_can.c b/drivers/net/can/at91_can.c
index fdf82fb..7f576b4 100644
--- a/drivers/net/can/at91_can.c
+++ b/drivers/net/can/at91_can.c
@@ -1,8 +1,8 @@
 /*
- * at91_can.c -  CAN network driver for AT91 SoC CAN controller
+ * at91_can.c - CAN network driver for AT91 SoC CAN controller
  *
  * (C) 2007 by Hans J. Koch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">hjk at linutronix.de</A>&gt;
- * (C) 2008 by Marc Kleine-Budde &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kernel at pengutronix.de</A>&gt;
+ * (C) 2008, 2009 by Marc Kleine-Budde &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kernel at pengutronix.de</A>&gt;
  *
  * This software may be distributed under the terms of the GNU General
  * Public License (&quot;GPL&quot;) version 2 as distributed in the 'COPYING'
@@ -12,28 +12,28 @@
  *
  */
 
-#include &lt;linux/platform_device.h&gt;
+#include &lt;linux/clk.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/if_arp.h&gt;
+#include &lt;linux/init.h&gt;
 #include &lt;linux/interrupt.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
 #include &lt;linux/netdevice.h&gt;
+#include &lt;linux/platform_device.h&gt;
+#include &lt;linux/skbuff.h&gt;
 #include &lt;linux/spinlock.h&gt;
-#include &lt;linux/module.h&gt;
-#include &lt;linux/kernel.h&gt;
 #include &lt;linux/string.h&gt;
-#include &lt;linux/if_arp.h&gt;
-#include &lt;linux/skbuff.h&gt;
 #include &lt;linux/types.h&gt;
-#include &lt;linux/errno.h&gt;
-#include &lt;linux/init.h&gt;
-#include &lt;linux/clk.h&gt;
 
 #include &lt;socketcan/can.h&gt;
-#include &lt;socketcan/can/error.h&gt;
 #include &lt;socketcan/can/dev.h&gt;
+#include &lt;socketcan/can/error.h&gt;
 
 #include &lt;mach/board.h&gt;
 
 #define DRV_NAME		&quot;at91_can&quot;
-#define MAX_INTERRUPT_WORK	4
+#define AT91_NAPI_WEIGHT	12
 
 /*
  * RX/TX Mailbox split
@@ -44,15 +44,21 @@
 
 #define AT91_MB_RX_FIRST	0
 #define AT91_MB_RX_LAST		(AT91_MB_RX_FIRST + AT91_MB_RX_NUM - 1)
-#define AT91_MB_RX_BANKS	3
-#define AT91_MB_RX_BANK_WIDTH	(AT91_MB_RX_NUM / AT91_MB_RX_BANKS)
-#define AT91_MB_RX_BANK_MASK(i)	(((1 &lt;&lt; AT91_MB_RX_BANK_WIDTH) - 1) &lt;&lt; \
-				(AT91_MB_RX_BANK_WIDTH * (i)))
+
+#define AT91_MB_RX_MASK(i)	((1 &lt;&lt; (i)) - 1)
+#define AT91_MB_RX_SPLIT	8
+#define AT91_MB_RX_LOW_LAST	(AT91_MB_RX_SPLIT - 1)
+#define AT91_MB_RX_LOW_MASK	(AT91_MB_RX_MASK(AT91_MB_RX_SPLIT))
 
 #define AT91_MB_TX_NUM		(1 &lt;&lt; AT91_MB_TX_SHIFT)
 #define AT91_MB_TX_FIRST	(AT91_MB_RX_LAST + 1)
 #define AT91_MB_TX_LAST		(AT91_MB_TX_FIRST + AT91_MB_TX_NUM - 1)
 
+#define AT91_NEXT_PRIO_SHIFT	(AT91_MB_TX_SHIFT)
+#define AT91_NEXT_PRIO_MASK	(0xf &lt;&lt; AT91_MB_TX_SHIFT)
+#define AT91_NEXT_MB_MASK	(AT91_MB_TX_NUM - 1)
+#define AT91_NEXT_MASK		((AT91_MB_TX_NUM - 1) | AT91_NEXT_PRIO_MASK)
+
 /* Common registers */
 enum at91_reg {
 	AT91_MR		= 0x000,
@@ -79,28 +85,28 @@ enum at91_reg {
 #define AT91_MCR(i)		(enum at91_reg)(0x21C + ((i) * 0x20))
 
 /* Register bits */
-#define AT91_MR_AT91EN		(1 &lt;&lt; 0)
-#define AT91_MR_LPM		(1 &lt;&lt; 1)
-#define AT91_MR_ABM		(1 &lt;&lt; 2)
-#define AT91_MR_OVL		(1 &lt;&lt; 3)
-#define AT91_MR_TEOF		(1 &lt;&lt; 4)
-#define AT91_MR_TTM		(1 &lt;&lt; 5)
-#define AT91_MR_TIMFRZ		(1 &lt;&lt; 6)
-#define AT91_MR_DRPT		(1 &lt;&lt; 7)
+#define AT91_MR_CANEN		BIT(0)
+#define AT91_MR_LPM		BIT(1)
+#define AT91_MR_ABM		BIT(2)
+#define AT91_MR_OVL		BIT(3)
+#define AT91_MR_TEOF		BIT(4)
+#define AT91_MR_TTM		BIT(5)
+#define AT91_MR_TIMFRZ		BIT(6)
+#define AT91_MR_DRPT		BIT(7)
 
-#define AT91_SR_RBSY		(1 &lt;&lt; 29)
+#define AT91_SR_RBSY		BIT(29)
 
-#define AT91_MMR_PRIO_SHIFT	16
+#define AT91_MMR_PRIO_SHIFT	(16)
 
-#define AT91_MID_MIDE		(1 &lt;&lt; 29)
+#define AT91_MID_MIDE		BIT(29)
 
-#define AT91_MSR_MRTR		(1 &lt;&lt; 20)
-#define AT91_MSR_MABT		(1 &lt;&lt; 22)
-#define AT91_MSR_MRDY		(1 &lt;&lt; 23)
-#define AT91_MSR_MMI		(1 &lt;&lt; 24)
+#define AT91_MSR_MRTR		BIT(20)
+#define AT91_MSR_MABT		BIT(22)
+#define AT91_MSR_MRDY		BIT(23)
+#define AT91_MSR_MMI		BIT(24)
 
-#define AT91_MCR_MRTR		(1 &lt;&lt; 20)
-#define AT91_MCR_MTCR		(1 &lt;&lt; 23)
+#define AT91_MCR_MRTR		BIT(20)
+#define AT91_MCR_MTCR		BIT(23)
 
 /* Mailbox Modes */
 enum at91_mb_mode {
@@ -114,10 +120,10 @@ enum at91_mb_mode {
 
 /* Interrupt mask bits */
 #define AT91_IRQ_MB_RX		((1 &lt;&lt; (AT91_MB_RX_LAST + 1)) \
-				- (1 &lt;&lt; AT91_MB_RX_FIRST))
+				 - (1 &lt;&lt; AT91_MB_RX_FIRST))
 #define AT91_IRQ_MB_TX		((1 &lt;&lt; (AT91_MB_TX_LAST + 1)) \
-				- (1 &lt;&lt; AT91_MB_TX_FIRST))
-#define AT91_IRQ_MB_AL		(AT91_IRQ_MB_RX | AT91_IRQ_MB_TX)
+				 - (1 &lt;&lt; AT91_MB_TX_FIRST))
+#define AT91_IRQ_MB_ALL		(AT91_IRQ_MB_RX | AT91_IRQ_MB_TX)
 
 #define AT91_IRQ_ERRA		(1 &lt;&lt; 16)
 #define AT91_IRQ_WARN		(1 &lt;&lt; 17)
@@ -133,111 +139,214 @@ enum at91_mb_mode {
 #define AT91_IRQ_FERR		(1 &lt;&lt; 27)
 #define AT91_IRQ_BERR		(1 &lt;&lt; 28)
 
-#define	AT91_IRQ_ERR_ALL	0x1fff0000
-#define AT91_IRQ_ERR_CANFRAME	(AT91_IRQ_CERR | AT91_IRQ_SERR | \
+#define AT91_IRQ_ERR_ALL	(0x1fff0000)
+#define AT91_IRQ_ERR_FRAME	(AT91_IRQ_CERR | AT91_IRQ_SERR | \
 				 AT91_IRQ_AERR | AT91_IRQ_FERR | AT91_IRQ_BERR)
 #define AT91_IRQ_ERR_LINE	(AT91_IRQ_ERRA | AT91_IRQ_WARN | \
 				 AT91_IRQ_ERRP | AT91_IRQ_BOFF)
 
+#define AT91_IRQ_ALL		(0x1fffffff)
+
 struct at91_priv {
-	struct can_priv		can;	/* must be the first member! */
+	struct can_priv		can;	   /* must be the first member! */
+	struct net_device	*dev;
+	struct napi_struct	napi;
 
-	struct clk		*clk;
-	struct at91_can_data	*pdata;
+	void __iomem		*reg_base;
 
-#define AT91_NEXT_PRIO_SHIFT	(AT91_MB_TX_SHIFT)
-#define AT91_NEXT_PRIO_MASK	(0xf &lt;&lt; AT91_MB_TX_SHIFT)
-#define AT91_NEXT_MB_MASK	(AT91_MB_TX_NUM - 1)
-#define AT91_NEXT_MASK		((AT91_MB_TX_NUM - 1) | AT91_NEXT_PRIO_MASK)
+	u32			reg_sr;
 	unsigned int		tx_next;
 	unsigned int		tx_echo;
+	unsigned int		rx_next;
 
-	unsigned int		rx_bank;
-	void __iomem		*reg_base; /* ioremap'ed address to registers */
+	struct clk		*clk;
+	struct at91_can_data	*pdata;
 };
 
-
 static struct can_bittiming_const at91_bittiming_const = {
-	.tseg1_min = 4,
-	.tseg1_max = 16,
-	.tseg2_min = 2,
-	.tseg2_max = 8,
-	.sjw_max = 4,
-	.brp_min = 2,
-	.brp_max = 128,
-	.brp_inc = 1,
+	.tseg1_min	= 4,
+	.tseg1_max	= 16,
+	.tseg2_min	= 2,
+	.tseg2_max	= 8,
+	.sjw_max	= 4,
+	.brp_min 	= 2,
+	.brp_max	= 128,
+	.brp_inc	= 1,
 };
 
-
-static inline int get_tx_next_mb(struct at91_priv *priv)
+static inline int get_tx_next_mb(const struct at91_priv *priv)
 {
 	return (priv-&gt;tx_next &amp; AT91_NEXT_MB_MASK) + AT91_MB_TX_FIRST;
 }
 
-static inline int get_tx_next_prio(struct at91_priv *priv)
+static inline int get_tx_next_prio(const struct at91_priv *priv)
 {
 	return (priv-&gt;tx_next &gt;&gt; AT91_NEXT_PRIO_SHIFT) &amp; 0xf;
 }
 
-static inline int get_tx_echo_mb(struct at91_priv *priv)
+static inline int get_tx_echo_mb(const struct at91_priv *priv)
 {
 	return (priv-&gt;tx_echo &amp; AT91_NEXT_MB_MASK) + AT91_MB_TX_FIRST;
 }
 
-
-static inline u32 at91_read(struct net_device *dev, enum at91_reg reg)
+static inline u32 at91_read(const struct at91_priv *priv, enum at91_reg reg)
 {
-	struct at91_priv *priv = netdev_priv(dev);
 	return readl(priv-&gt;reg_base + reg);
 }
 
-static inline void
-at91_write(struct net_device *dev, enum at91_reg reg, u32 value)
+static inline void at91_write(const struct at91_priv *priv, enum at91_reg reg,
+		u32 value)
 {
-	struct at91_priv *priv = netdev_priv(dev);
 	writel(value, priv-&gt;reg_base + reg);
 }
 
+static inline void set_mb_mode_prio(const struct at91_priv *priv,
+		unsigned int mb, enum at91_mb_mode mode, int prio)
+{
+	at91_write(priv, AT91_MMR(mb), (mode &lt;&lt; 24) | (prio &lt;&lt; 16));
+}
 
-static inline void
-set_mb_mode_prio(struct net_device *dev, int mb, enum at91_mb_mode mode,
-		int prio)
+static inline void set_mb_mode(const struct at91_priv *priv, unsigned int mb,
+		enum at91_mb_mode mode)
 {
-	at91_write(dev, AT91_MMR(mb),
-		   (mode &lt;&lt; 24) |
-		   (prio &lt;&lt; 16));
+	set_mb_mode_prio(priv, mb, mode, 0);
 }
 
-static inline void
-set_mb_mode(struct net_device *dev, int mb, enum at91_mb_mode mode)
+static struct sk_buff *alloc_can_skb(struct net_device *dev,
+	struct can_frame **cf)
 {
-	set_mb_mode_prio(dev, mb, mode, 0);
+	struct sk_buff *skb;
+
+	skb = netdev_alloc_skb(dev, sizeof(struct can_frame));
+	if (unlikely(!skb))
+		return NULL;
+
+	skb-&gt;protocol = htons(ETH_P_CAN);
+	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
+	*cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
+
+	return skb;
 }
 
+static struct sk_buff *alloc_can_err_skb(struct net_device *dev,
+		struct can_frame **cf)
+{
+	struct sk_buff *skb;
+
+	skb = alloc_can_skb(dev, cf);
+	if (unlikely(!skb))
+		return NULL;
+
+	memset(*cf, 0, sizeof(struct can_frame));
+	(*cf)-&gt;can_id = CAN_ERR_FLAG;
+	(*cf)-&gt;can_dlc = CAN_ERR_DLC;
+
+	return skb;
+}
 
 /*
- * Enable or disable transceiver
+ * Swtich transceiver on or off
  */
-static void enable_can_transceiver(struct at91_priv *priv, int enable)
+static void at91_transceiver_switch(const struct at91_priv *priv, int on)
+{
+	if (priv-&gt;pdata &amp;&amp; priv-&gt;pdata-&gt;transceiver_switch)
+		priv-&gt;pdata-&gt;transceiver_switch(on);
+}
+
+static void at91_setup_mailboxes(struct net_device *dev)
+{
+	struct at91_priv *priv = netdev_priv(dev);
+	unsigned int i;
+
+	/*
+	 * The first 12 mailboxes are used as a reception FIFO. The
+	 * last mailbox is configured with overwrite option. The
+	 * overwrite flag indicates a FIFO overflow.
+	 */
+	for (i = AT91_MB_RX_FIRST; i &lt; AT91_MB_RX_LAST; i++)
+		set_mb_mode(priv, i, AT91_MB_MODE_RX);
+	set_mb_mode(priv, AT91_MB_RX_LAST, AT91_MB_MODE_RX_OVRWR);
+
+	/* The last 4 mailboxes are used for transmitting. */
+	for (i = AT91_MB_TX_FIRST; i &lt;= AT91_MB_TX_LAST; i++)
+		set_mb_mode_prio(priv, i, AT91_MB_MODE_TX, 0);
+
+	/* Reset tx and rx helper pointers */
+	priv-&gt;tx_next = priv-&gt;tx_echo = priv-&gt;rx_next = 0;
+}
+
+static int at91_set_bittiming(struct net_device *dev)
 {
-	if (priv-&gt;pdata &amp;&amp; priv-&gt;pdata-&gt;transceiver_enable)
-		priv-&gt;pdata-&gt;transceiver_enable(enable);
+	const struct at91_priv *priv = netdev_priv(dev);
+	const struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
+	u32 reg_br;
+
+	reg_br = ((priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES) &lt;&lt; 24) |
+		((bt-&gt;brp - 1) &lt;&lt; 16) |	((bt-&gt;sjw - 1) &lt;&lt; 12) |
+		((bt-&gt;prop_seg - 1) &lt;&lt; 8) | ((bt-&gt;phase_seg1 - 1) &lt;&lt; 4) |
+		((bt-&gt;phase_seg2 - 1) &lt;&lt; 0);
+
+	dev_info(ND2D(dev), &quot;writing AT91_BR: 0x%08x\n&quot;, reg_br);
+
+	at91_write(priv, AT91_BR, reg_br);
+
+	return 0;
 }
 
+static void at91_chip_start(struct net_device *dev)
+{
+	struct at91_priv *priv = netdev_priv(dev);
+	u32 reg_mr, reg_ier;
+
+	/* disable interrupts */
+	at91_write(priv, AT91_IDR, AT91_IRQ_ALL);
+
+	/* disable chip */
+	reg_mr = at91_read(priv, AT91_MR);
+	at91_write(priv, AT91_MR, reg_mr &amp; ~AT91_MR_CANEN);
+
+	at91_setup_mailboxes(dev);
+	at91_transceiver_switch(priv, 1);
+
+	/* enable chip */
+	at91_write(priv, AT91_MR, AT91_MR_CANEN);
+
+	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
+
+	/* Enable interrupts */
+	reg_ier = AT91_IRQ_MB_RX | AT91_IRQ_ERRP | AT91_IRQ_ERR_FRAME;
+	at91_write(priv, AT91_IDR, AT91_IRQ_ALL);
+	at91_write(priv, AT91_IER, reg_ier);
+}
+
+static void at91_chip_stop(struct net_device *dev, enum can_state state)
+{
+	struct at91_priv *priv = netdev_priv(dev);
+	u32 reg_mr;
+
+	/* disable interrupts */
+	at91_write(priv, AT91_IDR, AT91_IRQ_ALL);
+
+	reg_mr = at91_read(priv, AT91_MR);
+	at91_write(priv, AT91_MR, reg_mr &amp; ~AT91_MR_CANEN);
+
+	at91_transceiver_switch(priv, 0);
+	priv-&gt;can.state = state;
+}
 
 /*
  * theory of operation:
  *
- * Accoring to the datasheet priority 0 is the highest priority, 15 is
- * the lowest. If two mailboxes have the same priority level the
+ * According to the datasheet priority 0 is the highest priority, 15
+ * is the lowest. If two mailboxes have the same priority level the
  * message of the mailbox with the lowest number is sent first.
  *
- * We use the first TX mailbox mailbox (AT91_MB_TX_FIRST) with prio 0,
- * then the next mailbox with prio 0, and so on, until all mailboxes
- * are used. Then we start from the beginning with mailbox
+ * We use the first TX mailbox (AT91_MB_TX_FIRST) with prio 0, then
+ * the next mailbox with prio 0, and so on, until all mailboxes are
+ * used. Then we start from the beginning with mailbox
  * AT91_MB_TX_FIRST, but with prio 1, mailbox AT91_MB_TX_FIRST + 1
  * prio 1. When we reach the last mailbox with prio 15, we have to
- * stop sending, waiting for all messages to be delivered, than start
+ * stop sending, waiting for all messages to be delivered, then start
  * again with mailbox AT91_MB_TX_FIRST prio 0.
  *
  * We use the priv-&gt;tx_next as counter for the next transmission
@@ -253,16 +362,17 @@ static int at91_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	struct at91_priv *priv = netdev_priv(dev);
 	struct net_device_stats *stats = &amp;dev-&gt;stats;
 	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
+	unsigned int mb, prio;
 	u32 reg_mid, reg_mcr;
-	int mb, prio;
 
 	mb = get_tx_next_mb(priv);
 	prio = get_tx_next_prio(priv);
 
-	if (!(at91_read(dev, AT91_MSR(mb)) &amp; AT91_MSR_MRDY)) {
-		BUG();
-		/* FIXME: kfree? stats? */
-		return -EBUSY;
+	if (unlikely(!(at91_read(priv, AT91_MSR(mb)) &amp; AT91_MSR_MRDY))) {
+		netif_stop_queue(dev);
+
+		dev_err(ND2D(dev), &quot;BUG! TX buffer full when queue awake!\n&quot;);
+		return NETDEV_TX_BUSY;
 	}
 
 	if (cf-&gt;can_id &amp; CAN_EFF_FLAG)
@@ -270,21 +380,19 @@ static int at91_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	else
 		reg_mid = (cf-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; 18;
 
-	reg_mcr = ((cf-&gt;can_id &amp; CAN_RTR_FLAG) ? AT91_MCR_MRTR : 0 ) |
-		(cf-&gt;can_dlc &lt;&lt; 16) |
-		AT91_MCR_MTCR;
+	reg_mcr = ((cf-&gt;can_id &amp; CAN_RTR_FLAG) ? AT91_MCR_MRTR : 0) |
+		(cf-&gt;can_dlc &lt;&lt; 16) | AT91_MCR_MTCR;
 
 	/* disable MB while writing ID (see datasheet) */
-	set_mb_mode(dev, mb, AT91_MB_MODE_DISABLED);
-	at91_write(dev, AT91_MID(mb), reg_mid);
-	set_mb_mode_prio(dev, mb, AT91_MB_MODE_TX, prio);
+	set_mb_mode(priv, mb, AT91_MB_MODE_DISABLED);
+	at91_write(priv, AT91_MID(mb), reg_mid);
+	set_mb_mode_prio(priv, mb, AT91_MB_MODE_TX, prio);
 
-	at91_write(dev, AT91_MDL(mb), *(u32 *)(cf-&gt;data + 0));
-	at91_write(dev, AT91_MDH(mb), *(u32 *)(cf-&gt;data + 4));
+	at91_write(priv, AT91_MDL(mb), *(u32 *)(cf-&gt;data + 0));
+	at91_write(priv, AT91_MDH(mb), *(u32 *)(cf-&gt;data + 4));
 
 	/* This triggers transmission */
-	wmb();
-	at91_write(dev, AT91_MCR(mb), reg_mcr);
+	at91_write(priv, AT91_MCR(mb), reg_mcr);
 
 	stats-&gt;tx_bytes += cf-&gt;can_dlc;
 	dev-&gt;trans_start = jiffies;
@@ -301,46 +409,69 @@ static int at91_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	 * (== not ready)
 	 */
 	priv-&gt;tx_next++;
-	if (!(at91_read(dev, AT91_MSR(get_tx_next_mb(priv))) &amp;
+	if (!(at91_read(priv, AT91_MSR(get_tx_next_mb(priv))) &amp;
 	      AT91_MSR_MRDY) ||
-	    (priv-&gt;tx_next &amp; AT91_NEXT_MASK) == 0) {
+	    (priv-&gt;tx_next &amp; AT91_NEXT_MASK) == 0)
 		netif_stop_queue(dev);
-		dev_dbg(ND2D(dev),
-			&quot;stopping netif_queue, priv-&gt;tx_next=%d, &quot;
-			&quot;prio=%d, mb=%d\n&quot;,
-			priv-&gt;tx_next,
-			get_tx_next_prio(priv),
-			get_tx_next_mb(priv));
-	}
 
 	/* Enable interrupt for this mailbox */
-	at91_write(dev, AT91_IER, 1 &lt;&lt; mb);
+	at91_write(priv, AT91_IER, 1 &lt;&lt; mb);
 
-	return 0;
+	return NETDEV_TX_OK;
 }
 
+/**
+ * at91_activate_rx_low - activate lower rx mailboxes
+ * @priv: a91 context
+ *
+ * Reenables the lower mailboxes for reception of new CAN messages
+ */
+static inline void at91_activate_rx_low(const struct at91_priv *priv)
+{
+	u32 mask = AT91_MB_RX_LOW_MASK;
+	at91_write(priv, AT91_TCR, mask);
+}
 
 /**
- * at91_clear_bank - clear and reactive bank
- * @dev: net device
- * @bank: bank to clear
+ * at91_activate_rx_mb - reactive single rx mailbox
+ * @priv: a91 context
+ * @mb: mailbox to reactivate
  *
- * Clears and reenables IRQs on given bank in order to enable
- * reception of new CAN messages
+ * Reenables given mailbox for reception of new CAN messages
  */
-static void at91_clear_bank(struct net_device *dev, int bank)
+static inline void at91_activate_rx_mb(const struct at91_priv *priv,
+		unsigned int mb)
 {
-	int last, i;
-	u32 mask;
+	u32 mask = 1 &lt;&lt; mb;
+	at91_write(priv, AT91_TCR, mask);
+}
+
+/**
+ * at91_rx_overflow_err - send error frame due to rx overflow
+ * @dev: net device
+ */
+static void at91_rx_overflow_err(struct net_device *dev)
+{
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+	struct sk_buff *skb;
+	struct can_frame *cf;
 
-	last = AT91_MB_RX_BANK_WIDTH * (bank + 1);
-	for (i = AT91_MB_RX_BANK_WIDTH * bank; i &lt; last; i++)
-		at91_write(dev, AT91_MCR(i), AT91_MCR_MTCR);
+	dev_dbg(ND2D(dev), &quot;RX buffer overflow\n&quot;);
+	stats-&gt;rx_over_errors++;
+	stats-&gt;rx_errors++;
 
-	mask = AT91_MB_RX_BANK_MASK(bank);
-	at91_write(dev, AT91_IER, mask);
-}
+	skb = alloc_can_err_skb(dev, &amp;cf);
+	if (unlikely(!skb))
+		return;
 
+	cf-&gt;can_id |= CAN_ERR_CRTL;
+	cf-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+	netif_receive_skb(skb);
+
+	dev-&gt;last_rx = jiffies;
+	stats-&gt;rx_packets++;
+	stats-&gt;rx_bytes += cf-&gt;can_dlc;
+}
 
 /**
  * at91_read_mb - read CAN msg from mailbox (lowlevel impl)
@@ -351,31 +482,30 @@ static void at91_clear_bank(struct net_device *dev, int bank)
  * Reads a CAN message from the given mailbox and stores data into
  * given can frame. &quot;mb&quot; and &quot;cf&quot; must be valid.
  */
-static void at91_read_mb(struct net_device *dev, int mb, struct can_frame *cf)
+static void at91_read_mb(struct net_device *dev, unsigned int mb,
+		struct can_frame *cf)
 {
-	u32 reg_msr, reg_mid, reg_mdl, reg_mdh;
+	const struct at91_priv *priv = netdev_priv(dev);
+	u32 reg_msr, reg_mid;
 
-	reg_mid = at91_read(dev, AT91_MID(mb));
+	reg_mid = at91_read(priv, AT91_MID(mb));
 	if (reg_mid &amp; AT91_MID_MIDE)
-		cf-&gt;can_id = ((reg_mid &gt;&gt;  0) &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
+		cf-&gt;can_id = ((reg_mid &gt;&gt; 0) &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
 	else
-		cf-&gt;can_id =  (reg_mid &gt;&gt; 18) &amp; CAN_SFF_MASK;
+		cf-&gt;can_id = (reg_mid &gt;&gt; 18) &amp; CAN_SFF_MASK;
 
-	reg_msr = at91_read(dev, AT91_MSR(mb));
+	reg_msr = at91_read(priv, AT91_MSR(mb));
 	if (reg_msr &amp; AT91_MSR_MRTR)
 		cf-&gt;can_id |= CAN_RTR_FLAG;
-	cf-&gt;can_dlc = (reg_msr &gt;&gt; 16) &amp; 0xf;
-
-	reg_mdl = at91_read(dev, AT91_MDL(mb));
-	reg_mdh = at91_read(dev, AT91_MDH(mb));
+	cf-&gt;can_dlc = min_t(__u8, (reg_msr &gt;&gt; 16) &amp; 0xf, 8);
 
-	*(u32 *)(cf-&gt;data + 0) = reg_mdl;
-	*(u32 *)(cf-&gt;data + 4) = reg_mdh;
+	*(u32 *)(cf-&gt;data + 0) = at91_read(priv, AT91_MDL(mb));
+	*(u32 *)(cf-&gt;data + 4) = at91_read(priv, AT91_MDH(mb));
 
-	/*  FIXME: take care about AT91_MB_MODE_RX_OVRWR mb */
+	if (unlikely(mb == AT91_MB_RX_LAST &amp;&amp; reg_msr &amp; AT91_MSR_MMI))
+		at91_rx_overflow_err(dev);
 }
 
-
 /**
  * at91_read_msg - read CAN message from mailbox
  * @dev: net device
@@ -384,113 +514,211 @@ static void at91_read_mb(struct net_device *dev, int mb, struct can_frame *cf)
  * Reads a CAN message from given mailbox, and put into linux network
  * RX queue, does all housekeeping chores (stats, ...)
  */
-static void at91_read_msg(struct net_device *dev, int mb)
+static void at91_read_msg(struct net_device *dev, unsigned int mb)
 {
 	struct net_device_stats *stats = &amp;dev-&gt;stats;
 	struct can_frame *cf;
 	struct sk_buff *skb;
 
-	skb = netdev_alloc_skb(dev, sizeof(struct can_frame));
+	skb = alloc_can_skb(dev, &amp;cf);
 	if (unlikely(!skb)) {
-		if (net_ratelimit())
-			dev_warn(ND2D(dev),
-				 &quot;Memory squeeze, dropping packet.\n&quot;);
 		stats-&gt;rx_dropped++;
 		return;
 	}
-	skb-&gt;protocol = htons(ETH_P_CAN);
-	cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
 
 	at91_read_mb(dev, mb, cf);
-
-	netif_rx(skb);
+	netif_receive_skb(skb);
 
 	dev-&gt;last_rx = jiffies;
 	stats-&gt;rx_packets++;
 	stats-&gt;rx_bytes += cf-&gt;can_dlc;
 }
 
-
-/*
- * theory of operation
+/**
+ * at91_poll_rx - read multiple CAN messages from mailboxes
+ * @dev: net device
+ * @quota: max number of pkgs we're allowed to receive
+ *
+ * Theory of Operation:
  *
  * 12 of the 16 mailboxes on the chip are reserved for RX. we split
- * them into 3 groups (3 x 4 mbs) a.k.a banks.
+ * them into 2 groups. The lower group holds 8 and upper 4 mailboxes.
+ *
+ * Like it or not, but the chip always saves a received CAN message
+ * into the first free mailbox it finds (starting with the
+ * lowest). This makes it very difficult to read the messages in the
+ * right order from the chip. This is how we work around that problem:
  *
- * like it or not, but the chip always saves a received CAN message
- * into the first free mailbox it finds. This makes it very difficult
- * to read the messages in the right order from the chip. This is how
- * we work around that problem:
+ * The first message goes into mb nr. 0 and issues an interrupt. All
+ * rx ints are disabled in the interrupt handler and a napi poll is
+ * scheduled. We read the mailbox, but do _not_ reenable the mb (to
+ * receive another message).
  *
- * The first message goes into mb nr. 0 and issues an interrupt. We
- * read it, do _not_ reenable the mb (to receive another message), but
- * disable the interrupt though. This is done for the first bank
- * (i.e. mailbox 0-3).
+ *    lower mbxs      upper
+ *   ______^______    __^__
+ *  /             \  /     \
+ * +-+-+-+-+-+-+-+-++-+-+-+-+
+ * |x|x|x|x|x|x|x|x|| | | | |
+ * +-+-+-+-+-+-+-+-++-+-+-+-+
+ *  0 0 0 0 0 0  0 0 0 0 1 1  \ mail
+ *  0 1 2 3 4 5  6 7 8 9 0 1  / box
  *
- *   bank0    bank1    bank2
- *   __^__    __^__    __^__
- *  /     \  /     \  /     \
- * +-+-+-+-++-+-+-+-++-+-+-+-+
- * |x|x|x|x|| | | | || | | | |
- * +-+-+-+-++-+-+-+-++-+-+-+-+
- *  0 0 0 0  0 0 0 0  0 0 1 1  \ mail
- *  0 1 2 3  4 5 6 7  8 9 0 1  / box
+ * The variable priv-&gt;rx_next points to the next mailbox to read a
+ * message from. As long we're in the lower mailboxes we just read the
+ * mailbox but not reenable it.
  *
- * Then we switch to bank 1. If this bank is full, too, we reenable
- * bank number 0, and switch to bank 2. Imagine bank 2 like an overflow
- * bank, which takes CAN messages if bank 1 is full, but bank 0 not
- * cleared yet. In other words: from the reception of a message into
- * mb 7, we have the &quot;four mailboxes&quot; (of bank 2) time to enter the
- * interrupt service routine and reenable bank 0.
+ * With completion of the last of the lower mailboxes, we reenable the
+ * whole first group, but continue to look for filled mailboxes in the
+ * upper mailboxes. Imagine the second group like overflow mailboxes,
+ * which takes CAN messages if the lower goup is full. While in the
+ * upper group we reenable the mailbox right after reading it. Giving
+ * the chip more room to store messages.
  *
- * Nevertheless, after reenabling bank 0, we look at bank 2 first, to
- * see if there are some messages. Then we reactivate bank 1 and 2,
- * and switch to bank 0.
+ * After finishing we look again in the lower group if we've still
+ * quota.
  *
  */
-static void at91_irq_rx(struct net_device *dev, u32 reg_sr)
+static int at91_poll_rx(struct net_device *dev, int quota)
 {
 	struct at91_priv *priv = netdev_priv(dev);
-	unsigned long *addr = (unsigned long *)&amp;reg_sr;
-	int mb;
+	u32 reg_sr = at91_read(priv, AT91_SR);
+	const unsigned long *addr = (unsigned long *)&amp;reg_sr;
+	unsigned int mb;
+	int received = 0;
+
+	if (priv-&gt;rx_next &gt; AT91_MB_RX_LOW_LAST &amp;&amp;
+	    reg_sr &amp; AT91_MB_RX_LOW_MASK)
+		dev_info(ND2D(dev),
+			 &quot;order of incoming frames cannot be guaranteed\n&quot;);
+
+ again:
+	for (mb = find_next_bit(addr, AT91_MB_RX_NUM, priv-&gt;rx_next);
+	     mb &lt; AT91_MB_RX_NUM &amp;&amp; quota &gt; 0;
+	     reg_sr = at91_read(priv, AT91_SR),
+	     mb = find_next_bit(addr, AT91_MB_RX_NUM, ++priv-&gt;rx_next)) {
+		at91_read_msg(dev, mb);
 
-	/* masking of reg_sr not needed, already done by at91_irq */
+		/* reactivate mailboxes */
+		if (mb == AT91_MB_RX_LOW_LAST)
+			/* all lower mailboxed, if just finished it */
+			at91_activate_rx_low(priv);
+		else if (mb &gt; AT91_MB_RX_LOW_LAST)
+			/* only the mailbox we read */
+			at91_activate_rx_mb(priv, mb);
 
-	mb = find_next_bit(addr, AT91_MB_RX_NUM,
-			   AT91_MB_RX_BANK_WIDTH * priv-&gt;rx_bank);
-	while (mb &lt; AT91_MB_RX_NUM) {
-		dev_dbg(ND2D(dev),
-			&quot;%s: SR=0x%08x, mb=%d, mb_bit=0x%04x, rx_bank=%d\n&quot;,
-			__func__, reg_sr, mb, 1 &lt;&lt; mb, priv-&gt;rx_bank);
+		received++;
+		quota--;
+	}
 
-		at91_read_msg(dev, mb);
+	/* upper group completed, look again in lower */
+	if (priv-&gt;rx_next &gt; AT91_MB_RX_LOW_LAST &amp;&amp;
+	    quota &gt; 0 &amp;&amp; mb &gt;= AT91_MB_RX_NUM) {
+		priv-&gt;rx_next = 0;
+		goto again;
+	}
 
-		/* disable interrupt */
-		at91_write(dev, AT91_IDR, 1 &lt;&lt; mb);
+	return received;
+}
 
-		/* find next pending mailbox */
-		mb = find_next_bit(addr, AT91_MB_RX_NUM, mb + 1);
+static void at91_poll_err_frame(struct net_device *dev,
+		struct can_frame *cf, u32 reg_sr)
+{
+	struct at91_priv *priv = netdev_priv(dev);
+
+	/* CRC error */
+	if (reg_sr &amp; AT91_IRQ_CERR) {
+		dev_dbg(ND2D(dev), &quot;CERR irq\n&quot;);
+		dev-&gt;stats.rx_errors++;
+		priv-&gt;can.can_stats.bus_error++;
+		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
 	}
 
-	switch (priv-&gt;rx_bank) {
-	case 0:
-		if (!(at91_read(dev, AT91_IMR) &amp; AT91_MB_RX_BANK_MASK(0)))
-			priv-&gt;rx_bank = 1;
-		break;
-	case 1:
-		if (!(at91_read(dev, AT91_IMR) &amp; AT91_MB_RX_BANK_MASK(1))) {
-			at91_clear_bank(dev, 0);
-			priv-&gt;rx_bank = 2;
-		}
-		break;
-	case 2:
-		at91_clear_bank(dev, 1);
-		at91_clear_bank(dev, 2);
-		priv-&gt;rx_bank = 0;
-		break;
+	/* Stuffing Error */
+	if (reg_sr &amp; AT91_IRQ_SERR) {
+		dev_dbg(ND2D(dev), &quot;SERR irq\n&quot;);
+		dev-&gt;stats.rx_errors++;
+		priv-&gt;can.can_stats.bus_error++;
+		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
+		cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
 	}
+
+	/* Acknowledgement Error */
+	if (reg_sr &amp; AT91_IRQ_AERR) {
+		dev_dbg(ND2D(dev), &quot;AERR irq\n&quot;);
+		dev-&gt;stats.tx_errors++;
+		cf-&gt;can_id |= CAN_ERR_ACK;
+	}
+
+	/* Form error */
+	if (reg_sr &amp; AT91_IRQ_FERR) {
+		dev_dbg(ND2D(dev), &quot;FERR irq\n&quot;);
+		dev-&gt;stats.rx_errors++;
+		priv-&gt;can.can_stats.bus_error++;
+		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
+		cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
+	}
+
+	/* Bit Error */
+	if (reg_sr &amp; AT91_IRQ_BERR) {
+		dev_dbg(ND2D(dev), &quot;BERR irq\n&quot;);
+		dev-&gt;stats.tx_errors++;
+		priv-&gt;can.can_stats.bus_error++;
+		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
+		cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
+	}
+}
+
+static int at91_poll_err(struct net_device *dev, int quota, u32 reg_sr)
+{
+	struct sk_buff *skb;
+	struct can_frame *cf;
+
+	if (quota == 0)
+		return 0;
+
+	skb = alloc_can_err_skb(dev, &amp;cf);
+	if (unlikely(!skb))
+		return 0;
+
+	at91_poll_err_frame(dev, cf, reg_sr);
+	netif_receive_skb(skb);
+
+	dev-&gt;last_rx = jiffies;
+	dev-&gt;stats.rx_packets++;
+	dev-&gt;stats.rx_bytes += cf-&gt;can_dlc;
+
+	return 1;
 }
 
+static int at91_poll(struct napi_struct *napi, int quota)
+{
+	struct net_device *dev = napi-&gt;dev;
+	const struct at91_priv *priv = netdev_priv(dev);
+	u32 reg_sr = at91_read(priv, AT91_SR);
+	int work_done = 0;
+
+	if (reg_sr &amp; AT91_IRQ_MB_RX)
+		work_done += at91_poll_rx(dev, quota - work_done);
+
+	/*
+	 * The error bits are clear on read,
+	 * so use saved value from irq handler.
+	 */
+	reg_sr |= priv-&gt;reg_sr;
+	if (reg_sr &amp; AT91_IRQ_ERR_FRAME)
+		work_done += at91_poll_err(dev, quota - work_done, reg_sr);
+
+	if (work_done &lt; quota) {
+		/* enable IRQs for frame errors and all mailboxes &gt;= rx_next */
+		u32 reg_ier = AT91_IRQ_ERR_FRAME;
+		reg_ier |= AT91_IRQ_MB_RX &amp; ~AT91_MB_RX_MASK(priv-&gt;rx_next);
+
+		napi_complete(napi);
+		at91_write(priv, AT91_IER, reg_ier);
+	}
+
+	return work_done;
+}
 
 /*
  * theory of operation:
@@ -508,30 +736,19 @@ static void at91_irq_tx(struct net_device *dev, u32 reg_sr)
 {
 	struct at91_priv *priv = netdev_priv(dev);
 	u32 reg_msr;
-	int mb;
+	unsigned int mb;
 
 	/* masking of reg_sr not needed, already done by at91_irq */
 
-	for (/* nix */; priv-&gt;tx_echo &lt; priv-&gt;tx_next; priv-&gt;tx_echo++) {
+	for (/* nix */; (priv-&gt;tx_next - priv-&gt;tx_echo) &gt; 0; priv-&gt;tx_echo++) {
 		mb = get_tx_echo_mb(priv);
 
 		/* no event in mailbox? */
 		if (!(reg_sr &amp; (1 &lt;&lt; mb)))
 			break;
 
-		reg_msr = at91_read(dev, AT91_MSR(mb));
-
-		/* FIXME: BUGON no ready | abort */
-
-		dev_dbg(ND2D(dev),
-			&quot;%s: SR=0x%08x, mb=%d, mb_bit=0x%04x, mb status: %s, &quot;
-			&quot;tx_next=%d, tx_echo=%d\n&quot;,
-			__func__, reg_sr, mb, 1 &lt;&lt; mb,
-			reg_msr &amp; AT91_MSR_MRDY ? &quot;MRDY&quot; : &quot;MABT&quot;,
-			priv-&gt;tx_next, priv-&gt;tx_echo);
-
 		/* Disable irq for this TX mailbox */
-		at91_write(dev, AT91_IDR, 1 &lt;&lt; mb);
+		at91_write(priv, AT91_IDR, 1 &lt;&lt; mb);
 
 		/*
 		 * only echo if mailbox signals us a transfer
@@ -539,7 +756,9 @@ static void at91_irq_tx(struct net_device *dev, u32 reg_sr)
 		 * abort. &quot;can_bus_off()&quot; takes care about the skbs
 		 * parked in the echo queue.
 		 */
-		if (likely(reg_msr &amp; AT91_MSR_MRDY)) {
+		reg_msr = at91_read(priv, AT91_MSR(mb));
+		if (likely(reg_msr &amp; AT91_MSR_MRDY &amp;&amp;
+			   ~reg_msr &amp; AT91_MSR_MABT)) {
 			/* _NOTE_: substract AT91_MB_TX_FIRST offset from mb! */
 			can_get_echo_skb(dev, mb - AT91_MB_TX_FIRST);
 			dev-&gt;stats.tx_packets++;
@@ -556,102 +775,65 @@ static void at91_irq_tx(struct net_device *dev, u32 reg_sr)
 		netif_wake_queue(dev);
 }
 
-
-static void at91_irq_err_canframe(struct net_device *dev, u32 reg_sr)
-{
-	/* CRC error */
-	if (reg_sr &amp; AT91_IRQ_CERR)
-		dev_dbg(ND2D(dev), &quot;CERR irq\n&quot;);
-
-	/* stuffing error */
-	if (reg_sr &amp; AT91_IRQ_SERR)
-		dev_dbg(ND2D(dev), &quot;SERR irq\n&quot;);
-
-	/* Acknowledgement error */
-	if (reg_sr &amp; AT91_IRQ_AERR)
-		dev_dbg(ND2D(dev), &quot;AERR irq\n&quot;);
-
-	/* form error */
-	if (reg_sr &amp; AT91_IRQ_FERR)
-		dev_dbg(ND2D(dev), &quot;FERR irq\n&quot;);
-
-	/* bit error */
-	if (reg_sr &amp; AT91_IRQ_BERR)
-		dev_dbg(ND2D(dev), &quot;BERR irq\n&quot;);
-}
-
-
-static void at91_irq_err(struct net_device *dev, u32 reg_sr_masked)
+static void at91_irq_err_state(struct net_device *dev,
+		struct can_frame *cf, enum can_state new_state)
 {
 	struct at91_priv *priv = netdev_priv(dev);
-	enum can_state new_state;
-	u32 reg_sr, reg_ecr, reg_idr, reg_ier;
+	u32 reg_idr, reg_ier, reg_ecr;
 	u8 tec, rec;
 
-	reg_sr = at91_read(dev, AT91_SR);
-	reg_ecr = at91_read(dev, AT91_ECR);
-	tec = reg_ecr &gt;&gt; 16;
+	reg_ecr = at91_read(priv, AT91_ECR);
 	rec = reg_ecr &amp; 0xff;
-
-	dev_dbg(ND2D(dev), &quot;%s: TEC=%3d%s, REC=%3d, bits set: %s%s%s%s\n&quot;,
-		__func__,
-		tec,
-		reg_sr &amp; AT91_IRQ_BOFF ? &quot; (bus-off!)&quot; : &quot;&quot;,
-		rec,
-		reg_sr &amp; AT91_IRQ_ERRA ? &quot;ERRA &quot; : &quot;&quot;,
-		reg_sr &amp; AT91_IRQ_WARN ? &quot;WARN &quot; : &quot;&quot;,
-		reg_sr &amp; AT91_IRQ_ERRP ? &quot;ERRP &quot; : &quot;&quot;,
-		reg_sr &amp; AT91_IRQ_BOFF ? &quot;BOFF &quot; : &quot;&quot;);
-
-	/* we need to look at the unmasked reg_sr */
-	if (unlikely(reg_sr &amp; AT91_IRQ_BOFF))
-		new_state = CAN_STATE_BUS_OFF;
-	else if (unlikely(reg_sr &amp; AT91_IRQ_ERRP))
-		new_state = CAN_STATE_ERROR_PASSIVE;
-	else if (unlikely(reg_sr &amp; AT91_IRQ_WARN))
-		new_state = CAN_STATE_ERROR_WARNING;
-	else if (likely(reg_sr &amp; AT91_IRQ_ERRA))
-		new_state = CAN_STATE_ERROR_ACTIVE;
-	else {
-		BUG();	/* FIXME */
-		return;
-	}
-
-	/* state hasn't changed, no error in canframe */
-	if (new_state == priv-&gt;can.state &amp;&amp;
-	    !(reg_sr_masked &amp; AT91_IRQ_ERR_CANFRAME))
-		return;
-
+	tec = reg_ecr &gt;&gt; 16;
 
 	switch (priv-&gt;can.state) {
 	case CAN_STATE_ERROR_ACTIVE:
 		/*
-		 * from: ACTIVE
-		 * to  : BUS_WARNING, BUS_PASSIVE, BUS_OFF
+		 * from: ERROR_ACTIVE
+		 * to  : ERROR_WARNING, ERROR_PASSIVE, BUS_OFF
 		 * =&gt;  : there was a warning int
 		 */
 		if (new_state &gt;= CAN_STATE_ERROR_WARNING &amp;&amp;
-		    new_state &lt;= CAN_STATE_BUS_OFF)
+		    new_state &lt;= CAN_STATE_BUS_OFF) {
+			dev_dbg(ND2D(dev), &quot;Error Warning IRQ\n&quot;);
 			priv-&gt;can.can_stats.error_warning++;
+
+			cf-&gt;can_id |= CAN_ERR_CRTL;
+			cf-&gt;data[1] = (tec &gt; rec) ?
+				CAN_ERR_CRTL_TX_WARNING :
+				CAN_ERR_CRTL_RX_WARNING;
+		}
 	case CAN_STATE_ERROR_WARNING:	/* fallthrough */
 		/*
-		 * from: ACTIVE, BUS_WARNING
-		 * to  : BUS_PASSIVE, BUS_OFF
+		 * from: ERROR_ACTIVE, ERROR_WARNING
+		 * to  : ERROR_PASSIVE, BUS_OFF
 		 * =&gt;  : error passive int
 		 */
 		if (new_state &gt;= CAN_STATE_ERROR_PASSIVE &amp;&amp;
-		    new_state &lt;= CAN_STATE_BUS_OFF)
+		    new_state &lt;= CAN_STATE_BUS_OFF) {
+			dev_dbg(ND2D(dev), &quot;Error Passive IRQ\n&quot;);
 			priv-&gt;can.can_stats.error_passive++;
+
+			cf-&gt;can_id |= CAN_ERR_CRTL;
+			cf-&gt;data[1] = (tec &gt; rec) ?
+				CAN_ERR_CRTL_TX_PASSIVE :
+				CAN_ERR_CRTL_RX_PASSIVE;
+		}
 		break;
 	case CAN_STATE_BUS_OFF:
 		/*
-		 * this is a crude chip, happens very often that it is
-		 * in BUS_OFF but still tries to send a package. on
-		 * success it leaves bus off. so we have to reenable
-		 * the carrier.
+		 * from: BUS_OFF
+		 * to  : ERROR_ACTIVE, ERROR_WARNING, ERROR_PASSIVE
 		 */
-		if (new_state &lt;= CAN_STATE_ERROR_PASSIVE)
+		if (new_state &lt;= CAN_STATE_ERROR_PASSIVE) {
+			cf-&gt;can_id |= CAN_ERR_RESTARTED;
+
+			dev_dbg(dev-&gt;dev.parent, &quot;restarted\n&quot;);
+			priv-&gt;can.can_stats.restarts++;
+
 			netif_carrier_on(dev);
+			netif_wake_queue(dev);
+		}
 		break;
 	default:
 		break;
@@ -667,6 +849,9 @@ static void at91_irq_err(struct net_device *dev, u32 reg_sr_masked)
 		 * circumstances. so just enable AT91_IRQ_ERRP, thus
 		 * the &quot;fallthrough&quot;
 		 */
+		dev_dbg(ND2D(dev), &quot;Error Active\n&quot;);
+		cf-&gt;can_id |= CAN_ERR_PROT;
+		cf-&gt;data[2] = CAN_ERR_PROT_ACTIVE;
 	case CAN_STATE_ERROR_WARNING:	/* fallthrough */
 		reg_idr = AT91_IRQ_ERRA | AT91_IRQ_WARN | AT91_IRQ_BOFF;
 		reg_ier = AT91_IRQ_ERRP;
@@ -680,234 +865,110 @@ static void at91_irq_err(struct net_device *dev, u32 reg_sr_masked)
 			AT91_IRQ_WARN | AT91_IRQ_BOFF;
 		reg_ier = 0;
 
-		/*
-		 * FIXME: really abort?
-		 *
-		 * a somewhat &quot;special&quot; chip, even in BUS_OFF mode, it
-		 * accesses the bus. this is a no-no. we try to abort
-		 * transfers on all mailboxes. but the chip doesn't
-		 * seem to handle this correctly. a stuck-in-transfer
-		 * message isn't aborted. after bringing the CAN bus
-		 * back xin shape again, the stuck-in-transfer message
-		 * is tranferred and its MRDY bit is set. all other
-		 * queued messages are aborted (not send) their MABT
-		 * bit in MSR is _not_ set but the MRDY bit, too.
-		 */
-		dev_dbg(ND2D(dev), &quot;%s: aborting transfers, due to BUS OFF\n&quot;,
-			__func__);
+		cf-&gt;can_id |= CAN_ERR_BUSOFF;
 
-		at91_write(dev, AT91_ACR, AT91_IRQ_MB_TX);
+		dev_dbg(ND2D(dev), &quot;bus-off\n&quot;);
+		netif_carrier_off(dev);
+		priv-&gt;can.can_stats.bus_off++;
 
-		can_bus_off(dev);
+		/* turn off chip, if restart is disabled */
+		if (!priv-&gt;can.restart_ms) {
+			at91_chip_stop(dev, CAN_STATE_BUS_OFF);
+			return;
+		}
 		break;
 	default:
 		break;
 	}
 
-	dev_dbg(ND2D(dev), &quot;%s: writing IDR=0x%08x, IER=0x%08x\n&quot;,
-		__func__, reg_idr, reg_ier);
-	at91_write(dev, AT91_IDR, reg_idr);
-	at91_write(dev, AT91_IER, reg_ier);
-
-
-	{
-		struct sk_buff *skb;
-		struct can_frame *cf;
-
-		skb = netdev_alloc_skb(dev, sizeof(struct can_frame));
-		if (unlikely(!skb))
-			goto out;
-
-		skb-&gt;protocol = htons(ETH_P_CAN);
-		cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
-		memset(cf, 0, sizeof(struct can_frame));
+	at91_write(priv, AT91_IDR, reg_idr);
+	at91_write(priv, AT91_IER, reg_ier);
+}
 
-		cf-&gt;can_id  = CAN_ERR_FLAG;
-		cf-&gt;can_dlc = CAN_ERR_DLC;
+static void at91_irq_err(struct net_device *dev)
+{
+	struct at91_priv *priv = netdev_priv(dev);
+	struct sk_buff *skb;
+	struct can_frame *cf;
+	enum can_state new_state;
+	u32 reg_sr;
 
-		switch (new_state) {
-		case CAN_STATE_ERROR_WARNING:
-		case CAN_STATE_ERROR_PASSIVE:
-			cf-&gt;can_id |= CAN_ERR_CRTL;
+	reg_sr = at91_read(priv, AT91_SR);
 
-			if (new_state == CAN_STATE_ERROR_WARNING)
-				cf-&gt;data[1] = (tec &gt; rec) ?
-					CAN_ERR_CRTL_TX_WARNING :
-					CAN_ERR_CRTL_RX_WARNING;
-			else
-				cf-&gt;data[1] = (tec &gt; rec) ?
-					CAN_ERR_CRTL_TX_PASSIVE :
-					CAN_ERR_CRTL_RX_PASSIVE;
+	/* we need to look at the unmasked reg_sr */
+	if (unlikely(reg_sr &amp; AT91_IRQ_BOFF))
+		new_state = CAN_STATE_BUS_OFF;
+	else if (unlikely(reg_sr &amp; AT91_IRQ_ERRP))
+		new_state = CAN_STATE_ERROR_PASSIVE;
+	else if (unlikely(reg_sr &amp; AT91_IRQ_WARN))
+		new_state = CAN_STATE_ERROR_WARNING;
+	else if (likely(reg_sr &amp; AT91_IRQ_ERRA))
+		new_state = CAN_STATE_ERROR_ACTIVE;
+	else {
+		dev_err(ND2D(dev), &quot;BUG! hardware in undefined state\n&quot;);
+		return;
+	}
 
-			break;
-		case CAN_STATE_BUS_OFF:
-			cf-&gt;can_id |= CAN_ERR_BUSOFF;
-			break;
-		default:
-			break;
-		}
+	/* state hasn't changed */
+	if (likely(new_state == priv-&gt;can.state))
+		return;
 
+	skb = alloc_can_err_skb(dev, &amp;cf);
+	if (unlikely(!skb))
+		return;
 
-		netif_rx(skb);
+	at91_irq_err_state(dev, cf, new_state);
+	netif_rx(skb);
 
-		dev-&gt;last_rx = jiffies;
-		dev-&gt;stats.rx_packets++;
-		dev-&gt;stats.rx_bytes += cf-&gt;can_dlc;
-	}
+	dev-&gt;last_rx = jiffies;
+	dev-&gt;stats.rx_packets++;
+	dev-&gt;stats.rx_bytes += cf-&gt;can_dlc;
 
- out:
 	priv-&gt;can.state = new_state;
 }
 
-
 /*
  * interrupt handler
  */
-static irqreturn_t at91_irq(int irq, void *ndev_id)
+static irqreturn_t at91_irq(int irq, void *dev_id)
 {
-	struct net_device *dev = ndev_id;
+	struct net_device *dev = dev_id;
+	struct at91_priv *priv = netdev_priv(dev);
 	irqreturn_t handled = IRQ_NONE;
 	u32 reg_sr, reg_imr;
-	int boguscnt = MAX_INTERRUPT_WORK;
 
-	do {
-		reg_sr = at91_read(dev, AT91_SR);
-		reg_imr = at91_read(dev, AT91_IMR);
-		dev_dbg(ND2D(dev), &quot;%s: SR=0x%08x, IMR=0x%08x, [0x%08x]\n&quot;,
-			__func__,
-			reg_sr, reg_imr, reg_sr &amp; reg_imr);
+	reg_sr = at91_read(priv, AT91_SR);
+	reg_imr = at91_read(priv, AT91_IMR);
 
-		/* Ignore masked interrupts */
-		reg_sr &amp;= reg_imr;
-		if (!reg_sr)
-			goto exit;
-
-		handled = IRQ_HANDLED;
-
-		if (reg_sr &amp; AT91_IRQ_MB_RX) {
-			/* receive interrupt */
-			at91_irq_rx(dev, reg_sr);
-		}
-
-		if (reg_sr &amp; AT91_IRQ_MB_TX) {
-			/* transmission complete interrupt */
-			at91_irq_tx(dev, reg_sr);
-		}
+	/* Ignore masked interrupts */
+	reg_sr &amp;= reg_imr;
+	if (!reg_sr)
+		goto exit;
 
-		at91_irq_err(dev, reg_sr);
+	handled = IRQ_HANDLED;
 
-	} while (--boguscnt &gt; 0);
+	/* Receive or error interrupt? -&gt; napi */
+	if (reg_sr &amp; (AT91_IRQ_MB_RX | AT91_IRQ_ERR_FRAME)) {
+		/*
+		 * The error bits are clear on read,
+		 * save for later use.
+		 */
+		priv-&gt;reg_sr = reg_sr;
+		at91_write(priv, AT91_IDR,
+			   AT91_IRQ_MB_RX | AT91_IRQ_ERR_FRAME);
+		napi_schedule(&amp;priv-&gt;napi);
+	}
 
-	if (unlikely(boguscnt &lt;= 0)) {
-		dev_warn(ND2D(dev), &quot;Too much work at interrupt, &quot;
-			 &quot;status (at enter): 0x%08x, now: 0x%08x\n&quot;,
-			 reg_sr,
-			 at91_read(dev, AT91_SR) &amp; at91_read(dev, AT91_IMR));
+	/* Transmission complete interrupt */
+	if (reg_sr &amp; AT91_IRQ_MB_TX)
+		at91_irq_tx(dev, reg_sr);
 
-		/* Clear all interrupt sources. */
-		/* FIXME: do it? */
-	}
+	at91_irq_err(dev);
 
  exit:
 	return handled;
 }
 
-
-static void at91_setup_mailboxes(struct net_device *dev)
-{
-	struct at91_priv *priv = netdev_priv(dev);
-	int i;
-
-	/*
-	 * The first 12 mailboxes are used as a reception FIFO. The
-	 * last mailbox is configured with overwrite option. The
-	 * overwrite flag indicates a FIFO overflow.
-	 */
-	/* FIXME: clear accept regs (MID/MAM) */
-	for (i = AT91_MB_RX_FIRST; i &lt; AT91_MB_RX_LAST; i++)
-		set_mb_mode(dev, i, AT91_MB_MODE_RX);
-	set_mb_mode(dev, AT91_MB_RX_LAST, AT91_MB_MODE_RX_OVRWR);
-
-	/* The last 4 mailboxes are used for transmitting. */
-	for (i = AT91_MB_TX_FIRST; i &lt;= AT91_MB_TX_LAST; i++)
-		set_mb_mode_prio(dev, i, AT91_MB_MODE_TX, 0);
-
-
-	/* reset both tx and rx helper pointers */
-	priv-&gt;tx_next = priv-&gt;tx_echo = priv-&gt;rx_bank = 0;
-}
-
-static int at91_set_bittiming(struct net_device *dev)
-{
-	struct at91_priv *priv = netdev_priv(dev);
-	struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
-	u32 reg_br;
-
-	reg_br = ((priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES) &lt;&lt; 24) |
-		((bt-&gt;brp        - 1) &lt;&lt; 16) |
-		((bt-&gt;sjw        - 1) &lt;&lt; 12) |
-		((bt-&gt;prop_seg   - 1) &lt;&lt;  8) |
-		((bt-&gt;phase_seg1 - 1) &lt;&lt;  4) |
-		((bt-&gt;phase_seg2 - 1) &lt;&lt;  0);
-
-	dev_dbg(ND2D(dev), &quot;writing AT91_BR: 0x%08x, can_sys_clock: %d\n&quot;,
-		  reg_br, priv-&gt;can.clock.freq);
-	at91_write(dev, AT91_BR, reg_br);
-
-	return 0;
-}
-
-
-static void at91_chip_start(struct net_device *dev)
-{
-	struct at91_priv *priv = netdev_priv(dev);
-	u32 reg_mr, reg_ier;
-
-	/* disable interrupts */
-	at91_write(dev, AT91_IDR, 0x1fffffff);
-
-	/* disable chip */
-	reg_mr = at91_read(dev, AT91_MR);
-	at91_write(dev, AT91_MR, reg_mr &amp; ~AT91_MR_AT91EN);
-	wmb();
-
-	at91_setup_mailboxes(dev);
-
-	enable_can_transceiver(priv, 1);
-
-	/* enable chip */
-	reg_mr = at91_read(dev, AT91_MR);
-	at91_write(dev, AT91_MR, reg_mr | AT91_MR_AT91EN);
-
-	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
-
-	/* Enable interrupts */
-	reg_ier =
-		AT91_IRQ_MB_RX |
-		AT91_IRQ_ERRP;	/* AT91_IRQ_WARN screws up system */
-/* 		AT91_IRQ_CERR | AT91_IRQ_SERR |	AT91_IRQ_AERR | */
-/* 		AT91_IRQ_FERR |	AT91_IRQ_BERR; */
-	at91_write(dev, AT91_IDR, 0x1fffffff);
-	at91_write(dev, AT91_IER, reg_ier);
-}
-
-
-static void at91_chip_stop(struct net_device *dev)
-{
-	struct at91_priv *priv = netdev_priv(dev);
-	u32 reg_mr;
-
-	/* disable interrupts */
-	at91_write(dev, AT91_IDR, 0x1fffffff);
-
-	reg_mr = at91_read(dev, AT91_MR);
-	at91_write(dev, AT91_MR, reg_mr &amp; ~AT91_MR_AT91EN);
-
-	priv-&gt;can.state = CAN_STATE_STOPPED;
-	enable_can_transceiver(priv, 0);
-}
-
-
 static int at91_open(struct net_device *dev)
 {
 	struct at91_priv *priv = netdev_priv(dev);
@@ -929,6 +990,7 @@ static int at91_open(struct net_device *dev)
 
 	/* start chip and queuing */
 	at91_chip_start(dev);
+	napi_enable(&amp;priv-&gt;napi);
 	netif_start_queue(dev);
 
 	return 0;
@@ -941,7 +1003,6 @@ static int at91_open(struct net_device *dev)
 	return err;
 }
 
-
 /*
  * stop CAN bus activity
  */
@@ -950,8 +1011,9 @@ static int at91_close(struct net_device *dev)
 	struct at91_priv *priv = netdev_priv(dev);
 
 	netif_stop_queue(dev);
+	napi_disable(&amp;priv-&gt;napi);
+	at91_chip_stop(dev, CAN_STATE_STOPPED);
 
-	at91_chip_stop(dev);
 	free_irq(dev-&gt;irq, dev);
 	clk_disable(priv-&gt;clk);
 
@@ -960,15 +1022,10 @@ static int at91_close(struct net_device *dev)
 	return 0;
 }
 
-
-static int at91_set_mode(struct net_device *dev, u32 _mode)
+static int at91_set_mode(struct net_device *dev, enum can_mode mode)
 {
-	enum can_mode mode = _mode;
-
 	switch (mode) {
 	case CAN_MODE_START:
-		dev_dbg(ND2D(dev), &quot;%s: CAN_MODE_START requested\n&quot;, __func__);
-
 		at91_chip_start(dev);
 		netif_wake_queue(dev);
 		break;
@@ -980,7 +1037,6 @@ static int at91_set_mode(struct net_device *dev, u32 _mode)
 	return 0;
 }
 
-
 #if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
 static const struct net_device_ops at91_netdev_ops = {
 	.ndo_open	= at91_open,
@@ -1013,13 +1069,13 @@ static int __init at91_can_probe(struct platform_device *pdev)
 	}
 
 	if (!request_mem_region(res-&gt;start,
-				res-&gt;end - res-&gt;start + 1,
+				resource_size(res),
 				pdev-&gt;name)) {
 		err = -EBUSY;
 		goto exit_put;
 	}
 
-	addr = ioremap_nocache(res-&gt;start, res-&gt;end - res-&gt;start + 1);
+	addr = ioremap_nocache(res-&gt;start, resource_size(res));
 	if (!addr) {
 		err = -ENOMEM;
 		goto exit_release;
@@ -1032,24 +1088,26 @@ static int __init at91_can_probe(struct platform_device *pdev)
 	}
 
 #if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
-	dev-&gt;netdev_ops		= &amp;at91_netdev_ops;
+	dev-&gt;netdev_ops	= &amp;at91_netdev_ops;
 #else
-	dev-&gt;open		= at91_open;
-	dev-&gt;stop		= at91_close;
-	dev-&gt;hard_start_xmit	= at91_start_xmit;
+	dev-&gt;open = at91_open;
+	dev-&gt;stop = at91_close;
+	dev-&gt;hard_start_xmit = at91_start_xmit;
 #endif
-	dev-&gt;irq		= irq;
-	dev-&gt;flags		|= IFF_ECHO;
+	dev-&gt;irq = irq;
+	dev-&gt;flags |= IFF_ECHO;
 
 	priv = netdev_priv(dev);
-	priv-&gt;can.clock.freq		= clk_get_rate(clk);
-	priv-&gt;can.bittiming_const	= &amp;at91_bittiming_const;
-	priv-&gt;can.do_set_bittiming	= at91_set_bittiming;
-	priv-&gt;can.do_set_mode		= at91_set_mode;
-	priv-&gt;clk			= clk;
-	priv-&gt;reg_base			= addr;
+	priv-&gt;can.clock.freq = clk_get_rate(clk);
+	priv-&gt;can.bittiming_const = &amp;at91_bittiming_const;
+	priv-&gt;can.do_set_bittiming = at91_set_bittiming;
+	priv-&gt;can.do_set_mode = at91_set_mode;
+	priv-&gt;reg_base = addr;
+	priv-&gt;dev = dev;
+	priv-&gt;clk = clk;
+	priv-&gt;pdata = pdev-&gt;dev.platform_data;
 
-	priv-&gt;pdata		= pdev-&gt;dev.platform_data;
+	netif_napi_add(dev, &amp;priv-&gt;napi, at91_poll, AT91_NAPI_WEIGHT);
 
 	dev_set_drvdata(&amp;pdev-&gt;dev, dev);
 	SET_NETDEV_DEV(dev, &amp;pdev-&gt;dev);
@@ -1060,8 +1118,7 @@ static int __init at91_can_probe(struct platform_device *pdev)
 		goto exit_free;
 	}
 
-
-	dev_info(&amp;pdev-&gt;dev, &quot;device registered (reg_base=%#p, irq=%d)\n&quot;,
+	dev_info(&amp;pdev-&gt;dev, &quot;device registered (reg_base=%p, irq=%d)\n&quot;,
 		 priv-&gt;reg_base, dev-&gt;irq);
 
 	return 0;
@@ -1071,14 +1128,13 @@ static int __init at91_can_probe(struct platform_device *pdev)
  exit_iounmap:
 	iounmap(addr);
  exit_release:
-	release_mem_region(res-&gt;start, res-&gt;end - res-&gt;start + 1);
+	release_mem_region(res-&gt;start, resource_size(res));
  exit_put:
 	clk_put(clk);
  exit:
 	return err;
 }
 
-
 static int __devexit at91_can_remove(struct platform_device *pdev)
 {
 	struct net_device *dev = platform_get_drvdata(pdev);
@@ -1094,55 +1150,16 @@ static int __devexit at91_can_remove(struct platform_device *pdev)
 	iounmap(priv-&gt;reg_base);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	release_mem_region(res-&gt;start, res-&gt;end - res-&gt;start + 1);
+	release_mem_region(res-&gt;start, resource_size(res));
 
 	clk_put(priv-&gt;clk);
 
 	return 0;
 }
 
-#ifdef CONFIG_PM
-static int at91_can_suspend(struct platform_device *pdev,
-			    pm_message_t mesg)
-{
-	struct net_device *net_dev = platform_get_drvdata(pdev);
-	struct at91_priv *priv = netdev_priv(net_dev);
-
-	if (netif_running(net_dev)) {
-		/* TODO Disable IRQ? */
-		netif_stop_queue(net_dev);
-		netif_device_detach(net_dev);
-		enable_can_transceiver(priv, 0);
-		clk_disable(priv-&gt;clk);
-	}
-	return 0;
-}
-
-
-static int at91_can_resume(struct platform_device *pdev)
-{
-	struct net_device *net_dev = platform_get_drvdata(pdev);
-	struct at91_priv *priv = netdev_priv(net_dev);
-
-	if (netif_running(net_dev)) {
-		clk_enable(priv-&gt;clk);
-		enable_can_transceiver(priv, 1);
-		netif_device_attach(net_dev);
-		netif_start_queue(net_dev);
-		/* TODO Enable IRQ? */
-	}
-	return 0;
-}
-#else
-#define at91_can_suspend	NULL
-#define at91_can_resume		NULL
-#endif
-
 static struct platform_driver at91_can_driver = {
 	.probe		= at91_can_probe,
 	.remove		= __devexit_p(at91_can_remove),
-	.suspend	= at91_can_suspend,
-	.resume		= at91_can_resume,
 	.driver		= {
 		.name	= DRV_NAME,
 		.owner	= THIS_MODULE,
@@ -1166,5 +1183,4 @@ module_exit(at91_can_module_exit);
 
 MODULE_AUTHOR(&quot;Marc Kleine-Budde &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">mkl at pengutronix.de</A>&gt;&quot;);
 MODULE_LICENSE(&quot;GPL v2&quot;);
-MODULE_DESCRIPTION(&quot;LLCF/socketcan '&quot; DRV_NAME &quot;' network device driver&quot;);
-
+MODULE_DESCRIPTION(DRV_NAME &quot; CAN netdevice driver&quot;);
-- 
1.6.3.3

-- 
Pengutronix e.K.                         | Marc Kleine-Budde           |
Linux Solutions for Science and Industry | Phone: +49-231-2826-924     |
Vertretung West/Dortmund                 | Fax:   +49-5121-206917-5555 |
Amtsgericht Hildesheim, HRA 2686         | <A HREF="http://www.pengutronix.de">http://www.pengutronix.de</A>   |

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003086.html">[PATCH 2/2] ems_usb: Added support for EMS CPC-USB/ARM7 CAN/USB	interface
</A></li>
	<LI>Next message: <A HREF="003088.html">[PATCH v4] at91_can
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3090">[ date ]</a>
              <a href="thread.html#3090">[ thread ]</a>
              <a href="subject.html#3090">[ subject ]</a>
              <a href="author.html#3090">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
