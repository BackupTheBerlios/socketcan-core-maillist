<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [RFC PATCH] can: improved CAN error state handling
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2010-July/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BRFC%20PATCH%5D%20can%3A%20improved%20CAN%20error%20state%20handling&In-Reply-To=%3C4C4C6E98.2030209%40grandegger.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004491.html">
   <LINK REL="Next"  HREF="004493.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[RFC PATCH] can: improved CAN error state handling</H1>
    <B>Wolfgang Grandegger</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BRFC%20PATCH%5D%20can%3A%20improved%20CAN%20error%20state%20handling&In-Reply-To=%3C4C4C6E98.2030209%40grandegger.com%3E"
       TITLE="[RFC PATCH] can: improved CAN error state handling">wg at grandegger.com
       </A><BR>
    <I>Sun Jul 25 19:04:24 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="004491.html">[RFC PATCH] can: improved CAN error state handling
</A></li>
        <LI>Next message: <A HREF="004493.html">[RFC PATCH] can: improved CAN error state handling
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4492">[ date ]</a>
              <a href="thread.html#4492">[ thread ]</a>
              <a href="subject.html#4492">[ subject ]</a>
              <a href="author.html#4492">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 07/25/2010 05:43 PM, Marc Kleine-Budde wrote:
&gt;<i> Wolfgang Grandegger wrote:
</I>&gt;&gt;<i> On 07/25/2010 04:48 PM, Marc Kleine-Budde wrote:
</I>...
&gt;&gt;&gt;<i> I like that idea! From naive point of view, in the userspace I want
</I>&gt;&gt;&gt;<i> information that I can interpret stateless (i.e. without the need for a
</I>&gt;&gt;&gt;<i> statemachine == history).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I tend to introduce the error class:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  #define CAN_ERR_STATE_CHANGE 0x00000200U /* state changed / data[1]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> apart from
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  #define CAN_ERR_CRTL   0x00000004U /* controller problems / data[1]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> For any state change the CAN_ERR_STATE_CHANGE bit is set. If the state
</I>&gt;&gt;<i> got worse, the CAN_ERR_CRTL bit will be set as well. This would also
</I>&gt;&gt;<i> ensure backward compatibility.
</I>&gt;<i> 
</I>&gt;<i> What about CAN_CTRLMODE_BERR_REPORTING? How strict should it be
</I>&gt;<i> interpreted? In the flexcan driver, if CAN_CTRLMODE_BERR_REPORTING is
</I>&gt;<i> not active I don't send any bus error related error frames. Even if the
</I>&gt;<i> napi function is entered and the bus error bits are set!
</I>
Well, CAN_CTRLMODE_BERR_REPORTING was introduced to reduce the CPU load
due to bus errors by instructing the hardware to enable/disable bus
error interrupts. If that's not possible, there is no need to support
CAN_CTRLMODE_BERR_REPORTING. It does not tell if bus errors can be
generated by the hardware, at least that was the initial idea. I
realized that it's used in the Flexcan driver to suppress sending error
frames upstream, which is OK. I will update the ESD USB2 driver accordingly.

Anyway, it's not related to the state change handling ;-).

&gt;&gt;&gt;&gt;<i> No need for another state machine. But a common function is still useful
</I>&gt;&gt;&gt;&gt;<i> to fill an error frame for the state change, of course. I will try to
</I>&gt;&gt;&gt;&gt;<i> come up with a proposal soon.
</I>&gt;&gt;&gt;<i> I think there's need for (another) state machine, let me try to explain.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> In the interrupt or napi handler each driver determines the current can
</I>&gt;&gt;&gt;<i> state.
</I>&gt;&gt;&gt;<i> This can vary from a simple: read register and translate into
</I>&gt;&gt;&gt;<i> CAN_STATE_*, to a more complex function like you've written above. This
</I>&gt;&gt;&gt;<i> functions can even have fixups for strange hardware, like the MSCAN: The
</I>&gt;&gt;&gt;<i> mscan may think it's still in error warning, but we know tx/rx error
</I>&gt;&gt;&gt;<i> level below 96 means error active.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> If the can state has changed the driver calls the
</I>&gt;&gt;&gt;<i> &quot;fill-out-error-frame-function&quot;. This function will take care of strange
</I>&gt;&gt;&gt;<i> hardware again. E.g. if the can state changes from error passive to
</I>&gt;&gt;&gt;<i> error active the function can generate the missing to-error-warning
</I>&gt;&gt;&gt;<i> meesage. (If this is wanted). The same goes for the
</I>&gt;&gt;&gt;<i> state-is-getting-worse messages.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> OK, the prototype of a common function could be (similar to your
</I>&gt;&gt;<i> do_state function in the flexcan driver):
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   int can_handle_state_change(struct net_device *dev,
</I>&gt;&gt;<i>                               struct can_frame *cf,
</I>&gt;&gt;<i>                               enum can_state new_state,
</I>&gt;&gt;<i>                               int tx_err, int rx_err)
</I>&gt;<i> 
</I>&gt;<i> I'd drop the &quot;struct can_frame *cf&quot;, the function can take care of
</I>&gt;<i> allocating the frame and returning in case of an error. But this would
</I>&gt;<i> break you proposed detect &quot;getting worse&quot;.
</I>
Why, the calling function needs to allocate the frame anyway. Filling
the error message is one of the major tasks of that function. I would
also like to add tx- and rx-errs to data[6..7].

&gt;<i> Apart from this, {tx,rx}_err can be derived via the
</I>&gt;<i> priv-&gt;can.do_get_berr_counter function.
</I>
Yes, I agree. And if it's &quot;NULL&quot;, it cannot be read.

&gt;&gt;<i> If &quot;tx_err&quot; or &quot;rx_err == -1&quot;, they are ignored. If &quot;new_state ==
</I>&gt;<i> 
</I>&gt;<i> If priv-&gt;can.do_get_berr_counter if NULL, don't use it.
</I>&gt;<i> 
</I>&gt;&gt;<i> CAN_STATE_UNKNOWN&quot;, the state could be derived from tx_err or rx_err.
</I>&gt;&gt;<i> What do you think?
</I>&gt;<i> 
</I>&gt;<i> The CAN_STATE_UNKNOWN fallback is a good idea.
</I>
Let's see if we really need it.

I looked to your Flexcan implementation and I actually don't like that
more than one state might be set in the error message. It just makes it
tricky for the user space to handle it properly. The error message
reports a state change to &quot;x&quot; and it does not matter, if it does not
report state changes in between. What do you think?

Wolfgang.

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004491.html">[RFC PATCH] can: improved CAN error state handling
</A></li>
	<LI>Next message: <A HREF="004493.html">[RFC PATCH] can: improved CAN error state handling
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4492">[ date ]</a>
              <a href="thread.html#4492">[ thread ]</a>
              <a href="subject.html#4492">[ subject ]</a>
              <a href="author.html#4492">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
