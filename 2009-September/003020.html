<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH] ems_usb: CAN/USB driver for EMS CPC-USB/ARM7 CAN	interfaces
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20ems_usb%3A%20CAN/USB%20driver%20for%20EMS%20CPC-USB/ARM7%20CAN%0A%09interfaces&In-Reply-To=%3C4AA784CD.5050708%40ems-wuensche.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003022.html">
   <LINK REL="Next"  HREF="003023.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH] ems_usb: CAN/USB driver for EMS CPC-USB/ARM7 CAN	interfaces</H1>
    <B>Sebastian Haas</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20ems_usb%3A%20CAN/USB%20driver%20for%20EMS%20CPC-USB/ARM7%20CAN%0A%09interfaces&In-Reply-To=%3C4AA784CD.5050708%40ems-wuensche.com%3E"
       TITLE="[PATCH] ems_usb: CAN/USB driver for EMS CPC-USB/ARM7 CAN	interfaces">haas at ems-wuensche.com
       </A><BR>
    <I>Wed Sep  9 12:34:53 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003022.html">[PATCH] ems_usb: CAN/USB driver for EMS	CPC-USB/ARM7	CAN	interfaces
</A></li>
        <LI>Next message: <A HREF="003023.html">[PATCH] ems_usb: CAN/USB driver for EMS CPC-USB/ARM7	CAN	interfaces
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3020">[ date ]</a>
              <a href="thread.html#3020">[ thread ]</a>
              <a href="subject.html#3020">[ subject ]</a>
              <a href="author.html#3020">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Wolfgang,

I've fixed most white space, indentation and style issues.

Wolfgang Grandegger schrieb:
&gt;<i> Hi Sebastian,
</I>&gt;<i> 
</I>&gt;<i> chekcpatch.pl reports various errors like DOS endings :-( and lines too
</I>&gt;<i> long. More comments inline. I suggest various improvements mainly to
</I>&gt;<i> improve the readability. There are a few patterns:
</I>&gt;<i> 
</I>&gt;&gt;<i> +    union {
</I>&gt;&gt;<i> +        struct cpc_m16c_basic_params m16c_basic;
</I>&gt;&gt;<i> +        struct cpc_sja1000_params    sja1000;
</I>&gt;<i> 
</I>&gt;<i> Please don't align the names, especially because you do not do it
</I>&gt;<i> consequently.
</I>&gt;<i> 
</I>&gt;&gt;<i> +    struct can_frame *cf;
</I>&gt;&gt;<i> +    struct sk_buff *skb;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    struct net_device_stats *stats =&amp;dev-&gt;netdev-&gt;stats;
</I>&gt;<i> 
</I>&gt;<i> Don't use emtpy lines in the function/block header.
</I>&gt;<i> 
</I>&gt;&gt;<i> +#define CPC_MSG_T_CAN           1 /* CAN data frame */
</I>&gt;&gt;<i> +#define    CPC_MSG_T_RTR           8 /* CAN remote frame */
</I>&gt;<i> 
</I>&gt;<i> The names of some macro definition could be improved for better
</I>&gt;<i> readability.
</I>&gt;<i> 
</I>&gt;&gt;<i> +    msg-&gt;msg.canparams.cc_params.sja1000.mode = mod;
</I>&gt;<i> 
</I>&gt;<i> This is ugly. When it's used often, it could be replaced by:
</I>&gt;<i> 
</I>&gt;<i>     struct cpc_sja1000_params *sja =
</I>&gt;<i>         &amp;msg-&gt;msg.canparams.cc_params.sja1000;
</I>&gt;<i> 
</I>&gt;<i>         sja-&gt;acc_code0 = 0x00;
</I>&gt;<i>         ...
</I>Fixed.

&gt;<i> Often you use the variable name &quot;status&quot; for the function return value.
</I>&gt;<i> Please check if &quot;err&quot; might not be more appropriate.
</I>Yepp, done.

&gt;<i> Also, please put defines in the file header.
</I>&gt;<i> 
</I>&gt;<i> More comments inline...
</I>&gt;<i> 
</I>&gt;<i> On 09/09/2009 08:27 AM, Sebastian Haas wrote:
</I>&gt;&gt;<i> -----BEGIN PGP SIGNED MESSAGE-----
</I>&gt;&gt;<i> Hash: SHA1
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This patch adds support for the CAN/USB interface CPC-USB/ARM7 from EMS
</I>&gt;&gt;<i> Dr. Thomas Wuensche.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Signed-off-by: Sebastian Haas&lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">haas at ems-wuensche.com</A>&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   Makefile                  |    1
</I>&gt;&gt;<i>   drivers/net/can/Kconfig   |    8
</I>&gt;&gt;<i>   drivers/net/can/Makefile  |    1
</I>&gt;&gt;<i>   drivers/net/can/ems_usb.c | 1114
</I>&gt;&gt;<i> ++++++++++++++++++++++++++++++++++++++++++++++
</I>&gt;&gt;<i>   4 files changed, 1124 insertions(+)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Index: Makefile
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> - --- Makefile    (Revision 1048)
</I>&gt;&gt;<i> +++ Makefile    (Arbeitskopie)
</I>&gt;&gt;<i> @@ -19,6 +19,7 @@
</I>&gt;&gt;<i>   export CONFIG_CAN_PEAK_PCI=m
</I>&gt;&gt;<i>   export CONFIG_CAN_KVASER_PCI=m
</I>&gt;&gt;<i>   export CONFIG_CAN_EMS_PCI=m
</I>&gt;&gt;<i> +export CONFIG_CAN_EMS_USB=m
</I>&gt;&gt;<i>   export CONFIG_CAN_EMS_PCMCIA=m
</I>&gt;&gt;<i>   export CONFIG_CAN_EMS_104M=m
</I>&gt;&gt;<i>   export CONFIG_CAN_ESD_PCI=m
</I>&gt;&gt;<i> Index: drivers/net/can/Kconfig
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> - --- drivers/net/can/Kconfig    (Revision 1048)
</I>&gt;&gt;<i> +++ drivers/net/can/Kconfig    (Arbeitskopie)
</I>&gt;&gt;<i> @@ -127,6 +127,14 @@
</I>&gt;&gt;<i>         OpenFirmware bindings, e.g. if you have a PowerPC based system
</I>&gt;&gt;<i>         you may want to enable this option.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> +config CAN_EMS_USB
</I>&gt;&gt;<i> +    tristate &quot;EMS CPC-USB/ARM7&quot;
</I>&gt;&gt;<i> +    depends on USB&amp;&amp;  CAN_DEV
</I>&gt;&gt;<i> +    ---help---
</I>&gt;&gt;<i> +      This driver is for the one channel CAN/USB interface CPC-USB
</I>&gt;&gt;<i> +      from EMS Dr. Thomas Wuensche.
</I>&gt;&gt;<i> +      (<A HREF="http://www.ems-wuensche.de">http://www.ems-wuensche.de</A>).
</I>&gt;<i> 
</I>&gt;<i> Does fits on one line.
</I>&gt;<i> 
</I>&gt;&gt;<i>   config CAN_EMS_PCI
</I>&gt;&gt;<i>       tristate &quot;EMS CPC-PCI, CPC-PCIe and CPC-104P Card&quot;
</I>&gt;&gt;<i>       depends on PCI&amp;&amp;  CAN_SJA1000
</I>&gt;&gt;<i> Index: drivers/net/can/Makefile
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> - --- drivers/net/can/Makefile    (Revision 1048)
</I>&gt;&gt;<i> +++ drivers/net/can/Makefile    (Arbeitskopie)
</I>&gt;&gt;<i> @@ -49,6 +49,7 @@
</I>&gt;&gt;<i>   obj-$(CONFIG_CAN_MSCAN_OLD)    += old/mscan/
</I>&gt;&gt;<i>   obj-$(CONFIG_CAN_CCAN_OLD)    += old/ccan/
</I>&gt;&gt;<i>   obj-$(CONFIG_CAN_MCP251X)    += mcp251x.o
</I>&gt;&gt;<i> +obj-$(CONFIG_CAN_EMS_USB)    += ems_usb.o
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   ifeq ($(CONFIG_CAN_DEBUG_DEVICES),y)
</I>&gt;&gt;<i>       EXTRA_CFLAGS += -DDEBUG
</I>&gt;&gt;<i> Index: drivers/net/can/ems_usb.c
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> - --- drivers/net/can/ems_usb.c    (Revision 0)
</I>&gt;&gt;<i> +++ drivers/net/can/ems_usb.c    (Revision 0)
</I>&gt;&gt;<i> @@ -0,0 +1,1114 @@
</I>&gt;&gt;<i> +/*
</I>&gt;&gt;<i> + * CAN driver for EMS Dr. Thomas Wuensche CPC-USB/ARM7
</I>&gt;&gt;<i> + *
</I>&gt;&gt;<i> + * Copyright (C) 2004-2009 EMS Dr. Thomas Wuensche
</I>&gt;&gt;<i> + *
</I>&gt;&gt;<i> + * This program is free software; you can redistribute it and/or
</I>&gt;&gt;<i> modify it
</I>&gt;&gt;<i> + * under the terms of the GNU General Public License as published
</I>&gt;&gt;<i> + * by the Free Software Foundation; version 2 of the License.
</I>&gt;&gt;<i> + *
</I>&gt;&gt;<i> + * This program is distributed in the hope that it will be useful, but
</I>&gt;&gt;<i> + * WITHOUT ANY WARRANTY; without even the implied warranty of
</I>&gt;&gt;<i> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
</I>&gt;&gt;<i> + * General Public License for more details.
</I>&gt;&gt;<i> + *
</I>&gt;&gt;<i> + * You should have received a copy of the GNU General Public License
</I>&gt;&gt;<i> along
</I>&gt;&gt;<i> + * with this program; if not, write to the Free Software Foundation,
</I>&gt;&gt;<i> Inc.,
</I>&gt;&gt;<i> + * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +#include&lt;linux/init.h&gt;
</I>&gt;&gt;<i> +#include&lt;linux/signal.h&gt;
</I>&gt;&gt;<i> +#include&lt;linux/slab.h&gt;
</I>&gt;&gt;<i> +#include&lt;linux/module.h&gt;
</I>&gt;&gt;<i> +#include&lt;linux/netdevice.h&gt;
</I>&gt;&gt;<i> +#include&lt;linux/usb.h&gt;
</I>&gt;&gt;<i> +#include&lt;asm/uaccess.h&gt;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#include&lt;socketcan/can.h&gt;
</I>&gt;&gt;<i> +#include&lt;socketcan/can/dev.h&gt;
</I>&gt;&gt;<i> +#include&lt;socketcan/can/error.h&gt;
</I>&gt;&gt;<i> +#include&lt;socketcan/can/dev.h&gt;
</I>&gt;<i> 
</I>&gt;<i> Already included above.
</I>&gt;<i> 
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +MODULE_AUTHOR(&quot;Sebastian Haas&lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">haas at ems-wuensche.com</A>&gt;&quot;);
</I>&gt;&gt;<i> +MODULE_DESCRIPTION(&quot;CAN driver for EMS Dr. Thomas Wuensche CAN/USB
</I>&gt;&gt;<i> interfaces&quot;);
</I>&gt;&gt;<i> +MODULE_VERSION(&quot;v0.9&quot;);
</I>&gt;<i> 
</I>&gt;<i> I'm not happy about the version number. Git does a better job.
</I>Well, if Socket-CAN would actually use Git ;-)

&gt;&gt;<i> +MODULE_LICENSE(&quot;GPL v2&quot;);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* Control-Values for CPC_Control() Command Subject Selection */
</I>&gt;&gt;<i> +#define CONTR_CAN_Message 0x04
</I>&gt;&gt;<i> +#define    CONTR_CAN_State      0x0C
</I>&gt;&gt;<i> +#define CONTR_CmdQueue    0x18
</I>&gt;&gt;<i> +#define CONTR_BusError    0x1C
</I>&gt;<i> 
</I>&gt;<i> Please use uppercase letters and underscores for defines.
</I>&gt;<i> 
</I>&gt;&gt;<i> +/* Control Command Actions */
</I>&gt;&gt;<i> +#define CONTR_CONT_OFF    0
</I>&gt;&gt;<i> +#define CONTR_CONT_ON     1
</I>&gt;&gt;<i> +#define CONTR_SING_ON     2
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* Messages from CPC to PC contain a message object type field.
</I>&gt;&gt;<i> + * The following message types are sent by CPC and can be used in
</I>&gt;&gt;<i> + * handlers, others should be ignored.
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +#define CPC_MSG_T_CAN           1 /* CAN data frame */
</I>&gt;<i> 
</I>&gt;<i> What is the meaning of &quot;_T_&quot;? I would either remove it or use &quot;_TYPE_
</I>&gt;<i> instead to improve readability.
</I>It was previously related to the CPC_MSG_T typedef'ed structure. I've
renamed them all to CPC_MSG_TYPE_

&gt;&gt;<i> +#define    CPC_MSG_T_RTR           8 /* CAN remote frame */
</I>&gt;&gt;<i> +#define    CPC_MSG_T_CAN_PRMS     12 /* Actual CAN parameters */
</I>&gt;&gt;<i> +#define    CPC_MSG_T_CANSTATE     14 /* CAN state message */
</I>&gt;<i> 
</I>&gt;<i> Your naming here and in other places is not always logical to me and. I
</I>&gt;<i> think the following is more readable:
</I>&gt;<i> 
</I>&gt;<i> #define CPC_MSG_T_CAN_DATA       1 /* CAN data frame */
</I>&gt;<i> #define    CPC_MSG_T_CAN_RTR        8 /* CAN remote frame */
</I>&gt;<i> #define    CPC_MSG_T_CAN_PARAMS    12 /* Actual CAN parameters */
</I>&gt;<i> #define    CPC_MSG_T_CAN_STATE     14 /* CAN state message */
</I>&gt;<i> 
</I>&gt;<i> Would be more readable and consistent.
</I>Changed. I've just use the namings from our library.

&gt;&gt;<i> +#define    CPC_MSG_T_XCAN         16 /* XCAN data frame */
</I>&gt;<i> 
</I>&gt;<i> Indention? Why do you use tabs here?
</I>&gt;<i> 
</I>&gt;&gt;<i> +#define CPC_MSG_T_XRTR         17 /* XCAN remote frame */
</I>&gt;<i> 
</I>&gt;<i> CPC_MSG_T_CAN_XRTR or CPC_MSG_T_CAN_EXT_RTR? Please explain the meaning
</I>&gt;<i> of &quot;X&quot;:
</I>&gt;<i> 
</I>&gt;<i> /* Extended CAN remote frame */
</I>&gt;<i> /* Standard CAN remote frame */
</I>&gt;<i> 
</I>&gt;&gt;<i> +#define CPC_MSG_T_CONTROL      19 /* used for control of interface
</I>&gt;&gt;<i> behavior*/
</I>&gt;&gt;<i> +#define CPC_MSG_T_CONFIRM      20 /* response type for confirmed
</I>&gt;&gt;<i> requests */
</I>&gt;&gt;<i> +#define CPC_MSG_T_OVERRUN      21 /* response type for overrun
</I>&gt;&gt;<i> conditions */
</I>&gt;&gt;<i> +#define CPC_MSG_T_CANERROR     23 /* response type for bus error
</I>&gt;&gt;<i> conditions*/
</I>&gt;&gt;<i> +#define CPC_MSG_T_ERR_COUNTER  25 /* RX/TX error counter of CAN
</I>&gt;&gt;<i> controller */
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* Messages from the PC to the CPC interface contain a command field
</I>&gt;&gt;<i> + * Most of the command types are wrapped by the library functions and
</I>&gt;&gt;<i> have
</I>&gt;&gt;<i> + * therefore normally not to be used.
</I>&gt;&gt;<i> + * However, programmers who wish to circumvent the library and talk
</I>&gt;&gt;<i> directly
</I>&gt;&gt;<i> + * to the drivers (mainly Linux programmers) can use the following
</I>&gt;&gt;<i> + *
</I>&gt;&gt;<i> + * Command types:
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +#define CPC_CMD_T_CAN           1   /* CAN data frame */
</I>&gt;&gt;<i> +#define CPC_CMD_T_CONTROL       3   /* used for control of interface
</I>&gt;&gt;<i> behavior */
</I>&gt;&gt;<i> +#define    CPC_CMD_T_CAN_PRMS      6   /* set CAN parameters */
</I>&gt;&gt;<i> +#define    CPC_CMD_T_INQ_CAN_PARMS 11  /* inquire actual CAN
</I>&gt;&gt;<i> parameters */
</I>&gt;&gt;<i> +#define    CPC_CMD_T_RTR           13  /* CAN remote frame */
</I>&gt;&gt;<i> +#define    CPC_CMD_T_CANSTATE      14  /* CAN state message */
</I>&gt;&gt;<i> +#define    CPC_CMD_T_XCAN          15  /* XCAN data frame */
</I>&gt;<i> 
</I>&gt;<i> See above.
</I>&gt;<i> 
</I>&gt;&gt;<i> +#define CPC_CMD_T_XRTR          16  /* XCAN remote frame */
</I>&gt;&gt;<i> +#define CPC_CMD_T_CAN_EXIT      200 /* exit the CAN */
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CPC_CMD_T_INQ_ERR_COUNTER 25 /* request the CAN error
</I>&gt;&gt;<i> counters */
</I>&gt;&gt;<i> +#define    CPC_CMD_T_CLEAR_MSG_QUEUE 8  /* clear CPC_MSG queue */
</I>&gt;&gt;<i> +#define    CPC_CMD_T_CLEAR_CMD_QUEUE 28 /* clear CPC_CMD queue */
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define SJA1000 2 /* Philips basic CAN controller */
</I>&gt;<i> 
</I>&gt;<i> Please be more specific, e.g. CPC_CC_SJA1000 or CPC_CC_TYPE_SJA1000.
</I>&gt;<i> 
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* CAN-Message representation in a CPC_MSG
</I>&gt;&gt;<i> + * Message object type is CPC_MSG_T_CAN or CPC_MSG_T_RTR
</I>&gt;&gt;<i> + * or CPC_MSG_T_XCAN or CPC_MSG_T_XRTR
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +struct cpc_can_msg {
</I>&gt;&gt;<i> +    u32 id;
</I>&gt;&gt;<i> +    u8 length;
</I>&gt;&gt;<i> +    u8 msg[8];
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* representation of the CAN parameters for the SJA1000 controller */
</I>&gt;&gt;<i> +struct cpc_sja1000_params {
</I>&gt;&gt;<i> +    u8 mode;
</I>&gt;&gt;<i> +    u8 acc_code0;
</I>&gt;&gt;<i> +    u8 acc_code1;
</I>&gt;&gt;<i> +    u8 acc_code2;
</I>&gt;&gt;<i> +    u8 acc_code3;
</I>&gt;&gt;<i> +    u8 acc_mask0;
</I>&gt;&gt;<i> +    u8 acc_mask1;
</I>&gt;&gt;<i> +    u8 acc_mask2;
</I>&gt;&gt;<i> +    u8 acc_mask3;
</I>&gt;&gt;<i> +    u8 btr0;
</I>&gt;&gt;<i> +    u8 btr1;
</I>&gt;&gt;<i> +    u8 outp_contr;
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* Representation of the CAN parameters for the M16C controller
</I>&gt;&gt;<i> + * in basic CAN mode (means no full CAN)
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +struct cpc_m16c_basic_params {
</I>&gt;&gt;<i> +    u8 con0;
</I>&gt;&gt;<i> +    u8 con1;
</I>&gt;&gt;<i> +    u8 ctlr0;
</I>&gt;&gt;<i> +    u8 ctlr1;
</I>&gt;&gt;<i> +    u8 clk;
</I>&gt;&gt;<i> +    u8 acc_std_code0;
</I>&gt;&gt;<i> +    u8 acc_std_code1;
</I>&gt;&gt;<i> +    u8 acc_ext_code0;
</I>&gt;&gt;<i> +    u8 acc_ext_code1;
</I>&gt;&gt;<i> +    u8 acc_ext_code2;
</I>&gt;&gt;<i> +    u8 acc_ext_code3;
</I>&gt;&gt;<i> +    u8 acc_std_mask0;
</I>&gt;&gt;<i> +    u8 acc_std_mask1;
</I>&gt;&gt;<i> +    u8 acc_ext_mask0;
</I>&gt;&gt;<i> +    u8 acc_ext_mask1;
</I>&gt;&gt;<i> +    u8 acc_ext_mask2;
</I>&gt;&gt;<i> +    u8 acc_ext_mask3;
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* CAN params message representation */
</I>&gt;&gt;<i> +struct cpc_can_params {
</I>&gt;&gt;<i> +    u8 cc_type;
</I>&gt;&gt;<i> +    union {
</I>&gt;&gt;<i> +        struct cpc_m16c_basic_params m16c_basic;
</I>&gt;&gt;<i> +        struct cpc_sja1000_params    sja1000;
</I>&gt;<i> 
</I>&gt;<i> Please avoid alignment of names also because you do not use it
</I>&gt;<i> consequently.
</I>Yepp.

&gt;<i> 
</I>&gt;&gt;<i> +    } cc_params;
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* Structure for confirmed message handling */
</I>&gt;&gt;<i> +struct cpc_confirm {
</I>&gt;&gt;<i> +    u8 result; /* error code */
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* Overrun types */
</I>&gt;&gt;<i> +#define CPC_OVR_EVENT_CAN       0x01
</I>&gt;&gt;<i> +#define CPC_OVR_EVENT_CANSTATE  0x02
</I>&gt;&gt;<i> +#define CPC_OVR_EVENT_BUSERROR  0x04
</I>&gt;<i> 
</I>&gt;<i> /s/_EVENT// ?
</I>&gt;<i> 
</I>&gt;&gt;<i> +/* If the CAN controller lost a message
</I>&gt;&gt;<i> + * we indicate it with the highest bit
</I>&gt;&gt;<i> + * set in the count field.
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +#define CPC_OVR_HW              0x80
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* Structure for overrun conditions */
</I>&gt;&gt;<i> +struct cpc_overrun {
</I>&gt;&gt;<i> +    u8 event;
</I>&gt;&gt;<i> +    u8 count;
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* SJA1000 CAN errors (compatible to NXP LPC2119) */
</I>&gt;&gt;<i> +struct cpc_sja1000_can_error {
</I>&gt;&gt;<i> +    u8 ecc;
</I>&gt;&gt;<i> +    u8 rxerr;
</I>&gt;&gt;<i> +    u8 txerr;
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* structure for CAN error conditions */
</I>&gt;&gt;<i> +#define  CPC_CAN_ECODE_ERRFRAME   0x01
</I>&gt;<i> 
</I>&gt;<i> Please put the defines in the file header.,
</I>Okay.

&gt;&gt;<i> +struct cpc_can_error {
</I>&gt;&gt;<i> +    u8 ecode;
</I>&gt;&gt;<i> +    struct {
</I>&gt;&gt;<i> +        u8 cc_type;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        union {
</I>&gt;&gt;<i> +            struct cpc_sja1000_can_error sja1000;
</I>&gt;&gt;<i> +        } regs;
</I>&gt;&gt;<i> +    } cc;
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* Structure containing RX/TX error counter.
</I>&gt;&gt;<i> + * This structure is used to request the
</I>&gt;&gt;<i> + * values of the CAN controllers TX and RX
</I>&gt;&gt;<i> + * error counter.
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +struct cpc_can_err_counter {
</I>&gt;&gt;<i> +    u8 rx;
</I>&gt;&gt;<i> +    u8 tx;
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* Main message type used between library and application */
</I>&gt;&gt;<i> +struct __attribute__ ((packed)) ems_cpc_msg  {
</I>&gt;&gt;<i> +    u8  type;     /* type of message */
</I>&gt;&gt;<i> +    u8  length;     /* length of data within union 'msg' */
</I>&gt;&gt;<i> +    u8  msgid;     /* confirmation handle */
</I>&gt;&gt;<i> +    u32 ts_sec;     /* timestamp in seconds */
</I>&gt;&gt;<i> +    u32 ts_nsec; /* timestamp in nano seconds */
</I>&gt;<i> 
</I>&gt;<i> Comment alignment?
</I>Done.

&gt;&gt;<i> +    union {
</I>&gt;&gt;<i> +        u8 generic[64];
</I>&gt;&gt;<i> +        struct cpc_can_msg    canmsg;
</I>&gt;&gt;<i> +        struct cpc_can_params canparams;
</I>&gt;&gt;<i> +        struct cpc_confirm    confirmation;
</I>&gt;&gt;<i> +        struct cpc_overrun    overrun;
</I>&gt;&gt;<i> +        struct cpc_can_error  error;
</I>&gt;&gt;<i> +        struct cpc_can_err_counter err_counter;
</I>&gt;&gt;<i> +        u8 canstate;
</I>&gt;<i> 
</I>&gt;<i> See above.
</I>Done.

&gt;&gt;<i> +    } msg;
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* Define these values to match your devices */
</I>&gt;&gt;<i> +#define USB_CPCUSB_VENDOR_ID    0x12D6
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define USB_CPCUSB_M16C_PRODUCT_ID    0x0888
</I>&gt;&gt;<i> +#define USB_CPCUSB_LPC2119_PRODUCT_ID 0x0444
</I>&gt;<i> 
</I>&gt;<i> Please put defines in the file header.
</I>Done and renamed LPC2119 to ARM7 as this is the official product name.

&gt;&gt;<i> +/* Table of devices that work with this driver
</I>&gt;&gt;<i> + * NOTE: This driver supports only CPC-USB/ARM7 (LPC2119) yet.
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +static struct usb_device_id ems_usb_table[] = {
</I>&gt;&gt;<i> +    //{USB_DEVICE(USB_CPCUSB_VENDOR_ID, USB_CPCUSB_M16C_PRODUCT_ID)},
</I>&gt;&gt;<i> +    {USB_DEVICE(USB_CPCUSB_VENDOR_ID, USB_CPCUSB_LPC2119_PRODUCT_ID)},
</I>&gt;&gt;<i> +    {}            /* Terminating entry */
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +MODULE_DEVICE_TABLE(usb, ems_usb_table);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CPC_MSG_HEADER_LEN 11
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define RX_BUFFER_SIZE 64
</I>&gt;&gt;<i> +#define HEADER_SIZE    4
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define MAX_RX_URBS 10
</I>&gt;&gt;<i> +#define MAX_TX_URBS 8
</I>&gt;<i> 
</I>&gt;<i> Please put defines in the file header. Also a prefix, e.g. CPC_ might be
</I>&gt;<i> logical.
</I>I prefer to let them at their current position. Everything before that was
related to the communication protocol for CPC-USB. But here the drivers
internal structures start and moving the defines to the file header would
not improve readability.

&gt;&gt;<i> +struct ems_usb {
</I>&gt;&gt;<i> +    struct can_priv can;    /* must be the first member */
</I>&gt;&gt;<i> +    int open_time;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    struct sk_buff *echo_skb[CAN_ECHO_SKB_MAX];
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    struct usb_device *udev;
</I>&gt;&gt;<i> +    struct net_device *netdev;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    atomic_t          active_tx_urbs;
</I>&gt;&gt;<i> +    struct usb_anchor tx_submitted;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    struct usb_anchor rx_submitted;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    struct urb *intr_urb;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    u8 *tx_msg_buffer;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    u8 intr_in_buffer[4];
</I>&gt;&gt;<i> +    unsigned int free_slots; /* Remember number of freely available
</I>&gt;&gt;<i> slots */
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    struct ems_cpc_msg active_params; /* Active controller parameters */
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define GET_PARAMS(d) (d-&gt;active_params.msg.canparams.cc_params.sja1000)
</I>&gt;<i> 
</I>&gt;<i> Rarely used. Consider removing it for better readability.
</I>You are right. Removed.

&gt;<i> 
</I>&gt;&gt;<i> +/* Mode register NXP LPC2119/SJA1000 CAN Controller */
</I>&gt;&gt;<i> +#define MOD_NORMAL 0x00
</I>&gt;&gt;<i> +#define MOD_RM 0x01
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* ECC register NXP LPC2119/SJA1000 CAN Controller */
</I>&gt;&gt;<i> +#define ECC_SEG        0x1F
</I>&gt;&gt;<i> +#define ECC_DIR        0x20
</I>&gt;&gt;<i> +#define ECC_ERR        6
</I>&gt;&gt;<i> +#define ECC_BIT        0x00
</I>&gt;&gt;<i> +#define ECC_FORM    0x40
</I>&gt;&gt;<i> +#define ECC_STUFF    0x80
</I>&gt;&gt;<i> +#define ECC_MASK    0xc0
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* status register content */
</I>&gt;&gt;<i> +#define SR_BS        0x80
</I>&gt;&gt;<i> +#define SR_ES        0x40
</I>&gt;<i> 
</I>&gt;<i> Please put defines in the file header. Consider using a proper prefix,
</I>&gt;<i> e.g. SJA_ or CPC_.
</I>Done.

&gt;&gt;<i> +static void init_params_sja1000(struct ems_cpc_msg *msg, u8 btr0, u8
</I>&gt;&gt;<i> btr1,
</I>&gt;&gt;<i> +                                u8 outp, u8 mod)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    msg-&gt;type = CPC_CMD_T_CAN_PRMS;
</I>&gt;&gt;<i> +    msg-&gt;length = sizeof(struct cpc_can_params);
</I>&gt;&gt;<i> +    msg-&gt;msgid = 0;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    msg-&gt;msg.canparams.cc_type = SJA1000;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    msg-&gt;msg.canparams.cc_params.sja1000.acc_code0 = 0x00;
</I>&gt;&gt;<i> +    msg-&gt;msg.canparams.cc_params.sja1000.acc_code1 = 0x00;
</I>&gt;&gt;<i> +    msg-&gt;msg.canparams.cc_params.sja1000.acc_code2 = 0x00;
</I>&gt;&gt;<i> +    msg-&gt;msg.canparams.cc_params.sja1000.acc_code3 = 0x00;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    msg-&gt;msg.canparams.cc_params.sja1000.acc_mask0 = 0xFF;
</I>&gt;&gt;<i> +    msg-&gt;msg.canparams.cc_params.sja1000.acc_mask1 = 0xFF;
</I>&gt;&gt;<i> +    msg-&gt;msg.canparams.cc_params.sja1000.acc_mask2 = 0xFF;
</I>&gt;&gt;<i> +    msg-&gt;msg.canparams.cc_params.sja1000.acc_mask3 = 0xFF;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    msg-&gt;msg.canparams.cc_params.sja1000.btr0 = btr0;
</I>&gt;&gt;<i> +    msg-&gt;msg.canparams.cc_params.sja1000.btr1 = btr1;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    msg-&gt;msg.canparams.cc_params.sja1000.outp_contr = outp;
</I>&gt;&gt;<i> +    msg-&gt;msg.canparams.cc_params.sja1000.mode = mod;
</I>&gt;<i> 
</I>&gt;<i> Ugly. Maybe:
</I>&gt;<i> 
</I>&gt;<i>     struct cpc_sja1000_params *sja =
</I>&gt;<i>         &amp;msg-&gt;msg.canparams.cc_params.sja1000;
</I>&gt;<i> 
</I>&gt;<i>         sja-&gt;acc_code0 = 0x00;
</I>&gt;<i>         ...
</I>Done.

&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static void ems_usb_read_interrupt_callback(struct urb *urb)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    struct ems_usb *dev = urb-&gt;context;
</I>&gt;&gt;<i> +    struct net_device *netdev;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    int retval;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    netdev = dev-&gt;netdev;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (!netif_device_present(netdev))
</I>&gt;&gt;<i> +        return;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    switch (urb-&gt;status) {
</I>&gt;&gt;<i> +    case 0:
</I>&gt;&gt;<i> +        dev-&gt;free_slots = dev-&gt;intr_in_buffer[1];
</I>&gt;&gt;<i> +        break;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    case -ECONNRESET:/* unlink */
</I>&gt;&gt;<i> +    case -ENOENT:
</I>&gt;&gt;<i> +    case -ESHUTDOWN:
</I>&gt;&gt;<i> +        return;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    default:
</I>&gt;&gt;<i> +        dev_info(ND2D(netdev), &quot;nonzero urb status %d\n&quot;, urb-&gt;status);
</I>&gt;&gt;<i> +        break;
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    retval = usb_submit_urb(urb, GFP_ATOMIC);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (retval == -ENODEV)
</I>&gt;&gt;<i> +        netif_device_detach(netdev);
</I>&gt;&gt;<i> +    else if (retval)
</I>&gt;&gt;<i> +        dev_err(ND2D(netdev), &quot;failed resubmitting intr urb: %d\n&quot;,
</I>&gt;&gt;<i> retval);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    return;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static void ems_usb_rx_canmsg(struct ems_usb *dev, struct ems_cpc_msg
</I>&gt;&gt;<i> *msg)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    struct can_frame *cf;
</I>&gt;&gt;<i> +    struct sk_buff *skb;
</I>&gt;&gt;<i> +    int i;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    struct net_device_stats *stats =&amp;dev-&gt;netdev-&gt;stats;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    skb = dev_alloc_skb(sizeof(struct can_frame));
</I>&gt;&gt;<i> +    if (skb == NULL)
</I>&gt;&gt;<i> +        return;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    skb-&gt;dev = dev-&gt;netdev;
</I>&gt;&gt;<i> +    skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
</I>&gt;&gt;<i> +    memset(cf, 0, sizeof(struct can_frame));
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    cf-&gt;can_id  = msg-&gt;msg.canmsg.id;
</I>&gt;&gt;<i> +    cf-&gt;can_dlc = msg-&gt;msg.canmsg.length&gt;  8 ? 8 :
</I>&gt;&gt;<i> msg-&gt;msg.canmsg.length;
</I>&gt;<i> 
</I>&gt;<i> Coding style.
</I>Used clamp_t() instead.

&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (msg-&gt;type == CPC_MSG_T_XCAN || msg-&gt;type == CPC_MSG_T_XRTR)
</I>&gt;&gt;<i> +        cf-&gt;can_id |= CAN_EFF_FLAG;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (msg-&gt;type == CPC_MSG_T_RTR || msg-&gt;type == CPC_MSG_T_XRTR) {
</I>&gt;&gt;<i> +        cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;&gt;<i> +    } else {
</I>&gt;&gt;<i> +        *(u64 *)(&amp;cf-&gt;data) = 0; /* clear payload */
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        for (i = 0; i&lt;  cf-&gt;can_dlc; i++)
</I>&gt;&gt;<i> +            cf-&gt;data[i] = msg-&gt;msg.canmsg.msg[i];
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    netif_rx(skb);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    dev-&gt;netdev-&gt;last_rx = jiffies;
</I>&gt;&gt;<i> +    stats-&gt;rx_packets++;
</I>&gt;&gt;<i> +    stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static void ems_usb_rx_err(struct ems_usb *dev, struct ems_cpc_msg *msg)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    struct can_frame *cf;
</I>&gt;&gt;<i> +    struct sk_buff *skb;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    struct net_device_stats *stats =&amp;dev-&gt;netdev-&gt;stats;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    skb = dev_alloc_skb(sizeof(struct can_frame));
</I>&gt;&gt;<i> +    if (skb == NULL)
</I>&gt;&gt;<i> +        return;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    skb-&gt;dev = dev-&gt;netdev;
</I>&gt;&gt;<i> +    skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
</I>&gt;&gt;<i> +    memset(cf, 0, sizeof(struct can_frame));
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    cf-&gt;can_id  = CAN_ERR_FLAG;
</I>&gt;&gt;<i> +    cf-&gt;can_dlc = CAN_ERR_DLC;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (msg-&gt;type == CPC_MSG_T_CANSTATE) {
</I>&gt;&gt;<i> +        u8 status = msg-&gt;msg.canstate;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        if (status&amp;  SR_BS) {
</I>&gt;&gt;<i> +            dev-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;&gt;<i> +            cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +            can_bus_off(dev-&gt;netdev);
</I>&gt;&gt;<i> +        } else if (status&amp;  SR_ES) {
</I>&gt;&gt;<i> +            dev-&gt;can.state = CAN_STATE_ERROR_WARNING;
</I>&gt;&gt;<i> +            dev-&gt;can.can_stats.error_warning++;
</I>&gt;&gt;<i> +        } else {
</I>&gt;&gt;<i> +            dev-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;&gt;<i> +            dev-&gt;can.can_stats.error_passive++;
</I>&gt;&gt;<i> +        }
</I>&gt;&gt;<i> +    } else if (msg-&gt;type == CPC_MSG_T_CANERROR) {
</I>&gt;&gt;<i> +        u8 ecc   = msg-&gt;msg.error.cc.regs.sja1000.ecc;
</I>&gt;&gt;<i> +        u8 txerr = msg-&gt;msg.error.cc.regs.sja1000.txerr;
</I>&gt;&gt;<i> +        u8 rxerr = msg-&gt;msg.error.cc.regs.sja1000.rxerr;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        /* bus error interrupt */
</I>&gt;&gt;<i> +        dev-&gt;can.can_stats.bus_error++;
</I>&gt;&gt;<i> +        stats-&gt;rx_errors++;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        switch (ecc&amp;  ECC_MASK) {
</I>&gt;&gt;<i> +        case ECC_BIT:
</I>&gt;&gt;<i> +            cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
</I>&gt;&gt;<i> +            break;
</I>&gt;&gt;<i> +        case ECC_FORM:
</I>&gt;&gt;<i> +            cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;&gt;<i> +            break;
</I>&gt;&gt;<i> +        case ECC_STUFF:
</I>&gt;&gt;<i> +            cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;&gt;<i> +            break;
</I>&gt;&gt;<i> +        default:
</I>&gt;&gt;<i> +            cf-&gt;data[2] |= CAN_ERR_PROT_UNSPEC;
</I>&gt;&gt;<i> +            cf-&gt;data[3] = ecc&amp;  ECC_SEG;
</I>&gt;&gt;<i> +            break;
</I>&gt;&gt;<i> +        }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        /* Error occured during transmission? */
</I>&gt;&gt;<i> +        if ((ecc&amp;  ECC_DIR) == 0)
</I>&gt;&gt;<i> +            cf-&gt;data[2] |= CAN_ERR_PROT_TX;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        if (dev-&gt;can.state == CAN_STATE_ERROR_WARNING ||
</I>&gt;&gt;<i> +                dev-&gt;can.state == CAN_STATE_ERROR_PASSIVE) {
</I>&gt;&gt;<i> +            cf-&gt;data[1] = (txerr&gt;   rxerr) ?
</I>&gt;<i> 
</I>&gt;<i>             cf-&gt;data[1] = (txerr&gt; rxerr) ?
</I>&gt;<i> 
</I>Fixed.

&gt;&gt;<i> +                    CAN_ERR_CRTL_TX_PASSIVE : CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;&gt;<i> +        }
</I>&gt;&gt;<i> +    } else if (msg-&gt;type == CPC_MSG_T_OVERRUN) {
</I>&gt;&gt;<i> +        cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;&gt;<i> +        cf-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        stats-&gt;rx_over_errors++;
</I>&gt;&gt;<i> +        stats-&gt;rx_errors++;
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    netif_rx(skb);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    dev-&gt;netdev-&gt;last_rx = jiffies;
</I>&gt;&gt;<i> +    stats-&gt;rx_packets++;
</I>&gt;&gt;<i> +    stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/*
</I>&gt;&gt;<i> + * callback for bulk IN urb
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +static void ems_usb_read_bulk_callback(struct urb *urb)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    struct ems_usb *dev = urb-&gt;context;
</I>&gt;&gt;<i> +    struct net_device *netdev;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    int retval;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    netdev = dev-&gt;netdev;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (!netif_device_present(netdev))
</I>&gt;&gt;<i> +        return;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    switch (urb-&gt;status) {
</I>&gt;&gt;<i> +    case 0:        /* success */
</I>&gt;&gt;<i> +        break;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    case -ENOENT:
</I>&gt;&gt;<i> +        return;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    default:
</I>&gt;&gt;<i> +        dev_warn(ND2D(netdev), &quot;nonzero URB status %d\n&quot;, urb-&gt;status);
</I>&gt;<i> 
</I>&gt;<i> Error?
</I>URBs are often happen to failed, especially when the device stops or get
removed.

&gt;&gt;<i> +        goto resubmit_urb;
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (urb-&gt;actual_length&gt;  HEADER_SIZE) {
</I>&gt;&gt;<i> +        struct ems_cpc_msg *msg;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        u8 *ibuf = urb-&gt;transfer_buffer;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        u8 msgCnt, again, start;
</I>&gt;<i> 
</I>&gt;<i> Remove empty lines above.
</I>Done.

&gt;&gt;<i> +        msgCnt = ibuf[0]&amp;  ~0x80;
</I>&gt;&gt;<i> +        again = ibuf[0]&amp;  0x80;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        start = HEADER_SIZE;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        while (msgCnt) {
</I>&gt;<i> 
</I>&gt;<i> msg_cnt or msg_count!?
</I>Done.

&gt;&gt;<i> +            msg = (struct ems_cpc_msg *)&amp;ibuf[start];
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +            switch (msg-&gt;type) {
</I>&gt;&gt;<i> +            case CPC_MSG_T_CANSTATE:
</I>&gt;&gt;<i> +                /* Process CAN state changes */
</I>&gt;&gt;<i> +                ems_usb_rx_err(dev, msg);
</I>&gt;&gt;<i> +                break;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +            case CPC_MSG_T_CAN:
</I>&gt;&gt;<i> +            case CPC_MSG_T_XCAN:
</I>&gt;&gt;<i> +            case CPC_MSG_T_RTR:
</I>&gt;&gt;<i> +            case CPC_MSG_T_XRTR:
</I>&gt;&gt;<i> +                ems_usb_rx_canmsg(dev, msg);
</I>&gt;&gt;<i> +                break;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +            case CPC_MSG_T_CANERROR:
</I>&gt;&gt;<i> +                /* Process errorframe */
</I>&gt;&gt;<i> +                ems_usb_rx_err(dev, msg);
</I>&gt;&gt;<i> +                break;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +            case CPC_MSG_T_OVERRUN:
</I>&gt;&gt;<i> +                /* Message lost while receiving */
</I>&gt;&gt;<i> +                ems_usb_rx_err(dev, msg);
</I>&gt;&gt;<i> +                break;
</I>&gt;&gt;<i> +            }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +            start += CPC_MSG_HEADER_LEN + msg-&gt;length;
</I>&gt;&gt;<i> +            msgCnt--;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +            if (start&gt;  urb-&gt;transfer_buffer_length) {
</I>&gt;<i> 
</I>&gt;<i> Coding style.
</I>Do you mean the missing space before '&gt;' and the additional 2 space after?
I can't explain how it happens, in my patch file these whitespace are okay.

&gt;<i> 
</I>&gt;&gt;<i> +                err(&quot;%d&gt;  %d\n&quot;, start, urb-&gt;transfer_buffer_length);
</I>&gt;<i> 
</I>&gt;<i> dev_err()?
</I>Done.

&gt;&gt;<i> +                break;
</I>&gt;&gt;<i> +            }
</I>&gt;&gt;<i> +        }
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +resubmit_urb:
</I>&gt;&gt;<i> +    usb_fill_bulk_urb(urb, dev-&gt;udev, usb_rcvbulkpipe(dev-&gt;udev, 2),
</I>&gt;&gt;<i> +        urb-&gt;transfer_buffer, RX_BUFFER_SIZE,
</I>&gt;&gt;<i> ems_usb_read_bulk_callback, dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    retval = usb_submit_urb(urb, GFP_ATOMIC);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (retval == -ENODEV)
</I>&gt;&gt;<i> +        netif_device_detach(netdev);
</I>&gt;&gt;<i> +    else if (retval)
</I>&gt;&gt;<i> +        dev_err(ND2D(netdev), &quot;failed resubmitting bulk urb: %d\n&quot;,
</I>&gt;&gt;<i> retval);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    return;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/*
</I>&gt;&gt;<i> + * callback for bulk IN urb
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +static void ems_usb_write_bulk_callback(struct urb *urb)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    struct ems_usb *dev = urb-&gt;context;
</I>&gt;&gt;<i> +    struct net_device *netdev;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (!dev)
</I>&gt;&gt;<i> +        return;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    netdev = dev-&gt;netdev;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (!netif_device_present(netdev))
</I>&gt;&gt;<i> +        return;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (urb-&gt;status)
</I>&gt;&gt;<i> +        dev_info(ND2D(netdev), &quot;%s: Tx status %d\n&quot;, netdev-&gt;name,
</I>&gt;&gt;<i> urb-&gt;status);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* free up our allocated buffer */
</I>&gt;&gt;<i> +    usb_buffer_free(urb-&gt;dev, urb-&gt;transfer_buffer_length,
</I>&gt;&gt;<i> +            urb-&gt;transfer_buffer, urb-&gt;transfer_dma);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    netdev-&gt;trans_start = jiffies;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* transmission complete interrupt */
</I>&gt;&gt;<i> +    netdev-&gt;stats.tx_packets++;
</I>&gt;&gt;<i> +    can_get_echo_skb(netdev, 0);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    atomic_dec(&amp;dev-&gt;active_tx_urbs);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (netif_queue_stopped(netdev))
</I>&gt;&gt;<i> +        netif_wake_queue(netdev);
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/**
</I>&gt;&gt;<i> + * Send the given CPC command synchronously
</I>&gt;&gt;<i> + */
</I>&gt;<i> 
</I>&gt;<i> Docbook comment?
</I>Oops, old habit.

&gt;&gt;<i> +static int ems_usb_command_msg(struct ems_usb *dev, struct
</I>&gt;&gt;<i> ems_cpc_msg *msg)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    int actual_length;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* Copy payload */
</I>&gt;&gt;<i> +    memcpy(&amp;dev-&gt;tx_msg_buffer[HEADER_SIZE], msg,
</I>&gt;&gt;<i> +           msg-&gt;length + CPC_MSG_HEADER_LEN);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* Clear header */
</I>&gt;&gt;<i> +    memset(&amp;dev-&gt;tx_msg_buffer[0], 0, HEADER_SIZE);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    return usb_bulk_msg(dev-&gt;udev, usb_sndbulkpipe(dev-&gt;udev, 2),
</I>&gt;&gt;<i> +                        &amp;dev-&gt;tx_msg_buffer[0],
</I>&gt;&gt;<i> +                        msg-&gt;length + CPC_MSG_HEADER_LEN + HEADER_SIZE,
</I>&gt;&gt;<i> +                        &amp;actual_length, 1000);
</I>&gt;&gt;<i> +}
</I>&gt;<i> 
</I>&gt;<i> Alignment? Line length?
</I>Cleaned.

&gt;&gt;<i> +
</I>&gt;&gt;<i> +/*
</I>&gt;&gt;<i> + * Change CAN controllers' mode register
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +static int ems_usb_write_mode(struct ems_usb *dev, u8 mode)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    GET_PARAMS(dev).mode = mode;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    return ems_usb_command_msg(dev,&amp;dev-&gt;active_params);
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/*
</I>&gt;&gt;<i> + * Send a CPC_Control command to change behaviour when interface
</I>&gt;&gt;<i> receives a CAN
</I>&gt;&gt;<i> + * message, bus error or CAN state changed notifications.
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +static int ems_usb_control_cmd(struct ems_usb *dev, u8 val)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    struct ems_cpc_msg cmd;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    cmd.type = CPC_CMD_T_CONTROL;
</I>&gt;&gt;<i> +    cmd.length = CPC_MSG_HEADER_LEN + 1;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    cmd.msgid = 0;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    cmd.msg.generic[0] = val;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    return ems_usb_command_msg(dev,&amp;cmd);
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/*
</I>&gt;&gt;<i> + * Start interface
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +static int ems_usb_start(struct ems_usb *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    struct net_device *netdev =  dev-&gt;netdev;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    int result, i;
</I>&gt;<i> 
</I>&gt;<i> Please remove empty line above. Also s/result/err/ might be more
</I>&gt;<i> appropriate. Please check.
</I>Done.

&gt;&gt;<i> +
</I>&gt;&gt;<i> +    dev-&gt;intr_in_buffer[0] = 0;
</I>&gt;&gt;<i> +    dev-&gt;free_slots = 15; /* initial size */
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    for (i = 0; i&lt;  MAX_RX_URBS; i++) {
</I>&gt;&gt;<i> +        struct urb *urb = NULL;
</I>&gt;&gt;<i> +        u8 *buf = NULL;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        /* create a urb, and a buffer for it, and copy the data to
</I>&gt;&gt;<i> the urb */
</I>&gt;&gt;<i> +        urb = usb_alloc_urb(0, GFP_ATOMIC);
</I>&gt;&gt;<i> +        if (!urb) {
</I>&gt;&gt;<i> +            dev_err(ND2D(netdev), &quot;No memory left for URBs\n&quot;);
</I>&gt;&gt;<i> +            return -ENOMEM;
</I>&gt;&gt;<i> +        }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        buf = usb_buffer_alloc(dev-&gt;udev, RX_BUFFER_SIZE, GFP_KERNEL,
</I>&gt;&gt;<i> +                            &amp;urb-&gt;transfer_dma);
</I>&gt;&gt;<i> +        if (!buf) {
</I>&gt;&gt;<i> +            dev_err(ND2D(netdev), &quot;No memory left for USB buffer\n&quot;);
</I>&gt;&gt;<i> +            usb_free_urb(urb);
</I>&gt;&gt;<i> +            break;
</I>&gt;&gt;<i> +        }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        usb_fill_bulk_urb(urb, dev-&gt;udev, usb_rcvbulkpipe(dev-&gt;udev,
</I>&gt;&gt;<i> 2), buf,
</I>&gt;&gt;<i> +                RX_BUFFER_SIZE, ems_usb_read_bulk_callback, dev);
</I>&gt;&gt;<i> +        urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
</I>&gt;&gt;<i> +        usb_anchor_urb(urb,&amp;dev-&gt;rx_submitted);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        result = usb_submit_urb(urb, GFP_KERNEL);
</I>&gt;&gt;<i> +        if (result) {
</I>&gt;&gt;<i> +            if (result == -ENODEV)
</I>&gt;&gt;<i> +                netif_device_detach(dev-&gt;netdev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +            usb_unanchor_urb(urb);
</I>&gt;&gt;<i> +            usb_buffer_free(dev-&gt;udev, RX_BUFFER_SIZE, buf,
</I>&gt;&gt;<i> urb-&gt;transfer_dma);
</I>&gt;&gt;<i> +            break;
</I>&gt;&gt;<i> +        }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        /* Drop reference, USB core will take care of freeing it */
</I>&gt;&gt;<i> +        usb_free_urb(urb);
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* Do we submitted any URBs */
</I>&gt;&gt;<i> +    if (i == 0) {
</I>&gt;&gt;<i> +        dev_warn(ND2D(netdev), &quot;couldn't setup read URBs\n&quot;);
</I>&gt;&gt;<i> +        return result ? result : -ENOMEM;
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* Warn if we've couldn't transmit all the URBs */
</I>&gt;&gt;<i> +    if (i&lt;  MAX_RX_URBS)
</I>&gt;<i> 
</I>&gt;<i> Coding style.
</I>Same as above.

&gt;&gt;<i> +        dev_warn(ND2D(netdev), &quot;rx performance may be slow\n&quot;);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* Setup and start interrupt URB */
</I>&gt;&gt;<i> +    usb_fill_int_urb(dev-&gt;intr_urb, dev-&gt;udev,
</I>&gt;&gt;<i> +                     usb_rcvintpipe(dev-&gt;udev, 1),
</I>&gt;&gt;<i> +                     dev-&gt;intr_in_buffer, sizeof(dev-&gt;intr_in_buffer),
</I>&gt;&gt;<i> +                     ems_usb_read_interrupt_callback, dev, 1);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    result = usb_submit_urb(dev-&gt;intr_urb, GFP_KERNEL);
</I>&gt;&gt;<i> +    if (result) {
</I>&gt;&gt;<i> +        if (result == -ENODEV)
</I>&gt;&gt;<i> +            netif_device_detach(dev-&gt;netdev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        dev_warn(ND2D(netdev), &quot;intr urb submit failed: %d\n&quot;, result);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        return result;
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* CPC-USB will transfer received message to host */
</I>&gt;&gt;<i> +    result = ems_usb_control_cmd(dev, CONTR_CAN_Message |
</I>&gt;&gt;<i> CONTR_CONT_ON);
</I>&gt;&gt;<i> +    if (result)
</I>&gt;&gt;<i> +        goto failed;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* CPC-USB will transfer CAN state changes to host */
</I>&gt;&gt;<i> +    result = ems_usb_control_cmd(dev, CONTR_CAN_State | CONTR_CONT_ON);
</I>&gt;&gt;<i> +    if (result)
</I>&gt;&gt;<i> +        goto failed;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* CPC-USB will transfer bus errors to host */
</I>&gt;&gt;<i> +    result = ems_usb_control_cmd(dev, CONTR_BusError | CONTR_CONT_ON);
</I>&gt;&gt;<i> +    if (result)
</I>&gt;&gt;<i> +        goto failed;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    result = ems_usb_write_mode(dev, MOD_NORMAL);
</I>&gt;&gt;<i> +    if (result)
</I>&gt;&gt;<i> +        goto failed;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    return 0;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +failed:
</I>&gt;&gt;<i> +    if (result == -ENODEV)
</I>&gt;&gt;<i> +        netif_device_detach(dev-&gt;netdev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    dev_warn(ND2D(netdev), &quot;couldn't submit control: %d\n&quot;, result);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    return result;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static int alloc_all_urbs(struct ems_usb *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    init_usb_anchor(&amp;dev-&gt;rx_submitted);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    init_usb_anchor(&amp;dev-&gt;tx_submitted);
</I>&gt;&gt;<i> +    atomic_set(&amp;dev-&gt;active_tx_urbs, 0);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    dev-&gt;intr_urb = usb_alloc_urb(0, GFP_KERNEL);
</I>&gt;&gt;<i> +    if (!dev-&gt;intr_urb)
</I>&gt;&gt;<i> +        return 0;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    return 1;
</I>&gt;&gt;<i> +}
</I>&gt;<i> 
</I>&gt;<i> Unusual return values for error and success.
</I>Function remove, was only called once in the code.

&gt;&gt;<i> +static void free_all_urbs(struct ems_usb *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    usb_free_urb(dev-&gt;intr_urb);
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static void unlink_all_urbs(struct ems_usb *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    usb_unlink_urb(dev-&gt;intr_urb);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    usb_kill_anchored_urbs(&amp;dev-&gt;rx_submitted);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    usb_kill_anchored_urbs(&amp;dev-&gt;tx_submitted);
</I>&gt;&gt;<i> +    atomic_set(&amp;dev-&gt;active_tx_urbs, 0);
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static int ems_usb_open(struct net_device *netdev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    struct ems_usb *dev = netdev_priv(netdev);
</I>&gt;&gt;<i> +    int result;
</I>&gt;<i> 
</I>&gt;<i> s/result/err/ ? See above.
</I>Done.

&gt;&gt;<i> +
</I>&gt;&gt;<i> +    result = ems_usb_write_mode(dev, MOD_RM);
</I>&gt;&gt;<i> +    if (result)
</I>&gt;&gt;<i> +        return result;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* common open */
</I>&gt;&gt;<i> +    result = open_candev(netdev);
</I>&gt;&gt;<i> +    if (result)
</I>&gt;&gt;<i> +        return result;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* finally start device */
</I>&gt;&gt;<i> +    result = ems_usb_start(dev);
</I>&gt;&gt;<i> +    if (result) {
</I>&gt;&gt;<i> +        if (result == -ENODEV)
</I>&gt;&gt;<i> +            netif_device_detach(dev-&gt;netdev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        dev_warn(ND2D(netdev), &quot;couldn't start device: %d\n&quot;, result);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        return result;
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    dev-&gt;open_time = jiffies;
</I>&gt;&gt;<i> +    dev-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> 
</I>&gt;<i> Should go to usb_start.
</I>Done.

&gt;&gt;<i> +
</I>&gt;&gt;<i> +    netif_start_queue(netdev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    return 0;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static int ems_usb_start_xmit(struct sk_buff *skb, struct net_device
</I>&gt;&gt;<i> *netdev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    struct ems_usb *dev = netdev_priv(netdev);
</I>&gt;&gt;<i> +    struct net_device_stats *stats =&amp;netdev-&gt;stats;
</I>&gt;&gt;<i> +    struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;&gt;<i> +    struct ems_cpc_msg *msg = NULL;
</I>&gt;&gt;<i> +    struct urb *urb = NULL;
</I>&gt;&gt;<i> +    u8 *buf = NULL;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    size_t size = HEADER_SIZE + CPC_MSG_HEADER_LEN + sizeof(struct
</I>&gt;&gt;<i> cpc_can_msg);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    int i, result;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* create a urb, and a buffer for it, and copy the data to the
</I>&gt;&gt;<i> urb */
</I>&gt;&gt;<i> +    urb = usb_alloc_urb(0, GFP_ATOMIC);
</I>&gt;&gt;<i> +    if (!urb) {
</I>&gt;&gt;<i> +        dev_err(ND2D(netdev), &quot;No memory left for URBs\n&quot;);
</I>&gt;&gt;<i> +        return -ENOMEM;
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    buf = usb_buffer_alloc(dev-&gt;udev, size,
</I>&gt;&gt;<i> GFP_KERNEL,&amp;urb-&gt;transfer_dma);
</I>&gt;&gt;<i> +    if (!buf) {
</I>&gt;&gt;<i> +        dev_err(ND2D(netdev), &quot;No memory left for USB buffer\n&quot;);
</I>&gt;&gt;<i> +        usb_free_urb(urb);
</I>&gt;&gt;<i> +        return -ENOMEM;
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    msg = (struct ems_cpc_msg *)&amp;buf[HEADER_SIZE];
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    msg-&gt;msg.canmsg.id = cf-&gt;can_id&amp;  0x1FFFFFFFU;
</I>&gt;&gt;<i> +    msg-&gt;msg.canmsg.length = cf-&gt;can_dlc;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (cf-&gt;can_id&amp;  CAN_RTR_FLAG) {
</I>&gt;&gt;<i> +        msg-&gt;type = cf-&gt;can_id&amp;  CAN_EFF_FLAG ? CPC_CMD_T_XRTR :
</I>&gt;&gt;<i> CPC_CMD_T_RTR;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        msg-&gt;length = 4 + 1;
</I>&gt;&gt;<i> +    } else {
</I>&gt;&gt;<i> +        msg-&gt;type = cf-&gt;can_id&amp;  CAN_EFF_FLAG ? CPC_CMD_T_XCAN :
</I>&gt;&gt;<i> CPC_CMD_T_CAN;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        for (i = 0; i&lt;  cf-&gt;can_dlc; i++)
</I>&gt;&gt;<i> +            msg-&gt;msg.canmsg.msg[i] = cf-&gt;data[i];
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        msg-&gt;length = 4 + 1 + cf-&gt;can_dlc;
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    usb_fill_bulk_urb(urb, dev-&gt;udev, usb_sndbulkpipe(dev-&gt;udev, 2),
</I>&gt;&gt;<i> buf,
</I>&gt;&gt;<i> +            size, ems_usb_write_bulk_callback, dev);
</I>&gt;&gt;<i> +    urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
</I>&gt;&gt;<i> +    usb_anchor_urb(urb,&amp;dev-&gt;tx_submitted);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    can_put_echo_skb(skb, netdev, 0);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    result = usb_submit_urb(urb, GFP_ATOMIC);
</I>&gt;&gt;<i> +    if (result) {
</I>&gt;&gt;<i> +        can_free_echo_skb(netdev, 0);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        usb_unanchor_urb(urb);
</I>&gt;&gt;<i> +        usb_buffer_free(dev-&gt;udev, size, buf, urb-&gt;transfer_dma);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        if (result == -ENODEV) {
</I>&gt;&gt;<i> +            netif_device_detach(netdev);
</I>&gt;&gt;<i> +        } else {
</I>&gt;&gt;<i> +            dev_warn(ND2D(netdev), &quot;failed tx_urb %d\n&quot;, result);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +            stats-&gt;tx_errors++;
</I>&gt;&gt;<i> +            netif_start_queue(netdev);
</I>&gt;&gt;<i> +        }
</I>&gt;&gt;<i> +    } else {
</I>&gt;&gt;<i> +        atomic_inc(&amp;dev-&gt;active_tx_urbs);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        stats-&gt;tx_bytes += cf-&gt;can_dlc;
</I>&gt;&gt;<i> +        netdev-&gt;trans_start = jiffies;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        stats-&gt;tx_packets++;
</I>&gt;&gt;<i> +        stats-&gt;tx_bytes += skb-&gt;len;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        netdev-&gt;trans_start = jiffies;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        /* Slow down tx path */
</I>&gt;&gt;<i> +        if (atomic_read(&amp;dev-&gt;active_tx_urbs)&gt;  MAX_TX_URBS ||
</I>&gt;&gt;<i> +                dev-&gt;free_slots&lt;  5) {
</I>&gt;&gt;<i> +            netif_stop_queue(netdev);
</I>&gt;&gt;<i> +            return 0;
</I>&gt;&gt;<i> +        }
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* release our reference to this urb, the
</I>&gt;&gt;<i> +     * USB core will eventually free it entirely
</I>&gt;&gt;<i> +     */
</I>&gt;&gt;<i> +    usb_free_urb(urb);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    return 0;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static int ems_usb_close(struct net_device *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    struct ems_usb *priv = netdev_priv(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    netif_stop_queue(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* Stop polling */
</I>&gt;&gt;<i> +    unlink_all_urbs(priv);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* Set CAN controller to reset mode */
</I>&gt;&gt;<i> +    if (ems_usb_write_mode(priv, MOD_RM))
</I>&gt;&gt;<i> +        dev_warn(ND2D(dev), &quot;couldn't stop device&quot;);
</I>&gt;<i> 
</I>&gt;<i> Hm, it's that an error?
</I>May happen during close as the communication is abort. Don't
think it is an error.

&gt;&gt;<i> +
</I>&gt;&gt;<i> +    close_candev(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    priv-&gt;open_time = 0;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    return 0;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#if LINUX_VERSION_CODE&gt;  KERNEL_VERSION(2,6,28)
</I>&gt;&gt;<i> +static const struct net_device_ops ems_usb_netdev_ops = {
</I>&gt;&gt;<i> +    .ndo_open       = ems_usb_open,
</I>&gt;&gt;<i> +    .ndo_stop       = ems_usb_close,
</I>&gt;&gt;<i> +    .ndo_start_xmit = ems_usb_start_xmit,
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +#endif
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static struct can_bittiming_const ems_usb_bittiming_const = {
</I>&gt;&gt;<i> +    .name = &quot;ems_usb&quot;,
</I>&gt;&gt;<i> +    .tseg1_min = 1,
</I>&gt;&gt;<i> +    .tseg1_max = 16,
</I>&gt;&gt;<i> +    .tseg2_min = 1,
</I>&gt;&gt;<i> +    .tseg2_max = 8,
</I>&gt;&gt;<i> +    .sjw_max = 4,
</I>&gt;&gt;<i> +    .brp_min = 1,
</I>&gt;&gt;<i> +    .brp_max = 64,
</I>&gt;&gt;<i> +    .brp_inc = 1,
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static int ems_usb_set_mode(struct net_device *dev, enum can_mode mode)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    struct ems_usb *priv = netdev_priv(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (!priv-&gt;open_time)
</I>&gt;&gt;<i> +        return -EINVAL;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    switch (mode) {
</I>&gt;&gt;<i> +    case CAN_MODE_START:
</I>&gt;&gt;<i> +        if (ems_usb_write_mode(priv, MOD_NORMAL))
</I>&gt;&gt;<i> +            dev_warn(ND2D(dev), &quot;couldn't start device&quot;);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        if (netif_queue_stopped(dev))
</I>&gt;&gt;<i> +            netif_wake_queue(dev);
</I>&gt;&gt;<i> +        break;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    default:
</I>&gt;&gt;<i> +        return -EOPNOTSUPP;
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    return 0;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static int ems_usb_set_bittiming(struct net_device *dev)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    struct ems_usb *priv = netdev_priv(dev);
</I>&gt;&gt;<i> +    struct can_bittiming *bt =&amp;priv-&gt;can.bittiming;
</I>&gt;&gt;<i> +    u8 btr0, btr1;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    btr0 = ((bt-&gt;brp - 1)&amp;  0x3f) | (((bt-&gt;sjw - 1)&amp;  0x3)&lt;&lt;  6);
</I>&gt;&gt;<i> +    btr1 = ((bt-&gt;prop_seg + bt-&gt;phase_seg1 - 1)&amp;  0xf) |
</I>&gt;&gt;<i> +        (((bt-&gt;phase_seg2 - 1)&amp;  0x7)&lt;&lt;  4);
</I>&gt;&gt;<i> +    if (priv-&gt;can.ctrlmode&amp;  CAN_CTRLMODE_3_SAMPLES)
</I>&gt;&gt;<i> +        btr1 |= 0x80;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    dev_info(ND2D(dev), &quot;setting BTR0=0x%02x BTR1=0x%02x\n&quot;, btr0,
</I>&gt;&gt;<i> btr1);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    GET_PARAMS(priv).btr0 = btr0;
</I>&gt;&gt;<i> +    GET_PARAMS(priv).btr1 = btr1;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    return ems_usb_command_msg(priv,&amp;priv-&gt;active_params);
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/*
</I>&gt;&gt;<i> + * probe function for new CPC-USB devices
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +static int ems_usb_probe(struct usb_interface *intf,
</I>&gt;&gt;<i> +                         const struct usb_device_id *id)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    struct net_device *dev;
</I>&gt;&gt;<i> +    struct ems_usb *priv;
</I>&gt;&gt;<i> +    int result;
</I>&gt;<i> 
</I>&gt;<i> s/result/err/ ? See above.
</I>Done.

&gt;&gt;<i> +
</I>&gt;&gt;<i> +    dev = alloc_candev(sizeof(struct ems_usb));
</I>&gt;&gt;<i> +    if (!dev) {
</I>&gt;&gt;<i> +        err(&quot;Out of memory&quot;);
</I>&gt;<i> 
</I>&gt;<i> dev_err()? There are more similar lines below.
</I>Done.

&gt;&gt;<i> +        return -ENOMEM;
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    priv = netdev_priv(dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    priv-&gt;udev = interface_to_usbdev(intf);
</I>&gt;&gt;<i> +    priv-&gt;netdev = dev;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    priv-&gt;can.state            = CAN_STATE_STOPPED;
</I>&gt;&gt;<i> +    priv-&gt;can.bittiming_const  =&amp;ems_usb_bittiming_const;
</I>&gt;&gt;<i> +    priv-&gt;can.do_set_bittiming = ems_usb_set_bittiming;
</I>&gt;&gt;<i> +    priv-&gt;can.do_set_mode      = ems_usb_set_mode;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    dev-&gt;flags |= IFF_ECHO;    /* we support local echo */
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* The device actually uses a 16MHz clock to generate the CAN
</I>&gt;&gt;<i> clock, but it
</I>&gt;&gt;<i> +     * expects SJA1000 bit settings based on 8MHz (is internally
</I>&gt;&gt;<i> converted).
</I>&gt;&gt;<i> +     */
</I>&gt;&gt;<i> +    priv-&gt;can.clock.freq = 8000000;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#if LINUX_VERSION_CODE&gt;  KERNEL_VERSION(2,6,28)
</I>&gt;&gt;<i> +    dev-&gt;netdev_ops =&amp;ems_usb_netdev_ops;
</I>&gt;&gt;<i> +#else
</I>&gt;&gt;<i> +    dev-&gt;open = ems_usb_open;
</I>&gt;&gt;<i> +    dev-&gt;stop = ems_usb_close;
</I>&gt;&gt;<i> +    dev-&gt;hard_start_xmit = ems_usb_start_xmit;
</I>&gt;&gt;<i> +#endif
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    dev-&gt;flags |= IFF_ECHO;    /* we support local echo */
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (!alloc_all_urbs(priv)) {
</I>&gt;&gt;<i> +        err(&quot;Out of memory&quot;);
</I>&gt;&gt;<i> +        free_candev(dev);
</I>&gt;&gt;<i> +        return -ENOMEM;
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    priv-&gt;tx_msg_buffer = kzalloc(HEADER_SIZE + sizeof(struct
</I>&gt;&gt;<i> ems_cpc_msg),
</I>&gt;&gt;<i> +                                  GFP_KERNEL);
</I>&gt;<i> 
</I>&gt;<i> Alignment of second line.
</I>Done.

&gt;&gt;<i> +    if (!priv-&gt;tx_msg_buffer) {
</I>&gt;&gt;<i> +        err(&quot;Out of memory&quot;);
</I>&gt;&gt;<i> +        free_candev(dev);
</I>&gt;&gt;<i> +        free_all_urbs(priv);
</I>&gt;&gt;<i> +        return -ENOMEM;
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    usb_set_intfdata(intf, priv);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    SET_NETDEV_DEV(dev,&amp;intf-&gt;dev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    init_params_sja1000(&amp;priv-&gt;active_params, 0, 0, 0xDA, MOD_RM);
</I>&gt;&gt;<i> +    result = ems_usb_command_msg(priv,&amp;priv-&gt;active_params);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (result)
</I>&gt;&gt;<i> +        dev_warn(ND2D(dev), &quot;couldn't initialize controller: %d\n&quot;,
</I>&gt;&gt;<i> result);
</I>&gt;<i> 
</I>&gt;<i> That's an error condition, isn't it?
</I>Yepp and fixed.

&gt;&gt;<i> +    return register_candev(dev);
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/*
</I>&gt;&gt;<i> + * called by the usb core when the device is removed from the system
</I>&gt;&gt;<i> + */
</I>&gt;&gt;<i> +static void ems_usb_disconnect(struct usb_interface *intf)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    struct ems_usb *dev = usb_get_intfdata(intf);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    usb_set_intfdata(intf, NULL);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (dev) {
</I>&gt;&gt;<i> +        unregister_netdev(dev-&gt;netdev);
</I>&gt;&gt;<i> +        free_candev(dev-&gt;netdev);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +        unlink_all_urbs(dev);
</I>&gt;&gt;<i> +        free_all_urbs(dev);
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +/* usb specific object needed to register this driver with the usb
</I>&gt;&gt;<i> subsystem */
</I>&gt;&gt;<i> +static struct usb_driver ems_usb_driver = {
</I>&gt;&gt;<i> +    .name       = &quot;ems_usb&quot;,
</I>&gt;&gt;<i> +    .probe      = ems_usb_probe,
</I>&gt;&gt;<i> +    .disconnect = ems_usb_disconnect,
</I>&gt;&gt;<i> +    .id_table   = ems_usb_table,
</I>&gt;&gt;<i> +};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static int __init ems_usb_init(void)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    int result;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    printk(KERN_INFO &quot;CPC-USB kernel driver loaded\n&quot;);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    /* register this driver with the USB subsystem */
</I>&gt;&gt;<i> +    result = usb_register(&amp;ems_usb_driver);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    if (result) {
</I>&gt;&gt;<i> +        err(&quot;usb_register failed. Error number %d\n&quot;, result);
</I>&gt;&gt;<i> +        return result;
</I>&gt;&gt;<i> +    }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +    return 0;
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +static void __exit ems_usb_exit(void)
</I>&gt;&gt;<i> +{
</I>&gt;&gt;<i> +    /* deregister this driver with the USB subsystem */
</I>&gt;&gt;<i> +    usb_deregister(&amp;ems_usb_driver);
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +module_init(ems_usb_init);
</I>&gt;&gt;<i> +module_exit(ems_usb_exit);
</I>&gt;<i> 
</I>&gt;<i> I have not really reviewed the driver from the functional point of view.
</I>&gt;<i> Will do later. Apart from that, the patch looks already quite good.
</I>Thanks.

I've finally figured out why I couldn't see the long length, my tab width
is 4 instead of 8.

Will send patch v2 within the next minutes.

Cheers, Sebastian
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.9 (GNU/Linux)
Comment: Using GnuPG with Mozilla - <A HREF="http://enigmail.mozdev.org">http://enigmail.mozdev.org</A>

iEYEARECAAYFAkqnhMUACgkQpqRB8PJG7XwQeQCgk5iYzKm4rpLa/rPDgvzS87wJ
1s8AnibUbBKLaMzOV9FkkjJIQXEQJVAG
=ZuW4
-----END PGP SIGNATURE-----
-- 
EMS Dr. Thomas Wuensche e.K.
Sonnenhang 3
85304 Ilmmuenster
HRA Neuburg a.d. Donau, HR-Nr. 70.106
Phone: +49-8441-490260
Fax  : +49-8441-81860
<A HREF="http://www.ems-wuensche.com">http://www.ems-wuensche.com</A>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003022.html">[PATCH] ems_usb: CAN/USB driver for EMS	CPC-USB/ARM7	CAN	interfaces
</A></li>
	<LI>Next message: <A HREF="003023.html">[PATCH] ems_usb: CAN/USB driver for EMS CPC-USB/ARM7	CAN	interfaces
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3020">[ date ]</a>
              <a href="thread.html#3020">[ thread ]</a>
              <a href="subject.html#3020">[ subject ]</a>
              <a href="author.html#3020">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
