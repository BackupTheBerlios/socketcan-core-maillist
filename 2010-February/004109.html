<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH 0/2] add support for Janz MODULbus devices
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2010-February/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%200/2%5D%20add%20support%20for%20Janz%20MODULbus%20devices&In-Reply-To=%3C20100224205206.GE10085%40ovro.caltech.edu%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004108.html">
   <LINK REL="Next"  HREF="004110.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH 0/2] add support for Janz MODULbus devices</H1>
    <B>Ira W. Snyder</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%200/2%5D%20add%20support%20for%20Janz%20MODULbus%20devices&In-Reply-To=%3C20100224205206.GE10085%40ovro.caltech.edu%3E"
       TITLE="[PATCH 0/2] add support for Janz MODULbus devices">iws at ovro.caltech.edu
       </A><BR>
    <I>Wed Feb 24 21:52:06 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="004108.html">[PATCH 0/2] add support for Janz MODULbus devices
</A></li>
        <LI>Next message: <A HREF="004110.html">[PATCH 0/2] add support for Janz MODULbus devices
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4109">[ date ]</a>
              <a href="thread.html#4109">[ thread ]</a>
              <a href="subject.html#4109">[ subject ]</a>
              <a href="author.html#4109">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wed, Feb 24, 2010 at 08:41:06PM +0100, Marc Kleine-Budde wrote:
&gt;<i> Ira W. Snyder wrote:
</I>&gt;<i> &gt; On Wed, Feb 24, 2010 at 08:08:15PM +0100, Marc Kleine-Budde wrote:
</I>&gt;<i> &gt;&gt; Ira W. Snyder wrote:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; [...]
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; But we want so solve the TX problem. You only have to stop the
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; netif_queue if you TX ring is full. Then you have to deal with calling
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; netif_wake_queue() eventually. But we obviously don't want to poll.
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; The solution might be to look at the TX queue in the interrupt handler
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; and/or the NAPI loop. And now we get back to my first question. If the
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; controller does a loopback in hardware, i.e. you receive a frame for
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; each frame send, you don't need to poll the TX queue length.
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; If you receive a CAN frame it might be on of your's, which means the TX
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; queue might have at least room for one frame. In pseudo code it might
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; look like this:
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; xmit()
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; {
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; 	send_frame_to_hardware();
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; 	if (tx_ring_full) {
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; 		netif_stop_queue();
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; 		priv-&gt;flags |= TX_RING_FULL;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; 	}
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; }
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; irq() and netif_poll()
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; {
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; 	if (priv-&gt;flags &amp; TX_RING_FULL) {
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; 		if (room_in_ring()) {
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; 			priv-&gt;flags &amp;= ~TX_RING_FULL;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; 			netif_wake_queue();
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; 		}
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; 	}
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; }
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; Should be implemented race-free, i.e. you might have to use atomic_*
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; operations and/or don't use a shared flag variable.
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; Cool, that should work. netif_queue_stopped() could be used instead of
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; the TX_RING_FULL flag.
</I>&gt;<i> &gt;&gt;&gt;&gt; right...good point
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; I should have looked at my own driver :)
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; If room_in_ring() is cheap, it boils down to:
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; irq() and netif_poll()
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; {
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; 	if (room_in_ring()) {
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; 		netif_wake_queue();
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; }
</I>&gt;<i> &gt;&gt;&gt;&gt; Otherwise:
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; irq() and netif_poll()
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; {
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; 	if (netif_queue_stopped() &amp;&amp; room_in_ring()) {
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; 		netif_wake_queue();
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt;&gt; }
</I>&gt;<i> &gt;&gt;&gt; Hmm, this *almost* works. Running &quot;cangen -g 0 can0&quot; quickly gets the
</I>&gt;<i> &gt;&gt;&gt; queue into a hung state, though.
</I>&gt;<i> &gt;&gt; what is a &quot;hung state&quot;?
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; I added printk() to the sites where I stop/wake the queue. It is always
</I>&gt;<i> &gt;&gt;&gt; woken up correctly, but cangen always exits with &quot;write: No buffer space
</I>&gt;<i> &gt;&gt;&gt; available&quot; after a few stop/wake cycles. Immediately running cangen
</I>&gt;<i> &gt;&gt;&gt; again works for a few more stop/wake cycles.
</I>&gt;<i> &gt;&gt; let's look the the cangen source if there's propper error handling...
</I>&gt;<i> &gt;&gt; <A HREF="http://svn.berlios.de/viewvc/socketcan/trunk/can-utils/cangen.c?revision=787&amp;view=markup">http://svn.berlios.de/viewvc/socketcan/trunk/can-utils/cangen.c?revision=787&amp;view=markup</A>
</I>&gt;<i> &gt;&gt; nope, there isn't
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; There's the option &quot;-i&quot; to ignore ENOBUFS, which is....we don't want to
</I>&gt;<i> &gt;&gt; do that....
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Better improbe the source: (from the pengutronix' canutils...)
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; again:
</I>&gt;<i> &gt;&gt;         len = write(s, &amp;frame, sizeof(frame));
</I>&gt;<i> &gt;&gt;         if (len == -1) {
</I>&gt;<i> &gt;&gt;                 switch (errno) {
</I>&gt;<i> &gt;&gt;                 case ENOBUFS: {
</I>&gt;<i> &gt;&gt;                         int err;
</I>&gt;<i> &gt;&gt;                         struct pollfd fds[] = {
</I>&gt;<i> &gt;&gt;                                 {
</I>&gt;<i> &gt;&gt;                                         .fd     = s,
</I>&gt;<i> &gt;&gt;                                         .events = POLLOUT,
</I>&gt;<i> &gt;&gt;                                 },
</I>&gt;<i> &gt;&gt;                         };
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;                         err = poll(fds, 1, 1000);
</I>&gt;<i> &gt;&gt;                         if (err == -1 &amp;&amp; errno != -EINTR) {
</I>&gt;<i> &gt;&gt;                                 perror(&quot;poll()&quot;);
</I>&gt;<i> &gt;&gt;                                 exit(EXIT_FAILURE);
</I>&gt;<i> &gt;&gt;                         } else if (err == 0) {
</I>&gt;<i> &gt;&gt; 				printf(&quot;a timeout occured\n&quot;);
</I>&gt;<i> &gt;&gt; 				exit(EXIT_FAILURE);
</I>&gt;<i> &gt;&gt; 			}
</I>&gt;<i> &gt;&gt;                 }
</I>&gt;<i> &gt;&gt;                 case EINTR:     /* fallthrough */
</I>&gt;<i> &gt;&gt;                         goto again;
</I>&gt;<i> &gt;&gt;                 default:
</I>&gt;<i> &gt;&gt;                         perror(&quot;write&quot;);
</I>&gt;<i> &gt;&gt;                         exit(EXIT_FAILURE);
</I>&gt;<i> &gt;&gt;                 }
</I>&gt;<i> &gt;&gt;         }
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; If you hit a timeout, which means you cannot send packages for 1000 ms,
</I>&gt;<i> &gt;&gt; your send queue probably didn't wake up...
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Is there any chance you can send me the pengutronix version of
</I>&gt;<i> &gt; cangen/canutils? I can't find it on their website.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://www.pengutronix.de/software/socket-can/download/canutils/v4.0/">http://www.pengutronix.de/software/socket-can/download/canutils/v4.0/</A>
</I>&gt;<i> <A HREF="http://www.pengutronix.de/software/libsocketcan/download/">http://www.pengutronix.de/software/libsocketcan/download/</A>
</I>&gt;<i> 
</I>&gt;<i> you need the libsocketcan, too
</I>&gt;<i> 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;&gt; Here is the output of ifconfig:
</I>&gt;<i> &gt;&gt;&gt; can0      Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  
</I>&gt;<i> &gt;&gt;&gt;           UP RUNNING NOARP  MTU:16  Metric:1
</I>&gt;<i> &gt;&gt;&gt;           RX packets:1902 errors:0 dropped:0 overruns:0 frame:0
</I>&gt;<i> &gt;&gt;&gt;           TX packets:1902 errors:0 dropped:0 overruns:0 carrier:0
</I>&gt;<i> &gt;&gt;&gt;           collisions:0 txqueuelen:10 
</I>&gt;<i> &gt;&gt;&gt;           RX bytes:10767 (10.5 KiB)  TX bytes:10767 (10.5 KiB)
</I>&gt;<i> &gt;&gt;&gt;           Interrupt:22 
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; can1      Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  
</I>&gt;<i> &gt;&gt;&gt;           UP RUNNING NOARP  MTU:16  Metric:1
</I>&gt;<i> &gt;&gt;&gt;           RX packets:1902 errors:0 dropped:0 overruns:0 frame:0
</I>&gt;<i> &gt;&gt;&gt;           TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
</I>&gt;<i> &gt;&gt;&gt;           collisions:0 txqueuelen:10 
</I>&gt;<i> &gt;&gt;&gt;           RX bytes:10767 (10.5 KiB)  TX bytes:0 (0.0 b)
</I>&gt;<i> &gt;&gt;&gt;           Interrupt:22 
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; I'm stopping the queue correctly: the xmit() routine never complains that it
</I>&gt;<i> &gt;&gt;&gt; tried to transmit but had no buffer space. You'll see that we didn't drop any
</I>&gt;<i> &gt;&gt;&gt; packets in this run. In another run, we did drop packets. It is like the
</I>&gt;<i> &gt;&gt;&gt; firmware didn't echo the packets back to me. Also note that the TX of
</I>&gt;<i> &gt;&gt;&gt; can0 always matches the RX of can1. They're cabled together, so this is
</I>&gt;<i> &gt;&gt;&gt; expected.
</I>&gt;<i> &gt;&gt; Hmm...it looks like this.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Double check your RX path, so that you don't loose any frames in
</I>&gt;<i> &gt;&gt; software. Is it possible that the RX and TX collide in your driver
</I>&gt;<i> &gt;&gt; and/or in hardware?
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I'm pretty sure that I do not lose RX frames in my driver. When I do,
</I>&gt;<i> &gt; stats-&gt;rx_dropped is always incremented. I do get the following warning
</I>&gt;<i> 
</I>&gt;<i> I mean loosing RX frames due to an programming error...
</I>&gt;<i> 
</I>
I've inlined the current version of the driver below. I called the
&quot;room_in_ring()&quot; function &quot;ican3_txok()&quot; in my code. The places you'll
want to evaluate are ican3_xmit(), ican3_recv_skb(), ican3_work(), and
ican3_irq(). I'm worried about the netif_wake_queue() in ican3_irq(),
since nothing guarantees the net_device is open yet. It doesn't seem to
cause a problem though.

&gt;<i> &gt; from lockdep, though. Sorry about the length. The best I can get from
</I>&gt;<i> &gt; the output is that something in the networking open() code is broken (or
</I>&gt;<i> &gt; needs a special lockdep annotation).
</I>&gt;<i> 
</I>&gt;<i> Puhh...I havn't read this before.
</I>&gt;<i> 
</I>&gt;<i> The problem is a from within a HARDIRQ-safe a HARDIRQ-unsafe lock is
</I>&gt;<i> aquired.
</I>&gt;<i> 
</I>&gt;<i> the HARDIRQ-safe seems to be the spin lock in your interrupt handler,
</I>&gt;<i> the unsafe one is in the close path on a socket.
</I>&gt;<i> 
</I>
I agree. Still, I don't know how to fix it.

&gt;<i> &gt; [  134.540375] janz-cmodio 0000:01:0e.0: PCI-&gt;APIC IRQ transform: INT A -&gt; IRQ 22
</I>&gt;<i> &gt; [  134.547629] janz-cmodio 0000:01:0e.0: setting latency timer to 64
</I>&gt;<i> &gt; [  134.684269] janz-ican3 janz-ican3.0: module 0: registered CAN device
</I>&gt;<i> &gt; [  134.807929] janz-ican3 janz-ican3.1: module 1: registered CAN device
</I>&gt;<i> &gt; [  175.361588] janz-ican3 janz-ican3.0: ican3_xmit: stopping queue
</I>&gt;<i> &gt; [  175.373104] janz-ican3 janz-ican3.0: ican3_recv_skb: waking queue
</I>&gt;<i> &gt; [  175.379556] 
</I>&gt;<i> &gt; [  175.379559] ======================================================
</I>&gt;<i> &gt; [  175.383277] [ INFO: HARDIRQ-safe -&gt; HARDIRQ-unsafe lock order detected ]
</I>&gt;<i> &gt; [  175.383277] 2.6.33-rc7-00000-rc7 #3
</I>&gt;<i> &gt; [  175.383277] ------------------------------------------------------
</I>&gt;<i> &gt; [  175.383277] events/0/5 [HC0[0]:SC1[1]:HE0:SE0] is trying to acquire:
</I>&gt;<i> &gt; [  175.383277]  (clock-AF_CAN){++.-..}, at: [&lt;c11920e7&gt;] sock_def_write_space+0x15/0x8d
</I>&gt;<i> &gt; [  175.383277] 
</I>&gt;<i> &gt; [  175.383277] and this task is already holding:
</I>&gt;<i> &gt; [  175.383277]  (&amp;(&amp;mod-&gt;lock)-&gt;rlock){-.-...}, at: [&lt;f898df29&gt;] ican3_xmit+0x48/0x277 [janz_ican3]
</I>&gt;<i> &gt; [  175.383277] which would create a new lock dependency:
</I>&gt;<i> &gt; [  175.383277]  (&amp;(&amp;mod-&gt;lock)-&gt;rlock){-.-...} -&gt; (clock-AF_CAN){++.-..}
</I>&gt;<i> &gt; [  175.383277] 
</I>&gt;<i> &gt; [  175.383277] but this new dependency connects a HARDIRQ-irq-safe lock:
</I>&gt;<i> &gt; [  175.383277]  (&amp;(&amp;mod-&gt;lock)-&gt;rlock){-.-...}
</I>&gt;<i> &gt; [  175.383277] ... which became HARDIRQ-irq-safe at:
</I>&gt;<i> &gt; [  175.383277]   [&lt;c103d47f&gt;] __lock_acquire+0x4ce/0x756
</I>&gt;<i> &gt; [  175.383277]   [&lt;c103e209&gt;] lock_acquire+0x45/0x5c
</I>&gt;<i> &gt; [  175.383277]   [&lt;c12037a7&gt;] _raw_spin_lock_irqsave+0x24/0x34
</I>&gt;<i> 
</I>&gt;<i> from your interrupt handler you aquire a spin_lock
</I>&gt;<i> 
</I>&gt;<i> &gt; [  175.383277]   [&lt;f898d3c9&gt;] ican3_irq+0x41/0x164 [janz_ican3]
</I>&gt;<i> &gt; [  175.383277]   [&lt;c10463ab&gt;] handle_IRQ_event+0x1d/0x9a
</I>&gt;<i> &gt; [  175.383277]   [&lt;c1047872&gt;] handle_fasteoi_irq+0x9a/0xa7
</I>&gt;<i> &gt; [  175.383277] 
</I>&gt;<i> &gt; [  175.383277] to a HARDIRQ-irq-unsafe lock:
</I>&gt;<i> &gt; [  175.383277]  (clock-AF_CAN){++.-..}
</I>&gt;<i> &gt; [  175.383277] ... which became HARDIRQ-irq-unsafe at:
</I>&gt;<i> &gt; [  175.383277] ...  [&lt;c103d500&gt;] __lock_acquire+0x54f/0x756
</I>&gt;<i> &gt; [  175.383277]   [&lt;c103e209&gt;] lock_acquire+0x45/0x5c
</I>&gt;<i> &gt; [  175.383277]   [&lt;c12038da&gt;] _raw_write_lock_bh+0x20/0x2f
</I>&gt;<i> &gt; [  175.383277]   [&lt;c11e3be7&gt;] raw_release+0xf9/0x14c
</I>&gt;<i> &gt; [  175.383277]   [&lt;c118f55c&gt;] sock_release+0x14/0x58
</I>&gt;<i> &gt; [  175.383277]   [&lt;c118fc4c&gt;] sock_close+0x1c/0x20
</I>&gt;<i> &gt; [  175.383277]   [&lt;c106fc41&gt;] __fput+0xeb/0x187
</I>&gt;<i> &gt; [  175.383277]   [&lt;c106fe8d&gt;] fput+0x16/0x18
</I>&gt;<i> &gt; [  175.383277]   [&lt;c106d873&gt;] filp_close+0x51/0x5b
</I>&gt;<i> &gt; [  175.383277]   [&lt;c106e9c3&gt;] sys_close+0x67/0xa0
</I>&gt;<i> &gt; [  175.383277]   [&lt;c1002657&gt;] sysenter_do_call+0x12/0x36
</I>&gt;<i> 
</I>&gt;<i> soneone calls a &quot;close&quot; ^^^
</I>&gt;<i> 
</I>&gt;<i> &gt; [  175.383277] 
</I>&gt;<i> &gt; [  175.383277] other info that might help us debug this:
</I>&gt;<i> &gt; [  175.383277] 
</I>&gt;<i> &gt; [  175.383277] 4 locks held by events/0/5:
</I>&gt;<i> &gt; [  175.383277]  #0:  (events){+.+.+.}, at: [&lt;c102ce51&gt;] worker_thread+0xc9/0x1c9
</I>&gt;<i> &gt; [  175.383277]  #1:  ((&amp;mod-&gt;work)){+.+...}, at: [&lt;c102ce51&gt;] worker_thread+0xc9/0x1c9
</I>&gt;<i> &gt; [  175.383277]  #2:  (_xmit_NONE#2){+.-...}, at: [&lt;c11a693a&gt;] sch_direct_xmit+0x2d/0x113
</I>&gt;<i> &gt; [  175.383277]  #3:  (&amp;(&amp;mod-&gt;lock)-&gt;rlock){-.-...}, at: [&lt;f898df29&gt;] ican3_xmit+0x48/0x277 [janz_ican3]
</I>&gt;<i> &gt; [  175.383277] 
</I>&gt;<i> &gt; [  175.383277] the dependencies between HARDIRQ-irq-safe lock and the holding lock:
</I>&gt;<i> &gt; [  175.383277] -&gt; (&amp;(&amp;mod-&gt;lock)-&gt;rlock){-.-...} ops: 0 {
</I>&gt;<i> &gt; [  175.383277]    IN-HARDIRQ-W at:
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c103d47f&gt;] __lock_acquire+0x4ce/0x756
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c103e209&gt;] lock_acquire+0x45/0x5c
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c12037a7&gt;] _raw_spin_lock_irqsave+0x24/0x34
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;f898d3c9&gt;] ican3_irq+0x41/0x164 [janz_ican3]
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c10463ab&gt;] handle_IRQ_event+0x1d/0x9a
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c1047872&gt;] handle_fasteoi_irq+0x9a/0xa7
</I>&gt;<i> &gt; [  175.383277]    IN-SOFTIRQ-W at:
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c103d4a3&gt;] __lock_acquire+0x4f2/0x756
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c103e209&gt;] lock_acquire+0x45/0x5c
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c12037a7&gt;] _raw_spin_lock_irqsave+0x24/0x34
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;f898d3c9&gt;] ican3_irq+0x41/0x164 [janz_ican3]
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c10463ab&gt;] handle_IRQ_event+0x1d/0x9a
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c1047872&gt;] handle_fasteoi_irq+0x9a/0xa7
</I>&gt;<i> &gt; [  175.383277]    INITIAL USE at:
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c103d571&gt;] __lock_acquire+0x5c0/0x756
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c103e209&gt;] lock_acquire+0x45/0x5c
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c12037a7&gt;] _raw_spin_lock_irqsave+0x24/0x34
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;f898d06e&gt;] ican3_send_msg+0x1c/0x1e6 [janz_ican3]
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;f898e64d&gt;] ican3_probe+0x421/0xc91 [janz_ican3]
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c1140dcd&gt;] platform_drv_probe+0xc/0xe
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c114022c&gt;] driver_probe_device+0x7d/0xf0
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c1140421&gt;] __device_attach+0x28/0x30
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c113f721&gt;] bus_for_each_drv+0x39/0x62
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c1140362&gt;] device_attach+0x45/0x59
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c113f6d3&gt;] bus_probe_device+0x1f/0x34
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c113e618&gt;] device_add+0x2f5/0x43b
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c11410d1&gt;] platform_device_add+0xd9/0x119
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c1141126&gt;] platform_device_register+0x15/0x18
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;f89a92df&gt;] cmodio_pci_probe+0x228/0x2cd [janz_cmodio]
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c10f5100&gt;] local_pci_probe+0xe/0x10
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c10f52cf&gt;] pci_device_probe+0x48/0x66
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c114022c&gt;] driver_probe_device+0x7d/0xf0
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c11402e2&gt;] __driver_attach+0x43/0x5f
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c113f950&gt;] bus_for_each_dev+0x39/0x5a
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c11400ff&gt;] driver_attach+0x14/0x16
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c113fdd7&gt;] bus_add_driver+0xa2/0x1c8
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c11405ab&gt;] driver_register+0x7b/0xd7
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c10f54c5&gt;] __pci_register_driver+0x4d/0xa0
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;f89ac017&gt;] 0xf89ac017
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c100104b&gt;] do_one_initcall+0x4b/0x135
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c104475e&gt;] sys_init_module+0xa9/0x1e3
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c1002657&gt;] sysenter_do_call+0x12/0x36
</I>&gt;<i> &gt; [  175.383277]  }
</I>&gt;<i> &gt; [  175.383277]  ... key      at: [&lt;f898f61c&gt;] __key.26093+0x0/0xfffff8a1 [janz_ican3]
</I>&gt;<i> &gt; [  175.383277]  ... acquired at:
</I>&gt;<i> &gt; [  175.383277]    [&lt;c103c497&gt;] check_irq_usage+0x50/0xad
</I>&gt;<i> &gt; [  175.383277]    [&lt;c103caf8&gt;] validate_chain+0x604/0xabd
</I>&gt;<i> &gt; [  175.383277]    [&lt;c103d69c&gt;] __lock_acquire+0x6eb/0x756
</I>&gt;<i> &gt; [  175.383277]    [&lt;c103e209&gt;] lock_acquire+0x45/0x5c
</I>&gt;<i> &gt; [  175.383277]    [&lt;c1203adb&gt;] _raw_read_lock+0x1b/0x2a
</I>&gt;<i> &gt; [  175.383277]    [&lt;c11920e7&gt;] sock_def_write_space+0x15/0x8d
</I>&gt;<i> &gt; [  175.383277]    [&lt;c11918d3&gt;] sock_wfree+0x25/0x41
</I>&gt;<i> &gt; [  175.383277]    [&lt;c1193503&gt;] skb_release_head_state+0x43/0x46
</I>&gt;<i> &gt; [  175.383277]    [&lt;c11945c0&gt;] skb_release_all+0xb/0x15
</I>&gt;<i> &gt; [  175.383277]    [&lt;c1193e41&gt;] __kfree_skb+0xb/0x69
</I>&gt;<i> &gt; [  175.383277]    [&lt;c1193ef1&gt;] kfree_skb+0x28/0x2a
</I>&gt;<i> &gt; [  175.383277]    [&lt;f898e0ef&gt;] ican3_xmit+0x20e/0x277 [janz_ican3]
</I>&gt;<i> &gt; [  175.383277]    [&lt;c119a597&gt;] dev_hard_start_xmit+0x1c7/0x25d
</I>&gt;<i> &gt; [  175.383277]    [&lt;c11a695a&gt;] sch_direct_xmit+0x4d/0x113
</I>&gt;<i> &gt; [  175.383277]    [&lt;c11a6ab0&gt;] __qdisc_run+0x90/0xa2
</I>&gt;<i> &gt; [  175.383277]    [&lt;c119c90d&gt;] net_tx_action+0xa7/0xff
</I>&gt;<i> &gt; [  175.383277]    [&lt;c102384e&gt;] __do_softirq+0x75/0xf3
</I>&gt;<i> &gt; [  175.383277] 
</I>&gt;<i> &gt; [  175.383277] 
</I>&gt;<i> &gt; [  175.383277] the dependencies between the lock to be acquired and HARDIRQ-irq-unsafe lock:
</I>&gt;<i> &gt; [  175.383277] -&gt; (clock-AF_CAN){++.-..} ops: 0 {
</I>&gt;<i> &gt; [  175.383277]    HARDIRQ-ON-W at:
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c103d500&gt;] __lock_acquire+0x54f/0x756
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c103e209&gt;] lock_acquire+0x45/0x5c
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c12038da&gt;] _raw_write_lock_bh+0x20/0x2f
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c11e3be7&gt;] raw_release+0xf9/0x14c
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c118f55c&gt;] sock_release+0x14/0x58
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c118fc4c&gt;] sock_close+0x1c/0x20
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c106fc41&gt;] __fput+0xeb/0x187
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c106fe8d&gt;] fput+0x16/0x18
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c106d873&gt;] filp_close+0x51/0x5b
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c106e9c3&gt;] sys_close+0x67/0xa0
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c1002657&gt;] sysenter_do_call+0x12/0x36
</I>&gt;<i> &gt; [  175.383277]    HARDIRQ-ON-R at:
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c103d4d0&gt;] __lock_acquire+0x51f/0x756
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c103e209&gt;] lock_acquire+0x45/0x5c
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c1203adb&gt;] _raw_read_lock+0x1b/0x2a
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c119207c&gt;] sock_def_readable+0x15/0x6b
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c119149d&gt;] sock_queue_rcv_skb+0xfc/0x115
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c11e3901&gt;] raw_rcv+0x4a/0x5a
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c11e2491&gt;] can_rcv_filter+0x7a/0x147
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c11e2765&gt;] can_rcv+0xa8/0xed
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c1199aec&gt;] netif_receive_skb+0x288/0x2bb
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c119c1b5&gt;] process_backlog+0x63/0x8c
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c119c5e1&gt;] net_rx_action+0x4b/0x104
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c102384e&gt;] __do_softirq+0x75/0xf3
</I>&gt;<i> &gt; [  175.383277]    IN-SOFTIRQ-R at:
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c103d4a3&gt;] __lock_acquire+0x4f2/0x756
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c103e209&gt;] lock_acquire+0x45/0x5c
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c1203adb&gt;] _raw_read_lock+0x1b/0x2a
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c119207c&gt;] sock_def_readable+0x15/0x6b
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c119149d&gt;] sock_queue_rcv_skb+0xfc/0x115
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c11e3901&gt;] raw_rcv+0x4a/0x5a
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c11e2491&gt;] can_rcv_filter+0x7a/0x147
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c11e2765&gt;] can_rcv+0xa8/0xed
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c1199aec&gt;] netif_receive_skb+0x288/0x2bb
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c119c1b5&gt;] process_backlog+0x63/0x8c
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c119c5e1&gt;] net_rx_action+0x4b/0x104
</I>&gt;<i> &gt; [  175.383277]                                        [&lt;c102384e&gt;] __do_softirq+0x75/0xf3
</I>&gt;<i> &gt; [  175.383277]    INITIAL USE at:
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c103d571&gt;] __lock_acquire+0x5c0/0x756
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c103e209&gt;] lock_acquire+0x45/0x5c
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c1203adb&gt;] _raw_read_lock+0x1b/0x2a
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c11920e7&gt;] sock_def_write_space+0x15/0x8d
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c11918d3&gt;] sock_wfree+0x25/0x41
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c1193503&gt;] skb_release_head_state+0x43/0x46
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c11945c0&gt;] skb_release_all+0xb/0x15
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c1193e41&gt;] __kfree_skb+0xb/0x69
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c1193ef1&gt;] kfree_skb+0x28/0x2a
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;f898e0ef&gt;] ican3_xmit+0x20e/0x277 [janz_ican3]
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c119a597&gt;] dev_hard_start_xmit+0x1c7/0x25d
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c11a695a&gt;] sch_direct_xmit+0x4d/0x113
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c119d15d&gt;] dev_queue_xmit+0x22c/0x397
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c11e267e&gt;] can_send+0xd0/0x10f
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c11e3882&gt;] raw_sendmsg+0xc3/0xf8
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c118df5f&gt;] sock_aio_write+0xc5/0xce
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c106edf8&gt;] do_sync_write+0x88/0xca
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c106f49d&gt;] vfs_write+0x9d/0x116
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c106f86a&gt;] sys_write+0x3b/0x60
</I>&gt;<i> &gt; [  175.383277]                                       [&lt;c1002657&gt;] sysenter_do_call+0x12/0x36
</I>&gt;<i> &gt; [  175.383277]  }
</I>&gt;<i> &gt; [  175.383277]  ... key      at: [&lt;c186ba04&gt;] af_callback_keys+0xe8/0x128
</I>&gt;<i> &gt; [  175.383277]  ... acquired at:
</I>&gt;<i> &gt; [  175.383277]    [&lt;c103c497&gt;] check_irq_usage+0x50/0xad
</I>&gt;<i> &gt; [  175.383277]    [&lt;c103caf8&gt;] validate_chain+0x604/0xabd
</I>&gt;<i> &gt; [  175.383277]    [&lt;c103d69c&gt;] __lock_acquire+0x6eb/0x756
</I>&gt;<i> &gt; [  175.383277]    [&lt;c103e209&gt;] lock_acquire+0x45/0x5c
</I>&gt;<i> &gt; [  175.383277]    [&lt;c1203adb&gt;] _raw_read_lock+0x1b/0x2a
</I>&gt;<i> &gt; [  175.383277]    [&lt;c11920e7&gt;] sock_def_write_space+0x15/0x8d
</I>&gt;<i> &gt; [  175.383277]    [&lt;c11918d3&gt;] sock_wfree+0x25/0x41
</I>&gt;<i> &gt; [  175.383277]    [&lt;c1193503&gt;] skb_release_head_state+0x43/0x46
</I>&gt;<i> &gt; [  175.383277]    [&lt;c11945c0&gt;] skb_release_all+0xb/0x15
</I>&gt;<i> &gt; [  175.383277]    [&lt;c1193e41&gt;] __kfree_skb+0xb/0x69
</I>&gt;<i> &gt; [  175.383277]    [&lt;c1193ef1&gt;] kfree_skb+0x28/0x2a
</I>&gt;<i> &gt; [  175.383277]    [&lt;f898e0ef&gt;] ican3_xmit+0x20e/0x277 [janz_ican3]
</I>&gt;<i> &gt; [  175.383277]    [&lt;c119a597&gt;] dev_hard_start_xmit+0x1c7/0x25d
</I>&gt;<i> &gt; [  175.383277]    [&lt;c11a695a&gt;] sch_direct_xmit+0x4d/0x113
</I>&gt;<i> &gt; [  175.383277]    [&lt;c11a6ab0&gt;] __qdisc_run+0x90/0xa2
</I>&gt;<i> &gt; [  175.383277]    [&lt;c119c90d&gt;] net_tx_action+0xa7/0xff
</I>&gt;<i> &gt; [  175.383277]    [&lt;c102384e&gt;] __do_softirq+0x75/0xf3
</I>&gt;<i> &gt; [  175.383277] 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt; Another improvement for the cangen utility is to exit after a certain
</I>&gt;<i> &gt;&gt; number of messages. So you can match the number of generated frames with
</I>&gt;<i> &gt;&gt; the rx/tx counters of the CAN cards and interrupts (cat /proc/interrupts)
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Yeah, that would be a good improvement too.
</I>&gt;<i> 
</I>&gt;<i> try cansequence from pengutronix' canutils
</I>&gt;<i> 
</I>
cansequence from the pengutronix canutils got pretty far:
....
sequence wrap around (698)

But then it hangs. It gets stuck in a poll() loop returning -ENOBUFS,
very, very rapidly. It starts eating all the CPU time in the poll()
loop.

Thanks,
Ira

NOTE: this is pre-RFCv4 code, with improvements found in this thread.
Please do not use it for a production system.

/*
 * Janz MODULbus VMOD-ICAN3 CAN Interface Driver
 *
 * Copyright (c) 2010 Ira W. Snyder &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">iws at ovro.caltech.edu</A>&gt;
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 */

#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;linux/delay.h&gt;
#include &lt;linux/platform_device.h&gt;

#include &lt;linux/netdevice.h&gt;
#include &lt;linux/can.h&gt;
#include &lt;linux/can/dev.h&gt;
#include &lt;linux/can/error.h&gt;

#include &quot;janz.h&quot;

/* the DPM has 64k of memory, organized into 256x 256 byte pages */
#define DPM_NUM_PAGES		256
#define DPM_PAGE_SIZE		256
#define DPM_PAGE_ADDR(p)	((p) * DPM_PAGE_SIZE)

/* JANZ ICAN3 &quot;old-style&quot; host interface queue page numbers */
#define QUEUE_OLD_CONTROL	0
#define QUEUE_OLD_RB0		1
#define QUEUE_OLD_RB1		2
#define QUEUE_OLD_WB0		3
#define QUEUE_OLD_WB1		4

/* Janz ICAN3 &quot;old-style&quot; host interface control registers */
#define MSYNC_PEER		0x00		/* ICAN only */
#define MSYNC_LOCL		0x01		/* host only */
#define TARGET_RUNNING		0x02

#define MSYNC_RB0		0x01
#define MSYNC_RB1		0x02
#define MSYNC_RBLW		0x04
#define MSYNC_RB_MASK		(MSYNC_RB0 | MSYNC_RB1)

#define MSYNC_WB0		0x10
#define MSYNC_WB1		0x20
#define MSYNC_WBLW		0x40
#define MSYNC_WB_MASK		(MSYNC_WB0 | MSYNC_WB1)

/* Janz ICAN3 &quot;new-style&quot; host interface queue page numbers */
#define QUEUE_TOHOST		5
#define QUEUE_FROMHOST_MID	6
#define QUEUE_FROMHOST_HIGH	7
#define QUEUE_FROMHOST_LOW	8

/* The first free page in the DPM is #9 */
#define DPM_FREE_START		9

/* Janz ICAN3 &quot;new-style&quot; and &quot;fast&quot; host interface descriptor flags */
#define DESC_VALID		0x80
#define DESC_WRAP		0x40
#define DESC_INTERRUPT		0x20
#define DESC_IVALID		0x10
#define DESC_LEN(len)		(len)

/* Janz ICAN3 Firmware Messages */
#define MSG_CONNECTI		0x02
#define MSG_DISCONNECT		0x03
#define MSG_IDVERS		0x04
#define MSG_MSGLOST		0x05
#define MSG_NEWHOSTIF		0x08
#define MSG_SETAFILMASK		0x10
#define MSG_INITFDPMQUEUE	0x11
#define MSG_HWCONF		0x12
#define MSG_FMSGLOST		0x15
#define MSG_CEVTIND		0x37
#define MSG_CBTRREQ		0x41
#define MSG_COFFREQ		0x42
#define MSG_CONREQ		0x43
#define MSG_CCONFREQ		0x47

/* Janz ICAN3 CAN Event Indication Message Types */
#define CEVTIND_EI		0x01
#define CEVTIND_DOI		0x02
#define CEVTIND_LOST		0x04
#define CEVTIND_FULL		0x08
#define CEVTIND_BEI		0x10

#define ICAN3_BUSERR_QUOTA_MAX	255

/*
 * SJA1000 Status and Error Register Definitions
 *
 * Copied from drivers/net/can/sja1000/sja1000.h
 */

/* status register content */
#define SR_BS		0x80
#define SR_ES		0x40
#define SR_TS		0x20
#define SR_RS		0x10
#define SR_TCS		0x08
#define SR_TBS		0x04
#define SR_DOS		0x02
#define SR_RBS		0x01

#define SR_CRIT (SR_BS|SR_ES)

/* ECC register */
#define ECC_SEG		0x1F
#define ECC_DIR		0x20
#define ECC_ERR		6
#define ECC_BIT		0x00
#define ECC_FORM	0x40
#define ECC_STUFF	0x80
#define ECC_MASK	0xc0

/* Number of buffers for use in the &quot;new-style&quot; host interface */
#define ICAN3_NEW_BUFFERS	16

/* Number of buffers for use in the &quot;fast&quot; host interface */
#define ICAN3_FAST_BUFFERS	256

/* Driver Name */
#define DRV_NAME &quot;janz-ican3&quot;

/* DPM Control Registers -- starts at offset 0x100 in the MODULbus registers */
struct ican3_dpm_control {
	/* window address register */
	u8 window_address;
	u8 unused1;

	/*
	 * Read access: clear interrupt from microcontroller
	 * Write access: send interrupt to microcontroller
	 */
	u8 interrupt;
	u8 unused2;

	/* write-only: reset all hardware on the module */
	u8 hwreset;
	u8 unused3;

	/* write-only: generate an interrupt to the TPU */
	u8 tpuinterrupt;
};

struct ican3_dev {

	/* must be the first member */
	struct can_priv can;

	/* CAN network device */
	struct net_device *ndev;

	/* Device for printing */
	struct device *dev;

	/* module number */
	unsigned int num;

	/* base address of registers and IRQ */
	struct janz_cmodio_onboard_regs __iomem *ctrl;
	struct ican3_dpm_control *dpmctrl;
	void __iomem *dpm;
	int irq;

	/* old and new style host interface */
	unsigned int iftype;
	spinlock_t lock;

	/* new host interface */
	unsigned int rx_int;
	unsigned int rx_num;
	unsigned int tx_num;

	/* fast host interface */
	unsigned int fastrx_start;
	unsigned int fastrx_int;
	unsigned int fastrx_num;
	unsigned int fasttx_start;
	unsigned int fasttx_num;

	/* first free DPM page */
	unsigned int free_page;

	/* interrupt handling */
	struct work_struct work;
};

struct ican3_msg {
	u8 control;
	u8 spec;
	__le16 len;
	u8 data[252];
};

struct ican3_new_desc {
	u8 control;
	u8 pointer;
};

struct ican3_fast_desc {
	u8 control;
	u8 command;
	u8 data[14];
};

/* write to the window basic address register */
static inline void ican3_set_page(struct ican3_dev *mod, unsigned int page)
{
	BUG_ON(page &gt;= DPM_NUM_PAGES);
	iowrite8(page, &amp;mod-&gt;dpmctrl-&gt;window_address);
}

/*
 * ICAN3 &quot;old-style&quot; host interface
 */

/*
 * Recieve a message from the ICAN3 &quot;old-style&quot; firmware interface
 *
 * LOCKING: must hold mod-&gt;lock
 *
 * returns 0 on success, -ENOMEM when no message exists
 */
static int ican3_old_recv_msg(struct ican3_dev *mod, struct ican3_msg *msg)
{
	unsigned int mbox, mbox_page;
	u8 locl, peer, xord;

	/* get the MSYNC registers */
	ican3_set_page(mod, QUEUE_OLD_CONTROL);
	peer = ioread8(mod-&gt;dpm + MSYNC_PEER);
	locl = ioread8(mod-&gt;dpm + MSYNC_LOCL);
	xord = locl ^ peer;

	if ((xord &amp; MSYNC_RB_MASK) == 0x00) {
		dev_dbg(mod-&gt;dev, &quot;no mbox for reading\n&quot;);
		return -ENOMEM;
	}

	/* find the first free mbox to read */
	if ((xord &amp; MSYNC_RB_MASK) == MSYNC_RB_MASK)
		mbox = (xord &amp; MSYNC_RBLW) ? MSYNC_RB0 : MSYNC_RB1;
	else
		mbox = (xord &amp; MSYNC_RB0) ? MSYNC_RB0 : MSYNC_RB1;

	/* copy the message */
	mbox_page = (mbox == MSYNC_RB0) ? QUEUE_OLD_RB0 : QUEUE_OLD_RB1;
	ican3_set_page(mod, mbox_page);
	memcpy_fromio(msg, mod-&gt;dpm, sizeof(*msg));

	/*
	 * notify the firmware that the read buffer is available
	 * for it to fill again
	 */
	locl ^= mbox;

	ican3_set_page(mod, QUEUE_OLD_CONTROL);
	iowrite8(locl, mod-&gt;dpm + MSYNC_LOCL);
	return 0;
}

/*
 * Send a message through the &quot;old-style&quot; firmware interface
 *
 * LOCKING: must hold mod-&gt;lock
 *
 * returns 0 on success, -ENOMEM when no free space exists
 */
static int ican3_old_send_msg(struct ican3_dev *mod, struct ican3_msg *msg)
{
	unsigned int mbox, mbox_page;
	u8 locl, peer, xord;

	/* get the MSYNC registers */
	ican3_set_page(mod, QUEUE_OLD_CONTROL);
	peer = ioread8(mod-&gt;dpm + MSYNC_PEER);
	locl = ioread8(mod-&gt;dpm + MSYNC_LOCL);
	xord = locl ^ peer;

	if ((xord &amp; MSYNC_WB_MASK) == MSYNC_WB_MASK) {
		dev_err(mod-&gt;dev, &quot;no mbox for writing\n&quot;);
		return -ENOMEM;
	}

	/* calculate a free mbox to use */
	mbox = (xord &amp; MSYNC_WB0) ? MSYNC_WB1 : MSYNC_WB0;

	/* copy the message to the DPM */
	mbox_page = (mbox == MSYNC_WB0) ? QUEUE_OLD_WB0 : QUEUE_OLD_WB1;
	ican3_set_page(mod, mbox_page);
	memcpy_toio(mod-&gt;dpm, msg, sizeof(*msg));

	locl ^= mbox;
	if (mbox == MSYNC_WB1)
		locl |= MSYNC_WBLW;

	ican3_set_page(mod, QUEUE_OLD_CONTROL);
	iowrite8(locl, mod-&gt;dpm + MSYNC_LOCL);
	return 0;
}

/*
 * ICAN3 &quot;new-style&quot; Host Interface Setup
 */

static void ican3_init_new_host_interface(struct ican3_dev *mod)
{
	struct ican3_new_desc desc;
	unsigned long flags;
	void __iomem *dst;
	int i;

	spin_lock_irqsave(&amp;mod-&gt;lock, flags);

	/* setup the internal datastructures for RX */
	mod-&gt;rx_num = 0;
	mod-&gt;rx_int = 0;

	/* tohost queue descriptors are in page 5 */
	ican3_set_page(mod, QUEUE_TOHOST);
	dst = mod-&gt;dpm;

	/* initialize the tohost (rx) queue descriptors: pages 9-24 */
	for (i = 0; i &lt; ICAN3_NEW_BUFFERS; i++) {
		desc.control = DESC_INTERRUPT | DESC_LEN(1); /* I L=1 */
		desc.pointer = mod-&gt;free_page;

		/* set wrap flag on last buffer */
		if (i == ICAN3_NEW_BUFFERS - 1)
			desc.control |= DESC_WRAP;

		memcpy_toio(dst, &amp;desc, sizeof(desc));
		dst += sizeof(desc);
		mod-&gt;free_page++;
	}

	/* fromhost (tx) mid queue descriptors are in page 6 */
	ican3_set_page(mod, QUEUE_FROMHOST_MID);
	dst = mod-&gt;dpm;

	/* setup the internal datastructures for TX */
	mod-&gt;tx_num = 0;

	/* initialize the fromhost mid queue descriptors: pages 25-40 */
	for (i = 0; i &lt; ICAN3_NEW_BUFFERS; i++) {
		desc.control = DESC_VALID | DESC_LEN(1); /* V L=1 */
		desc.pointer = mod-&gt;free_page;

		/* set wrap flag on last buffer */
		if (i == ICAN3_NEW_BUFFERS - 1)
			desc.control |= DESC_WRAP;

		memcpy_toio(dst, &amp;desc, sizeof(desc));
		dst += sizeof(desc);
		mod-&gt;free_page++;
	}

	/* fromhost hi queue descriptors are in page 7 */
	ican3_set_page(mod, QUEUE_FROMHOST_HIGH);
	dst = mod-&gt;dpm;

	/* initialize only a single buffer in the fromhost hi queue (unused) */
	desc.control = DESC_VALID | DESC_WRAP | DESC_LEN(1); /* VW L=1 */
	desc.pointer = mod-&gt;free_page;
	memcpy_toio(dst, &amp;desc, sizeof(desc));
	mod-&gt;free_page++;

	/* fromhost low queue descriptors are in page 8 */
	ican3_set_page(mod, QUEUE_FROMHOST_LOW);
	dst = mod-&gt;dpm;

	/* initialize only a single buffer in the fromhost low queue (unused) */
	desc.control = DESC_VALID | DESC_WRAP | DESC_LEN(1); /* VW L=1 */
	desc.pointer = mod-&gt;free_page;
	memcpy_toio(dst, &amp;desc, sizeof(desc));
	mod-&gt;free_page++;

	spin_unlock_irqrestore(&amp;mod-&gt;lock, flags);
}

/*
 * ICAN3 Fast Host Interface Setup
 */

static void ican3_init_fast_host_interface(struct ican3_dev *mod)
{
	struct ican3_fast_desc desc;
	unsigned long flags;
	unsigned int addr;
	void __iomem *dst;
	int i;

	spin_lock_irqsave(&amp;mod-&gt;lock, flags);

	/* save the start recv page */
	mod-&gt;fastrx_start = mod-&gt;free_page;
	mod-&gt;fastrx_num = 0;
	mod-&gt;fastrx_int = 0;

	/* build a single fast tohost queue descriptor */
	memset(&amp;desc, 0, sizeof(desc));
	desc.control = 0x00;
	desc.command = 1;

	/* build the tohost queue descriptor ring in memory */
	addr = 0;
	for (i = 0; i &lt; ICAN3_FAST_BUFFERS; i++) {

		/* set the wrap bit on the last buffer */
		if (i == ICAN3_FAST_BUFFERS - 1)
			desc.control |= DESC_WRAP;

		/* switch to the correct page */
		ican3_set_page(mod, mod-&gt;free_page);

		/* copy the descriptor to the DPM */
		dst = mod-&gt;dpm + addr;
		memcpy_toio(dst, &amp;desc, sizeof(desc));
		addr += sizeof(desc);

		/* move to the next page if necessary */
		if (addr &gt;= DPM_PAGE_SIZE) {
			addr = 0;
			mod-&gt;free_page++;
		}
	}

	/* make sure we page-align the next queue */
	if (addr != 0)
		mod-&gt;free_page++;

	/* save the start xmit page */
	mod-&gt;fasttx_start = mod-&gt;free_page;
	mod-&gt;fasttx_num = 0;

	/* build a single fast fromhost queue descriptor */
	memset(&amp;desc, 0, sizeof(desc));
	desc.control = DESC_VALID;
	desc.command = 1;

	/* build the fromhost queue descriptor ring in memory */
	addr = 0;
	for (i = 0; i &lt; ICAN3_FAST_BUFFERS; i++) {

		/* set the wrap bit on the last buffer */
		if (i == ICAN3_FAST_BUFFERS - 1)
			desc.control |= DESC_WRAP;

		/* switch to the correct page */
		ican3_set_page(mod, mod-&gt;free_page);

		/* copy the descriptor to the DPM */
		dst = mod-&gt;dpm + addr;
		memcpy_toio(dst, &amp;desc, sizeof(desc));
		addr += sizeof(desc);

		/* move to the next page if necessary */
		if (addr &gt;= DPM_PAGE_SIZE) {
			addr = 0;
			mod-&gt;free_page++;
		}
	}

	spin_unlock_irqrestore(&amp;mod-&gt;lock, flags);
}

/*
 * ICAN3 &quot;new-style&quot; Host Interface Message Helpers
 */

/*
 * LOCKING: must hold mod-&gt;lock
 */
static int ican3_new_send_msg(struct ican3_dev *mod, struct ican3_msg *msg)
{
	struct ican3_new_desc desc;
	void __iomem *desc_addr = mod-&gt;dpm + (mod-&gt;tx_num * sizeof(desc));

	/* switch to the fromhost mid queue, and read the buffer descriptor */
	ican3_set_page(mod, QUEUE_FROMHOST_MID);
	memcpy_fromio(&amp;desc, desc_addr, sizeof(desc));

	if (!(desc.control &amp; DESC_VALID)) {
		dev_dbg(mod-&gt;dev, &quot;%s: no free buffers\n&quot;, __func__);
		return -ENOMEM;
	}

	/* switch to the data page, copy the data */
	ican3_set_page(mod, desc.pointer);
	memcpy_toio(mod-&gt;dpm, msg, sizeof(*msg));

	/* switch back to the descriptor, set the valid bit, write it back */
	ican3_set_page(mod, QUEUE_FROMHOST_MID);
	desc.control ^= DESC_VALID;
	memcpy_toio(desc_addr, &amp;desc, sizeof(desc));

	/* update the tx number */
	mod-&gt;tx_num = (desc.control &amp; DESC_WRAP) ? 0 : (mod-&gt;tx_num + 1);
	return 0;
}

/*
 * LOCKING: must hold mod-&gt;lock
 */
static int ican3_new_recv_msg(struct ican3_dev *mod, struct ican3_msg *msg)
{
	struct ican3_new_desc desc;
	void __iomem *desc_addr = mod-&gt;dpm + (mod-&gt;rx_num * sizeof(desc));

	/* switch to the tohost queue, and read the buffer descriptor */
	ican3_set_page(mod, QUEUE_TOHOST);
	memcpy_fromio(&amp;desc, desc_addr, sizeof(desc));

	if (!(desc.control &amp; DESC_VALID)) {
		dev_dbg(mod-&gt;dev, &quot;%s: no buffers to recv\n&quot;, __func__);
		return -ENOMEM;
	}

	/* switch to the data page, copy the data */
	ican3_set_page(mod, desc.pointer);
	memcpy_fromio(msg, mod-&gt;dpm, sizeof(*msg));

	/* switch back to the descriptor, toggle the valid bit, write it back */
	ican3_set_page(mod, QUEUE_TOHOST);
	desc.control ^= DESC_VALID;
	memcpy_toio(desc_addr, &amp;desc, sizeof(desc));

	/* update the rx number */
	mod-&gt;rx_num = (desc.control &amp; DESC_WRAP) ? 0 : (mod-&gt;rx_num + 1);
	return 0;
}

/*
 * Message Send / Recv Helpers
 */

static int ican3_send_msg(struct ican3_dev *mod, struct ican3_msg *msg)
{
	unsigned long flags;
	int ret;

	spin_lock_irqsave(&amp;mod-&gt;lock, flags);

	if (mod-&gt;iftype == 0)
		ret = ican3_old_send_msg(mod, msg);
	else
		ret = ican3_new_send_msg(mod, msg);

	spin_unlock_irqrestore(&amp;mod-&gt;lock, flags);
	return ret;
}

static int ican3_recv_msg(struct ican3_dev *mod, struct ican3_msg *msg)
{
	unsigned long flags;
	int ret;

	spin_lock_irqsave(&amp;mod-&gt;lock, flags);

	if (mod-&gt;iftype == 0)
		ret = ican3_old_recv_msg(mod, msg);
	else
		ret = ican3_new_recv_msg(mod, msg);

	spin_unlock_irqrestore(&amp;mod-&gt;lock, flags);
	return ret;
}

/*
 * Quick Pre-constructed Messages
 */

static int ican3_msg_connect(struct ican3_dev *mod)
{
	struct ican3_msg msg;

	memset(&amp;msg, 0, sizeof(msg));
	msg.spec = MSG_CONNECTI;
	msg.len = cpu_to_le16(0);

	return ican3_send_msg(mod, &amp;msg);
}

static int ican3_msg_disconnect(struct ican3_dev *mod)
{
	struct ican3_msg msg;

	memset(&amp;msg, 0, sizeof(msg));
	msg.spec = MSG_DISCONNECT;
	msg.len = cpu_to_le16(0);

	return ican3_send_msg(mod, &amp;msg);
}

static int ican3_msg_newhostif(struct ican3_dev *mod)
{
	struct ican3_msg msg;
	int ret;

	memset(&amp;msg, 0, sizeof(msg));
	msg.spec = MSG_NEWHOSTIF;
	msg.len = cpu_to_le16(0);

	/* If we're not using the old interface, switching seems bogus */
	WARN_ON(mod-&gt;iftype != 0);

	ret = ican3_send_msg(mod, &amp;msg);
	if (ret)
		return ret;

	/* mark the module as using the new host interface */
	mod-&gt;iftype = 1;
	return 0;
}

static int ican3_msg_fasthostif(struct ican3_dev *mod)
{
	struct ican3_msg msg;
	unsigned int addr;

	memset(&amp;msg, 0, sizeof(msg));
	msg.spec = MSG_INITFDPMQUEUE;
	msg.len = cpu_to_le16(8);

	/* write the tohost queue start address */
	addr = DPM_PAGE_ADDR(mod-&gt;fastrx_start);
	msg.data[0] = addr &amp; 0xff;
	msg.data[1] = (addr &gt;&gt; 8) &amp; 0xff;
	msg.data[2] = (addr &gt;&gt; 16) &amp; 0xff;
	msg.data[3] = (addr &gt;&gt; 24) &amp; 0xff;

	/* write the fromhost queue start address */
	addr = DPM_PAGE_ADDR(mod-&gt;fasttx_start);
	msg.data[4] = addr &amp; 0xff;
	msg.data[5] = (addr &gt;&gt; 8) &amp; 0xff;
	msg.data[6] = (addr &gt;&gt; 16) &amp; 0xff;
	msg.data[7] = (addr &gt;&gt; 24) &amp; 0xff;

	/* If we're not using the new interface yet, we cannot do this */
	WARN_ON(mod-&gt;iftype != 1);

	return ican3_send_msg(mod, &amp;msg);
}

/*
 * Setup the CAN filter to either accept or reject all
 * messages from the CAN bus.
 */
static int ican3_set_id_filter(struct ican3_dev *mod, bool accept)
{
	struct ican3_msg msg;
	int ret;

	/* Standard Frame Format */
	memset(&amp;msg, 0, sizeof(msg));
	msg.spec = MSG_SETAFILMASK;
	msg.len = cpu_to_le16(5);
	msg.data[0] = 0x00; /* IDLo LSB */
	msg.data[1] = 0x00; /* IDLo MSB */
	msg.data[2] = 0xff; /* IDHi LSB */
	msg.data[3] = 0x07; /* IDHi MSB */

	/* accept all frames for fast host if, or reject all frames */
	msg.data[4] = accept ? 0x02 : 0x00;

	ret = ican3_send_msg(mod, &amp;msg);
	if (ret)
		return ret;

	/* Extended Frame Format */
	memset(&amp;msg, 0, sizeof(msg));
	msg.spec = MSG_SETAFILMASK;
	msg.len = cpu_to_le16(13);
	msg.data[0] = 0;    /* MUX = 0 */
	msg.data[1] = 0x00; /* IDLo LSB */
	msg.data[2] = 0x00;
	msg.data[3] = 0x00;
	msg.data[4] = 0x20; /* IDLo MSB */
	msg.data[5] = 0xff; /* IDHi LSB */
	msg.data[6] = 0xff;
	msg.data[7] = 0xff;
	msg.data[8] = 0x3f; /* IDHi MSB */

	/* accept all frames for fast host if, or reject all frames */
	msg.data[9] = accept ? 0x02 : 0x00;

	return ican3_send_msg(mod, &amp;msg);
}

/*
 * Bring the CAN bus online or offline
 */
static int ican3_set_bus_state(struct ican3_dev *mod, bool on)
{
	struct ican3_msg msg;

	memset(&amp;msg, 0, sizeof(msg));
	msg.spec = on ? MSG_CONREQ : MSG_COFFREQ;
	msg.len = cpu_to_le16(0);

	return ican3_send_msg(mod, &amp;msg);
}

static int ican3_set_termination(struct ican3_dev *mod, bool on)
{
	struct ican3_msg msg;

	memset(&amp;msg, 0, sizeof(msg));
	msg.spec = MSG_HWCONF;
	msg.len = cpu_to_le16(2);
	msg.data[0] = 0x00;
	msg.data[1] = on ? 0x01 : 0x00;

	return ican3_send_msg(mod, &amp;msg);
}

static int ican3_set_buserror(struct ican3_dev *mod, u8 quota)
{
	struct ican3_msg msg;

	memset(&amp;msg, 0, sizeof(msg));
	msg.spec = MSG_CCONFREQ;
	msg.len = cpu_to_le16(2);
	msg.data[0] = 0x00;
	msg.data[1] = quota;

	return ican3_send_msg(mod, &amp;msg);
}

/*
 * ICAN3 to Linux CAN Frame Conversion
 */

static void ican3_to_can_frame(struct ican3_dev *mod,
			       struct ican3_fast_desc *desc,
			       struct can_frame *cf)
{
	if ((desc-&gt;command &amp; 0x0f) == 0) {
		dev_dbg(mod-&gt;dev, &quot;%s: old frame format\n&quot;, __func__);
		if (desc-&gt;data[1] &amp; 0x10)
			cf-&gt;can_id |= CAN_RTR_FLAG;

		cf-&gt;can_id |= desc-&gt;data[0] &lt;&lt; 3;
		cf-&gt;can_id |= (desc-&gt;data[1] &amp; 0xe0) &gt;&gt; 5;
		cf-&gt;can_dlc = desc-&gt;data[1] &amp; 0x0f;
		memcpy(cf-&gt;data, &amp;desc-&gt;data[2], sizeof(cf-&gt;data));
	} else {
		dev_dbg(mod-&gt;dev, &quot;%s: new frame format\n&quot;, __func__);
		cf-&gt;can_dlc = desc-&gt;data[0] &amp; 0x0f;
		if (desc-&gt;data[0] &amp; 0x40)
			cf-&gt;can_id |= CAN_RTR_FLAG;

		if (desc-&gt;data[0] &amp; 0x80) {
			cf-&gt;can_id |= CAN_EFF_FLAG;
			cf-&gt;can_id |= desc-&gt;data[2] &lt;&lt; 21; /* 28-21 */
			cf-&gt;can_id |= desc-&gt;data[3] &lt;&lt; 13; /* 20-13 */
			cf-&gt;can_id |= desc-&gt;data[4] &lt;&lt; 5;  /* 12-5  */
			cf-&gt;can_id |= (desc-&gt;data[5] &amp; 0xf8) &gt;&gt; 3;
		} else {
			cf-&gt;can_id |= desc-&gt;data[2] &lt;&lt; 3;  /* 10-3  */
			cf-&gt;can_id |= desc-&gt;data[3] &gt;&gt; 5;  /* 2-0   */
		}

		memcpy(cf-&gt;data, &amp;desc-&gt;data[6], sizeof(cf-&gt;data));
	}
}

static void can_frame_to_ican3(struct ican3_dev *mod,
			       struct can_frame *cf,
			       struct ican3_fast_desc *desc)
{
	/* clear out any stale data in the descriptor */
	memset(desc-&gt;data, 0, sizeof(desc-&gt;data));

	/* we always use the extended format, with the ECHO flag set */
	desc-&gt;command = 1;
	desc-&gt;data[0] |= cf-&gt;can_dlc;
	desc-&gt;data[1] |= 0x10; /* echo */

	if (cf-&gt;can_id &amp; CAN_RTR_FLAG)
		desc-&gt;data[0] |= 0x40;

	/* pack the id into the correct places */
	if (cf-&gt;can_id &amp; CAN_EFF_FLAG) {
		dev_dbg(mod-&gt;dev, &quot;%s: extended frame\n&quot;, __func__);
		desc-&gt;data[0] |= 0x80; /* extended id frame */
		desc-&gt;data[2] = (cf-&gt;can_id &amp; 0x1fe00000) &gt;&gt; 21; /* 28-21 */
		desc-&gt;data[3] = (cf-&gt;can_id &amp; 0x001fe000) &gt;&gt; 13; /* 20-13 */
		desc-&gt;data[4] = (cf-&gt;can_id &amp; 0x00001fe0) &gt;&gt; 5;  /* 12-5  */
		desc-&gt;data[5] = (cf-&gt;can_id &amp; 0x0000001f) &lt;&lt; 3;  /* 4-0   */
	} else {
		dev_dbg(mod-&gt;dev, &quot;%s: standard frame\n&quot;, __func__);
		desc-&gt;data[2] = (cf-&gt;can_id &amp; 0x7F8) &gt;&gt; 3; /* bits 10-3 */
		desc-&gt;data[3] = (cf-&gt;can_id &amp; 0x007) &lt;&lt; 5; /* bits 2-0  */
	}

	/* copy the data bits into the descriptor */
	memcpy(&amp;desc-&gt;data[6], cf-&gt;data, sizeof(cf-&gt;data));
}

/*
 * Interrupt Handling
 */

/*
 * Handle an ID + Version message response from the firmware. We never generate
 * this message in production code, but it is very useful when debugging to be
 * able to display this message.
 */
static void ican3_handle_idvers(struct ican3_dev *mod, struct ican3_msg *msg)
{
	dev_dbg(mod-&gt;dev, &quot;IDVERS response: %s\n&quot;, msg-&gt;data);
}

static void ican3_handle_msglost(struct ican3_dev *mod, struct ican3_msg *msg)
{
	struct net_device *dev = mod-&gt;ndev;
	struct net_device_stats *stats = &amp;dev-&gt;stats;
	struct can_frame *cf;
	struct sk_buff *skb;

	/*
	 * Report that communication messages with the microcontroller firmware
	 * are being lost. These are never CAN frames, so we do not generate an
	 * error frame for userspace
	 */
	if (msg-&gt;spec == MSG_MSGLOST) {
		dev_err(mod-&gt;dev, &quot;lost %d control messages\n&quot;, msg-&gt;data[0]);
		return;
	}

	/*
	 * Oops, this indicates that we have lost messages in the fast queue,
	 * which are exclusively CAN messages. Our driver isn't reading CAN
	 * frames fast enough.
	 *
	 * We'll pretend that the SJA1000 told us that it ran out of buffer
	 * space, because there is not a better message for this.
	 */
	skb = alloc_can_err_skb(dev, &amp;cf);
	if (skb) {
		cf-&gt;can_id |= CAN_ERR_CRTL;
		cf-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
		stats-&gt;rx_packets++;
		stats-&gt;rx_bytes += cf-&gt;can_dlc;
		netif_rx(skb);
	}
}

/*
 * Handle CAN Event Indication Messages from the firmware
 *
 * The ICAN3 firmware provides the values of some SJA1000 registers when it
 * generates this message. The code below is largely copied from the
 * drivers/net/can/sja1000/sja1000.c file, and adapted as necessary
 */
static int ican3_handle_cevtind(struct ican3_dev *mod, struct ican3_msg *msg)
{
	struct net_device *dev = mod-&gt;ndev;
	struct net_device_stats *stats = &amp;dev-&gt;stats;
	enum can_state state = mod-&gt;can.state;
	struct can_frame *cf;
	struct sk_buff *skb;
	u8 status, isrc;

	/* we can only handle the SJA1000 part */
	if (msg-&gt;data[1] != 0x02) {
		dev_err(mod-&gt;dev, &quot;unable to handle errors on non-SJA1000\n&quot;);
		return -ENODEV;
	}

	/* check the message length for sanity */
	if (msg-&gt;len &lt; 6) {
		dev_err(mod-&gt;dev, &quot;error message too short\n&quot;);
		return -EINVAL;
	}

	skb = alloc_can_err_skb(dev, &amp;cf);
	if (skb == NULL)
		return -ENOMEM;

	isrc = msg-&gt;data[0];
	status = msg-&gt;data[3];

	/* data overrun interrupt */
	if (isrc == CEVTIND_DOI || isrc == CEVTIND_LOST) {
		cf-&gt;can_id |= CAN_ERR_CRTL;
		cf-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
		stats-&gt;rx_over_errors++;
		stats-&gt;rx_errors++;
	}

	/* error warning interrupt */
	if (isrc == CEVTIND_EI) {
		if (status &amp; SR_BS) {
			state = CAN_STATE_BUS_OFF;
			cf-&gt;can_id |= CAN_ERR_BUSOFF;
			can_bus_off(dev);
		} else if (status &amp; SR_ES) {
			state = CAN_STATE_ERROR_WARNING;
		} else {
			state = CAN_STATE_ERROR_ACTIVE;
		}
	}

	/* bus error interrupt */
	if (isrc == CEVTIND_BEI) {
		u8 ecc = msg-&gt;data[2];
		mod-&gt;can.can_stats.bus_error++;
		stats-&gt;rx_errors++;
		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;

		switch (ecc &amp; ECC_MASK) {
		case ECC_BIT:
			cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
			break;
		case ECC_FORM:
			cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
			break;
		case ECC_STUFF:
			cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
			break;
		default:
			cf-&gt;data[2] |= CAN_ERR_PROT_UNSPEC;
			cf-&gt;data[3] = ecc &amp; ECC_SEG;
			break;
		}

		if ((ecc &amp; ECC_DIR) == 0)
			cf-&gt;data[2] |= CAN_ERR_PROT_TX;
	}

	if (state != mod-&gt;can.state &amp;&amp; (state == CAN_STATE_ERROR_WARNING ||
					state == CAN_STATE_ERROR_PASSIVE)) {
		u8 rxerr = msg-&gt;data[4];
		u8 txerr = msg-&gt;data[5];
		cf-&gt;can_id |= CAN_ERR_CRTL;
		if (state == CAN_STATE_ERROR_WARNING) {
			mod-&gt;can.can_stats.error_warning++;
			cf-&gt;data[1] = (txerr &gt; rxerr) ?
				CAN_ERR_CRTL_TX_WARNING :
				CAN_ERR_CRTL_RX_WARNING;
		} else {
			mod-&gt;can.can_stats.error_passive++;
			cf-&gt;data[1] = (txerr &gt; rxerr) ?
				CAN_ERR_CRTL_TX_PASSIVE :
				CAN_ERR_CRTL_RX_PASSIVE;
		}
	}

	mod-&gt;can.state = state;
	stats-&gt;rx_packets++;
	stats-&gt;rx_bytes += cf-&gt;can_dlc;
	netif_rx(skb);
	return 0;
}

static void ican3_handle_unknown_message(struct ican3_dev *mod,
					struct ican3_msg *msg)
{
	dev_warn(mod-&gt;dev, &quot;recieved unknown message: spec 0x%.2x length %d\n&quot;,
			   msg-&gt;spec, le16_to_cpu(msg-&gt;len));
}

/*
 * Handle a control message from the firmware
 */
static void ican3_handle_message(struct ican3_dev *mod, struct ican3_msg *msg)
{
	dev_dbg(mod-&gt;dev, &quot;%s: modno %d spec 0x%.2x len %d bytes\n&quot;, __func__,
			   mod-&gt;num, msg-&gt;spec, le16_to_cpu(msg-&gt;len));

	switch (msg-&gt;spec) {
	case MSG_IDVERS:
		ican3_handle_idvers(mod, msg);
		break;
	case MSG_MSGLOST:
	case MSG_FMSGLOST:
		ican3_handle_msglost(mod, msg);
		break;
	case MSG_CEVTIND:
		ican3_handle_cevtind(mod, msg);
		break;
	default:
		ican3_handle_unknown_message(mod, msg);
		break;
	}
}

/*
 * Check that there is room in the TX ring to transmit another skb
 *
 * LOCKING: must hold mod-&gt;lock
 */
static bool ican3_txok(struct ican3_dev *mod)
{
	struct ican3_fast_desc __iomem *desc;
	u8 control;

	/* copy the control bits of the descriptor */
	ican3_set_page(mod, mod-&gt;fasttx_start + (mod-&gt;fasttx_num / 16));
	desc = mod-&gt;dpm + ((mod-&gt;fasttx_num % 16) * sizeof(*desc));
	control = ioread8(&amp;desc-&gt;control);

	/* if the control bits are not valid, then we have no more space */
	if (!(control &amp; DESC_VALID))
		return false;

	return true;
}

/*
 * Recieve one CAN frame from the hardware
 *
 * This works like the core of a NAPI function, but is intended to be called
 * from workqueue context instead. This driver already needs a workqueue to
 * process control messages, so we use the workqueue instead of using NAPI.
 * This was done to simplify locking.
 *
 * CONTEXT: must be called from user context
 */
static int ican3_recv_skb(struct ican3_dev *mod)
{
	struct net_device *ndev = mod-&gt;ndev;
	struct net_device_stats *stats = &amp;ndev-&gt;stats;
	struct ican3_fast_desc desc;
	void __iomem *desc_addr;
	struct can_frame *cf;
	struct sk_buff *skb;
	unsigned long flags;
	int ret;

	spin_lock_irqsave(&amp;mod-&gt;lock, flags);

	/*
	 * This hardware doesn't support TX-done notifications, so we are
	 * emulating it the best we can. If the TX queue is stopped and we
	 * have space in the TX ring, then we need to wake the queue.
	 */
	if (netif_queue_stopped(ndev) &amp;&amp; ican3_txok(mod)) {
		dev_info(mod-&gt;dev, &quot;%s: waking queue\n&quot;, __func__);
		netif_wake_queue(ndev);
	}

	/* copy the whole descriptor */
	ican3_set_page(mod, mod-&gt;fastrx_start + (mod-&gt;fastrx_num / 16));
	desc_addr = mod-&gt;dpm + ((mod-&gt;fastrx_num % 16) * sizeof(desc));
	memcpy_fromio(&amp;desc, desc_addr, sizeof(desc));

	/* check that we actually have a CAN frame */
	if (!(desc.control &amp; DESC_VALID)) {
		ret = -ENOBUFS;
		goto out_unlock;
	}

	/* allocate an skb */
	skb = alloc_can_skb(ndev, &amp;cf);
	if (unlikely(skb == NULL)) {
		stats-&gt;rx_dropped++;
		goto err_noalloc;
	}

	/* convert the ICAN3 frame into Linux CAN format */
	ican3_to_can_frame(mod, &amp;desc, cf);

	/* receive the skb, update statistics */
	netif_rx(skb);
	stats-&gt;rx_packets++;
	stats-&gt;rx_bytes += cf-&gt;can_dlc;

err_noalloc:
	/* toggle the valid bit and return the descriptor to the ring */
	desc.control ^= DESC_VALID;
	memcpy_toio(desc_addr, &amp;desc, 1);

	/* update the next buffer pointer */
	mod-&gt;fastrx_num = (desc.control &amp; DESC_WRAP) ? 0
						     : (mod-&gt;fastrx_num + 1);

	/* there are still more buffers to process */
	ret = 0;

out_unlock:
	spin_unlock_irqrestore(&amp;mod-&gt;lock, flags);
	return ret;
}

static void ican3_work(struct work_struct *work)
{
	struct ican3_dev *mod = container_of(work, struct ican3_dev, work);
	struct ican3_msg msg;
	int ret;

	/* process all communication messages */
	while (true) {
		ret = ican3_recv_msg(mod, &amp;msg);
		if (ret)
			break;

		ican3_handle_message(mod, &amp;msg);
	}

	/* process all CAN frames from the fast interface */
	while (true) {
		ret = ican3_recv_skb(mod);
		if (ret)
			break;
	}
}

/*
 * Handle a MODULbus interrupt
 *
 * Due to the way the firmware works, we must first go through all of the
 * buffers and unset their IVALID flag, then notify our work function to
 * process the message. The IVALID flag must be unset before clearing the
 * interrupt.
 *
 * Only after the message has been processed can the VALID flag be unset.
 */
static void ican3_handle_interrupt(struct ican3_dev *mod)
{
	unsigned long flags;
	u8 control;

	spin_lock_irqsave(&amp;mod-&gt;lock, flags);

	/*
	 * If we're using the old-style host interface, we only need to
	 * start the work function, since the fast host interface (and
	 * therefore CAN frame reception) cannot be working yet
	 */
	if (mod-&gt;iftype == 0) {
		schedule_work(&amp;mod-&gt;work);
		goto out_unlock;
	}

	/*
	 * Ok, at least the new-style host interface must be running, so we
	 * need to go through it's buffers and unset all of their DESC_IVALID
	 * bits before clearing the interrupt
	 */
	while (true) {
		struct ican3_new_desc __iomem *desc;

		/* check the new host interface tohost queue */
		ican3_set_page(mod, QUEUE_TOHOST);
		desc = mod-&gt;dpm + (mod-&gt;rx_int * sizeof(*desc));
		control = ioread8(&amp;desc-&gt;control);

		/* check if we're finished with buffers */
		if (!(control &amp; DESC_IVALID))
			break;

		/* write the control bits back with IVALID unset */
		control &amp;= ~DESC_IVALID;
		iowrite8(control, &amp;desc-&gt;control);

		/*
		 * update the interrupt handler's position and schedule
		 * the work function to run at some point in the future
		 */
		mod-&gt;rx_int = (control &amp; DESC_WRAP) ? 0 : (mod-&gt;rx_int + 1);
		schedule_work(&amp;mod-&gt;work);
	}

	/* Check the fast host interface for interrupts */
	while (true) {
		struct ican3_fast_desc __iomem *desc;

		/* check the fast host interface */
		ican3_set_page(mod, mod-&gt;fastrx_start + (mod-&gt;fastrx_int / 16));
		desc = mod-&gt;dpm + ((mod-&gt;fastrx_int % 16) * sizeof(*desc));
		control = ioread8(&amp;desc-&gt;control);

		/* check if we're finished with buffers */
		if (!(control &amp; DESC_IVALID))
			break;

		/* write back the control bits with IVALID unset */
		control &amp;= ~DESC_IVALID;
		iowrite8(control, &amp;desc-&gt;control);

		/*
		 * update the interrupt handler's position and schedule
		 * the work function to run at some point in the future
		 */
		mod-&gt;fastrx_int = (control &amp; DESC_WRAP) ? 0
							: (mod-&gt;fastrx_int + 1);
		schedule_work(&amp;mod-&gt;work);
	}

	/* Wake up the transmit queue if necessary */
	if (netif_queue_stopped(mod-&gt;ndev) &amp;&amp; ican3_txok(mod)) {
		dev_info(mod-&gt;dev, &quot;%s: waking queue\n&quot;, __func__);
		netif_wake_queue(mod-&gt;ndev);
	}

out_unlock:
	/* clear the MODULbus interrupt from the microcontroller */
	ioread8(&amp;mod-&gt;dpmctrl-&gt;interrupt);
	spin_unlock_irqrestore(&amp;mod-&gt;lock, flags);
}

static irqreturn_t ican3_irq(int irq, void *dev_id)
{
	struct ican3_dev *mod = dev_id;
	u8 stat;

	/*
	 * The interrupt status register on this device reports interrupts
	 * as zeroes instead of using ones like most other devices
	 */
	stat = ioread8(&amp;mod-&gt;ctrl-&gt;int_disable) &amp; (1 &lt;&lt; mod-&gt;num);
	if (stat == (1 &lt;&lt; mod-&gt;num))
		return IRQ_NONE;

	dev_dbg(mod-&gt;dev, &quot;IRQ: module %d\n&quot;, mod-&gt;num);
	ican3_handle_interrupt(mod);
	return IRQ_HANDLED;
}

/*
 * Firmware reset, startup, and shutdown
 */

/*
 * Reset an ICAN module to its power-on state
 *
 * CONTEXT: no network device registered
 * LOCKING: work function disabled
 */
static int ican3_reset_module(struct ican3_dev *mod)
{
	u8 val = 1 &lt;&lt; mod-&gt;num;
	unsigned long start;
	u8 runold, runnew;

	/* disable interrupts so no more work is scheduled */
	iowrite8(1 &lt;&lt; mod-&gt;num, &amp;mod-&gt;ctrl-&gt;int_disable);

	/* flush any pending work */
	flush_scheduled_work();

	/* the first unallocated page in the DPM is #9 */
	mod-&gt;free_page = DPM_FREE_START;

	ican3_set_page(mod, QUEUE_OLD_CONTROL);
	runold = ioread8(mod-&gt;dpm + TARGET_RUNNING);

	/* reset the module */
	iowrite8(val, &amp;mod-&gt;ctrl-&gt;reset_assert);
	iowrite8(val, &amp;mod-&gt;ctrl-&gt;reset_deassert);

	/* wait until the module has finished resetting and is running */
	start = jiffies;
	do {
		ican3_set_page(mod, QUEUE_OLD_CONTROL);
		runnew = ioread8(mod-&gt;dpm + TARGET_RUNNING);
		if (runnew == (runold ^ 0xff))
			return 0;

		msleep(10);
	} while (time_before(jiffies, start + HZ / 4));

	dev_err(mod-&gt;dev, &quot;failed to reset CAN module\n&quot;);
	return -ETIMEDOUT;
}

static void ican3_shutdown_module(struct ican3_dev *mod)
{
	ican3_msg_disconnect(mod);
	ican3_reset_module(mod);
}

/*
 * Startup an ICAN module, bringing it into fast mode
 */
static int ican3_startup_module(struct ican3_dev *mod)
{
	int ret;

	ret = ican3_reset_module(mod);
	if (ret) {
		dev_err(mod-&gt;dev, &quot;unable to reset module\n&quot;);
		return ret;
	}

	/* re-enable interrupts so we can send messages */
	iowrite8(1 &lt;&lt; mod-&gt;num, &amp;mod-&gt;ctrl-&gt;int_enable);

	ret = ican3_msg_connect(mod);
	if (ret) {
		dev_err(mod-&gt;dev, &quot;unable to connect to module\n&quot;);
		return ret;
	}

	ican3_init_new_host_interface(mod);
	ret = ican3_msg_newhostif(mod);
	if (ret) {
		dev_err(mod-&gt;dev, &quot;unable to switch to new-style interface\n&quot;);
		return ret;
	}

	ret = ican3_set_termination(mod, true);
	if (ret) {
		dev_err(mod-&gt;dev, &quot;unable to enable termination\n&quot;);
		return ret;
	}

	ret = ican3_set_buserror(mod, ICAN3_BUSERR_QUOTA_MAX);
	if (ret) {
		dev_err(mod-&gt;dev, &quot;unable to set bus-error\n&quot;);
		return ret;
	}

	ican3_init_fast_host_interface(mod);
	ret = ican3_msg_fasthostif(mod);
	if (ret) {
		dev_err(mod-&gt;dev, &quot;unable to switch to fast host interface\n&quot;);
		return ret;
	}

	ret = ican3_set_id_filter(mod, true);
	if (ret) {
		dev_err(mod-&gt;dev, &quot;unable to set acceptance filter\n&quot;);
		return ret;
	}

	return 0;
}

/*
 * CAN Network Device
 */

static int ican3_open(struct net_device *ndev)
{
	struct ican3_dev *mod = netdev_priv(ndev);
	int ret;

	/* open the CAN layer */
	ret = open_candev(ndev);
	if (ret) {
		dev_err(mod-&gt;dev, &quot;unable to start CAN layer\n&quot;);
		return ret;
	}

	/* bring the bus online */
	ret = ican3_set_bus_state(mod, true);
	if (ret) {
		dev_err(mod-&gt;dev, &quot;unable to set bus-on\n&quot;);
		close_candev(ndev);
		return ret;
	}

	/* start up the network device */
	mod-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
	netif_start_queue(ndev);

	return 0;
}

static int ican3_stop(struct net_device *ndev)
{
	struct ican3_dev *mod = netdev_priv(ndev);
	int ret;

	/* stop the network device xmit routine */
	netif_stop_queue(ndev);
	mod-&gt;can.state = CAN_STATE_STOPPED;

	/* bring the bus offline, stop receiving packets */
	ret = ican3_set_bus_state(mod, false);
	if (ret) {
		dev_err(mod-&gt;dev, &quot;unable to set bus-off\n&quot;);
		return ret;
	}

	/* close the CAN layer */
	close_candev(ndev);
	return 0;
}

static int ican3_xmit(struct sk_buff *skb, struct net_device *ndev)
{
	struct ican3_dev *mod = netdev_priv(ndev);
	struct net_device_stats *stats = &amp;ndev-&gt;stats;
	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
	struct ican3_fast_desc desc;
	void __iomem *desc_addr;
	unsigned long flags;

	spin_lock_irqsave(&amp;mod-&gt;lock, flags);

	/* check that we can actually transmit */
	if (!ican3_txok(mod)) {
		dev_err(mod-&gt;dev, &quot;no free descriptors, stopping queue\n&quot;);
		netif_stop_queue(ndev);
		spin_unlock_irqrestore(&amp;mod-&gt;lock, flags);
		return NETDEV_TX_BUSY;
	}

	/* copy the control bits of the descriptor */
	ican3_set_page(mod, mod-&gt;fasttx_start + (mod-&gt;fasttx_num / 16));
	desc_addr = mod-&gt;dpm + ((mod-&gt;fasttx_num % 16) * sizeof(desc));
	memset(&amp;desc, 0, sizeof(desc));
	memcpy_fromio(&amp;desc, desc_addr, 1);

	/* convert the Linux CAN frame into ICAN3 format */
	can_frame_to_ican3(mod, cf, &amp;desc);

	/*
	 * the programming manual says that you must set the IVALID bit, then
	 * interrupt, then set the valid bit. Quite weird, but it seems to be
	 * required for this to work
	 */
	desc.control |= DESC_IVALID;
	memcpy_toio(desc_addr, &amp;desc, sizeof(desc));

	/* generate a MODULbus interrupt to the microcontroller */
	iowrite8(0x01, &amp;mod-&gt;dpmctrl-&gt;interrupt);

	desc.control ^= DESC_VALID;
	memcpy_toio(desc_addr, &amp;desc, sizeof(desc));

	/* update the next buffer pointer */
	mod-&gt;fasttx_num = (desc.control &amp; DESC_WRAP) ? 0
						     : (mod-&gt;fasttx_num + 1);

	/* update statistics */
	stats-&gt;tx_packets++;
	stats-&gt;tx_bytes += cf-&gt;can_dlc;
	kfree_skb(skb);

	/*
	 * This hardware doesn't have TX-done notifications, so we'll try and
	 * emulate it the best we can using ECHO skbs. Get the next TX
	 * descriptor, and see if we have room to send. If not, stop the queue.
	 * It will be woken when the ECHO skb for the current packet is recv'd.
	 */

	/* copy the control bits of the descriptor */
	if (!ican3_txok(mod)) {
		dev_info(mod-&gt;dev, &quot;%s: stopping queue\n&quot;, __func__);
		netif_stop_queue(ndev);
	}

	spin_unlock_irqrestore(&amp;mod-&gt;lock, flags);
	return NETDEV_TX_OK;
}

static const struct net_device_ops ican3_netdev_ops = {
	.ndo_open	= ican3_open,
	.ndo_stop	= ican3_stop,
	.ndo_start_xmit	= ican3_xmit,
};

/*
 * Low-level CAN Device
 */

/* This structure was stolen from drivers/net/can/sja1000/sja1000.c */
static struct can_bittiming_const ican3_bittiming_const = {
	.name = DRV_NAME,
	.tseg1_min = 1,
	.tseg1_max = 16,
	.tseg2_min = 1,
	.tseg2_max = 8,
	.sjw_max = 4,
	.brp_min = 1,
	.brp_max = 64,
	.brp_inc = 1,
};

/*
 * This routine was stolen from drivers/net/can/sja1000/sja1000.c
 *
 * The bittiming register command for the ICAN3 just sets the bit timing
 * registers on the SJA1000 chip directly
 */
static int ican3_set_bittiming(struct net_device *ndev)
{
	struct ican3_dev *mod = netdev_priv(ndev);
	struct can_bittiming *bt = &amp;mod-&gt;can.bittiming;
	struct ican3_msg msg;
	u8 btr0, btr1;

	btr0 = ((bt-&gt;brp - 1) &amp; 0x3f) | (((bt-&gt;sjw - 1) &amp; 0x3) &lt;&lt; 6);
	btr1 = ((bt-&gt;prop_seg + bt-&gt;phase_seg1 - 1) &amp; 0xf) |
		(((bt-&gt;phase_seg2 - 1) &amp; 0x7) &lt;&lt; 4);
	if (mod-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES)
		btr1 |= 0x80;

	memset(&amp;msg, 0, sizeof(msg));
	msg.spec = MSG_CBTRREQ;
	msg.len = cpu_to_le16(4);
	msg.data[0] = 0x00;
	msg.data[1] = 0x00;
	msg.data[2] = btr0;
	msg.data[3] = btr1;

	return ican3_send_msg(mod, &amp;msg);
}

static int ican3_set_mode(struct net_device *ndev, enum can_mode mode)
{
	struct ican3_dev *mod = netdev_priv(ndev);
	int ret;

	if (mode != CAN_MODE_START)
		return -ENOTSUPP;

	/* bring the bus online */
	ret = ican3_set_bus_state(mod, true);
	if (ret) {
		dev_err(mod-&gt;dev, &quot;unable to set bus-on\n&quot;);
		return ret;
	}

	/* start up the network device */
	mod-&gt;can.state = CAN_STATE_ERROR_ACTIVE;

	if (netif_queue_stopped(ndev))
		netif_wake_queue(ndev);

	return 0;
}

/*
 * PCI Subsystem
 */

static int __devinit ican3_probe(struct platform_device *pdev)
{
	struct janz_platform_data *pdata;
	struct net_device *ndev;
	struct ican3_dev *mod;
	struct resource *res;
	struct device *dev;
	int ret;

	pdata = pdev-&gt;dev.platform_data;
	if (!pdata)
		return -ENXIO;

	dev_dbg(&amp;pdev-&gt;dev, &quot;probe: module number %d\n&quot;, pdata-&gt;modno);

	/* save the struct device for printing */
	dev = &amp;pdev-&gt;dev;

	/* allocate the CAN device and private data */
	ndev = alloc_candev(sizeof(*mod), 0);
	if (!ndev) {
		dev_err(dev, &quot;unable to allocate CANdev\n&quot;);
		ret = -ENOMEM;
		goto out_return;
	}

	platform_set_drvdata(pdev, ndev);
	mod = netdev_priv(ndev);
	mod-&gt;ndev = ndev;
	mod-&gt;dev = &amp;pdev-&gt;dev;
	mod-&gt;num = pdata-&gt;modno;
	INIT_WORK(&amp;mod-&gt;work, ican3_work);
	spin_lock_init(&amp;mod-&gt;lock);

	/* the first unallocated page in the DPM is 9 */
	mod-&gt;free_page = DPM_FREE_START;

	ndev-&gt;netdev_ops = &amp;ican3_netdev_ops;
	ndev-&gt;flags |= IFF_ECHO;
	SET_NETDEV_DEV(ndev, &amp;pdev-&gt;dev);

	mod-&gt;can.clock.freq = 8000000;
	mod-&gt;can.bittiming_const = &amp;ican3_bittiming_const;
	mod-&gt;can.do_set_bittiming = ican3_set_bittiming;
	mod-&gt;can.do_set_mode = ican3_set_mode;

	/* find our IRQ number */
	mod-&gt;irq = platform_get_irq(pdev, 0);
	if (mod-&gt;irq &lt; 0) {
		dev_err(dev, &quot;IRQ line not found\n&quot;);
		ret = -ENODEV;
		goto out_free_ndev;
	}

	ndev-&gt;irq = mod-&gt;irq;

	/* get access to the MODULbus registers for this module */
	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (!res) {
		dev_err(dev, &quot;MODULbus registers not found\n&quot;);
		ret = -ENODEV;
		goto out_free_ndev;
	}

	mod-&gt;dpm = ioremap(res-&gt;start, resource_size(res));
	if (!mod-&gt;dpm) {
		dev_err(dev, &quot;MODULbus registers not ioremap\n&quot;);
		ret = -ENOMEM;
		goto out_free_ndev;
	}

	mod-&gt;dpmctrl = mod-&gt;dpm + DPM_PAGE_SIZE;

	/* get access to the control registers for this module */
	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
	if (!res) {
		dev_err(dev, &quot;CONTROL registers not found\n&quot;);
		ret = -ENODEV;
		goto out_iounmap_dpm;
	}

	mod-&gt;ctrl = ioremap(res-&gt;start, resource_size(res));
	if (!mod-&gt;ctrl) {
		dev_err(dev, &quot;CONTROL registers not ioremap\n&quot;);
		ret = -ENOMEM;
		goto out_iounmap_dpm;
	}

	/* disable our IRQ, then hookup the IRQ handler */
	iowrite8(1 &lt;&lt; mod-&gt;num, &amp;mod-&gt;ctrl-&gt;int_disable);
	ret = request_irq(mod-&gt;irq, ican3_irq, IRQF_SHARED, DRV_NAME, mod);
	if (ret) {
		dev_err(dev, &quot;unable to request IRQ\n&quot;);
		goto out_iounmap_ctrl;
	}

	/* reset and initialize the CAN controller into fast mode */
	ret = ican3_startup_module(mod);
	if (ret) {
		dev_err(dev, &quot;%s: unable to start CANdev\n&quot;, __func__);
		goto out_free_irq;
	}

	/* register with the Linux CAN layer */
	ret = register_candev(ndev);
	if (ret) {
		dev_err(dev, &quot;%s: unable to register CANdev\n&quot;, __func__);
		goto out_free_irq;
	}

	dev_info(dev, &quot;module %d: registered CAN device\n&quot;, pdata-&gt;modno);
	return 0;

out_free_irq:
	iowrite8(1 &lt;&lt; mod-&gt;num, &amp;mod-&gt;ctrl-&gt;int_disable);
	free_irq(mod-&gt;irq, mod);
out_iounmap_ctrl:
	iounmap(mod-&gt;ctrl);
out_iounmap_dpm:
	iounmap(mod-&gt;dpm);
out_free_ndev:
	free_candev(ndev);
out_return:
	return ret;
}

static int __devexit ican3_remove(struct platform_device *pdev)
{
	struct net_device *ndev = platform_get_drvdata(pdev);
	struct ican3_dev *mod = netdev_priv(ndev);

	/* unregister the netdevice, stop interrupts */
	unregister_netdev(ndev);
	iowrite8(1 &lt;&lt; mod-&gt;num, &amp;mod-&gt;ctrl-&gt;int_disable);
	free_irq(mod-&gt;irq, mod);

	/* put the module into reset */
	ican3_shutdown_module(mod);

	/* unmap all registers */
	iounmap(mod-&gt;ctrl);
	iounmap(mod-&gt;dpm);

	free_candev(ndev);

	return 0;
}

static struct platform_driver ican3_driver = {
	.driver		= {
		.name	= DRV_NAME,
		.owner	= THIS_MODULE,
	},
	.probe		= ican3_probe,
	.remove		= ican3_remove,
};

static int __init ican3_init(void)
{
	return platform_driver_register(&amp;ican3_driver);
}

static void __exit ican3_exit(void)
{
	platform_driver_unregister(&amp;ican3_driver);
}

MODULE_AUTHOR(&quot;Ira W. Snyder &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">iws at ovro.caltech.edu</A>&gt;&quot;);
MODULE_DESCRIPTION(&quot;Janz MODULbus VMOD-ICAN3 Driver&quot;);
MODULE_LICENSE(&quot;GPL&quot;);
MODULE_ALIAS(&quot;platform:janz-ican3&quot;);

module_init(ican3_init);
module_exit(ican3_exit);



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004108.html">[PATCH 0/2] add support for Janz MODULbus devices
</A></li>
	<LI>Next message: <A HREF="004110.html">[PATCH 0/2] add support for Janz MODULbus devices
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4109">[ date ]</a>
              <a href="thread.html#4109">[ thread ]</a>
              <a href="subject.html#4109">[ subject ]</a>
              <a href="author.html#4109">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
