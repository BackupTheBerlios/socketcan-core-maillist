<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Review of netlink's
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20Review%20of%20netlink%27s&In-Reply-To=%3C20090618131630.GD3579%40e-circ.dyndns.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002718.html">
   <LINK REL="Next"  HREF="002735.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Review of netlink's</H1>
    <B>Kurt Van Dijck</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20Review%20of%20netlink%27s&In-Reply-To=%3C20090618131630.GD3579%40e-circ.dyndns.org%3E"
       TITLE="Review of netlink's">kurt.van.dijck at eia.be
       </A><BR>
    <I>Thu Jun 18 15:16:31 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002718.html">Review of netlink's 
</A></li>
        <LI>Next message: <A HREF="002735.html">Review of netlink's
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2733">[ date ]</a>
              <a href="thread.html#2733">[ thread ]</a>
              <a href="subject.html#2733">[ subject ]</a>
              <a href="author.html#2733">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, Jun 18, 2009 at 01:25:03PM +0200, Wolfgang Grandegger wrote:
&gt;<i>      1	/*
</I>&gt;<i>      2	* drivers/net/can/softing/softing_main.c
</I>&gt;<i>      3	*
</I>&gt;<i>      4	* Copyright (C) 2008
</I>&gt;<i>      5	*
</I>&gt;<i>      6	* - Kurt Van Dijck, EIA Electronics
</I>&gt;<i>      7	*
</I>&gt;<i>      8	* This program is free software; you can redistribute it and/or modify
</I>&gt;<i>      9	* it under the terms of the version 2 of the GNU General Public License
</I>&gt;<i>     10	* as published by the Free Software Foundation
</I>&gt;<i>     11	*
</I>&gt;<i>     12	* This program is distributed in the hope that it will be useful,
</I>&gt;<i>     13	* but WITHOUT ANY WARRANTY; without even the implied warranty of
</I>&gt;<i>     14	* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
</I>&gt;<i>     15	* GNU General Public License for more details.
</I>&gt;<i>     16	*
</I>&gt;<i>     17	* You should have received a copy of the GNU General Public License
</I>&gt;<i>     18	* along with this program; if not, write to the Free Software
</I>&gt;<i>     19	* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
</I>&gt;<i>     20	*/
</I>&gt;<i> 
</I>&gt;<i> That's not the usual documentation style.
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * Bla bla
</I>&gt;<i>  */
</I>&gt;<i> 
</I>&gt;<i> /* Bla bla */ and not /*Bla bla*/
</I>&gt;<i> 
</I>&gt;<i> is preferred. Just nitpicking, sorry.
</I>code-style, no offense.
&gt;<i> 
</I>&gt;<i>     21	
</I>&gt;<i>     22	#include &lt;linux/version.h&gt;
</I>&gt;<i>     23	#include &lt;linux/module.h&gt;
</I>&gt;<i>     24	#include &lt;linux/init.h&gt;
</I>&gt;<i>     25	#include &lt;linux/device.h&gt;
</I>&gt;<i>     26	#include &lt;linux/firmware.h&gt;
</I>&gt;<i>     27	#include &lt;linux/interrupt.h&gt;
</I>&gt;<i>     28	#include &lt;linux/mutex.h&gt;
</I>&gt;<i>     29	#include &lt;linux/io.h&gt;
</I>&gt;<i>     30	
</I>&gt;<i>     31	#include &quot;softing.h&quot;
</I>&gt;<i>     32	
</I>&gt;<i>     33	#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
</I>&gt;<i>     34	#error This driver does not support Kernel versions &lt; 2.6.23
</I>&gt;<i>     35	#endif
</I>&gt;<i>     36	
</I>&gt;<i>     37	/*softing_unlocked_tx_run:*/
</I>line 37 must go
&gt;<i>     38	/*trigger the tx queue-ing*/
</I>&gt;<i> 
</I>&gt;<i> Hm?
</I>....
&gt;<i> 
</I>&gt;<i> That's not a leagal return value. Choose one of
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://lxr.linux.no/linux+v2.6.30/include/linux/netdevice.h#L90">http://lxr.linux.no/linux+v2.6.30/include/linux/netdevice.h#L90</A>
</I>that's new to me, thanx
&gt;<i> 
</I>&gt;<i> Also, you are responsible for handling/freeing the skb if your
</I>&gt;<i> return NETDEV_TX_OK.
</I>I recently got aware of that. can_put_echo_skb does the job.
&gt;<i> 
</I>&gt;<i>     51		if (in_interrupt()) {
</I>&gt;<i>     52			bhlock = 0;
</I>&gt;<i>     53			spin_lock(&amp;card-&gt;spin);
</I>&gt;<i>     54		} else {
</I>&gt;<i>     55			bhlock = 1;
</I>&gt;<i>     56			spin_lock_bh(&amp;card-&gt;spin);
</I>&gt;<i>     57		}
</I>&gt;<i>     58		if (!card-&gt;fw.up) {
</I>&gt;<i>     59			ret = -EIO;
</I>&gt;<i>     60			goto xmit_done;
</I>&gt;<i>     61		}
</I>&gt;<i>     62		if (netif_carrier_ok(priv-&gt;netdev) &lt;= 0) {
</I>&gt;<i> 
</I>&gt;<i> if (!netif_carrier_ok(priv-&gt;netdev)) ? Also, I think this
</I>&gt;<i> function will not be called if the carrier is off.
</I>doesn't hurt?
&gt;<i> 
</I>&gt;<i>     63			ret = -EBADF;
</I>&gt;<i>     64			goto xmit_done;
</I>&gt;<i>     65		}
</I>&gt;<i>     66		if (card-&gt;tx.pending &gt;= TXMAX) {
</I>&gt;<i>     67			ret = -EBUSY;
</I>&gt;<i>     68			goto xmit_done;
</I>&gt;<i>     69		}
</I>&gt;<i>     70		if (priv-&gt;tx.pending &gt;= CAN_ECHO_SKB_MAX) {
</I>&gt;<i>     71			ret = -EBUSY;
</I>&gt;<i>     72			goto xmit_done;
</I>&gt;<i>     73		}
</I>&gt;<i> 
</I>&gt;<i> Can that happen?
</I>I queue up to CAN_ECHO_SKB_MAX skb's into the card. after that, 
I have no room for the echo's, so must stop queueing. isn't it?
&gt;<i> 
</I>&gt;<i>     74		fifo_wr = card-&gt;dpram.tx-&gt;wr;
</I>&gt;<i>     75		if (fifo_wr == card-&gt;dpram.tx-&gt;rd) {
</I>&gt;<i>     76			/*fifo full */
</I>&gt;<i>     77			ret = -EAGAIN;
</I>&gt;<i>     78			goto xmit_done;
</I>&gt;<i>     79		}
</I>&gt;<i>     80		memcpy(&amp;msg, skb-&gt;data, sizeof(msg));
</I>&gt;<i>     81		ptr = &amp;card-&gt;dpram.tx-&gt;fifo[fifo_wr][0];
</I>&gt;<i>     82		cmd = CMD_TX;
</I>&gt;<i>     83		if (msg.can_id &amp; CAN_RTR_FLAG)
</I>&gt;<i>     84			cmd |= CMD_RTR;
</I>&gt;<i>     85		if (msg.can_id &amp; CAN_EFF_FLAG)
</I>&gt;<i>     86			cmd |= CMD_XTD;
</I>&gt;<i>     87		if (priv-&gt;index)
</I>&gt;<i>     88			cmd |= CMD_BUS2;
</I>&gt;<i>     89		*ptr++ = cmd;
</I>&gt;<i>     90		*ptr++ = msg.can_dlc;
</I>&gt;<i>     91		*ptr++ = (msg.can_id &gt;&gt; 0);
</I>&gt;<i>     92		*ptr++ = (msg.can_id &gt;&gt; 8);
</I>&gt;<i>     93		if (msg.can_id &amp; CAN_EFF_FLAG) {
</I>&gt;<i>     94			*ptr++ = (msg.can_id &gt;&gt; 16);
</I>&gt;<i>     95			*ptr++ = (msg.can_id &gt;&gt; 24);
</I>&gt;<i>     96		} else {
</I>&gt;<i>     97			/*increment 1, not 2 as you might think */
</I>&gt;<i>     98			ptr += 1;
</I>&gt;<i>     99		}
</I>&gt;<i>    100		if (!(msg.can_id &amp; CAN_RTR_FLAG))
</I>&gt;<i>    101			memcpy_toio(ptr, &amp;msg.data[0], msg.can_dlc);
</I>&gt;<i>    102		if (++fifo_wr &gt;=
</I>&gt;<i>    103			 sizeof(card-&gt;dpram.tx-&gt;fifo) /
</I>&gt;<i>    104			 sizeof(card-&gt;dpram.tx-&gt;fifo[0]))
</I>&gt;<i>    105			fifo_wr = 0;
</I>&gt;<i>    106		card-&gt;dpram.tx-&gt;wr = fifo_wr;
</I>&gt;<i>    107		ret = 0;
</I>&gt;<i>    108		++card-&gt;tx.pending;
</I>&gt;<i>    109		++priv-&gt;tx.pending;
</I>&gt;<i>    110		can_put_echo_skb(skb, dev, priv-&gt;tx.echo_put);
</I>&gt;<i>    111		++priv-&gt;tx.echo_put;
</I>&gt;<i>    112		if (priv-&gt;tx.echo_put &gt;= CAN_ECHO_SKB_MAX)
</I>&gt;<i>    113			priv-&gt;tx.echo_put = 0;
</I>&gt;<i>    114	xmit_done:
</I>&gt;<i>    115		if (bhlock)
</I>&gt;<i>    116			spin_unlock_bh(&amp;card-&gt;spin);
</I>&gt;<i>    117		else
</I>&gt;<i>    118			spin_unlock(&amp;card-&gt;spin);
</I>&gt;<i>    119		if (card-&gt;tx.pending &gt;= TXMAX) {
</I>&gt;<i>    120			struct softing_priv *bus;
</I>&gt;<i>    121			int j;
</I>&gt;<i>    122			for (j = 0; j &lt; card-&gt;nbus; ++j) {
</I>&gt;<i>    123				bus = card-&gt;bus[j];
</I>&gt;<i>    124				if (!bus)
</I>&gt;<i>    125					continue;
</I>&gt;<i>    126				netif_stop_queue(bus-&gt;netdev);
</I>&gt;<i>    127			}
</I>&gt;<i>    128		}
</I>&gt;<i>    129		if (ret &lt; 0)
</I>&gt;<i>    130			netif_stop_queue(dev);
</I>&gt;<i>    131	
</I>&gt;<i>    132		return ret;
</I>&gt;<i>    133	}
</I>&gt;<i>    134	
</I>&gt;<i>    135	static int softing_dev_svc_once(struct softing *card)
</I>&gt;<i>    136	{
</I>&gt;<i>    137		int j;
</I>&gt;<i>    138		struct softing_priv *bus;
</I>&gt;<i>    139		struct sk_buff *skb;
</I>&gt;<i>    140		struct can_frame msg;
</I>&gt;<i>    141	
</I>&gt;<i>    142		unsigned int fifo_rd;
</I>&gt;<i>    143		unsigned int cnt = 0;
</I>&gt;<i>    144		struct net_device_stats *stats;
</I>&gt;<i>    145	
</I>&gt;<i>    146		memset(&amp;msg, 0, sizeof(msg));
</I>&gt;<i>    147		if (card-&gt;dpram.rx-&gt;lost_msg) {
</I>&gt;<i>    148			/*reset condition */
</I>&gt;<i>    149			card-&gt;dpram.rx-&gt;lost_msg = 0;
</I>&gt;<i>    150			/* prepare msg */
</I>&gt;<i>    151			msg.can_id = CAN_ERR_FLAG | CAN_ERR_CRTL;
</I>&gt;<i>    152			msg.can_dlc = CAN_ERR_DLC;
</I>&gt;<i>    153			msg.data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
</I>&gt;<i>    154			/*service to both busses, we don't know which one generated */
</I>&gt;<i>    155			for (j = 0; j &lt; card-&gt;nbus; ++j) {
</I>&gt;<i>    156				bus = card-&gt;bus[j];
</I>&gt;<i>    157				if (!bus)
</I>&gt;<i>    158					continue;
</I>&gt;<i>    159				if (!netif_running(bus-&gt;netdev))
</I>&gt;<i>    160					continue;
</I>&gt;<i>    161				if (!netif_carrier_ok(bus-&gt;netdev))
</I>&gt;<i>    162					continue;
</I>&gt;<i> 
</I>&gt;<i> Smells racy.
</I>2 checks that just test flags? It's called from device interrupt, not
netdevice hook.
&gt;<i> 
</I>&gt;<i>    163	#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
</I>&gt;<i>    164				stats = can_get_stats(bus-&gt;netdev);
</I>&gt;<i>    165	#else
</I>&gt;<i>    166				stats = &amp;bus-&gt;netdev-&gt;stats;
</I>&gt;<i>    167	#endif
</I>&gt;<i>    168				++stats-&gt;rx_over_errors;
</I>&gt;<i> 
</I>&gt;<i> And &quot;stats-&gt;rx_errors++;&quot; as well.
</I>I got _no_ error frame, I was just too slow to catch up.
does rx_errors not mean: error frames?
&gt;<i> 
</I>&gt;<i>    169				skb = dev_alloc_skb(sizeof(msg));
</I>&gt;<i>    170				if (!skb)
</I>&gt;<i>    171					return -ENOMEM;
</I>&gt;<i>    172				skb-&gt;dev = bus-&gt;netdev;
</I>&gt;<i>    173				skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;<i>    174				skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
</I>&gt;<i>    175				memcpy(skb_put(skb, sizeof(msg)), &amp;msg, sizeof(msg));
</I>&gt;<i>    176				if (netif_rx(skb))
</I>&gt;<i>    177					dev_kfree_skb_irq(skb);
</I>&gt;<i>    178			}
</I>&gt;<i>    179			memset(&amp;msg, 0, sizeof(msg));
</I>&gt;<i>    180			++cnt;
</I>&gt;<i>    181		}
</I>&gt;<i>    182	
</I>&gt;<i>    183		fifo_rd = card-&gt;dpram.rx-&gt;rd;
</I>&gt;<i>    184		if (++fifo_rd &gt;=
</I>&gt;<i>    185			 sizeof(card-&gt;dpram.rx-&gt;fifo) / sizeof(card-&gt;dpram.rx-&gt;fifo[0]))
</I>&gt;<i>    186			fifo_rd = 0;
</I>&gt;<i>    187		if (card-&gt;dpram.rx-&gt;wr != fifo_rd) {
</I>&gt;<i>    188			u8 *ptr;
</I>&gt;<i>    189			u32 tmp;
</I>&gt;<i>    190			u8 cmd;
</I>&gt;<i>    191			int do_skb;
</I>&gt;<i>    192	
</I>&gt;<i>    193			ptr = &amp;card-&gt;dpram.rx-&gt;fifo[fifo_rd][0];
</I>&gt;<i>    194	
</I>&gt;<i>    195			cmd = *ptr++;
</I>&gt;<i>    196			if (cmd == 0xff) {
</I>&gt;<i>    197				/*not quite usefull, probably the card has got out */
</I>&gt;<i>    198				dev_alert(card-&gt;dev, &quot;got cmd 0x%02x,&quot;
</I>&gt;<i>    199					&quot;I suspect the card is lost\n&quot;, cmd);
</I>&gt;<i>    200			}
</I>&gt;<i>    201			/*dev_info(card-&gt;dev, &quot;0x%02x\n&quot;, cmd);*/
</I>&gt;<i>    202			bus = card-&gt;bus[0];
</I>&gt;<i>    203			if (cmd &amp; CMD_BUS2)
</I>&gt;<i>    204				bus = card-&gt;bus[1];
</I>&gt;<i>    205	
</I>&gt;<i>    206	#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
</I>&gt;<i>    207			stats = can_get_stats(bus-&gt;netdev);
</I>&gt;<i>    208	#else
</I>&gt;<i>    209			stats = &amp;bus-&gt;netdev-&gt;stats;
</I>&gt;<i>    210	#endif
</I>&gt;<i>    211			if (cmd &amp; CMD_ERR) {
</I>&gt;<i>    212				u8 can_state;
</I>&gt;<i>    213				u8 state;
</I>&gt;<i>    214				state = *ptr++;
</I>&gt;<i>    215	
</I>&gt;<i>    216				msg.can_id = CAN_ERR_FLAG;
</I>&gt;<i>    217				msg.can_dlc = CAN_ERR_DLC;
</I>&gt;<i>    218	
</I>&gt;<i>    219				if (state &amp; 0x80) {
</I>&gt;<i>    220					can_state = CAN_STATE_BUS_OFF;
</I>&gt;<i>    221					msg.can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i>    222					state = 2;
</I>&gt;<i>    223				} else if (state &amp; 0x60) {
</I>&gt;<i>    224					can_state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i>    225					msg.can_id |= CAN_ERR_BUSERROR;
</I>&gt;<i> 
</I>&gt;<i> This should be set to CAN_ERR_CRTL, I think. And you also
</I>&gt;<i> need to fill msg.data[1].
</I>I need to read docs :-)
&gt;<i> 
</I>&gt;<i>    226					state = 1;
</I>&gt;<i>    227				} else {
</I>&gt;<i>    228					can_state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i>    229					state = 0;
</I>&gt;<i>    230					do_skb = 0;
</I>&gt;<i>    231				}
</I>&gt;<i>    232				/*update DPRAM */
</I>&gt;<i>    233				if (!bus-&gt;index)
</I>&gt;<i>    234					card-&gt;dpram.info-&gt;bus_state = state;
</I>&gt;<i>    235				else
</I>&gt;<i>    236					card-&gt;dpram.info-&gt;bus_state2 = state;
</I>&gt;<i>    237				/*timestamp */
</I>&gt;<i>    238				tmp =	 (ptr[0] &lt;&lt;  0)
</I>&gt;<i>    239					|(ptr[1] &lt;&lt;  8)
</I>&gt;<i>    240					|(ptr[2] &lt;&lt; 16)
</I>&gt;<i>    241					|(ptr[3] &lt;&lt; 24);
</I>&gt;<i>    242				ptr += 4;
</I>&gt;<i>    243				/*msg.time = */ softing_time2usec(card, tmp);
</I>&gt;<i>    244				/*trigger dual port RAM */
</I>&gt;<i>    245				mb();
</I>&gt;<i>    246				card-&gt;dpram.rx-&gt;rd = fifo_rd;
</I>&gt;<i>    247	
</I>&gt;<i>    248				/*update internal status */
</I>&gt;<i>    249				if (can_state != bus-&gt;can.state) {
</I>&gt;<i>    250					bus-&gt;can.state = can_state;
</I>&gt;<i>    251					if (can_state == CAN_STATE_ERROR_PASSIVE)
</I>&gt;<i>    252						bus-&gt;can.can_stats.error_passive += 1;
</I>&gt;<i> 
</I>&gt;<i> bus-&gt;can.can_stats.error_passive++ !
</I>&gt;<i> 
</I>&gt;<i>    253					if (can_state == CAN_STATE_BUS_OFF) {
</I>&gt;<i>    254						/* this calls can_close_cleanup() */
</I>&gt;<i>    255						can_bus_off(bus-&gt;netdev);
</I>&gt;<i>    256						netif_carrier_off(bus-&gt;netdev);
</I>&gt;<i>    257						netif_stop_queue(bus-&gt;netdev);
</I>&gt;<i> 
</I>&gt;<i> can_bus_off already calls netif_carrier_off(). But I need to
</I>&gt;<i> check if it should not just call netif_stop_queue().
</I>Yep, I found that yesterday too.
I planned to drop all carrier control as soon as open_candev() &amp;
close_candev() started using it too.
&gt;<i> 
</I>&gt;<i>    258					}
</I>&gt;<i>    259				}
</I>&gt;<i>    260				bus-&gt;can.can_stats.bus_error += 1;
</I>&gt;<i> 
</I>&gt;<i> A state change is not a bus-error. I think your card does not report
</I>&gt;<i> individual errors like the SJA1000. And please use &quot;++&quot;. And for
</I>&gt;<i> real errors, we should also increment &quot;stats-&gt;rx_errors++&quot;.
</I>I can instruct the card to report them. But not sure how good it is.
the card is based upon an sja1000 internally.
&gt;<i> 
</I>&gt;<i>    261	
</I>&gt;<i>    262				/*trigger socketcan */
</I>&gt;<i>    263				if ((can_state == CAN_STATE_BUS_OFF)
</I>&gt;<i>    264					 || (can_state == CAN_STATE_ERROR_PASSIVE)) {
</I>&gt;<i>    265					skb = dev_alloc_skb(sizeof(msg));
</I>&gt;<i>    266					if (!skb)
</I>&gt;<i>    267						return -ENOMEM;
</I>&gt;<i>    268					skb-&gt;dev = bus-&gt;netdev;
</I>&gt;<i>    269					skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;<i>    270					skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
</I>&gt;<i>    271					memcpy(skb_put(skb, sizeof(msg)), &amp;msg,
</I>&gt;<i>    272							 sizeof(msg));
</I>&gt;<i>    273					if (netif_rx(skb))
</I>&gt;<i>    274						dev_kfree_skb_irq(skb);
</I>&gt;<i>    275				}
</I>&gt;<i>    276			} else {
</I>&gt;<i>    277				if (cmd &amp; CMD_RTR)
</I>&gt;<i>    278					msg.can_id |= CAN_RTR_FLAG;
</I>&gt;<i>    279				/* acknowledge, was tx msg
</I>&gt;<i>    280				 * no real tx flag to set
</I>&gt;<i>    281				if (cmd &amp; CMD_ACK) {
</I>&gt;<i>    282				}
</I>&gt;<i>    283				 */
</I>&gt;<i>    284				msg.can_dlc = *ptr++;
</I>&gt;<i>    285				if (msg.can_dlc &gt; 8)
</I>&gt;<i>    286					msg.can_dlc = 8;
</I>&gt;<i>    287				if (cmd &amp; CMD_XTD) {
</I>&gt;<i>    288					msg.can_id |= CAN_EFF_FLAG;
</I>&gt;<i>    289					msg.can_id |=
</I>&gt;<i>    290							(ptr[0] &lt;&lt; 0)
</I>&gt;<i>    291						 | (ptr[1] &lt;&lt; 8)
</I>&gt;<i>    292						 | (ptr[2] &lt;&lt; 16)
</I>&gt;<i>    293						 | (ptr[3] &lt;&lt; 24);
</I>&gt;<i>    294					ptr += 4;
</I>&gt;<i>    295				} else {
</I>&gt;<i>    296					msg.can_id |= (ptr[0] &lt;&lt; 0) | (ptr[1] &lt;&lt; 8);
</I>&gt;<i>    297					ptr += 2;
</I>&gt;<i>    298				}
</I>&gt;<i>    299				tmp = (ptr[0] &lt;&lt; 0)
</I>&gt;<i>    300					 | (ptr[1] &lt;&lt; 8)
</I>&gt;<i>    301					 | (ptr[2] &lt;&lt; 16)
</I>&gt;<i>    302					 | (ptr[3] &lt;&lt; 24);
</I>&gt;<i>    303				ptr += 4;
</I>&gt;<i>    304				/*msg.time = */ softing_time2usec(card, tmp);
</I>&gt;<i>    305				memcpy_fromio(&amp;msg.data[0], ptr, 8);
</I>&gt;<i>    306				ptr += 8;
</I>&gt;<i>    307				/*trigger dual port RAM */
</I>&gt;<i>    308				mb();
</I>&gt;<i>    309				card-&gt;dpram.rx-&gt;rd = fifo_rd;
</I>&gt;<i>    310				/*update socket */
</I>&gt;<i>    311				if (cmd &amp; CMD_ACK) {
</I>&gt;<i>    312					can_get_echo_skb(bus-&gt;netdev, bus-&gt;tx.echo_get);
</I>&gt;<i>    313					++bus-&gt;tx.echo_get;
</I>&gt;<i>    314					if (bus-&gt;tx.echo_get &gt;= CAN_ECHO_SKB_MAX)
</I>&gt;<i>    315						bus-&gt;tx.echo_get = 0;
</I>&gt;<i>    316					if (bus-&gt;tx.pending)
</I>&gt;<i>    317						--bus-&gt;tx.pending;
</I>&gt;<i>    318					if (card-&gt;tx.pending)
</I>&gt;<i>    319						--card-&gt;tx.pending;
</I>&gt;<i>    320					stats-&gt;tx_packets += 1;
</I>&gt;<i>    321					stats-&gt;tx_bytes += msg.can_dlc;
</I>&gt;<i>    322				} else {
</I>&gt;<i>    323					stats-&gt;rx_packets += 1;
</I>&gt;<i>    324					stats-&gt;rx_bytes += msg.can_dlc;
</I>&gt;<i>    325					bus-&gt;netdev-&gt;last_rx = jiffies;
</I>&gt;<i>    326					skb = dev_alloc_skb(sizeof(msg));
</I>&gt;<i>    327					if (skb) {
</I>&gt;<i>    328						skb-&gt;dev = bus-&gt;netdev;
</I>&gt;<i>    329						skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;<i>    330						skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
</I>&gt;<i>    331						memcpy(skb_put(skb, sizeof(msg)), &amp;msg,
</I>&gt;<i>    332								 sizeof(msg));
</I>&gt;<i>    333						if (netif_rx(skb))
</I>&gt;<i>    334							dev_kfree_skb_irq(skb);
</I>&gt;<i>    335					}
</I>&gt;<i> 
</I>&gt;<i> The above pattern is repeated a few time and you may consider
</I>&gt;<i> using a function to avoid code duplication.
</I>Yep
&gt;<i> 
</I>&gt;<i>    336				}
</I>&gt;<i>    337			}
</I>&gt;<i>    338			++cnt;
</I>&gt;<i>    339		}
</I>&gt;<i>    340		return cnt;
</I>&gt;<i>    341	}
</I>&gt;<i>    342	
</I>&gt;<i>    343	static void softing_dev_svc(unsigned long param)
</I>&gt;<i>    344	{
</I>&gt;<i>    345		struct softing *card = (struct softing *)param;
</I>&gt;<i>    346		struct softing_priv *bus;
</I>&gt;<i>    347		int j;
</I>&gt;<i>    348		int offset;
</I>&gt;<i>    349	
</I>&gt;<i>    350		spin_lock(&amp;card-&gt;spin);
</I>&gt;<i>    351		while (softing_dev_svc_once(card) &gt; 0)
</I>&gt;<i>    352			++card-&gt;irq.svc_count;
</I>&gt;<i>    353		/*resume tx queue's */
</I>&gt;<i>    354		offset = card-&gt;tx.last_bus;
</I>&gt;<i>    355		for (j = 0; j &lt; card-&gt;nbus; ++j) {
</I>&gt;<i>    356			if (card-&gt;tx.pending &gt;= TXMAX)
</I>&gt;<i>    357				break;
</I>&gt;<i>    358			bus = card-&gt;bus[(j + offset) % card-&gt;nbus];
</I>&gt;<i>    359			if (!netif_running(bus-&gt;netdev))
</I>&gt;<i>    360				continue;
</I>&gt;<i>    361			if (!netif_carrier_ok(bus-&gt;netdev))
</I>&gt;<i>    362				continue;
</I>&gt;<i>    363			netif_wake_queue(bus-&gt;netdev);
</I>&gt;<i>    364		}
</I>&gt;<i>    365		spin_unlock(&amp;card-&gt;spin);
</I>&gt;<i>    366	}
</I>&gt;<i>    367	
</I>&gt;<i>    368	static
</I>&gt;<i>    369	irqreturn_t dev_interrupt_shared(int irq, void *dev_id)
</I>&gt;<i>    370	{
</I>&gt;<i>    371		struct softing *card = (struct softing *)dev_id;
</I>&gt;<i>    372		unsigned char ir;
</I>&gt;<i>    373		ir = card-&gt;dpram.virt[0xe02];
</I>&gt;<i>    374		card-&gt;dpram.virt[0xe02] = 0;
</I>&gt;<i>    375		if (card-&gt;dpram.rx-&gt;rd == 0xffff) {
</I>&gt;<i>    376			dev_alert(card-&gt;dev, &quot;I think the card is gone\n&quot;);
</I>&gt;<i>    377			return IRQ_NONE;
</I>&gt;<i>    378		}
</I>&gt;<i>    379		if (ir == 1) {
</I>&gt;<i>    380			tasklet_schedule(&amp;card-&gt;irq.bh);
</I>&gt;<i>    381			return IRQ_HANDLED;
</I>&gt;<i>    382		} else if (ir == 0x10) {
</I>&gt;<i>    383			return IRQ_NONE;
</I>&gt;<i>    384		} else {
</I>&gt;<i>    385			return IRQ_NONE;
</I>&gt;<i>    386		}
</I>&gt;<i>    387	}
</I>&gt;<i>    388	
</I>&gt;<i>    389	static
</I>&gt;<i>    390	irqreturn_t dev_interrupt_nshared(int irq, void *dev_id)
</I>&gt;<i>    391	{
</I>&gt;<i>    392		struct softing *card = (struct softing *)dev_id;
</I>&gt;<i>    393		unsigned char irq_host;
</I>&gt;<i>    394		irq_host = card-&gt;dpram.irq-&gt;to_host;
</I>&gt;<i>    395		/* make sure we have a copy, before clearing the variable in DPRAM */
</I>&gt;<i>    396		rmb();
</I>&gt;<i>    397		card-&gt;dpram.irq-&gt;to_host = 0;
</I>&gt;<i>    398		/* make sure we cleared it */
</I>&gt;<i>    399		wmb();
</I>&gt;<i>    400		if (card-&gt;dpram.rx-&gt;rd == 0xffff) {
</I>&gt;<i>    401			dev_alert(card-&gt;dev, &quot;I think the card is gone\n&quot;);
</I>&gt;<i>    402			return IRQ_NONE;
</I>&gt;<i>    403		}
</I>&gt;<i>    404		tasklet_schedule(&amp;card-&gt;irq.bh);
</I>&gt;<i>    405		return IRQ_HANDLED;
</I>&gt;<i>    406	}
</I>&gt;<i>    407	
</I>&gt;<i>    408	static int netdev_open(struct net_device *ndev)
</I>&gt;<i>    409	{
</I>&gt;<i>    410		struct softing_priv *priv = netdev_priv(ndev);
</I>&gt;<i>    411		struct softing *card = priv-&gt;card;
</I>&gt;<i>    412		int ret;
</I>&gt;<i>    413	
</I>&gt;<i>    414		/* check or determine and set bittime */
</I>&gt;<i>    415		ret = mutex_lock_interruptible(&amp;card-&gt;fw.lock);
</I>&gt;<i>    416		if (ret)
</I>&gt;<i>    417			goto fail_lock;
</I>&gt;<i>    418		ret = open_candev(ndev);
</I>&gt;<i>    419		if (ret)
</I>&gt;<i>    420			goto fail_candev;
</I>&gt;<i>    421		if (!card-&gt;fw.up) {
</I>&gt;<i>    422			ret = -EIO;
</I>&gt;<i>    423			goto fail_state;
</I>&gt;<i>    424		}
</I>&gt;<i>    425		ret = softing_cycle(card, priv, 1);
</I>&gt;<i>    426		if (ret)
</I>&gt;<i>    427			goto fail_firmware;
</I>&gt;<i>    428		mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i>    429		return 0;
</I>&gt;<i>    430	
</I>&gt;<i>    431	fail_firmware:
</I>&gt;<i>    432	fail_state:
</I>&gt;<i>    433		close_candev(ndev);
</I>&gt;<i>    434	fail_candev:
</I>&gt;<i>    435		mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i>    436	fail_lock:
</I>&gt;<i>    437		return ret;
</I>&gt;<i>    438	}
</I>&gt;<i>    439	
</I>&gt;<i>    440	static int netdev_stop(struct net_device *ndev)
</I>&gt;<i>    441	{
</I>&gt;<i>    442		struct softing_priv *priv = netdev_priv(ndev);
</I>&gt;<i>    443		struct softing *card = priv-&gt;card;
</I>&gt;<i>    444		int ret;
</I>&gt;<i>    445	
</I>&gt;<i>    446		ret = mutex_lock_interruptible(&amp;card-&gt;fw.lock);
</I>&gt;<i>    447		if (ret)
</I>&gt;<i>    448			goto fail_lock;
</I>&gt;<i>    449		close_candev(ndev);
</I>&gt;<i>    450		if (!card-&gt;fw.up) {
</I>&gt;<i>    451			ret = -EIO;
</I>&gt;<i>    452			goto fail_state;
</I>&gt;<i>    453		}
</I>&gt;<i>    454		ret = softing_cycle(card, priv, 0);
</I>&gt;<i>    455		if (ret)
</I>&gt;<i>    456			goto fail_firmware;
</I>&gt;<i>    457		mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i>    458		return 0;
</I>&gt;<i>    459	fail_firmware:
</I>&gt;<i>    460	fail_state:
</I>&gt;<i> 
</I>&gt;<i> Hm.
</I>&gt;<i> 
</I>&gt;<i>    461		mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i>    462	fail_lock:
</I>&gt;<i>    463		return ret;
</I>&gt;<i>    464	}
</I>&gt;<i>    465	
</I>&gt;<i>    466	static int candev_set_mode(struct net_device *ndev, enum can_mode mode)
</I>&gt;<i>    467	{
</I>&gt;<i>    468		struct softing_priv *priv = netdev_priv(ndev);
</I>&gt;<i>    469		struct softing *card = priv-&gt;card;
</I>&gt;<i>    470		int ret;
</I>&gt;<i>    471		switch (mode) {
</I>&gt;<i>    472		case CAN_MODE_START:
</I>&gt;<i>    473			/*recovery from busoff? */
</I>&gt;<i>    474			if (mutex_lock_interruptible(&amp;card-&gt;fw.lock))
</I>&gt;<i>    475				return -ERESTARTSYS;
</I>&gt;<i>    476			ret = softing_cycle(card, priv, 1);
</I>&gt;<i>    477			if (ret)
</I>&gt;<i>    478				close_candev(priv-&gt;netdev);
</I>&gt;<i>    479			mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i>    480			return ret;
</I>&gt;<i>    481		case CAN_MODE_STOP:
</I>&gt;<i>    482		case CAN_MODE_SLEEP:
</I>&gt;<i>    483			return -EOPNOTSUPP;
</I>&gt;<i>    484		}
</I>&gt;<i>    485		return 0;
</I>&gt;<i>    486	}
</I>&gt;<i>    487	
</I>&gt;<i>    488	/*assume the card-&gt;lock is held*/
</I>&gt;<i>    489	
</I>&gt;<i>    490	int softing_card_irq(struct softing *card, int enable)
</I>&gt;<i>    491	{
</I>&gt;<i>    492		int ret;
</I>&gt;<i>    493		if (!enable) {
</I>&gt;<i>    494			if (card-&gt;irq.requested &amp;&amp; card-&gt;irq.nr) {
</I>&gt;<i>    495				free_irq(card-&gt;irq.nr, card);
</I>&gt;<i>    496				card-&gt;irq.requested = 0;
</I>&gt;<i>    497			}
</I>&gt;<i>    498			return 0;
</I>&gt;<i>    499		}
</I>&gt;<i>    500		if (!card-&gt;irq.requested &amp;&amp; (card-&gt;irq.nr)) {
</I>&gt;<i>    501			irqreturn_t(*fn) (int, void *);
</I>&gt;<i>    502			unsigned int flags;
</I>&gt;<i>    503			flags = IRQF_DISABLED | IRQF_SHARED;/*| IRQF_TRIGGER_LOW; */
</I>&gt;<i>    504			fn = dev_interrupt_nshared;
</I>&gt;<i>    505			if (card-&gt;desc-&gt;generation &gt;= 2)
</I>&gt;<i>    506				fn = dev_interrupt_shared;
</I>&gt;<i>    507			ret = request_irq(card-&gt;irq.nr, fn, flags, card-&gt;id.name, card);
</I>&gt;<i>    508			if (ret) {
</I>&gt;<i>    509				dev_alert(card-&gt;dev, &quot;%s, request_irq(%u) failed\n&quot;,
</I>&gt;<i>    510					card-&gt;id.name, card-&gt;irq.nr);
</I>&gt;<i>    511				return ret;
</I>&gt;<i>    512			}
</I>&gt;<i>    513			card-&gt;irq.requested = 1;
</I>&gt;<i>    514		}
</I>&gt;<i>    515		return 0;
</I>&gt;<i>    516	}
</I>&gt;<i>    517	
</I>&gt;<i>    518	static void shutdown_card(struct softing *card)
</I>&gt;<i>    519	{
</I>&gt;<i>    520		int fw_up = 0;
</I>&gt;<i>    521		dev_dbg(card-&gt;dev, &quot;%s()\n&quot;, __func__);
</I>&gt;<i>    522		if (mutex_lock_interruptible(&amp;card-&gt;fw.lock))
</I>&gt;<i>    523			/* return -ERESTARTSYS*/;
</I>&gt;<i>    524		fw_up = card-&gt;fw.up;
</I>&gt;<i>    525		card-&gt;fw.up = 0;
</I>&gt;<i>    526	
</I>&gt;<i>    527		if (card-&gt;irq.requested &amp;&amp; card-&gt;irq.nr) {
</I>&gt;<i>    528			free_irq(card-&gt;irq.nr, card);
</I>&gt;<i>    529			card-&gt;irq.requested = 0;
</I>&gt;<i>    530		}
</I>&gt;<i>    531		if (fw_up) {
</I>&gt;<i>    532			if (card-&gt;fn.enable_irq)
</I>&gt;<i>    533				card-&gt;fn.enable_irq(card, 0);
</I>&gt;<i>    534			if (card-&gt;fn.reset)
</I>&gt;<i>    535				card-&gt;fn.reset(card, 1);
</I>&gt;<i>    536		}
</I>&gt;<i>    537		mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i>    538		tasklet_kill(&amp;card-&gt;irq.bh);
</I>&gt;<i>    539	}
</I>&gt;<i>    540	
</I>&gt;<i>    541	static int boot_card(struct softing *card)
</I>&gt;<i>    542	{
</I>&gt;<i>    543		unsigned char *lp;
</I>&gt;<i>    544		static const unsigned char stream[] =
</I>&gt;<i>    545			{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, };
</I>&gt;<i>    546		unsigned char back[sizeof(stream)];
</I>&gt;<i>    547		dev_dbg(card-&gt;dev, &quot;%s()\n&quot;, __func__);
</I>&gt;<i>    548	
</I>&gt;<i>    549		if (mutex_lock_interruptible(&amp;card-&gt;fw.lock))
</I>&gt;<i>    550			return -ERESTARTSYS;
</I>&gt;<i>    551		if (card-&gt;fw.up) {
</I>&gt;<i>    552			mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i>    553			return 0;
</I>&gt;<i>    554		}
</I>&gt;<i>    555		/*reset board */
</I>&gt;<i>    556	
</I>&gt;<i>    557		if (card-&gt;fn.enable_irq)
</I>&gt;<i>    558			card-&gt;fn.enable_irq(card, 1);
</I>&gt;<i>    559		/*boot card */
</I>&gt;<i>    560		if (card-&gt;fn.reset)
</I>&gt;<i>    561			card-&gt;fn.reset(card, 1);
</I>&gt;<i>    562		/*test dp ram */
</I>&gt;<i>    563		if (!card-&gt;dpram.virt)
</I>&gt;<i>    564			goto open_failed;
</I>&gt;<i>    565		for (lp = card-&gt;dpram.virt; &amp;lp[sizeof(stream)] &lt;= card-&gt;dpram.end;
</I>&gt;<i>    566			lp += sizeof(stream)) {
</I>&gt;<i>    567	
</I>&gt;<i>    568			memcpy_toio(lp, stream, sizeof(stream));
</I>&gt;<i>    569			/* flush IO cache */
</I>&gt;<i>    570			mb();
</I>&gt;<i>    571			memcpy_fromio(back, lp, sizeof(stream));
</I>&gt;<i>    572	
</I>&gt;<i>    573			if (!memcmp(back, stream, sizeof(stream)))
</I>&gt;<i>    574				continue;
</I>&gt;<i>    575			/* memory is not equal */
</I>&gt;<i>    576			dev_alert(card-&gt;dev, &quot;write to dpram failed at 0x%04lx\n&quot;,
</I>&gt;<i>    577				lp - card-&gt;dpram.virt);
</I>&gt;<i>    578			goto open_failed;
</I>&gt;<i>    579		}
</I>&gt;<i>    580		wmb();
</I>&gt;<i>    581		/*load boot firmware */
</I>&gt;<i>    582		if (softing_load_fw(card-&gt;desc-&gt;boot.fw, card, card-&gt;dpram.virt,
</I>&gt;<i>    583					 card-&gt;dpram.size,
</I>&gt;<i>    584					 card-&gt;desc-&gt;boot.offs -
</I>&gt;<i>    585					 card-&gt;desc-&gt;boot.addr))
</I>&gt;<i>    586			goto open_failed;
</I>&gt;<i>    587		/*load load firmware */
</I>&gt;<i>    588		if (softing_load_fw(card-&gt;desc-&gt;load.fw, card, card-&gt;dpram.virt,
</I>&gt;<i>    589					 card-&gt;dpram.size,
</I>&gt;<i>    590					 card-&gt;desc-&gt;load.offs -
</I>&gt;<i>    591					 card-&gt;desc-&gt;load.addr))
</I>&gt;<i>    592			goto open_failed;
</I>&gt;<i>    593	
</I>&gt;<i>    594		if (card-&gt;fn.reset)
</I>&gt;<i>    595			card-&gt;fn.reset(card, 0);
</I>&gt;<i>    596		if (softing_bootloader_command(card, 0, &quot;card boot&quot;))
</I>&gt;<i>    597			goto open_failed;
</I>&gt;<i>    598		if (softing_load_app_fw(card-&gt;desc-&gt;app.fw, card))
</I>&gt;<i>    599			goto open_failed;
</I>&gt;<i>    600		/*reset chip */
</I>&gt;<i>    601		card-&gt;dpram.info-&gt;reset_rcv_fifo = 0;
</I>&gt;<i>    602		card-&gt;dpram.info-&gt;reset = 1;
</I>&gt;<i>    603		/*sync */
</I>&gt;<i>    604		if (softing_fct_cmd(card, 99, 0x55, &quot;sync-a&quot;))
</I>&gt;<i>    605			goto open_failed;
</I>&gt;<i>    606		if (softing_fct_cmd(card, 99, 0xaa, &quot;sync-a&quot;))
</I>&gt;<i>    607			goto open_failed;
</I>&gt;<i>    608		/*reset chip */
</I>&gt;<i>    609		if (softing_fct_cmd(card, 0, 0, &quot;reset_chip&quot;))
</I>&gt;<i>    610			goto open_failed;
</I>&gt;<i>    611		/*get_serial */
</I>&gt;<i>    612		if (softing_fct_cmd(card, 43, 0, &quot;get_serial_number&quot;))
</I>&gt;<i>    613			goto open_failed;
</I>&gt;<i>    614		card-&gt;id.serial =
</I>&gt;<i>    615			 (u16) card-&gt;dpram.fct-&gt;param[1] +
</I>&gt;<i>    616			 (((u16) card-&gt;dpram.fct-&gt;param[2]) &lt;&lt; 16);
</I>&gt;<i>    617		/*get_version */
</I>&gt;<i>    618		if (softing_fct_cmd(card, 12, 0, &quot;get_version&quot;))
</I>&gt;<i>    619			goto open_failed;
</I>&gt;<i>    620		card-&gt;id.fw = (u16) card-&gt;dpram.fct-&gt;param[1];
</I>&gt;<i>    621		card-&gt;id.hw = (u16) card-&gt;dpram.fct-&gt;param[2];
</I>&gt;<i>    622		card-&gt;id.lic = (u16) card-&gt;dpram.fct-&gt;param[3];
</I>&gt;<i>    623		card-&gt;id.chip[0] = (u16) card-&gt;dpram.fct-&gt;param[4];
</I>&gt;<i>    624		card-&gt;id.chip[1] = (u16) card-&gt;dpram.fct-&gt;param[5];
</I>&gt;<i>    625	
</I>&gt;<i>    626		dev_info(card-&gt;dev, &quot;card booted, type %s, &quot;
</I>&gt;<i>    627				&quot;serial %u, fw %u, hw %u, lic %u, chip (%u,%u)\n&quot;,
</I>&gt;<i>    628			  card-&gt;id.name, card-&gt;id.serial, card-&gt;id.fw, card-&gt;id.hw,
</I>&gt;<i>    629			  card-&gt;id.lic, card-&gt;id.chip[0], card-&gt;id.chip[1]);
</I>&gt;<i>    630	
</I>&gt;<i>    631		card-&gt;fw.up = 1;
</I>&gt;<i>    632		mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i>    633		return 0;
</I>&gt;<i>    634	open_failed:
</I>&gt;<i>    635		card-&gt;fw.up = 0;
</I>&gt;<i>    636		if (card-&gt;fn.enable_irq)
</I>&gt;<i>    637			card-&gt;fn.enable_irq(card, 0);
</I>&gt;<i>    638		if (card-&gt;fn.reset)
</I>&gt;<i>    639			card-&gt;fn.reset(card, 1);
</I>&gt;<i>    640		mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i>    641		return EINVAL;
</I>&gt;<i>    642	}
</I>&gt;<i>    643	
</I>&gt;<i>    644	/*sysfs stuff*/
</I>&gt;<i> 
</I>&gt;<i> Would it make sense to put sysfs related code in an extra file?
</I>If you find it not appropriate here, I don't mind putting in a seperate
file.
&gt;<i> 
</I>&gt;<i>    645	
</I>&gt;<i>    646	/* Because the struct softing may be used by pcmcia devices
</I>&gt;<i>    647	 * as well as pci devices, * we have no clue how to get
</I>&gt;<i>    648	 * from a struct device * towards the struct softing *.
</I>&gt;<i>    649	 * It may go over a pci_device-&gt;priv or over a pcmcia_device-&gt;priv.
</I>&gt;<i>    650	 * Therefore, provide the struct softing pointer within the attribute.
</I>&gt;<i>    651	 * Then we don't need driver/bus specific things in these attributes
</I>&gt;<i>    652	 */
</I>&gt;<i>    653	struct softing_attribute {
</I>&gt;<i>    654		struct device_attribute dev;
</I>&gt;<i>    655		ssize_t (*show) (struct softing *card, char *buf);
</I>&gt;<i>    656		ssize_t (*store)(struct softing *card, const char *buf, size_t count);
</I>&gt;<i>    657		struct softing *card;
</I>&gt;<i>    658	};
</I>&gt;<i>    659	
</I>&gt;<i>    660	static ssize_t rd_card_attr(struct device *dev, struct device_attribute *attr
</I>&gt;<i>    661			, char *buf) {
</I>&gt;<i>    662		struct softing_attribute *cattr
</I>&gt;<i>    663			= container_of(attr, struct softing_attribute, dev);
</I>&gt;<i>    664		return cattr-&gt;show ? cattr-&gt;show(cattr-&gt;card, buf) : 0;
</I>&gt;<i>    665	}
</I>&gt;<i>    666	static ssize_t wr_card_attr(struct device *dev, struct device_attribute *attr
</I>&gt;<i>    667			, const char *buf, size_t count) {
</I>&gt;<i>    668		struct softing_attribute *cattr
</I>&gt;<i>    669			= container_of(attr, struct softing_attribute, dev);
</I>&gt;<i>    670		return cattr-&gt;store ? cattr-&gt;store(cattr-&gt;card, buf, count) : 0;
</I>&gt;<i>    671	}
</I>&gt;<i>    672	
</I>&gt;<i>    673	#define declare_attr(_name, _mode, _show, _store) { \
</I>&gt;<i>    674		.dev = { \
</I>&gt;<i>    675			.attr = { \
</I>&gt;<i>    676				.name = __stringify(_name), \
</I>&gt;<i>    677				.mode = _mode, \
</I>&gt;<i>    678			}, \
</I>&gt;<i>    679			.show = rd_card_attr, \
</I>&gt;<i>    680			.store = wr_card_attr, \
</I>&gt;<i>    681		}, \
</I>&gt;<i>    682		.show =	_show, \
</I>&gt;<i>    683		.store = _store, \
</I>&gt;<i>    684	}
</I>&gt;<i>    685	
</I>&gt;<i>    686	#define CARD_SHOW(name, member) \
</I>&gt;<i>    687	static ssize_t show_##name(struct softing *card, char *buf) { \
</I>&gt;<i>    688		return sprintf(buf, &quot;%u\n&quot;, card-&gt;member); \
</I>&gt;<i>    689	}
</I>&gt;<i>    690	CARD_SHOW(serial	, id.serial);
</I>&gt;<i>    691	CARD_SHOW(firmware	, id.fw);
</I>&gt;<i>    692	CARD_SHOW(hardware	, id.hw);
</I>&gt;<i>    693	CARD_SHOW(license	, id.lic);
</I>&gt;<i>    694	CARD_SHOW(freq		, id.freq);
</I>&gt;<i>    695	CARD_SHOW(txpending	, tx.pending);
</I>&gt;<i>    696	
</I>&gt;<i>    697	static const struct softing_attribute card_attr_proto[] = {
</I>&gt;<i>    698		declare_attr(serial	, 0444, show_serial	, 0),
</I>&gt;<i>    699		declare_attr(firmware	, 0444, show_firmware	, 0),
</I>&gt;<i>    700		declare_attr(hardware	, 0444, show_hardware	, 0),
</I>&gt;<i>    701		declare_attr(license	, 0444, show_license	, 0),
</I>&gt;<i>    702		declare_attr(freq	, 0444, show_freq	, 0),
</I>&gt;<i>    703		declare_attr(txpending	, 0644, show_txpending	, 0),
</I>&gt;<i>    704	};
</I>&gt;<i>    705	
</I>&gt;<i>    706	static int mk_card_sysfs(struct softing *card)
</I>&gt;<i>    707	{
</I>&gt;<i>    708		int size;
</I>&gt;<i>    709		int j;
</I>&gt;<i>    710	
</I>&gt;<i>    711		size = sizeof(card_attr_proto)/sizeof(card_attr_proto[0]);
</I>&gt;<i>    712		card-&gt;attr = kmalloc((size+1)*sizeof(card-&gt;attr[0]), GFP_KERNEL);
</I>&gt;<i>    713		if (!card-&gt;attr)
</I>&gt;<i>    714			goto attr_mem_failed;
</I>&gt;<i>    715		memcpy(card-&gt;attr, card_attr_proto, size * sizeof(card-&gt;attr[0]));
</I>&gt;<i>    716		memset(&amp;card-&gt;attr[size], 0, sizeof(card-&gt;attr[0]));
</I>&gt;<i>    717	
</I>&gt;<i>    718		card-&gt;grp  = kmalloc((size+1)*sizeof(card-&gt;grp[0]), GFP_KERNEL);
</I>&gt;<i>    719		if (!card-&gt;grp)
</I>&gt;<i>    720			goto grp_mem_failed;
</I>&gt;<i>    721	
</I>&gt;<i>    722		for (j = 0; j &lt; size; ++j) {
</I>&gt;<i>    723			card-&gt;attr[j].card = card;
</I>&gt;<i>    724			card-&gt;grp[j] = &amp;card-&gt;attr[j].dev.attr;
</I>&gt;<i>    725			if (!card-&gt;attr[j].show)
</I>&gt;<i>    726				card-&gt;attr[j].dev.attr.mode &amp;= ~(S_IRUGO);
</I>&gt;<i>    727			if (!card-&gt;attr[j].store)
</I>&gt;<i>    728				card-&gt;attr[j].dev.attr.mode &amp;= ~(S_IWUGO);
</I>&gt;<i>    729		}
</I>&gt;<i>    730		card-&gt;grp[size] = 0;
</I>&gt;<i>    731		card-&gt;sysfs.name	= &quot;softing&quot;;
</I>&gt;<i>    732		card-&gt;sysfs.attrs = card-&gt;grp;
</I>&gt;<i>    733		if (sysfs_create_group(&amp;card-&gt;dev-&gt;kobj, &amp;card-&gt;sysfs) &lt; 0)
</I>&gt;<i>    734			goto sysfs_failed;
</I>&gt;<i>    735	
</I>&gt;<i>    736		return 0;
</I>&gt;<i>    737	
</I>&gt;<i>    738	sysfs_failed:
</I>&gt;<i>    739		kfree(card-&gt;grp);
</I>&gt;<i>    740	grp_mem_failed:
</I>&gt;<i>    741		kfree(card-&gt;attr);
</I>&gt;<i>    742	attr_mem_failed:
</I>&gt;<i>    743		return -1;
</I>&gt;<i>    744	}
</I>&gt;<i>    745	static void rm_card_sysfs(struct softing *card)
</I>&gt;<i>    746	{
</I>&gt;<i>    747		sysfs_remove_group(&amp;card-&gt;dev-&gt;kobj, &amp;card-&gt;sysfs);
</I>&gt;<i>    748		kfree(card-&gt;grp);
</I>&gt;<i>    749		kfree(card-&gt;attr);
</I>&gt;<i>    750	}
</I>&gt;<i>    751	
</I>&gt;<i>    752	static ssize_t show_chip(struct device *dev
</I>&gt;<i>    753			, struct device_attribute *attr, char *buf)
</I>&gt;<i>    754	{
</I>&gt;<i>    755		struct net_device *ndev = to_net_dev(dev);
</I>&gt;<i>    756		struct softing_priv *priv = netdev2softing(ndev);
</I>&gt;<i>    757		return sprintf(buf, &quot;%i\n&quot;, priv-&gt;chip);
</I>&gt;<i>    758	}
</I>&gt;<i>    759	
</I>&gt;<i>    760	static ssize_t show_output(struct device *dev
</I>&gt;<i>    761			, struct device_attribute *attr, char *buf)
</I>&gt;<i>    762	{
</I>&gt;<i>    763		struct net_device *ndev = to_net_dev(dev);
</I>&gt;<i>    764		struct softing_priv *priv = netdev2softing(ndev);
</I>&gt;<i>    765		return sprintf(buf, &quot;0x%02x\n&quot;, priv-&gt;output);
</I>&gt;<i>    766	}
</I>&gt;<i>    767	
</I>&gt;<i>    768	static ssize_t store_output(struct device *dev
</I>&gt;<i>    769			, struct device_attribute *attr
</I>&gt;<i>    770			, const char *buf, size_t count)
</I>&gt;<i>    771	{
</I>&gt;<i>    772		struct net_device *ndev = to_net_dev(dev);
</I>&gt;<i>    773		struct softing_priv *priv = netdev2softing(ndev);
</I>&gt;<i>    774		struct softing *card = priv-&gt;card;
</I>&gt;<i>    775		unsigned long val;
</I>&gt;<i>    776		int ret;
</I>&gt;<i>    777	
</I>&gt;<i>    778		ret = strict_strtoul(buf, 0, &amp;val);
</I>&gt;<i>    779		if (ret &lt; 0)
</I>&gt;<i>    780			return ret;
</I>&gt;<i>    781		val &amp;= 0xFF;
</I>&gt;<i>    782	
</I>&gt;<i>    783		if (mutex_lock_interruptible(&amp;card-&gt;fw.lock))
</I>&gt;<i>    784			return -ERESTARTSYS;
</I>&gt;<i>    785		if (netif_running(ndev)) {
</I>&gt;<i>    786			int j;
</I>&gt;<i>    787			/* we will need a restart */
</I>&gt;<i>    788			for (j = 0; j &lt; card-&gt;nbus; ++j) {
</I>&gt;<i>    789				if (j == priv-&gt;index)
</I>&gt;<i>    790					/* me, myself &amp; I */
</I>&gt;<i>    791					continue;
</I>&gt;<i>    792				if (card-&gt;bus[j]-&gt;netdev-&gt;flags &amp; IFF_UP) {
</I>&gt;<i>    793					mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i>    794					return -EBUSY;
</I>&gt;<i>    795				}
</I>&gt;<i>    796			}
</I>&gt;<i>    797			priv-&gt;output = val;
</I>&gt;<i>    798			softing_cycle(card, priv, 1);
</I>&gt;<i>    799		} else {
</I>&gt;<i>    800			priv-&gt;output = val;
</I>&gt;<i>    801		}
</I>&gt;<i>    802		mutex_unlock(&amp;card-&gt;fw.lock);
</I>&gt;<i>    803		return count;
</I>&gt;<i>    804	}
</I>&gt;<i>    805	/* TODO
</I>&gt;<i>    806	 * the latest softing cards support sleep mode too
</I>&gt;<i>    807	 */
</I>&gt;<i>    808	
</I>&gt;<i>    809	static const DEVICE_ATTR(chip, S_IRUGO, show_chip, 0);
</I>&gt;<i>    810	static const DEVICE_ATTR(output, S_IRUGO | S_IWUSR, show_output, store_output);
</I>&gt;<i>    811	
</I>&gt;<i>    812	static const struct attribute *const netdev_sysfs_entries[] = {
</I>&gt;<i>    813		&amp;dev_attr_chip		.attr,
</I>&gt;<i>    814		&amp;dev_attr_output	.attr,
</I>&gt;<i>    815		0,
</I>&gt;<i>    816	};
</I>&gt;<i>    817	static const struct attribute_group netdev_sysfs = {
</I>&gt;<i>    818		.name  = 0,
</I>&gt;<i>    819		.attrs = (struct attribute **)netdev_sysfs_entries,
</I>&gt;<i>    820	};
</I>&gt;<i>    821	
</I>&gt;<i>    822	static int mk_netdev_sysfs(struct softing_priv *priv)
</I>&gt;<i>    823	{
</I>&gt;<i>    824		if (!priv-&gt;netdev-&gt;dev.kobj.sd) {
</I>&gt;<i>    825			dev_alert(priv-&gt;card-&gt;dev, &quot;sysfs_create_group would fail\n&quot;);
</I>&gt;<i>    826			return ENODEV;
</I>&gt;<i>    827		}
</I>&gt;<i>    828		return sysfs_create_group(&amp;priv-&gt;netdev-&gt;dev.kobj, &amp;netdev_sysfs);
</I>&gt;<i>    829	}
</I>&gt;<i>    830	static void rm_netdev_sysfs(struct softing_priv *priv)
</I>&gt;<i>    831	{
</I>&gt;<i>    832		sysfs_remove_group(&amp;priv-&gt;netdev-&gt;dev.kobj, &amp;netdev_sysfs);
</I>&gt;<i>    833	}
</I>&gt;<i>    834	
</I>&gt;<i>    835	#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
</I>&gt;<i>    836	static const struct net_device_ops softing_netdev_ops = {
</I>&gt;<i>    837		.ndo_open 	= netdev_open,
</I>&gt;<i>    838		.ndo_stop	= netdev_stop,
</I>&gt;<i>    839		.ndo_start_xmit	= netdev_start_xmit,
</I>&gt;<i>    840	};
</I>&gt;<i>    841	#endif
</I>&gt;<i>    842	
</I>&gt;<i>    843	static struct softing_priv *mk_netdev(struct softing *card, u16 chip_id)
</I>&gt;<i>    844	{
</I>&gt;<i>    845		struct net_device *ndev;
</I>&gt;<i>    846		struct softing_priv *priv;
</I>&gt;<i>    847	
</I>&gt;<i>    848		ndev = alloc_candev(sizeof(*priv));
</I>&gt;<i>    849		if (!ndev) {
</I>&gt;<i>    850			dev_alert(card-&gt;dev, &quot;alloc_candev failed\n&quot;);
</I>&gt;<i>    851			return 0;
</I>&gt;<i>    852		}
</I>&gt;<i>    853		priv = netdev_priv(ndev);
</I>&gt;<i>    854		priv-&gt;netdev		= ndev;
</I>&gt;<i>    855		priv-&gt;card		= card;
</I>&gt;<i>    856		memcpy(&amp;priv-&gt;btr_const, &amp;softing_btr_const, sizeof(priv-&gt;btr_const));
</I>&gt;<i>    857		priv-&gt;btr_const.brp_max = card-&gt;desc-&gt;max_brp;
</I>&gt;<i>    858		priv-&gt;btr_const.sjw_max = card-&gt;desc-&gt;max_sjw;
</I>&gt;<i>    859		priv-&gt;can.bittiming_const = &amp;priv-&gt;btr_const;
</I>&gt;<i>    860		priv-&gt;can.clock.freq	= 8000000;
</I>&gt;<i> 
</I>&gt;<i> Don't define a default bitrate, please.
</I>Did I?
&gt;<i> 
</I>&gt;<i>    861		priv-&gt;chip 		= chip_id;
</I>&gt;<i>    862		priv-&gt;output = softing_default_output(card, priv);
</I>&gt;<i>    863		SET_NETDEV_DEV(ndev, card-&gt;dev);
</I>&gt;<i>    864	
</I>&gt;<i>    865		ndev-&gt;flags |= IFF_ECHO;
</I>&gt;<i>    866	#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
</I>&gt;<i>    867		ndev-&gt;netdev_ops	= &amp;softing_netdev_ops;
</I>&gt;<i>    868	#else
</I>&gt;<i>    869		ndev-&gt;open		= netdev_open;
</I>&gt;<i>    870		ndev-&gt;stop		= netdev_stop;
</I>&gt;<i>    871		ndev-&gt;hard_start_xmit	= netdev_start_xmit;
</I>&gt;<i>    872	#endif
</I>&gt;<i>    873		priv-&gt;can.do_set_mode	= candev_set_mode;
</I>&gt;<i>    874	
</I>&gt;<i>    875		return priv;
</I>&gt;<i>    876	}
</I>&gt;<i>    877	
</I>&gt;<i>    878	static int reg_netdev(struct softing_priv *priv)
</I>&gt;<i>    879	{
</I>&gt;<i>    880		int ret;
</I>&gt;<i>    881		netif_carrier_off(priv-&gt;netdev);
</I>&gt;<i>    882		ret = register_candev(priv-&gt;netdev);
</I>&gt;<i>    883		if (ret) {
</I>&gt;<i>    884			dev_alert(priv-&gt;card-&gt;dev, &quot;%s, register failed\n&quot;,
</I>&gt;<i>    885				priv-&gt;card-&gt;id.name);
</I>&gt;<i>    886			goto reg_failed;
</I>&gt;<i>    887		}
</I>&gt;<i>    888		ret = mk_netdev_sysfs(priv);
</I>&gt;<i>    889		if (ret) {
</I>&gt;<i>    890			dev_alert(priv-&gt;card-&gt;dev, &quot;%s, sysfs failed\n&quot;,
</I>&gt;<i>    891				priv-&gt;card-&gt;id.name);
</I>&gt;<i>    892			goto sysfs_failed;
</I>&gt;<i>    893		}
</I>&gt;<i>    894		return 0;
</I>&gt;<i>    895	sysfs_failed:
</I>&gt;<i>    896		unregister_candev(priv-&gt;netdev);
</I>&gt;<i>    897	reg_failed:
</I>&gt;<i>    898		return EINVAL;
</I>&gt;<i>    899	}
</I>&gt;<i>    900	
</I>&gt;<i>    901	void rm_softing(struct softing *card)
</I>&gt;<i>    902	{
</I>&gt;<i>    903		int j;
</I>&gt;<i>    904	
</I>&gt;<i>    905		/*first, disable card*/
</I>&gt;<i>    906		shutdown_card(card);
</I>&gt;<i>    907	
</I>&gt;<i>    908		for (j = 0; j &lt; card-&gt;nbus; ++j) {
</I>&gt;<i>    909			if (!card-&gt;bus[j])
</I>&gt;<i>    910				continue;
</I>&gt;<i>    911			rm_netdev_sysfs(card-&gt;bus[j]);
</I>&gt;<i>    912			unregister_candev(card-&gt;bus[j]-&gt;netdev);
</I>&gt;<i>    913			free_candev(card-&gt;bus[j]-&gt;netdev);
</I>&gt;<i>    914		}
</I>&gt;<i>    915	
</I>&gt;<i>    916		rm_card_sysfs(card);
</I>&gt;<i>    917	
</I>&gt;<i>    918		iounmap(card-&gt;dpram.virt);
</I>&gt;<i>    919	}
</I>&gt;<i>    920	EXPORT_SYMBOL(rm_softing);
</I>&gt;<i>    921	
</I>&gt;<i>    922	int mk_softing(struct softing *card)
</I>&gt;<i>    923	{
</I>&gt;<i>    924		int j;
</I>&gt;<i>    925	
</I>&gt;<i>    926		/* try_module_get(THIS_MODULE); */
</I>&gt;<i>    927		mutex_init(&amp;card-&gt;fw.lock);
</I>&gt;<i>    928		spin_lock_init(&amp;card-&gt;spin);
</I>&gt;<i>    929		tasklet_init(&amp;card-&gt;irq.bh, softing_dev_svc, (unsigned long)card);
</I>&gt;<i>    930	
</I>&gt;<i>    931		card-&gt;desc = softing_lookup_desc(card-&gt;id.manf, card-&gt;id.prod);
</I>&gt;<i>    932		if (!card-&gt;desc) {
</I>&gt;<i>    933			dev_alert(card-&gt;dev, &quot;0x%04x:0x%04x not supported\n&quot;,
</I>&gt;<i>    934				card-&gt;id.manf, card-&gt;id.prod);
</I>&gt;<i>    935			goto lookup_failed;
</I>&gt;<i>    936		}
</I>&gt;<i>    937		card-&gt;id.name = card-&gt;desc-&gt;name;
</I>&gt;<i>    938	
</I>&gt;<i>    939		card-&gt;dpram.virt = ioremap(card-&gt;dpram.phys, card-&gt;dpram.size);
</I>&gt;<i>    940		if (!card-&gt;dpram.virt) {
</I>&gt;<i>    941			dev_alert(card-&gt;dev, &quot;dpram ioremap failed\n&quot;);
</I>&gt;<i>    942			goto ioremap_failed;
</I>&gt;<i>    943		}
</I>&gt;<i>    944	
</I>&gt;<i>    945		card-&gt;dpram.size = card-&gt;desc-&gt;dpram_size;
</I>&gt;<i>    946		card-&gt;dpram.end = &amp;card-&gt;dpram.virt[card-&gt;dpram.size];
</I>&gt;<i>    947		/*initialize_board */
</I>&gt;<i>    948		card-&gt;dpram.rx = (struct softing_rx *)&amp;card-&gt;dpram.virt[0x0000];
</I>&gt;<i>    949		card-&gt;dpram.tx = (struct softing_tx *)&amp;card-&gt;dpram.virt[0x0400];
</I>&gt;<i>    950		card-&gt;dpram.fct = (struct softing_fct *)&amp;card-&gt;dpram.virt[0x0300];
</I>&gt;<i>    951		card-&gt;dpram.info = (struct softing_info *)&amp;card-&gt;dpram.virt[0x0330];
</I>&gt;<i>    952		card-&gt;dpram.command = (unsigned short *)&amp;card-&gt;dpram.virt[0x07e0];
</I>&gt;<i>    953		card-&gt;dpram.receipt = (unsigned short *)&amp;card-&gt;dpram.virt[0x07f0];
</I>&gt;<i>    954		card-&gt;dpram.irq = (struct softing_irq *)&amp;card-&gt;dpram.virt[0x07fe];
</I>&gt;<i>    955	
</I>&gt;<i>    956		/*reset card */
</I>&gt;<i>    957		if (card-&gt;fn.reset)
</I>&gt;<i>    958			card-&gt;fn.reset(card, 1);
</I>&gt;<i>    959		if (boot_card(card)) {
</I>&gt;<i>    960			dev_alert(card-&gt;dev, &quot;failed to boot\n&quot;);
</I>&gt;<i>    961			goto boot_failed;
</I>&gt;<i>    962		}
</I>&gt;<i>    963	
</I>&gt;<i>    964		/*only now, the chip's are known */
</I>&gt;<i>    965		card-&gt;id.freq = card-&gt;desc-&gt;freq * 1000000UL;
</I>&gt;<i>    966	
</I>&gt;<i>    967		if (mk_card_sysfs(card)) {
</I>&gt;<i>    968			dev_alert(card-&gt;dev, &quot;sysfs failed\n&quot;);
</I>&gt;<i>    969			goto sysfs_failed;
</I>&gt;<i>    970		}
</I>&gt;<i>    971	
</I>&gt;<i>    972		if (card-&gt;nbus &gt; (sizeof(card-&gt;bus) / sizeof(card-&gt;bus[0]))) {
</I>&gt;<i>    973			card-&gt;nbus = sizeof(card-&gt;bus) / sizeof(card-&gt;bus[0]);
</I>&gt;<i>    974			dev_alert(card-&gt;dev, &quot;have %u busses\n&quot;, card-&gt;nbus);
</I>&gt;<i>    975		}
</I>&gt;<i>    976	
</I>&gt;<i>    977		for (j = 0; j &lt; card-&gt;nbus; ++j) {
</I>&gt;<i>    978			card-&gt;bus[j] = mk_netdev(card, card-&gt;id.chip[j]);
</I>&gt;<i>    979			if (!card-&gt;bus[j]) {
</I>&gt;<i>    980				dev_alert(card-&gt;dev, &quot;failed to make can[%i]&quot;, j);
</I>&gt;<i>    981				goto netdev_failed;
</I>&gt;<i>    982			}
</I>&gt;<i>    983			card-&gt;bus[j]-&gt;index = j;
</I>&gt;<i>    984		}
</I>&gt;<i>    985		for (j = 0; j &lt; card-&gt;nbus; ++j) {
</I>&gt;<i>    986			if (reg_netdev(card-&gt;bus[j])) {
</I>&gt;<i>    987				dev_alert(card-&gt;dev,
</I>&gt;<i>    988					&quot;failed to register can[%i]\n&quot;, j);
</I>&gt;<i>    989				goto reg_failed;
</I>&gt;<i>    990			}
</I>&gt;<i>    991		}
</I>&gt;<i>    992		dev_info(card-&gt;dev, &quot;card initialised\n&quot;);
</I>&gt;<i>    993		return 0;
</I>&gt;<i>    994	
</I>&gt;<i>    995	reg_failed:
</I>&gt;<i>    996		for (j = 0; j &lt; card-&gt;nbus; ++j) {
</I>&gt;<i>    997			if (!card-&gt;bus[j])
</I>&gt;<i>    998				continue;
</I>&gt;<i>    999			rm_netdev_sysfs(card-&gt;bus[j]);
</I>&gt;<i>   1000			unregister_candev(card-&gt;bus[j]-&gt;netdev);
</I>&gt;<i>   1001		}
</I>&gt;<i>   1002	netdev_failed:
</I>&gt;<i>   1003		for (j = 0; j &lt; card-&gt;nbus; ++j) {
</I>&gt;<i>   1004			if (!card-&gt;bus[j])
</I>&gt;<i>   1005				continue;
</I>&gt;<i>   1006			free_candev(card-&gt;bus[j]-&gt;netdev);
</I>&gt;<i>   1007		}
</I>&gt;<i>   1008		rm_card_sysfs(card);
</I>&gt;<i>   1009	sysfs_failed:
</I>&gt;<i>   1010		shutdown_card(card);
</I>&gt;<i>   1011	boot_failed:
</I>&gt;<i>   1012		iounmap(card-&gt;dpram.virt);
</I>&gt;<i>   1013		card-&gt;dpram.virt = 0;
</I>&gt;<i>   1014		card-&gt;dpram.end = 0;
</I>&gt;<i>   1015	ioremap_failed:
</I>&gt;<i>   1016	lookup_failed:
</I>&gt;<i>   1017		tasklet_kill(&amp;card-&gt;irq.bh);
</I>&gt;<i>   1018		return EINVAL;
</I>&gt;<i>   1019	}
</I>&gt;<i>   1020	EXPORT_SYMBOL(mk_softing);
</I>&gt;<i>   1021	
</I>&gt;<i>   1022	static int __init mod_start(void)
</I>&gt;<i>   1023	{
</I>&gt;<i>   1024		return 0;
</I>&gt;<i>   1025	}
</I>&gt;<i> 
</I>&gt;<i> A KERN_INFO message would be nice here.
</I>OK
&gt;<i> 
</I>&gt;<i>   1027	static void __exit mod_stop(void)
</I>&gt;<i>   1028	{
</I>&gt;<i>   1029	}
</I>&gt;<i>   1030	
</I>&gt;<i>   1031	module_init(mod_start);
</I>&gt;<i>   1032	module_exit(mod_stop);
</I>&gt;<i>   1033	
</I>&gt;<i>   1034	MODULE_DESCRIPTION(&quot;socketcan softing driver&quot;);
</I>&gt;<i>   1035	MODULE_AUTHOR(&quot;Kurt Van Dijck &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kurt.van.dijck at eia.be</A>&gt;&quot;);
</I>&gt;<i>   1036	MODULE_LICENSE(&quot;GPL&quot;);
</I>&gt;<i>   1037	
</I>&gt;<i>   1038	int softing_debug = 1;
</I>&gt;<i>   1039	EXPORT_SYMBOL(softing_debug);
</I>&gt;<i>   1040	module_param(softing_debug, int , S_IRUGO | S_IWUSR | S_IWGRP);
</I>&gt;<i>   1041	MODULE_PARM_DESC(softing_debug, &quot;trace softing functions&quot;);
</I>&gt;<i> 
</I>&gt;<i> Is this still needed? Or do you need it just for development?
</I>I could drop that
&gt;<i> 
</I>&gt;<i> As your locking seems tricky, please use a kernel with
</I>&gt;<i> CONFIG_PROVE_LOCKING=y for testing.
</I>I'll do

I'll come back after that.
&gt;<i> 
</I>&gt;<i> Wolfgang.
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002718.html">Review of netlink's 
</A></li>
	<LI>Next message: <A HREF="002735.html">Review of netlink's
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2733">[ date ]</a>
              <a href="thread.html#2733">[ thread ]</a>
              <a href="subject.html#2733">[ subject ]</a>
              <a href="author.html#2733">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
