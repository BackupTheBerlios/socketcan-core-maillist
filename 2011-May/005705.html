<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH v4 1/1] can: add pruss CAN driver.
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2011-May/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20v4%201/1%5D%20can%3A%20add%20pruss%20CAN%20driver.&In-Reply-To=%3C20110504155750.GC322%40e-circ.dyndns.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005741.html">
   <LINK REL="Next"  HREF="005707.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH v4 1/1] can: add pruss CAN driver.</H1>
    <B>Kurt Van Dijck</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20v4%201/1%5D%20can%3A%20add%20pruss%20CAN%20driver.&In-Reply-To=%3C20110504155750.GC322%40e-circ.dyndns.org%3E"
       TITLE="[PATCH v4 1/1] can: add pruss CAN driver.">kurt.van.dijck at eia.be
       </A><BR>
    <I>Wed May  4 17:57:50 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="005741.html">[PATCH v4 1/1] can: add pruss CAN driver.
</A></li>
        <LI>Next message: <A HREF="005707.html">[PATCH v4 1/1] can: add pruss CAN driver.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5705">[ date ]</a>
              <a href="thread.html#5705">[ thread ]</a>
              <a href="subject.html#5705">[ subject ]</a>
              <a href="author.html#5705">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> 
</I>&gt;<i> &gt; How hard would it be to implement that feature in Socket CAN?
</I>&gt;<i> 
</I>&gt;<i> CAN controllers usually provide some kind of hardware CAN id filtering,
</I>&gt;<i> but in a very hardware dependent way. A generic interface may be able to
</I>&gt;<i> handle the PRUSS restrictions as well. CAN devices are usually
</I>&gt;<i> configured through the netlink interface. e.g.
</I>&gt;<i> 
</I>&gt;<i>   $ ip link set can0 up type can bitrate 125000
</I>&gt;<i> 
</I>&gt;<i> and such a common interface would be netlink based as well.
</I>ack.
&gt;<i> 
</I>&gt;<i> &gt; Is that something that Subhasish or someone else could to as a prerequisite
</I>&gt;<i> &gt; to merging the driver?
</I>&gt;<i> 
</I>&gt;<i> Any ideas on how to handle hardware filtering in a generic way are
</I>&gt;<i> welcome. I will try to come up with a proposal sooner than later.
</I>
When doing so, I'd vote for an unlimited(by software) list of hardware filters (id/mask).
The hardware must abort when no more filters are available.
I think that when using hardware filters, knowing the actual device
with it's amount of hardware filters is the least of your problems.
Userspace applications that suddenly stop working properly due to
hw filters (i.e. some traffic not coming in anymore) will be a major
source of bugreports.

Kurt

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005741.html">[PATCH v4 1/1] can: add pruss CAN driver.
</A></li>
	<LI>Next message: <A HREF="005707.html">[PATCH v4 1/1] can: add pruss CAN driver.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5705">[ date ]</a>
              <a href="thread.html#5705">[ thread ]</a>
              <a href="subject.html#5705">[ subject ]</a>
              <a href="author.html#5705">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
