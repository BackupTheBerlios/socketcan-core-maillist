<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [RFC PATCH 1/4] SPEAr320 CCAN driver
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2010-September/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BRFC%20PATCH%201/4%5D%20SPEAr320%20CCAN%20driver&In-Reply-To=%3CD5ECB3C7A6F99444980976A8C6D8963816A0936C17%40EAPEX1MAIL1.st.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004603.html">
   <LINK REL="Next"  HREF="004605.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[RFC PATCH 1/4] SPEAr320 CCAN driver</H1>
    <B>Bhupesh SHARMA</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BRFC%20PATCH%201/4%5D%20SPEAr320%20CCAN%20driver&In-Reply-To=%3CD5ECB3C7A6F99444980976A8C6D8963816A0936C17%40EAPEX1MAIL1.st.com%3E"
       TITLE="[RFC PATCH 1/4] SPEAr320 CCAN driver">bhupesh.sharma at st.com
       </A><BR>
    <I>Wed Sep  1 13:37:05 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="004603.html">[RFC PATCH 1/4] SPEAr320 CCAN driver
</A></li>
        <LI>Next message: <A HREF="004605.html">[RFC PATCH 1/4] SPEAr320 CCAN driver
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4604">[ date ]</a>
              <a href="thread.html#4604">[ thread ]</a>
              <a href="subject.html#4604">[ subject ]</a>
              <a href="author.html#4604">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Marc,

&gt;<i> -----Original Message-----
</I>&gt;<i> From: Marc Kleine-Budde [mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">mkl at pengutronix.de</A>]
</I>&gt;<i> Sent: Wednesday, September 01, 2010 4:48 PM
</I>&gt;<i> To: Bhupesh SHARMA
</I>&gt;<i> Cc: <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">wg at grandegger.com</A>; <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">Socketcan-core at lists.berlios.de</A>
</I>&gt;<i> Subject: Re: [RFC PATCH 1/4] SPEAr320 CCAN driver
</I>&gt;<i> 
</I>&gt;<i> Bhupesh SHARMA wrote:
</I>&gt;<i> &gt; Hi Wolfgang,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Please ignore the earlier mail..
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; -----Original Message-----
</I>&gt;<i> &gt;&gt; From: Wolfgang Grandegger [mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">wg at grandegger.com</A>]
</I>&gt;<i> &gt;&gt; Sent: Wednesday, September 01, 2010 2:44 PM
</I>&gt;<i> &gt;&gt; To: Bhupesh SHARMA
</I>&gt;<i> &gt;&gt; Cc: <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">Socketcan-core at lists.berlios.de</A>
</I>&gt;<i> &gt;&gt; Subject: Re: [RFC PATCH 1/4] SPEAr320 CCAN driver
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Hi Bhupesh,
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; On 09/01/2010 11:01 AM, Bhupesh SHARMA wrote:
</I>&gt;<i> &gt;&gt;&gt; Hi Wolfgang,
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; -----Original Message-----
</I>&gt;<i> &gt;&gt;&gt;&gt; From: Wolfgang Grandegger [mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">wg at grandegger.com</A>]
</I>&gt;<i> &gt;&gt;&gt;&gt; Sent: Wednesday, September 01, 2010 12:56 PM
</I>&gt;<i> &gt;&gt;&gt;&gt; To: Bhupesh SHARMA
</I>&gt;<i> &gt;&gt;&gt;&gt; Cc: <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">Socketcan-core at lists.berlios.de</A>
</I>&gt;<i> &gt;&gt;&gt;&gt; Subject: Re: [RFC PATCH 1/4] SPEAr320 CCAN driver
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; Hi Bhupesh,
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt; On 09/01/2010 06:40 AM, Bhupesh SHARMA wrote:
</I>&gt;<i> &gt;&gt; ...
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; It is also particularly useful as we now have a new SPEAr1310 SoC
</I>&gt;<i> &gt;&gt;&gt;&gt; which also uses the Bosch CCAN controller
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; , but the glue logic has changed from SPEAr320 and hence we can
</I>&gt;<i> &gt;&gt;&gt;&gt; handle most of the platform/machine specific details
</I>&gt;<i> &gt;&gt;&gt;&gt;&gt; in SPEAr1310 driver and keep Bosch CCAN driver as it is.
</I>&gt;<i> &gt;&gt;&gt;&gt; What has changed with the new Soc and what platform specific
</I>&gt;<i> &gt;&gt;&gt;&gt; details and initializations do you think about? I personally do
</I>&gt;<i> not
</I>&gt;<i> &gt;&gt;&gt;&gt; see a lot of platform specific code in your spear320_can.c. Just
</I>&gt;<i> &gt;&gt; spear320_can_read()
</I>&gt;<i> &gt;&gt;&gt;&gt; and spear320_can_write() and also these functions look pretty
</I>&gt;<i> &gt;&gt; generic.
</I>&gt;<i> &gt;&gt;&gt;&gt; Also note that platform specific initialization is usually not
</I>&gt;<i> done
</I>&gt;<i> &gt;&gt; in
</I>&gt;<i> &gt;&gt;&gt;&gt; the CAN driver but the platform code.
</I>&gt;<i> &gt;&gt;&gt; In a way you are correct: mainly the spear320_can_read() and
</I>&gt;<i> &gt;&gt; spear320_can_write()
</I>&gt;<i> &gt;&gt;&gt; change from spear1310_can_read() and spear1310_can_write()
</I>&gt;<i> &gt;&gt; implementations.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Can you show us the new spear1310_can_read/write functions? I want
</I>&gt;<i> to
</I>&gt;<i> &gt;&gt; understand how generic they really are.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; spear1310 differs from spear320 in the way that 16-bit registers are
</I>&gt;<i> &gt; aligned at a 16-bit boundary whereas in spear320 these 16-bit
</I>&gt;<i> &gt; registers are aligned at a 32-bit boundary. So, while spear1310
</I>&gt;<i> routines should look like this:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; static u16 spear1310_can_read_reg(const struct bosch_ccan_priv *priv,
</I>&gt;<i> &gt; 				enum ccan_regs reg)
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; 	u16 val;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 	/* 16 bit registers are aligned at 16-bit boundary */
</I>&gt;<i> &gt; 	val = readw(priv-&gt;reg_base + reg);
</I>&gt;<i> &gt; 	return val;
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; static void spear1310_can_write_reg(const struct bosch_ccan_priv
</I>&gt;<i> *priv,
</I>&gt;<i> &gt; 				enum ccan_regs reg, u16 val)
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; 	/* 16 bit registers are aligned at 16-bit boundary */
</I>&gt;<i> &gt; 	writew(val, priv-&gt;reg_base + reg);
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The one for SPEAr320 will look like:
</I>&gt;<i> &gt; static u16 spear320_can_read_reg(const struct bosch_ccan_priv *priv,
</I>&gt;<i> &gt; 				enum ccan_regs reg)
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; 	u16 val;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 	/* shifting 1 place because 16 bit registers are word aligned */
</I>&gt;<i> &gt; 	val = readw(priv-&gt;reg_base + (reg &lt;&lt; 1));
</I>&gt;<i> &gt; 	return val;
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; static void spear320_can_write_reg(const struct bosch_ccan_priv
</I>&gt;<i> *priv,
</I>&gt;<i> &gt; 				enum ccan_regs reg, u16 val)
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; 	/* shifting 1 place because 16 bit registers are word aligned */
</I>&gt;<i> &gt; 	writew(val, priv-&gt;reg_base + (reg &lt;&lt; 1)); }
</I>&gt;<i> 
</I>&gt;<i> [...]
</I>&gt;<i> 
</I>&gt;<i> &gt; Please let me know on basis of the above register definitions.
</I>&gt;<i> 
</I>&gt;<i> Have a look at the sja1000_platform driver that Wolfgang already
</I>&gt;<i> mentioned:
</I>&gt;<i> <A HREF="http://lxr.linux.no/linux+v2.6.35/drivers/net/can/sja1000/sja1000_platf">http://lxr.linux.no/linux+v2.6.35/drivers/net/can/sja1000/sja1000_platf</A>
</I>&gt;<i> orm.c#L39
</I>&gt;<i> 
</I>&gt;<i> IMHO for normal SOC like your spears it would be sufficient to have a
</I>&gt;<i> generic ccan_platform driver, just like the sja1000.
</I>&gt;<i> 
</I>&gt;<i> If you have a broken ccan integration in your SOC, like on the hynix
</I>&gt;<i> chip (the one we developed a driver for at pengutronix), you can
</I>&gt;<i> provide your own driver with the sepcial read/write functions.
</I>
Infact the case for SPEAr is almost similar to the Hynix chip as the glue logic (read, register interface)
has and will keep changing for different SoCs- just have a look at the SPEAr320 and SPEAr1310 interfaces
in my original mail. This makes it almost impossible to keep a single platform driver file on
lines of sja1000_platform.c for CCAN.

&gt;<i> Does the generic ccan driver support clock handling and does it have
</I>&gt;<i> support for transceiver enable/disable callbacks?
</I>
Here again the glue logic comes into picture. On both the SoCs that we have now the CAN source clock is APB(83.3 MHz)
However this changes if someone uses a SoC's that doesn't have a ARM core yet it still uses the Bosch CCAN controllers
internally. In that case the CCAN driver should be kept independent of the clock handling stuff and it should be
done by a driver like SoCxxx_can.c that only uses the Bosch CCAN driver services and keeps track of all the 
platform data disparities.

Please let me know if this makes sense to you.

Regards,
Bhupesh

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004603.html">[RFC PATCH 1/4] SPEAr320 CCAN driver
</A></li>
	<LI>Next message: <A HREF="004605.html">[RFC PATCH 1/4] SPEAr320 CCAN driver
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4604">[ date ]</a>
              <a href="thread.html#4604">[ thread ]</a>
              <a href="subject.html#4604">[ subject ]</a>
              <a href="author.html#4604">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
