<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH net-next-2.6 v7 1/1] can: c_can: Added support for Bosch C_CAN	controller
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2011-February/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20net-next-2.6%20v7%201/1%5D%20can%3A%20c_can%3A%20Added%20support%20for%20Bosch%20C_CAN%0A%09controller&In-Reply-To=%3C1297419478-27667-1-git-send-email-bhupesh.sharma%40st.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005509.html">
   <LINK REL="Next"  HREF="005523.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH net-next-2.6 v7 1/1] can: c_can: Added support for Bosch C_CAN	controller</H1>
    <B>Bhupesh Sharma</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20net-next-2.6%20v7%201/1%5D%20can%3A%20c_can%3A%20Added%20support%20for%20Bosch%20C_CAN%0A%09controller&In-Reply-To=%3C1297419478-27667-1-git-send-email-bhupesh.sharma%40st.com%3E"
       TITLE="[PATCH net-next-2.6 v7 1/1] can: c_can: Added support for Bosch C_CAN	controller">bhupesh.sharma at st.com
       </A><BR>
    <I>Fri Feb 11 11:17:58 CET 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="005509.html">[PATCH] pch_can: fix tseg1/tseg2 setting issue
</A></li>
        <LI>Next message: <A HREF="005523.html">[PATCH net-next-2.6 v7 1/1] can: c_can: Added support for Bosch	C_CAN	controller
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5514">[ date ]</a>
              <a href="thread.html#5514">[ thread ]</a>
              <a href="subject.html#5514">[ subject ]</a>
              <a href="author.html#5514">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Bosch C_CAN controller is a full-CAN implementation which is compliant
to CAN protocol version 2.0 part A and B. Bosch C_CAN user manual can be
obtained from:
<A HREF="http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/">http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/</A>
c_can/users_manual_c_can.pdf

This patch adds the support for this controller.
The following are the design choices made while writing the controller
driver:
1. Interface Register set IF1 has be used only in the current design.
2. Out of the 32 Message objects available, 16 are kept aside for RX
   purposes and the rest for TX purposes.
3. NAPI implementation is such that both the TX and RX paths function
   in polling mode.

Signed-off-by: Bhupesh Sharma &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">bhupesh.sharma at st.com</A>&gt;
---
Changes since V6:
1. Added check for calling netif_stop_queue() in case next TX object
   is busy.
2. Added logic *not* to copy data to rx'ed RTR frames.
3. Moved enums, defines and structs present in c_can.h file to the respective
   c-file where they are actually used.
4. Corrected message object busy status routine by using a better name
   and design approach.
5. Moved *set_bittiming* call to the *c_can_chip_config* function.
      
 drivers/net/can/Kconfig                |    2 +
 drivers/net/can/Makefile               |    1 +
 drivers/net/can/c_can/Kconfig          |   15 +
 drivers/net/can/c_can/Makefile         |    8 +
 drivers/net/can/c_can/c_can.c          | 1158 ++++++++++++++++++++++++++++++++
 drivers/net/can/c_can/c_can.h          |   86 +++
 drivers/net/can/c_can/c_can_platform.c |  207 ++++++
 7 files changed, 1477 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/can/c_can/Kconfig
 create mode 100644 drivers/net/can/c_can/Makefile
 create mode 100644 drivers/net/can/c_can/c_can.c
 create mode 100644 drivers/net/can/c_can/c_can.h
 create mode 100644 drivers/net/can/c_can/c_can_platform.c

diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
index 5dec456..1d699e3 100644
--- a/drivers/net/can/Kconfig
+++ b/drivers/net/can/Kconfig
@@ -115,6 +115,8 @@ source &quot;drivers/net/can/mscan/Kconfig&quot;
 
 source &quot;drivers/net/can/sja1000/Kconfig&quot;
 
+source &quot;drivers/net/can/c_can/Kconfig&quot;
+
 source &quot;drivers/net/can/usb/Kconfig&quot;
 
 source &quot;drivers/net/can/softing/Kconfig&quot;
diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
index 53c82a7..24ebfe8 100644
--- a/drivers/net/can/Makefile
+++ b/drivers/net/can/Makefile
@@ -13,6 +13,7 @@ obj-y				+= softing/
 
 obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
 obj-$(CONFIG_CAN_MSCAN)		+= mscan/
+obj-$(CONFIG_CAN_C_CAN)		+= c_can/
 obj-$(CONFIG_CAN_AT91)		+= at91_can.o
 obj-$(CONFIG_CAN_TI_HECC)	+= ti_hecc.o
 obj-$(CONFIG_CAN_MCP251X)	+= mcp251x.o
diff --git a/drivers/net/can/c_can/Kconfig b/drivers/net/can/c_can/Kconfig
new file mode 100644
index 0000000..ffb9773
--- /dev/null
+++ b/drivers/net/can/c_can/Kconfig
@@ -0,0 +1,15 @@
+menuconfig CAN_C_CAN
+	tristate &quot;Bosch C_CAN devices&quot;
+	depends on CAN_DEV &amp;&amp; HAS_IOMEM
+
+if CAN_C_CAN
+
+config CAN_C_CAN_PLATFORM
+	tristate &quot;Generic Platform Bus based C_CAN driver&quot;
+	---help---
+	  This driver adds support for the C_CAN chips connected to
+	  the &quot;platform bus&quot; (Linux abstraction for directly to the
+	  processor attached devices) which can be found on various
+	  boards from ST Microelectronics (<A HREF="http://www.st.com">http://www.st.com</A>)
+	  like the SPEAr1310 and SPEAr320 evaluation boards.
+endif
diff --git a/drivers/net/can/c_can/Makefile b/drivers/net/can/c_can/Makefile
new file mode 100644
index 0000000..9273f6d
--- /dev/null
+++ b/drivers/net/can/c_can/Makefile
@@ -0,0 +1,8 @@
+#
+#  Makefile for the Bosch C_CAN controller drivers.
+#
+
+obj-$(CONFIG_CAN_C_CAN) += c_can.o
+obj-$(CONFIG_CAN_C_CAN_PLATFORM) += c_can_platform.o
+
+ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
diff --git a/drivers/net/can/c_can/c_can.c b/drivers/net/can/c_can/c_can.c
new file mode 100644
index 0000000..1405078
--- /dev/null
+++ b/drivers/net/can/c_can/c_can.c
@@ -0,0 +1,1158 @@
+/*
+ * CAN bus driver for Bosch C_CAN controller
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Bhupesh Sharma &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">bhupesh.sharma at st.com</A>&gt;
+ *
+ * Borrowed heavily from the C_CAN driver originally written by:
+ * Copyright (C) 2007
+ * - Sascha Hauer, Marc Kleine-Budde, Pengutronix &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">s.hauer at pengutronix.de</A>&gt;
+ * - Simon Kallweit, intefo AG &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">simon.kallweit at intefo.ch</A>&gt;
+ *
+ * TX and RX NAPI implementation has been borrowed from at91 CAN driver
+ * written by:
+ * Copyright
+ * (C) 2007 by Hans J. Koch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">hjk at hansjkoch.de</A>&gt;
+ * (C) 2008, 2009 by Marc Kleine-Budde &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kernel at pengutronix.de</A>&gt;
+ *
+ * Bosch C_CAN controller is compliant to CAN protocol version 2.0 part A and B.
+ * Bosch C_CAN user manual can be obtained from:
+ * <A HREF="http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/">http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/</A>
+ * users_manual_c_can.pdf
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed &quot;as is&quot; without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/version.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/delay.h&gt;
+#include &lt;linux/netdevice.h&gt;
+#include &lt;linux/if_arp.h&gt;
+#include &lt;linux/if_ether.h&gt;
+#include &lt;linux/list.h&gt;
+#include &lt;linux/delay.h&gt;
+#include &lt;linux/io.h&gt;
+
+#include &lt;linux/can.h&gt;
+#include &lt;linux/can/dev.h&gt;
+#include &lt;linux/can/error.h&gt;
+
+#include &quot;c_can.h&quot;
+
+/* control register */
+#define CONTROL_TEST		BIT(7)
+#define CONTROL_CCE		BIT(6)
+#define CONTROL_DISABLE_AR	BIT(5)
+#define CONTROL_ENABLE_AR	(0 &lt;&lt; 5)
+#define CONTROL_EIE		BIT(3)
+#define CONTROL_SIE		BIT(2)
+#define CONTROL_IE		BIT(1)
+#define CONTROL_INIT		BIT(0)
+
+/* test register */
+#define TEST_RX			BIT(7)
+#define TEST_TX1		BIT(6)
+#define TEST_TX2		BIT(5)
+#define TEST_LBACK		BIT(4)
+#define TEST_SILENT		BIT(3)
+#define TEST_BASIC		BIT(2)
+
+/* status register */
+#define STATUS_BOFF		BIT(7)
+#define STATUS_EWARN		BIT(6)
+#define STATUS_EPASS		BIT(5)
+#define STATUS_RXOK		BIT(4)
+#define STATUS_TXOK		BIT(3)
+
+/* error counter register */
+#define ERR_CNT_TEC_MASK	0xff
+#define ERR_CNT_TEC_SHIFT	0
+#define ERR_CNT_REC_SHIFT	8
+#define ERR_CNT_REC_MASK	(0x7f &lt;&lt; ERR_CNT_REC_SHIFT)
+#define ERR_CNT_RP_SHIFT	15
+#define ERR_CNT_RP_MASK		(0x1 &lt;&lt; ERR_CNT_RP_SHIFT)
+
+/* bit-timing register */
+#define BTR_BRP_MASK		0x3f
+#define BTR_BRP_SHIFT		0
+#define BTR_SJW_SHIFT		6
+#define BTR_SJW_MASK		(0x3 &lt;&lt; BTR_SJW_SHIFT)
+#define BTR_TSEG1_SHIFT		8
+#define BTR_TSEG1_MASK		(0xf &lt;&lt; BTR_TSEG1_SHIFT)
+#define BTR_TSEG2_SHIFT		12
+#define BTR_TSEG2_MASK		(0x7 &lt;&lt; BTR_TSEG2_SHIFT)
+
+/* brp extension register */
+#define BRP_EXT_BRPE_MASK	0x0f
+#define BRP_EXT_BRPE_SHIFT	0
+
+/* IFx command request */
+#define IF_COMR_BUSY		BIT(15)
+
+/* IFx command mask */
+#define IF_COMM_WR		BIT(7)
+#define IF_COMM_MASK		BIT(6)
+#define IF_COMM_ARB		BIT(5)
+#define IF_COMM_CONTROL		BIT(4)
+#define IF_COMM_CLR_INT_PND	BIT(3)
+#define IF_COMM_TXRQST		BIT(2)
+#define IF_COMM_DATAA		BIT(1)
+#define IF_COMM_DATAB		BIT(0)
+#define IF_COMM_ALL		(IF_COMM_MASK | IF_COMM_ARB | \
+				IF_COMM_CONTROL | IF_COMM_TXRQST | \
+				IF_COMM_DATAA | IF_COMM_DATAB)
+
+/* IFx arbitration */
+#define IF_ARB_MSGVAL		BIT(15)
+#define IF_ARB_MSGXTD		BIT(14)
+#define IF_ARB_TRANSMIT		BIT(13)
+
+/* IFx message control */
+#define IF_MCONT_NEWDAT		BIT(15)
+#define IF_MCONT_MSGLST		BIT(14)
+#define IF_MCONT_CLR_MSGLST	(0 &lt;&lt; 14)
+#define IF_MCONT_INTPND		BIT(13)
+#define IF_MCONT_UMASK		BIT(12)
+#define IF_MCONT_TXIE		BIT(11)
+#define IF_MCONT_RXIE		BIT(10)
+#define IF_MCONT_RMTEN		BIT(9)
+#define IF_MCONT_TXRQST		BIT(8)
+#define IF_MCONT_EOB		BIT(7)
+#define IF_MCONT_DLC_MASK	0xf
+
+/*
+ * IFx register masks:
+ * allow easy operation on 16-bit registers when the
+ * argument is 32-bit instead
+ */
+#define IFX_WRITE_LOW_16BIT(x)	((x) &amp; 0xFFFF)
+#define IFX_WRITE_HIGH_16BIT(x)	(((x) &amp; 0xFFFF0000) &gt;&gt; 16)
+
+/* message object split */
+#define C_CAN_NO_OF_OBJECTS	32
+#define C_CAN_MSG_OBJ_RX_NUM	16
+#define C_CAN_MSG_OBJ_TX_NUM	16
+
+#define C_CAN_MSG_OBJ_RX_FIRST	1
+#define C_CAN_MSG_OBJ_RX_LAST	(C_CAN_MSG_OBJ_RX_FIRST + \
+				C_CAN_MSG_OBJ_RX_NUM - 1)
+
+#define C_CAN_MSG_OBJ_TX_FIRST	(C_CAN_MSG_OBJ_RX_LAST + 1)
+#define C_CAN_MSG_OBJ_TX_LAST	(C_CAN_MSG_OBJ_TX_FIRST + \
+				C_CAN_MSG_OBJ_TX_NUM - 1)
+
+#define C_CAN_MSG_OBJ_RX_SPLIT	9
+#define C_CAN_MSG_RX_LOW_LAST	(C_CAN_MSG_OBJ_RX_SPLIT - 1)
+
+#define C_CAN_NEXT_MSG_OBJ_MASK	(C_CAN_MSG_OBJ_TX_NUM - 1)
+#define RECEIVE_OBJECT_BITS	0x0000ffff
+
+/* status interrupt */
+#define STATUS_INTERRUPT	0x8000
+
+/* global interrupt masks */
+#define ENABLE_ALL_INTERRUPTS	1
+#define DISABLE_ALL_INTERRUPTS	0
+
+/* minimum timeout for checking BUSY status */
+#define MIN_TIMEOUT_VALUE	6
+
+/* napi related */
+#define C_CAN_NAPI_WEIGHT	C_CAN_MSG_OBJ_RX_NUM
+
+/* c_can lec values */
+enum c_can_lec_type {
+	LEC_NO_ERROR = 0,
+	LEC_STUFF_ERROR,
+	LEC_FORM_ERROR,
+	LEC_ACK_ERROR,
+	LEC_BIT1_ERROR,
+	LEC_BIT0_ERROR,
+	LEC_CRC_ERROR,
+	LEC_UNUSED,
+};
+
+/*
+ * c_can error types:
+ * Bus errors (BUS_OFF, ERROR_WARNING, ERROR_PASSIVE) are supported
+ */
+enum c_can_bus_error_types {
+	C_CAN_NO_ERROR = 0,
+	C_CAN_BUS_OFF,
+	C_CAN_ERROR_WARNING,
+	C_CAN_ERROR_PASSIVE,
+};
+
+static struct can_bittiming_const c_can_bittiming_const = {
+	.name = KBUILD_MODNAME,
+	.tseg1_min = 2,		/* Time segment 1 = prop_seg + phase_seg1 */
+	.tseg1_max = 16,
+	.tseg2_min = 1,		/* Time segment 2 = phase_seg2 */
+	.tseg2_max = 8,
+	.sjw_max = 4,
+	.brp_min = 1,
+	.brp_max = 1024,	/* 6-bit BRP field + 4-bit BRPE field*/
+	.brp_inc = 1,
+};
+
+static inline int get_tx_next_msg_obj(const struct c_can_priv *priv)
+{
+	return (priv-&gt;tx_next &amp; C_CAN_NEXT_MSG_OBJ_MASK) +
+			C_CAN_MSG_OBJ_TX_FIRST;
+}
+
+static inline int get_tx_echo_msg_obj(const struct c_can_priv *priv)
+{
+	return (priv-&gt;tx_echo &amp; C_CAN_NEXT_MSG_OBJ_MASK) +
+			C_CAN_MSG_OBJ_TX_FIRST;
+}
+
+static u32 c_can_read_reg32(struct c_can_priv *priv, void *reg)
+{
+	u32 val = priv-&gt;read_reg(priv, reg);
+	val |= ((u32) priv-&gt;read_reg(priv, reg + 2)) &lt;&lt; 16;
+	return val;
+}
+
+static void c_can_enable_all_interrupts(struct c_can_priv *priv,
+						int enable)
+{
+	unsigned int cntrl_save = priv-&gt;read_reg(priv,
+						&amp;priv-&gt;regs-&gt;control);
+
+	if (enable)
+		cntrl_save |= (CONTROL_SIE | CONTROL_EIE | CONTROL_IE);
+	else
+		cntrl_save &amp;= ~(CONTROL_EIE | CONTROL_IE | CONTROL_SIE);
+
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control, cntrl_save);
+}
+
+static inline int c_can_msg_obj_is_busy(struct c_can_priv *priv, int iface)
+{
+	int count = MIN_TIMEOUT_VALUE;
+
+	while (count &amp;&amp; priv-&gt;read_reg(priv,
+				&amp;priv-&gt;regs-&gt;ifregs[iface].com_req) &amp;
+				IF_COMR_BUSY) {
+		count--;
+		udelay(1);
+	}
+
+	if (!count)
+		return 1;
+
+	return 0;
+}
+
+static inline void c_can_object_get(struct net_device *dev,
+					int iface, int objno, int mask)
+{
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	/*
+	 * As per specs, after writting the message object number in the
+	 * IF command request register the transfer b/w interface
+	 * register and message RAM must be complete in 6 CAN-CLK
+	 * period.
+	 */
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].com_mask,
+			IFX_WRITE_LOW_16BIT(mask));
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].com_req,
+			IFX_WRITE_LOW_16BIT(objno));
+
+	if (c_can_msg_obj_is_busy(priv, iface))
+		netdev_err(dev, &quot;timed out in object get\n&quot;);
+}
+
+static inline void c_can_object_put(struct net_device *dev,
+					int iface, int objno, int mask)
+{
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	/*
+	 * As per specs, after writting the message object number in the
+	 * IF command request register the transfer b/w interface
+	 * register and message RAM must be complete in 6 CAN-CLK
+	 * period.
+	 */
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].com_mask,
+			(IF_COMM_WR | IFX_WRITE_LOW_16BIT(mask)));
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].com_req,
+			IFX_WRITE_LOW_16BIT(objno));
+
+	if (c_can_msg_obj_is_busy(priv, iface))
+		netdev_err(dev, &quot;timed out in object put\n&quot;);
+}
+
+static void c_can_write_msg_object(struct net_device *dev,
+			int iface, struct can_frame *frame, int objno)
+{
+	int i;
+	u16 flags = 0;
+	unsigned int id;
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	if (!(frame-&gt;can_id &amp; CAN_RTR_FLAG))
+		flags |= IF_ARB_TRANSMIT;
+
+	if (frame-&gt;can_id &amp; CAN_EFF_FLAG) {
+		id = frame-&gt;can_id &amp; CAN_EFF_MASK;
+		flags |= IF_ARB_MSGXTD;
+	} else
+		id = ((frame-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; 18);
+
+	flags |= IF_ARB_MSGVAL;
+
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].arb1,
+				IFX_WRITE_LOW_16BIT(id));
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].arb2, flags |
+				IFX_WRITE_HIGH_16BIT(id));
+
+	for (i = 0; i &lt; frame-&gt;can_dlc; i += 2) {
+		priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].data[i / 2],
+				frame-&gt;data[i] | (frame-&gt;data[i + 1] &lt;&lt; 8));
+	}
+
+	/* enable interrupt for this message object */
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].msg_cntrl,
+			IF_MCONT_TXIE | IF_MCONT_TXRQST | IF_MCONT_EOB |
+			frame-&gt;can_dlc);
+	c_can_object_put(dev, iface, objno, IF_COMM_ALL);
+}
+
+static inline void c_can_mark_rx_msg_obj(struct net_device *dev,
+						int iface, int ctrl_mask,
+						int obj)
+{
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].msg_cntrl,
+			ctrl_mask &amp; ~(IF_MCONT_MSGLST | IF_MCONT_INTPND));
+	c_can_object_put(dev, iface, obj, IF_COMM_CONTROL);
+
+}
+
+static inline void c_can_activate_all_lower_rx_msg_obj(struct net_device *dev,
+						int iface,
+						int ctrl_mask)
+{
+	int i;
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	for (i = C_CAN_MSG_OBJ_RX_FIRST; i &lt;= C_CAN_MSG_RX_LOW_LAST; i++) {
+		priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].msg_cntrl,
+				ctrl_mask &amp; ~(IF_MCONT_MSGLST |
+					IF_MCONT_INTPND | IF_MCONT_NEWDAT));
+		c_can_object_put(dev, iface, i, IF_COMM_CONTROL);
+	}
+}
+
+static inline void c_can_activate_rx_msg_obj(struct net_device *dev,
+						int iface, int ctrl_mask,
+						int obj)
+{
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].msg_cntrl,
+			ctrl_mask &amp; ~(IF_MCONT_MSGLST |
+				IF_MCONT_INTPND | IF_MCONT_NEWDAT));
+	c_can_object_put(dev, iface, obj, IF_COMM_CONTROL);
+}
+
+static void c_can_handle_lost_msg_obj(struct net_device *dev,
+					int iface, int objno)
+{
+	struct c_can_priv *priv = netdev_priv(dev);
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+	struct sk_buff *skb;
+	struct can_frame *frame;
+
+	netdev_err(dev, &quot;msg lost in buffer %d\n&quot;, objno);
+
+	c_can_object_get(dev, iface, objno, IF_COMM_ALL &amp; ~IF_COMM_TXRQST);
+
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].msg_cntrl,
+			IF_MCONT_CLR_MSGLST);
+
+	c_can_object_put(dev, 0, objno, IF_COMM_CONTROL);
+
+	/* create an error msg */
+	skb = alloc_can_err_skb(dev, &amp;frame);
+	if (unlikely(!skb))
+		return;
+
+	frame-&gt;can_id |= CAN_ERR_CRTL;
+	frame-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+	stats-&gt;rx_errors++;
+	stats-&gt;rx_over_errors++;
+
+	netif_receive_skb(skb);
+}
+
+static int c_can_read_msg_object(struct net_device *dev, int iface, int ctrl)
+{
+	u16 flags, data;
+	int i;
+	unsigned int val;
+	struct c_can_priv *priv = netdev_priv(dev);
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+	struct sk_buff *skb;
+	struct can_frame *frame;
+
+	skb = alloc_can_skb(dev, &amp;frame);
+	if (!skb) {
+		stats-&gt;rx_dropped++;
+		return -ENOMEM;
+	}
+
+	frame-&gt;can_dlc = get_can_dlc(ctrl &amp; 0x0F);
+
+	flags =	priv-&gt;read_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].arb2);
+	val = priv-&gt;read_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].arb1) |
+		(flags &lt;&lt; 16);
+
+	if (flags &amp; IF_ARB_MSGXTD)
+		frame-&gt;can_id = (val &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
+	else
+		frame-&gt;can_id = (val &gt;&gt; 18) &amp; CAN_SFF_MASK;
+
+	if (flags &amp; IF_ARB_TRANSMIT)
+		frame-&gt;can_id |= CAN_RTR_FLAG;
+	else {
+		for (i = 0; i &lt; frame-&gt;can_dlc; i += 2) {
+			data = priv-&gt;read_reg(priv,
+				&amp;priv-&gt;regs-&gt;ifregs[iface].data[i / 2]);
+			frame-&gt;data[i] = data;
+			frame-&gt;data[i + 1] = data &gt;&gt; 8;
+		}
+	}
+
+	netif_receive_skb(skb);
+
+	stats-&gt;rx_packets++;
+	stats-&gt;rx_bytes += frame-&gt;can_dlc;
+
+	return 0;
+}
+
+static void c_can_setup_receive_object(struct net_device *dev, int iface,
+					int objno, unsigned int mask,
+					unsigned int id, unsigned int mcont)
+{
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].mask1,
+			IFX_WRITE_LOW_16BIT(mask));
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].mask2,
+			IFX_WRITE_HIGH_16BIT(mask));
+
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].arb1,
+			IFX_WRITE_LOW_16BIT(id));
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].arb2,
+			(IF_ARB_MSGVAL | IFX_WRITE_HIGH_16BIT(id)));
+
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].msg_cntrl, mcont);
+	c_can_object_put(dev, iface, objno, IF_COMM_ALL &amp; ~IF_COMM_TXRQST);
+
+	netdev_dbg(dev, &quot;obj no:%d, msgval:0x%08x\n&quot;, objno,
+			c_can_read_reg32(priv, &amp;priv-&gt;regs-&gt;msgval1));
+}
+
+static void c_can_inval_msg_object(struct net_device *dev, int iface, int objno)
+{
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].arb1, 0);
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].arb2, 0);
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].msg_cntrl, 0);
+
+	c_can_object_put(dev, iface, objno, IF_COMM_ARB | IF_COMM_CONTROL);
+
+	netdev_dbg(dev, &quot;obj no:%d, msgval:0x%08x\n&quot;, objno,
+			c_can_read_reg32(priv, &amp;priv-&gt;regs-&gt;msgval1));
+}
+
+static inline int c_can_is_next_tx_obj_busy(struct c_can_priv *priv, int objno)
+{
+	int val = c_can_read_reg32(priv, &amp;priv-&gt;regs-&gt;txrqst1);
+
+	/*
+	 * as transmission request register's bit n-1 corresponds to
+	 * message object n, we need to handle the same properly.
+	 */
+	if (val &amp; (1 &lt;&lt; (objno - 1)))
+		return 1;
+
+	return 0;
+}
+
+static netdev_tx_t c_can_start_xmit(struct sk_buff *skb,
+					struct net_device *dev)
+{
+	u32 msg_obj_no;
+	struct c_can_priv *priv = netdev_priv(dev);
+	struct can_frame *frame = (struct can_frame *)skb-&gt;data;
+
+	if (can_dropped_invalid_skb(dev, skb))
+		return NETDEV_TX_OK;
+
+	msg_obj_no = get_tx_next_msg_obj(priv);
+
+	/* prepare message object for transmission */
+	c_can_write_msg_object(dev, 0, frame, msg_obj_no);
+	can_put_echo_skb(skb, dev, msg_obj_no - C_CAN_MSG_OBJ_TX_FIRST);
+
+	/*
+	 * we have to stop the queue in case of a wrap around or
+	 * if the next TX message object is still in use
+	 */
+	priv-&gt;tx_next++;
+	if (c_can_is_next_tx_obj_busy(priv, get_tx_next_msg_obj(priv)) ||
+			(priv-&gt;tx_next &amp; C_CAN_NEXT_MSG_OBJ_MASK) == 0)
+		netif_stop_queue(dev);
+
+	return NETDEV_TX_OK;
+}
+
+static int c_can_set_bittiming(struct net_device *dev)
+{
+	unsigned int reg_btr, reg_brpe, ctrl_save;
+	u8 brp, brpe, sjw, tseg1, tseg2;
+	u32 ten_bit_brp;
+	struct c_can_priv *priv = netdev_priv(dev);
+	const struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
+
+	/* c_can provides a 6-bit brp and 4-bit brpe fields */
+	ten_bit_brp = bt-&gt;brp - 1;
+	brp = ten_bit_brp &amp; BTR_BRP_MASK;
+	brpe = ten_bit_brp &gt;&gt; 6;
+
+	sjw = bt-&gt;sjw - 1;
+	tseg1 = bt-&gt;prop_seg + bt-&gt;phase_seg1 - 1;
+	tseg2 = bt-&gt;phase_seg2 - 1;
+	reg_btr = brp | (sjw &lt;&lt; BTR_SJW_SHIFT) | (tseg1 &lt;&lt; BTR_TSEG1_SHIFT) |
+			(tseg2 &lt;&lt; BTR_TSEG2_SHIFT);
+	reg_brpe = brpe &amp; BRP_EXT_BRPE_MASK;
+
+	netdev_info(dev,
+		&quot;setting BTR=%04x BRPE=%04x\n&quot;, reg_btr, reg_brpe);
+
+	ctrl_save = priv-&gt;read_reg(priv, &amp;priv-&gt;regs-&gt;control);
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control,
+			ctrl_save | CONTROL_CCE | CONTROL_INIT);
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;btr, reg_btr);
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;brp_ext, reg_brpe);
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control, ctrl_save);
+
+	return 0;
+}
+
+/*
+ * Configure C_CAN message objects for Tx and Rx purposes:
+ * C_CAN provides a total of 32 message objects that can be configured
+ * either for Tx or Rx purposes. Here the first 16 message objects are used as
+ * a reception FIFO. The end of reception FIFO is signified by the EoB bit
+ * being SET. The remaining 16 message objects are kept aside for Tx purposes.
+ * See user guide document for further details on configuring message
+ * objects.
+ */
+static void c_can_configure_msg_objects(struct net_device *dev)
+{
+	int i;
+
+	/* first invalidate all message objects */
+	for (i = C_CAN_MSG_OBJ_RX_FIRST; i &lt;= C_CAN_NO_OF_OBJECTS; i++)
+		c_can_inval_msg_object(dev, 0, i);
+
+	/* setup receive message objects */
+	for (i = C_CAN_MSG_OBJ_RX_FIRST; i &lt; C_CAN_MSG_OBJ_RX_LAST; i++)
+		c_can_setup_receive_object(dev, 0, i, 0, 0,
+			(IF_MCONT_RXIE | IF_MCONT_UMASK) &amp; ~IF_MCONT_EOB);
+
+	c_can_setup_receive_object(dev, 0, C_CAN_MSG_OBJ_RX_LAST, 0, 0,
+			IF_MCONT_EOB | IF_MCONT_RXIE | IF_MCONT_UMASK);
+}
+
+/*
+ * Configure C_CAN chip:
+ * - enable/disable auto-retransmission
+ * - set operating mode
+ * - configure message objects
+ */
+static void c_can_chip_config(struct net_device *dev)
+{
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_ONE_SHOT)
+		/* disable automatic retransmission */
+		priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control,
+				CONTROL_DISABLE_AR);
+	else
+		/* enable automatic retransmission */
+		priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control,
+				CONTROL_ENABLE_AR);
+
+	if (priv-&gt;can.ctrlmode &amp; (CAN_CTRLMODE_LISTENONLY &amp;
+					CAN_CTRLMODE_LOOPBACK)) {
+		/* loopback + silent mode : useful for hot self-test */
+		priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control, CONTROL_EIE |
+				CONTROL_SIE | CONTROL_IE | CONTROL_TEST);
+		priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;test,
+				TEST_LBACK | TEST_SILENT);
+	} else if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LOOPBACK) {
+		/* loopback mode : useful for self-test function */
+		priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control, CONTROL_EIE |
+				CONTROL_SIE | CONTROL_IE | CONTROL_TEST);
+		priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;test, TEST_LBACK);
+	} else if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LISTENONLY) {
+		/* silent mode : bus-monitoring mode */
+		priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control, CONTROL_EIE |
+				CONTROL_SIE | CONTROL_IE | CONTROL_TEST);
+		priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;test, TEST_SILENT);
+	} else
+		/* normal mode*/
+		priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control,
+				CONTROL_EIE | CONTROL_SIE | CONTROL_IE);
+
+	/* configure message objects */
+	c_can_configure_msg_objects(dev);
+
+	/* set a `lec` value so that we can check for updates later */
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;status, LEC_UNUSED);
+
+	/* set bittiming params */
+	c_can_set_bittiming(dev);
+}
+
+static void c_can_start(struct net_device *dev)
+{
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	/* enable status change, error and module interrupts */
+	c_can_enable_all_interrupts(priv, ENABLE_ALL_INTERRUPTS);
+
+	/* basic c_can configuration */
+	c_can_chip_config(dev);
+
+	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
+
+	/* reset tx helper pointers */
+	priv-&gt;tx_next = priv-&gt;tx_echo = 0;
+}
+
+static void c_can_stop(struct net_device *dev)
+{
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	/* disable all interrupts */
+	c_can_enable_all_interrupts(priv, DISABLE_ALL_INTERRUPTS);
+
+	/* set the state as STOPPED */
+	priv-&gt;can.state = CAN_STATE_STOPPED;
+}
+
+static int c_can_set_mode(struct net_device *dev, enum can_mode mode)
+{
+	switch (mode) {
+	case CAN_MODE_START:
+		c_can_start(dev);
+		netif_wake_queue(dev);
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int c_can_get_berr_counter(const struct net_device *dev,
+					struct can_berr_counter *bec)
+{
+	unsigned int reg_err_counter;
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	reg_err_counter = priv-&gt;read_reg(priv, &amp;priv-&gt;regs-&gt;err_cnt);
+	bec-&gt;rxerr = (reg_err_counter &amp; ERR_CNT_REC_MASK) &gt;&gt;
+				ERR_CNT_REC_SHIFT;
+	bec-&gt;txerr = reg_err_counter &amp; ERR_CNT_TEC_MASK;
+
+	return 0;
+}
+
+/*
+ * theory of operation:
+ *
+ * priv-&gt;tx_echo holds the number of the oldest can_frame put for
+ * transmission into the hardware, but not yet ACKed by the CAN tx
+ * complete IRQ.
+ *
+ * We iterate from priv-&gt;tx_echo to priv-&gt;tx_next and check if the
+ * packet has been transmitted, echo it back to the CAN framework.
+ * If we discover a not yet transmitted package, stop looking for more.
+ */
+static void c_can_do_tx(struct net_device *dev)
+{
+	u32 val;
+	u32 msg_obj_no;
+	struct c_can_priv *priv = netdev_priv(dev);
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+
+	for (/* nix */; (priv-&gt;tx_next - priv-&gt;tx_echo) &gt; 0; priv-&gt;tx_echo++) {
+		msg_obj_no = get_tx_echo_msg_obj(priv);
+		c_can_inval_msg_object(dev, 0, msg_obj_no);
+		val = c_can_read_reg32(priv, &amp;priv-&gt;regs-&gt;txrqst1);
+		if (!(val &amp; (1 &lt;&lt; msg_obj_no))) {
+			can_get_echo_skb(dev,
+					msg_obj_no - C_CAN_MSG_OBJ_TX_FIRST);
+			stats-&gt;tx_bytes += priv-&gt;read_reg(priv,
+					&amp;priv-&gt;regs-&gt;ifregs[0].msg_cntrl)
+					&amp; IF_MCONT_DLC_MASK;
+			stats-&gt;tx_packets++;
+		}
+	}
+
+	/* restart queue if wrap-up or if queue stalled on last pkt */
+	if (((priv-&gt;tx_next &amp; C_CAN_NEXT_MSG_OBJ_MASK) != 0) ||
+			((priv-&gt;tx_echo &amp; C_CAN_NEXT_MSG_OBJ_MASK) == 0))
+		netif_wake_queue(dev);
+}
+
+/*
+ * theory of operation:
+ *
+ * c_can core saves a received CAN message into the first free message
+ * object it finds free (starting with the lowest). Bits NEWDAT and
+ * INTPND are set for this message object indicating that a new message
+ * has arrived. To work-around this issue, we keep two groups of message
+ * objects whose partitioning is defined by C_CAN_MSG_OBJ_RX_SPLIT.
+ *
+ * To ensure in-order frame reception we use the following
+ * approach while re-activating a message object to receive further
+ * frames:
+ * - if the current message object number is lower than
+ *   C_CAN_MSG_RX_LOW_LAST, do not clear the NEWDAT bit while clearing
+ *   the INTPND bit.
+ * - if the current message object number is equal to
+ *   C_CAN_MSG_RX_LOW_LAST then clear the NEWDAT bit of all lower
+ *   receive message objects.
+ * - if the current message object number is greater than
+ *   C_CAN_MSG_RX_LOW_LAST then clear the NEWDAT bit of
+ *   only this message object.
+ */
+static int c_can_do_rx_poll(struct net_device *dev, int quota)
+{
+	u32 num_rx_pkts = 0;
+	unsigned int msg_obj, msg_ctrl_save;
+	struct c_can_priv *priv = netdev_priv(dev);
+	u32 val = c_can_read_reg32(priv, &amp;priv-&gt;regs-&gt;intpnd1);
+
+	for (msg_obj = C_CAN_MSG_OBJ_RX_FIRST;
+			msg_obj &lt;= C_CAN_MSG_OBJ_RX_LAST &amp;&amp; quota &gt; 0;
+			val = c_can_read_reg32(priv, &amp;priv-&gt;regs-&gt;intpnd1),
+			msg_obj++) {
+		/*
+		 * as interrupt pending register's bit n-1 corresponds to
+		 * message object n, we need to handle the same properly.
+		 */
+		if (val &amp; (1 &lt;&lt; (msg_obj - 1))) {
+			c_can_object_get(dev, 0, msg_obj, IF_COMM_ALL &amp;
+					~IF_COMM_TXRQST);
+			msg_ctrl_save = priv-&gt;read_reg(priv,
+					&amp;priv-&gt;regs-&gt;ifregs[0].msg_cntrl);
+
+			if (msg_ctrl_save &amp; IF_MCONT_EOB)
+				return num_rx_pkts;
+
+			if (msg_ctrl_save &amp; IF_MCONT_MSGLST) {
+				c_can_handle_lost_msg_obj(dev, 0, msg_obj);
+				num_rx_pkts++;
+				quota--;
+				continue;
+			}
+
+			if (!(msg_ctrl_save &amp; IF_MCONT_NEWDAT))
+				continue;
+
+			/* read the data from the message object */
+			c_can_read_msg_object(dev, 0, msg_ctrl_save);
+
+			if (msg_obj &lt; C_CAN_MSG_RX_LOW_LAST)
+				c_can_mark_rx_msg_obj(dev, 0,
+						msg_ctrl_save, msg_obj);
+			else if (msg_obj &gt; C_CAN_MSG_RX_LOW_LAST)
+				/* activate this msg obj */
+				c_can_activate_rx_msg_obj(dev, 0,
+						msg_ctrl_save, msg_obj);
+			else if (msg_obj == C_CAN_MSG_RX_LOW_LAST)
+				/* activate all lower message objects */
+				c_can_activate_all_lower_rx_msg_obj(dev,
+						0, msg_ctrl_save);
+
+			num_rx_pkts++;
+			quota--;
+		}
+	}
+
+	return num_rx_pkts;
+}
+
+static inline int c_can_has_and_handle_berr(struct c_can_priv *priv)
+{
+	return (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_BERR_REPORTING) &amp;&amp;
+		(priv-&gt;current_status &amp; LEC_UNUSED);
+}
+
+static int c_can_handle_state_change(struct net_device *dev,
+				enum c_can_bus_error_types error_type)
+{
+	unsigned int reg_err_counter;
+	unsigned int rx_err_passive;
+	struct c_can_priv *priv = netdev_priv(dev);
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+	struct can_frame *cf;
+	struct sk_buff *skb;
+	struct can_berr_counter bec;
+
+	/* propogate the error condition to the CAN stack */
+	skb = alloc_can_err_skb(dev, &amp;cf);
+	if (unlikely(!skb))
+		return 0;
+
+	c_can_get_berr_counter(dev, &amp;bec);
+	reg_err_counter = priv-&gt;read_reg(priv, &amp;priv-&gt;regs-&gt;err_cnt);
+	rx_err_passive = (reg_err_counter &amp; ERR_CNT_RP_MASK) &gt;&gt;
+				ERR_CNT_RP_SHIFT;
+
+	switch (error_type) {
+	case C_CAN_ERROR_WARNING:
+		/* error warning state */
+		priv-&gt;can.can_stats.error_warning++;
+		priv-&gt;can.state = CAN_STATE_ERROR_WARNING;
+		cf-&gt;can_id |= CAN_ERR_CRTL;
+		cf-&gt;data[1] = (bec.txerr &gt; bec.rxerr) ?
+			CAN_ERR_CRTL_TX_WARNING :
+			CAN_ERR_CRTL_RX_WARNING;
+		cf-&gt;data[6] = bec.txerr;
+		cf-&gt;data[7] = bec.rxerr;
+
+		break;
+	case C_CAN_ERROR_PASSIVE:
+		/* error passive state */
+		priv-&gt;can.can_stats.error_passive++;
+		priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
+		cf-&gt;can_id |= CAN_ERR_CRTL;
+		if (rx_err_passive)
+			cf-&gt;data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
+		if (bec.txerr &gt; 127)
+			cf-&gt;data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
+
+		cf-&gt;data[6] = bec.txerr;
+		cf-&gt;data[7] = bec.rxerr;
+		break;
+	case C_CAN_BUS_OFF:
+		/* bus-off state */
+		priv-&gt;can.state = CAN_STATE_BUS_OFF;
+		cf-&gt;can_id |= CAN_ERR_BUSOFF;
+		/*
+		 * disable all interrupts in bus-off mode to ensure that
+		 * the CPU is not hogged down
+		 */
+		c_can_enable_all_interrupts(priv, DISABLE_ALL_INTERRUPTS);
+		can_bus_off(dev);
+		break;
+	default:
+		break;
+	}
+
+	netif_receive_skb(skb);
+	stats-&gt;rx_packets++;
+	stats-&gt;rx_bytes += cf-&gt;can_dlc;
+
+	return 1;
+}
+
+static int c_can_handle_bus_err(struct net_device *dev,
+				enum c_can_lec_type lec_type)
+{
+	struct c_can_priv *priv = netdev_priv(dev);
+	struct net_device_stats *stats = &amp;dev-&gt;stats;
+	struct can_frame *cf;
+	struct sk_buff *skb;
+
+	/*
+	 * early exit if no lec update or no error.
+	 * no lec update means that no CAN bus event has been detected
+	 * since CPU wrote 0x7 value to status reg.
+	 */
+	if (lec_type == LEC_UNUSED || lec_type == LEC_NO_ERROR)
+		return 0;
+
+	/* propogate the error condition to the CAN stack */
+	skb = alloc_can_err_skb(dev, &amp;cf);
+	if (unlikely(!skb))
+		return 0;
+
+	/*
+	 * check for 'last error code' which tells us the
+	 * type of the last error to occur on the CAN bus
+	 */
+
+	/* common for all type of bus errors */
+	priv-&gt;can.can_stats.bus_error++;
+	stats-&gt;rx_errors++;
+	cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
+	cf-&gt;data[2] |= CAN_ERR_PROT_UNSPEC;
+
+	switch (lec_type) {
+	case LEC_STUFF_ERROR:
+		netdev_dbg(dev, &quot;stuff error\n&quot;);
+		cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
+		break;
+	case LEC_FORM_ERROR:
+		netdev_dbg(dev, &quot;form error\n&quot;);
+		cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
+		break;
+	case LEC_ACK_ERROR:
+		netdev_dbg(dev, &quot;ack error\n&quot;);
+		cf-&gt;data[2] |= (CAN_ERR_PROT_LOC_ACK |
+				CAN_ERR_PROT_LOC_ACK_DEL);
+		break;
+	case LEC_BIT1_ERROR:
+		netdev_dbg(dev, &quot;bit1 error\n&quot;);
+		cf-&gt;data[2] |= CAN_ERR_PROT_BIT1;
+		break;
+	case LEC_BIT0_ERROR:
+		netdev_dbg(dev, &quot;bit0 error\n&quot;);
+		cf-&gt;data[2] |= CAN_ERR_PROT_BIT0;
+		break;
+	case LEC_CRC_ERROR:
+		netdev_dbg(dev, &quot;CRC error\n&quot;);
+		cf-&gt;data[2] |= (CAN_ERR_PROT_LOC_CRC_SEQ |
+				CAN_ERR_PROT_LOC_CRC_DEL);
+		break;
+	default:
+		break;
+	}
+
+	/* set a `lec` value so that we can check for updates later */
+	priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;status, LEC_UNUSED);
+
+	netif_receive_skb(skb);
+	stats-&gt;rx_packets++;
+	stats-&gt;rx_bytes += cf-&gt;can_dlc;
+
+	return 1;
+}
+
+static int c_can_poll(struct napi_struct *napi, int quota)
+{
+	u16 irqstatus;
+	int lec_type = 0;
+	int work_done = 0;
+	struct net_device *dev = napi-&gt;dev;
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	irqstatus = priv-&gt;read_reg(priv, &amp;priv-&gt;regs-&gt;interrupt);
+	if (!irqstatus)
+		goto end;
+
+	/* status events have the highest priority */
+	if (irqstatus == STATUS_INTERRUPT) {
+		priv-&gt;current_status = priv-&gt;read_reg(priv,
+					&amp;priv-&gt;regs-&gt;status);
+
+		/* handle Tx/Rx events */
+		if (priv-&gt;current_status &amp; STATUS_TXOK)
+			priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;status,
+					priv-&gt;current_status &amp; ~STATUS_TXOK);
+
+		if (priv-&gt;current_status &amp; STATUS_RXOK)
+			priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;status,
+					priv-&gt;current_status &amp; ~STATUS_RXOK);
+
+		/* handle state changes */
+		if ((priv-&gt;current_status &amp; STATUS_EWARN) &amp;&amp;
+				(!(priv-&gt;last_status &amp; STATUS_EWARN))) {
+			netdev_dbg(dev, &quot;entered error warning state\n&quot;);
+			work_done += c_can_handle_state_change(dev,
+						C_CAN_ERROR_WARNING);
+		}
+		if ((priv-&gt;current_status &amp; STATUS_EPASS) &amp;&amp;
+				(!(priv-&gt;last_status &amp; STATUS_EPASS))) {
+			netdev_dbg(dev, &quot;entered error passive state\n&quot;);
+			work_done += c_can_handle_state_change(dev,
+						C_CAN_ERROR_PASSIVE);
+		}
+		if ((priv-&gt;current_status &amp; STATUS_BOFF) &amp;&amp;
+				(!(priv-&gt;last_status &amp; STATUS_BOFF))) {
+			netdev_dbg(dev, &quot;entered bus off state\n&quot;);
+			work_done += c_can_handle_state_change(dev,
+						C_CAN_BUS_OFF);
+		}
+
+		/* handle bus recovery events */
+		if ((!(priv-&gt;current_status &amp; STATUS_BOFF)) &amp;&amp;
+				(priv-&gt;last_status &amp; STATUS_BOFF)) {
+			netdev_dbg(dev, &quot;left bus off state\n&quot;);
+			priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
+		}
+		if ((!(priv-&gt;current_status &amp; STATUS_EPASS)) &amp;&amp;
+				(priv-&gt;last_status &amp; STATUS_EPASS)) {
+			netdev_dbg(dev, &quot;left error passive state\n&quot;);
+			priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
+		}
+
+		priv-&gt;last_status = priv-&gt;current_status;
+
+		/* handle lec errors on the bus */
+		lec_type = c_can_has_and_handle_berr(priv);
+		if (lec_type)
+			work_done += c_can_handle_bus_err(dev, lec_type);
+	} else if ((irqstatus &gt;= C_CAN_MSG_OBJ_RX_FIRST) &amp;&amp;
+			(irqstatus &lt;= C_CAN_MSG_OBJ_RX_LAST)) {
+		/* handle events corresponding to receive message objects */
+		work_done += c_can_do_rx_poll(dev, (quota - work_done));
+	} else if ((irqstatus &gt;= C_CAN_MSG_OBJ_TX_FIRST) &amp;&amp;
+			(irqstatus &lt;= C_CAN_MSG_OBJ_TX_LAST)) {
+		/* handle events corresponding to transmit message objects */
+		c_can_do_tx(dev);
+	}
+
+end:
+	if (work_done &lt; quota) {
+		napi_complete(napi);
+		/* enable all IRQs */
+		c_can_enable_all_interrupts(priv, ENABLE_ALL_INTERRUPTS);
+	}
+
+	return work_done;
+}
+
+static irqreturn_t c_can_isr(int irq, void *dev_id)
+{
+	u16 irqstatus;
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	irqstatus = priv-&gt;read_reg(priv, &amp;priv-&gt;regs-&gt;interrupt);
+	if (!irqstatus)
+		return IRQ_NONE;
+
+	/* disable all interrupts and schedule the NAPI */
+	c_can_enable_all_interrupts(priv, DISABLE_ALL_INTERRUPTS);
+	napi_schedule(&amp;priv-&gt;napi);
+
+	return IRQ_HANDLED;
+}
+
+static int c_can_open(struct net_device *dev)
+{
+	int err;
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	/* open the can device */
+	err = open_candev(dev);
+	if (err) {
+		netdev_err(dev, &quot;failed to open can device\n&quot;);
+		return err;
+	}
+
+	/* register interrupt handler */
+	err = request_irq(dev-&gt;irq, &amp;c_can_isr, IRQF_SHARED, dev-&gt;name,
+				dev);
+	if (err &lt; 0) {
+		netdev_err(dev, &quot;failed to request interrupt\n&quot;);
+		goto exit_irq_fail;
+	}
+
+	/* start the c_can controller */
+	c_can_start(dev);
+
+	napi_enable(&amp;priv-&gt;napi);
+	netif_start_queue(dev);
+
+	return 0;
+
+exit_irq_fail:
+	close_candev(dev);
+	return err;
+}
+
+static int c_can_close(struct net_device *dev)
+{
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	netif_stop_queue(dev);
+	napi_disable(&amp;priv-&gt;napi);
+	c_can_stop(dev);
+	free_irq(dev-&gt;irq, dev);
+	close_candev(dev);
+
+	return 0;
+}
+
+struct net_device *alloc_c_can_dev(void)
+{
+	struct net_device *dev;
+	struct c_can_priv *priv;
+
+	dev = alloc_candev(sizeof(struct c_can_priv), C_CAN_MSG_OBJ_TX_NUM);
+	if (!dev)
+		return NULL;
+
+	priv = netdev_priv(dev);
+	netif_napi_add(dev, &amp;priv-&gt;napi, c_can_poll, C_CAN_NAPI_WEIGHT);
+
+	priv-&gt;dev = dev;
+	priv-&gt;can.bittiming_const = &amp;c_can_bittiming_const;
+	priv-&gt;can.do_set_mode = c_can_set_mode;
+	priv-&gt;can.do_get_berr_counter = c_can_get_berr_counter;
+	priv-&gt;can.ctrlmode_supported = CAN_CTRLMODE_ONE_SHOT |
+					CAN_CTRLMODE_LOOPBACK |
+					CAN_CTRLMODE_LISTENONLY |
+					CAN_CTRLMODE_BERR_REPORTING;
+
+	return dev;
+}
+EXPORT_SYMBOL_GPL(alloc_c_can_dev);
+
+void free_c_can_dev(struct net_device *dev)
+{
+	free_candev(dev);
+}
+EXPORT_SYMBOL_GPL(free_c_can_dev);
+
+static const struct net_device_ops c_can_netdev_ops = {
+	.ndo_open = c_can_open,
+	.ndo_stop = c_can_close,
+	.ndo_start_xmit = c_can_start_xmit,
+};
+
+int register_c_can_dev(struct net_device *dev)
+{
+	dev-&gt;flags |= IFF_ECHO;	/* we support local echo */
+	dev-&gt;netdev_ops = &amp;c_can_netdev_ops;
+
+	return register_candev(dev);
+}
+EXPORT_SYMBOL_GPL(register_c_can_dev);
+
+void unregister_c_can_dev(struct net_device *dev)
+{
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	/* disable all interrupts */
+	c_can_enable_all_interrupts(priv, DISABLE_ALL_INTERRUPTS);
+
+	unregister_candev(dev);
+}
+EXPORT_SYMBOL_GPL(unregister_c_can_dev);
+
+MODULE_AUTHOR(&quot;Bhupesh Sharma &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">bhupesh.sharma at st.com</A>&gt;&quot;);
+MODULE_LICENSE(&quot;GPL v2&quot;);
+MODULE_DESCRIPTION(&quot;CAN bus driver for Bosch C_CAN controller&quot;);
diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
new file mode 100644
index 0000000..9b7fbef
--- /dev/null
+++ b/drivers/net/can/c_can/c_can.h
@@ -0,0 +1,86 @@
+/*
+ * CAN bus driver for Bosch C_CAN controller
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Bhupesh Sharma &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">bhupesh.sharma at st.com</A>&gt;
+ *
+ * Borrowed heavily from the C_CAN driver originally written by:
+ * Copyright (C) 2007
+ * - Sascha Hauer, Marc Kleine-Budde, Pengutronix &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">s.hauer at pengutronix.de</A>&gt;
+ * - Simon Kallweit, intefo AG &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">simon.kallweit at intefo.ch</A>&gt;
+ *
+ * Bosch C_CAN controller is compliant to CAN protocol version 2.0 part A and B.
+ * Bosch C_CAN user manual can be obtained from:
+ * <A HREF="http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/">http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/</A>
+ * users_manual_c_can.pdf
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed &quot;as is&quot; without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef C_CAN_H
+#define C_CAN_H
+
+/* c_can IF registers */
+struct c_can_if_regs {
+	u16 com_req;
+	u16 com_mask;
+	u16 mask1;
+	u16 mask2;
+	u16 arb1;
+	u16 arb2;
+	u16 msg_cntrl;
+	u16 data[4];
+	u16 _reserved[13];
+};
+
+/* c_can hardware registers */
+struct c_can_regs {
+	u16 control;
+	u16 status;
+	u16 err_cnt;
+	u16 btr;
+	u16 interrupt;
+	u16 test;
+	u16 brp_ext;
+	u16 _reserved1;
+	struct c_can_if_regs ifregs[2]; /* [0] = IF1 and [1] = IF2 */
+	u16 _reserved2[8];
+	u16 txrqst1;
+	u16 txrqst2;
+	u16 _reserved3[6];
+	u16 newdat1;
+	u16 newdat2;
+	u16 _reserved4[6];
+	u16 intpnd1;
+	u16 intpnd2;
+	u16 _reserved5[6];
+	u16 msgval1;
+	u16 msgval2;
+	u16 _reserved6[6];
+};
+
+/* c_can private data structure */
+struct c_can_priv {
+	struct can_priv can;	/* must be the first member */
+	struct napi_struct napi;
+	struct net_device *dev;
+	int tx_object;
+	int current_status;
+	int last_status;
+	u16 (*read_reg) (struct c_can_priv *priv, void *reg);
+	void (*write_reg) (struct c_can_priv *priv, void *reg, u16 val);
+	struct c_can_regs __iomem *regs;
+	unsigned long irq_flags; /* for request_irq() */
+	unsigned int tx_next;
+	unsigned int tx_echo;
+	void *priv;		/* for board-specific data */
+};
+
+struct net_device *alloc_c_can_dev(void);
+void free_c_can_dev(struct net_device *dev);
+int register_c_can_dev(struct net_device *dev);
+void unregister_c_can_dev(struct net_device *dev);
+
+#endif /* C_CAN_H */
diff --git a/drivers/net/can/c_can/c_can_platform.c b/drivers/net/can/c_can/c_can_platform.c
new file mode 100644
index 0000000..0fc314e
--- /dev/null
+++ b/drivers/net/can/c_can/c_can_platform.c
@@ -0,0 +1,207 @@
+/*
+ * Platform CAN bus driver for Bosch C_CAN controller
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Bhupesh Sharma &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">bhupesh.sharma at st.com</A>&gt;
+ *
+ * Borrowed heavily from the C_CAN driver originally written by:
+ * Copyright (C) 2007
+ * - Sascha Hauer, Marc Kleine-Budde, Pengutronix &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">s.hauer at pengutronix.de</A>&gt;
+ * - Simon Kallweit, intefo AG &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">simon.kallweit at intefo.ch</A>&gt;
+ *
+ * Bosch C_CAN controller is compliant to CAN protocol version 2.0 part A and B.
+ * Bosch C_CAN user manual can be obtained from:
+ * <A HREF="http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/">http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/</A>
+ * users_manual_c_can.pdf
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed &quot;as is&quot; without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/version.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/delay.h&gt;
+#include &lt;linux/netdevice.h&gt;
+#include &lt;linux/if_arp.h&gt;
+#include &lt;linux/if_ether.h&gt;
+#include &lt;linux/list.h&gt;
+#include &lt;linux/delay.h&gt;
+#include &lt;linux/io.h&gt;
+#include &lt;linux/platform_device.h&gt;
+#include &lt;linux/clk.h&gt;
+
+#include &lt;linux/can/dev.h&gt;
+
+#include &quot;c_can.h&quot;
+
+/*
+ * 16-bit c_can registers can be arranged differently in the memory
+ * architecture of different implementations. For example: 16-bit
+ * registers can be aligned to a 16-bit boundary or 32-bit boundary etc.
+ * Handle the same by providing a common read/write interface.
+ */
+static u16 c_can_plat_read_reg_aligned_to_16bit(struct c_can_priv *priv,
+						void *reg)
+{
+	return readw(reg);
+}
+
+static void c_can_plat_write_reg_aligned_to_16bit(struct c_can_priv *priv,
+						void *reg, u16 val)
+{
+	writew(val, reg);
+}
+
+static u16 c_can_plat_read_reg_aligned_to_32bit(struct c_can_priv *priv,
+						void *reg)
+{
+	return readw(reg + (long)reg - (long)priv-&gt;regs);
+}
+
+static void c_can_plat_write_reg_aligned_to_32bit(struct c_can_priv *priv,
+						void *reg, u16 val)
+{
+	writew(val, reg + (long)reg - (long)priv-&gt;regs);
+}
+
+static int __devinit c_can_plat_probe(struct platform_device *pdev)
+{
+	int ret;
+	void __iomem *addr;
+	struct net_device *dev;
+	struct c_can_priv *priv;
+	struct resource *mem, *irq;
+	struct clk *clk;
+
+	/* get the appropriate clk */
+	clk = clk_get(&amp;pdev-&gt;dev, NULL);
+	if (IS_ERR(clk)) {
+		dev_err(&amp;pdev-&gt;dev, &quot;no clock defined\n&quot;);
+		ret = -ENODEV;
+		goto exit;
+	}
+
+	/* get the platform data */
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!mem || (irq &lt;= 0)) {
+		ret = -ENODEV;
+		goto exit_free_clk;
+	}
+
+	if (!request_mem_region(mem-&gt;start, resource_size(mem),
+				KBUILD_MODNAME)) {
+		dev_err(&amp;pdev-&gt;dev, &quot;resource unavailable\n&quot;);
+		ret = -ENODEV;
+		goto exit_free_clk;
+	}
+
+	addr = ioremap(mem-&gt;start, resource_size(mem));
+	if (!addr) {
+		dev_err(&amp;pdev-&gt;dev, &quot;failed to map can port\n&quot;);
+		ret = -ENOMEM;
+		goto exit_release_mem;
+	}
+
+	/* allocate the c_can device */
+	dev = alloc_c_can_dev();
+	if (!dev) {
+		ret = -ENOMEM;
+		goto exit_iounmap;
+	}
+
+	priv = netdev_priv(dev);
+
+	dev-&gt;irq = irq-&gt;start;
+	priv-&gt;regs = addr;
+	priv-&gt;can.clock.freq = clk_get_rate(clk);
+	priv-&gt;priv = clk;
+
+	switch (mem-&gt;flags &amp; IORESOURCE_MEM_TYPE_MASK) {
+	case IORESOURCE_MEM_32BIT:
+		priv-&gt;read_reg = c_can_plat_read_reg_aligned_to_32bit;
+		priv-&gt;write_reg = c_can_plat_write_reg_aligned_to_32bit;
+		break;
+	case IORESOURCE_MEM_16BIT:
+	default:
+		priv-&gt;read_reg = c_can_plat_read_reg_aligned_to_16bit;
+		priv-&gt;write_reg = c_can_plat_write_reg_aligned_to_16bit;
+		break;
+	}
+
+	platform_set_drvdata(pdev, dev);
+	SET_NETDEV_DEV(dev, &amp;pdev-&gt;dev);
+
+	ret = register_c_can_dev(dev);
+	if (ret) {
+		dev_err(&amp;pdev-&gt;dev, &quot;registering %s failed (err=%d)\n&quot;,
+			KBUILD_MODNAME, ret);
+		goto exit_free_device;
+	}
+
+	dev_info(&amp;pdev-&gt;dev, &quot;%s device registered (regs=%p, irq=%d)\n&quot;,
+		 KBUILD_MODNAME, priv-&gt;regs, dev-&gt;irq);
+	return 0;
+
+exit_free_device:
+	platform_set_drvdata(pdev, NULL);
+	free_c_can_dev(dev);
+exit_iounmap:
+	iounmap(addr);
+exit_release_mem:
+	release_mem_region(mem-&gt;start, resource_size(mem));
+exit_free_clk:
+	clk_put(clk);
+exit:
+	dev_err(&amp;pdev-&gt;dev, &quot;probe failed\n&quot;);
+
+	return ret;
+}
+
+static int __devexit c_can_plat_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct c_can_priv *priv = netdev_priv(dev);
+	struct resource *mem;
+
+	unregister_c_can_dev(dev);
+	platform_set_drvdata(pdev, NULL);
+
+	free_c_can_dev(dev);
+	iounmap(priv-&gt;regs);
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(mem-&gt;start, resource_size(mem));
+
+	clk_put(priv-&gt;priv);
+
+	return 0;
+}
+
+static struct platform_driver c_can_plat_driver = {
+	.driver = {
+		.name = KBUILD_MODNAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = c_can_plat_probe,
+	.remove = __devexit_p(c_can_plat_remove),
+};
+
+static int __init c_can_plat_init(void)
+{
+	return platform_driver_register(&amp;c_can_plat_driver);
+}
+module_init(c_can_plat_init);
+
+static void __exit c_can_plat_exit(void)
+{
+	platform_driver_unregister(&amp;c_can_plat_driver);
+}
+module_exit(c_can_plat_exit);
+
+MODULE_AUTHOR(&quot;Bhupesh Sharma &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">bhupesh.sharma at st.com</A>&gt;&quot;);
+MODULE_LICENSE(&quot;GPL v2&quot;);
+MODULE_DESCRIPTION(&quot;Platform CAN bus driver for Bosch C_CAN controller&quot;);
-- 
1.6.0.2


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005509.html">[PATCH] pch_can: fix tseg1/tseg2 setting issue
</A></li>
	<LI>Next message: <A HREF="005523.html">[PATCH net-next-2.6 v7 1/1] can: c_can: Added support for Bosch	C_CAN	controller
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5514">[ date ]</a>
              <a href="thread.html#5514">[ thread ]</a>
              <a href="subject.html#5514">[ subject ]</a>
              <a href="author.html#5514">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
