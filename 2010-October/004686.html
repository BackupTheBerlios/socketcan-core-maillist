<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [MeeGo-Dev][PATCH v3] Topcliff: Update PCH_CAN driver to 2.6.35
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2010-October/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BMeeGo-Dev%5D%5BPATCH%20v3%5D%20Topcliff%3A%20Update%20PCH_CAN%20driver%20to%202.6.35&In-Reply-To=%3C000401cb614f%24c932c750%2466f8800a%40maildom.okisemi.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="004687.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[MeeGo-Dev][PATCH v3] Topcliff: Update PCH_CAN driver to 2.6.35</H1>
    <B>Masayuki Ohtake</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BMeeGo-Dev%5D%5BPATCH%20v3%5D%20Topcliff%3A%20Update%20PCH_CAN%20driver%20to%202.6.35&In-Reply-To=%3C000401cb614f%24c932c750%2466f8800a%40maildom.okisemi.com%3E"
       TITLE="[MeeGo-Dev][PATCH v3] Topcliff: Update PCH_CAN driver to 2.6.35">masa-korg at dsn.okisemi.com
       </A><BR>
    <I>Fri Oct  1 12:02:36 CEST 2010</I>
    <P><UL>
        
        <LI>Next message: <A HREF="004687.html">[MeeGo-Dev][PATCH v3] Topcliff: Update PCH_CAN driver to 2.6.35
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4686">[ date ]</a>
              <a href="thread.html#4686">[ thread ]</a>
              <a href="subject.html#4686">[ subject ]</a>
              <a href="author.html#4686">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Wolfgang Grandegger,

Thank you for your comments.

We will modify and re-post ASAP.

I have a comment about below.
&gt;<i> In this driver you are using just *one* RX object. This means that the
</I>&gt;<i> CPU must handle new messages as quickly as possible otherwise message
</I>&gt;<i> losses will happen, right?. For sure, this will not make user's happy.
</I>&gt;<i> Any chance to use more RX objects in FIFO mode?
</I>
In case implementing with FIFO mode,
received packets may be our of order.
Because our CAN register access is slow.

I am confirming our CAN HW spec and the possibility of our-of-order.

Thanks, Ohtake(OKISemi)
---- Original Message ----- 
From: &quot;Wolfgang Grandegger&quot; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">wg at grandegger.com</A>&gt;
To: &quot;Masayuki Ohtak&quot; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">masa-korg at dsn.okisemi.com</A>&gt;
Cc: &quot;David S. Miller&quot; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">davem at davemloft.net</A>&gt;; &quot;Wolfram Sang&quot; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">w.sang at pengutronix.de</A>&gt;; &quot;Christian Pellegrin&quot;
&lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">chripell at fsfe.org</A>&gt;; &quot;Barry Song&quot; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">21cnbao at gmail.com</A>&gt;; &quot;Samuel Ortiz&quot; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">sameo at linux.intel.com</A>&gt;;
&lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">socketcan-core at lists.berlios.de</A>&gt;; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">netdev at vger.kernel.org</A>&gt;; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">linux-kernel at vger.kernel.org</A>&gt;; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">meego-dev at meego.com</A>&gt;;
&lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">andrew.chih.howe.khor at intel.com</A>&gt;; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">qi.wang at intel.com</A>&gt;; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">margie.foster at intel.com</A>&gt;; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">yong.y.wang at intel.com</A>&gt;;
&lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kok.howg.ewe at intel.com</A>&gt;; &quot;Tomoya MORINAGA&quot; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">morinaga526 at dsn.okisemi.com</A>&gt;; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">joel.clark at intel.com</A>&gt;
Sent: Thursday, September 30, 2010 6:10 PM
Subject: Re: [MeeGo-Dev][PATCH v3] Topcliff: Update PCH_CAN driver to 2.6.35


&gt;<i> Hi Ohtake,
</I>&gt;<i>
</I>&gt;<i> here comes my review, sorry for delay.
</I>&gt;<i>
</I>&gt;<i> On 09/24/2010 12:24 PM, Masayuki Ohtak wrote:
</I>&gt;<i> &gt; Hi Wolfgang and Marc,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; We have modified a pretty amount of our driver based on other accepted Socket CAN driver.
</I>&gt;<i> &gt; Additionally, We have reduced the number of lines 3601 to 1444.
</I>&gt;<i>
</I>&gt;<i> Much better, but I believe it could be reduced even further.
</I>&gt;<i>
</I>&gt;<i> &gt; Please check below.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Thanks, Ohtake(OKISemi)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; ---
</I>&gt;<i> &gt; CAN driver of Topcliff PCH
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Topcliff PCH is the platform controller hub that is going to be used in
</I>&gt;<i> &gt; Intel's upcoming general embedded platform. All IO peripherals in
</I>&gt;<i> &gt; Topcliff PCH are actually devices sitting on AMBA bus.
</I>&gt;<i> &gt; Topcliff PCH has CAN I/F. This driver enables CAN function.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Signed-off-by: Masayuki Ohtake &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">masa-korg at dsn.okisemi.com</A>&gt;
</I>&gt;<i> &gt; ---
</I>&gt;<i> &gt;  drivers/net/can/Kconfig   |    8 +
</I>&gt;<i> &gt;  drivers/net/can/Makefile  |    1 +
</I>&gt;<i> &gt;  drivers/net/can/pch_can.c | 1444 +++++++++++++++++++++++++++++++++++++++++++++
</I>&gt;<i> &gt;  3 files changed, 1453 insertions(+), 0 deletions(-)
</I>&gt;<i> &gt;  create mode 100644 drivers/net/can/pch_can.c
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
</I>&gt;<i> &gt; index 2c5227c..5c98a20 100644
</I>&gt;<i> &gt; --- a/drivers/net/can/Kconfig
</I>&gt;<i> &gt; +++ b/drivers/net/can/Kconfig
</I>&gt;<i> &gt; @@ -73,6 +73,14 @@ config CAN_JANZ_ICAN3
</I>&gt;<i> &gt;    This driver can also be built as a module. If so, the module will be
</I>&gt;<i> &gt;    called janz-ican3.ko.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; +config PCH_CAN
</I>&gt;<i> &gt; + tristate &quot;PCH CAN&quot;
</I>&gt;<i> &gt; + depends on  CAN_DEV
</I>&gt;<i> &gt; + ---help---
</I>&gt;<i> &gt; +   This driver is for PCH CAN of Topcliff which is an IOH for x86
</I>&gt;<i> &gt; +   embedded processor.
</I>&gt;<i> &gt; +   This driver can access CAN bus.
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt;  source &quot;drivers/net/can/mscan/Kconfig&quot;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;  source &quot;drivers/net/can/sja1000/Kconfig&quot;
</I>&gt;<i> &gt; diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
</I>&gt;<i> &gt; index 9047cd0..3ddc6a7 100644
</I>&gt;<i> &gt; --- a/drivers/net/can/Makefile
</I>&gt;<i> &gt; +++ b/drivers/net/can/Makefile
</I>&gt;<i> &gt; @@ -16,5 +16,6 @@ obj-$(CONFIG_CAN_TI_HECC) += ti_hecc.o
</I>&gt;<i> &gt;  obj-$(CONFIG_CAN_MCP251X) += mcp251x.o
</I>&gt;<i> &gt;  obj-$(CONFIG_CAN_BFIN) += bfin_can.o
</I>&gt;<i> &gt;  obj-$(CONFIG_CAN_JANZ_ICAN3) += janz-ican3.o
</I>&gt;<i> &gt; +obj-$(CONFIG_PCH_CAN) += pch_can.o
</I>&gt;<i>
</I>&gt;<i> Please provide patches against David Millers &quot;net-next-2.6&quot; GIT tree and
</I>&gt;<i> use the prefix &quot;can: &quot; in your subject next time. See
</I>&gt;<i> <A HREF="http://svn.berlios.de/wsvn/socketcan/trunk/README.submitting-patches">http://svn.berlios.de/wsvn/socketcan/trunk/README.submitting-patches</A>
</I>&gt;<i> for further information.
</I>&gt;<i>
</I>&gt;<i> &gt;  ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
</I>&gt;<i> &gt; diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
</I>&gt;<i> &gt; new file mode 100644
</I>&gt;<i> &gt; index 0000000..8c1731b
</I>&gt;<i> &gt; --- /dev/null
</I>&gt;<i> &gt; +++ b/drivers/net/can/pch_can.c
</I>&gt;<i> &gt; @@ -0,0 +1,1444 @@
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * Copyright (C) 1999 - 2010 Intel Corporation.
</I>&gt;<i> &gt; + * Copyright (C) 2010 OKI SEMICONDUCTOR Co., LTD.
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * This program is free software; you can redistribute it and/or modify
</I>&gt;<i> &gt; + * it under the terms of the GNU General Public License as published by
</I>&gt;<i> &gt; + * the Free Software Foundation; version 2 of the License.
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * This program is distributed in the hope that it will be useful,
</I>&gt;<i> &gt; + * but WITHOUT ANY WARRANTY; without even the implied warranty of
</I>&gt;<i> &gt; + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</I>&gt;<i> &gt; + * GNU General Public License for more details.
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * You should have received a copy of the GNU General Public License
</I>&gt;<i> &gt; + * along with this program; if not, write to the Free Software
</I>&gt;<i> &gt; + * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#include &lt;linux/interrupt.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/delay.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/io.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/module.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/sched.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/pci.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/init.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/kernel.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/types.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/errno.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/skbuff.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/can.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/can/dev.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/can/error.h&gt;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#define MAX_BITRATE 0x3e8
</I>&gt;<i>
</I>&gt;<i> Dead code? At least it's not used anywhere.
</I>&gt;<i>
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#define MAX_MSG_OBJ 32
</I>&gt;<i> &gt; +#define MSG_OBJ_RX 0 /* The receive message object flag. */
</I>&gt;<i> &gt; +#define MSG_OBJ_TX 1 /* The transmit message object flag. */
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#define ENABLE 1 /* The enable flag */
</I>&gt;<i> &gt; +#define DISABLE 0 /* The disable flag */
</I>&gt;<i> &gt; +#define CAN_CTRL_INIT 0x0001 /* The INIT bit of CANCONT register. */
</I>&gt;<i> &gt; +#define CAN_CTRL_IE 0x0002 /* The IE bit of CAN control register */
</I>&gt;<i> &gt; +#define CAN_CTRL_IE_SIE_EIE 0x000e
</I>&gt;<i> &gt; +#define CAN_CTRL_CCE 0x0040
</I>&gt;<i> &gt; +#define CAN_CTRL_OPT 0x0080 /* The OPT bit of CANCONT register. */
</I>&gt;<i> &gt; +#define CAN_OPT_SILENT 0x0008 /* The Silent bit of CANOPT reg. */
</I>&gt;<i> &gt; +#define CAN_OPT_LBACK 0x0010 /* The LoopBack bit of CANOPT reg. */
</I>&gt;<i> &gt; +#define CAN_CMASK_RX_TX_SET 0x00f3
</I>&gt;<i> &gt; +#define CAN_CMASK_RX_TX_GET 0x0073
</I>&gt;<i> &gt; +#define CAN_CMASK_ALL 0xff
</I>&gt;<i> &gt; +#define CAN_CMASK_RDWR 0x80
</I>&gt;<i> &gt; +#define CAN_CMASK_ARB 0x20
</I>&gt;<i> &gt; +#define CAN_CMASK_CTRL 0x10
</I>&gt;<i> &gt; +#define CAN_CMASK_MASK 0x40
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#define CAN_IF_MCONT_NEWDAT 0x8000
</I>&gt;<i> &gt; +#define CAN_IF_MCONT_INTPND 0x2000
</I>&gt;<i> &gt; +#define CAN_IF_MCONT_UMASK 0x1000
</I>&gt;<i> &gt; +#define CAN_IF_MCONT_TXIE 0x0800
</I>&gt;<i> &gt; +#define CAN_IF_MCONT_RXIE 0x0400
</I>&gt;<i> &gt; +#define CAN_IF_MCONT_RMTEN 0x0200
</I>&gt;<i> &gt; +#define CAN_IF_MCONT_TXRQXT 0x0100
</I>&gt;<i> &gt; +#define CAN_IF_MCONT_EOB 0x0080
</I>&gt;<i> &gt; +#define CAN_IF_MCONT_MSGLOST 0x4000
</I>&gt;<i> &gt; +#define CAN_MASK2_MDIR_MXTD 0xc000
</I>&gt;<i> &gt; +#define CAN_ID2_DIR 0x2000
</I>&gt;<i> &gt; +#define CAN_ID_MSGVAL 0x8000
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#define CAN_STATUS_INT 0x8000
</I>&gt;<i> &gt; +#define CAN_IF_CREQ_BUSY 0x8000
</I>&gt;<i> &gt; +#define CAN_ID2_XTD 0x4000
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#define CAN_REC 0x00007f00
</I>&gt;<i> &gt; +#define CAN_TEC 0x000000ff
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#define PCH_RX_OK 0x00000010
</I>&gt;<i> &gt; +#define PCH_TX_OK 0x00000008
</I>&gt;<i> &gt; +#define PCH_BUS_OFF 0x00000080
</I>&gt;<i> &gt; +#define PCH_EWARN 0x00000040
</I>&gt;<i> &gt; +#define PCH_EPASSIV 0x00000020
</I>&gt;<i>
</I>&gt;<i> &gt; +#define PCH_LEC0 0x00000001
</I>&gt;<i> &gt; +#define PCH_LEC1 0x00000002
</I>&gt;<i> &gt; +#define PCH_LEC2 0x00000004
</I>&gt;<i> &gt; +#define PCH_LEC_ALL (PCH_LEC0 | PCH_LEC1 | PCH_LEC2)
</I>&gt;<i> &gt; +#define PCH_STUF_ERR PCH_LEC0
</I>&gt;<i> &gt; +#define PCH_FORM_ERR PCH_LEC1
</I>&gt;<i> &gt; +#define PCH_ACK_ERR (PCH_LEC0 | PCH_LEC1)
</I>&gt;<i> &gt; +#define PCH_BIT1_ERR PCH_LEC2
</I>&gt;<i> &gt; +#define PCH_BIT0_ERR (PCH_LEC0 | PCH_LEC2)
</I>&gt;<i> &gt; +#define PCH_CRC_ERR (PCH_LEC1 | PCH_LEC2)
</I>&gt;<i>
</I>&gt;<i> enum {
</I>&gt;<i>   PCH_LEC_STUF_ERR = 0,
</I>&gt;<i> PCH_LEC_FORM_ERR,
</I>&gt;<i> PCH_LEC_ACK_ERR,
</I>&gt;<i> ...
</I>&gt;<i> PCH_LEC_ALL
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> Seems more appropriate. More comments below.
</I>&gt;<i>
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* bit position of certain controller bits. */
</I>&gt;<i> &gt; +#define BIT_BITT_BRP 0
</I>&gt;<i> &gt; +#define BIT_BITT_SJW 6
</I>&gt;<i> &gt; +#define BIT_BITT_TSEG1 8
</I>&gt;<i> &gt; +#define BIT_BITT_TSEG2 12
</I>&gt;<i> &gt; +#define BIT_IF1_MCONT_RXIE 10
</I>&gt;<i> &gt; +#define BIT_IF2_MCONT_TXIE 11
</I>&gt;<i> &gt; +#define BIT_BRPE_BRPE 6
</I>&gt;<i> &gt; +#define BIT_ES_TXERRCNT 0
</I>&gt;<i> &gt; +#define BIT_ES_RXERRCNT 8
</I>&gt;<i> &gt; +#define MSK_BITT_BRP 0x3f
</I>&gt;<i> &gt; +#define MSK_BITT_SJW 0xc0
</I>&gt;<i> &gt; +#define MSK_BITT_TSEG1 0xf00
</I>&gt;<i> &gt; +#define MSK_BITT_TSEG2 0x7000
</I>&gt;<i> &gt; +#define MSK_BRPE_BRPE 0x3c0
</I>&gt;<i> &gt; +#define MSK_BRPE_GET 0x0f
</I>&gt;<i> &gt; +#define MSK_CTRL_IE_SIE_EIE 0x07
</I>&gt;<i> &gt; +#define MSK_MCONT_TXIE 0x08
</I>&gt;<i> &gt; +#define MSK_MCONT_RXIE 0x10
</I>&gt;<i> &gt; +#define PCH_CAN_NO_TX_BUFF 1
</I>&gt;<i> &gt; +#define PCI_DEVICE_ID_INTEL_PCH1_CAN 0x8818
</I>&gt;<i> &gt; +#define COUNTER_LIMIT 0xFFFF
</I>&gt;<i>
</I>&gt;<i> Keep alignment?
</I>&gt;<i>
</I>&gt;<i> &gt; +#define PCH_CAN_CLK 50000 /* 50MHz */
</I>&gt;<i>
</I>&gt;<i> Please specify it in Hz already here.
</I>&gt;<i>
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* Total 32 OBJs */
</I>&gt;<i> &gt; +#define PCH_RX_OBJ_NUM 1
</I>&gt;<i> &gt; +#define PCH_TX_OBJ_NUM 1
</I>&gt;<i> &gt; +#define PCH_OBJ_NUM (PCH_TX_OBJ_NUM + PCH_RX_OBJ_NUM)
</I>&gt;<i>
</I>&gt;<i> Please explain biefly what message object are use for what purpose.
</I>&gt;<i> Either here or in the initialization code.
</I>&gt;<i>
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#define PCH_CAN_ACTIVE 0
</I>&gt;<i> &gt; +#define PCH_CAN_LISTEN 1
</I>&gt;<i> &gt; +#define PCH_CAN_STOP 0
</I>&gt;<i> &gt; +#define PCH_CAN_RUN 1
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#define PCH_CAN_ENABLE 0
</I>&gt;<i> &gt; +#define PCH_CAN_DISABLE 1
</I>&gt;<i> &gt; +#define PCH_CAN_ALL 2
</I>&gt;<i> &gt; +#define PCH_CAN_NONE 3
</I>&gt;<i>
</I>&gt;<i> The above are used in switch case and should therefore be anonymous
</I>&gt;<i> enums. I suggested to remove them because I'm not a real friend of the
</I>&gt;<i> helper functions which are just called *once*.
</I>&gt;<i>
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +struct pch_can_regs {
</I>&gt;<i> &gt; + u32 cont;
</I>&gt;<i> &gt; + u32 stat;
</I>&gt;<i> &gt; + u32 errc;
</I>&gt;<i> &gt; + u32 bitt;
</I>&gt;<i> &gt; + u32 intr;
</I>&gt;<i> &gt; + u32 opt;
</I>&gt;<i> &gt; + u32 brpe;
</I>&gt;<i> &gt; + u32 reserve1;
</I>&gt;<i> &gt; + u32 if1_creq;
</I>&gt;<i> &gt; + u32 if1_cmask;
</I>&gt;<i> &gt; + u32 if1_mask1;
</I>&gt;<i> &gt; + u32 if1_mask2;
</I>&gt;<i> &gt; + u32 if1_id1;
</I>&gt;<i> &gt; + u32 if1_id2;
</I>&gt;<i> &gt; + u32 if1_mcont;
</I>&gt;<i> &gt; + u32 if1_dataa1;
</I>&gt;<i> &gt; + u32 if1_dataa2;
</I>&gt;<i> &gt; + u32 if1_datab1;
</I>&gt;<i> &gt; + u32 if1_datab2;
</I>&gt;<i> &gt; + u32 reserve2;
</I>&gt;<i> &gt; + u32 reserve3[12];
</I>&gt;<i> &gt; + u32 if2_creq;
</I>&gt;<i> &gt; + u32 if2_cmask;
</I>&gt;<i> &gt; + u32 if2_mask1;
</I>&gt;<i> &gt; + u32 if2_mask2;
</I>&gt;<i> &gt; + u32 if2_id1;
</I>&gt;<i> &gt; + u32 if2_id2;
</I>&gt;<i> &gt; + u32 if2_mcont;
</I>&gt;<i> &gt; + u32 if2_dataa1;
</I>&gt;<i> &gt; + u32 if2_dataa2;
</I>&gt;<i> &gt; + u32 if2_datab1;
</I>&gt;<i> &gt; + u32 if2_datab2;
</I>&gt;<i> &gt; + u32 reserve4;
</I>&gt;<i> &gt; + u32 reserve5[20];
</I>&gt;<i> &gt; + u32 treq1;
</I>&gt;<i> &gt; + u32 treq2;
</I>&gt;<i> &gt; + u32 reserve6[2];
</I>&gt;<i> &gt; + u32 reserve7[56];
</I>&gt;<i> &gt; + u32 reserve8[3];
</I>&gt;<i> &gt; + u32 srst;
</I>&gt;<i> &gt; +};
</I>&gt;<i>
</I>&gt;<i> Nice.
</I>&gt;<i>
</I>&gt;<i> &gt; +struct pch_can_priv {
</I>&gt;<i> &gt; + struct can_priv can;
</I>&gt;<i> &gt; + void __iomem *base;
</I>&gt;<i> &gt; + unsigned int can_num;
</I>&gt;<i> &gt; + struct pci_dev *dev;
</I>&gt;<i> &gt; + unsigned int tx_enable[MAX_MSG_OBJ];
</I>&gt;<i> &gt; + unsigned int rx_enable[MAX_MSG_OBJ];
</I>&gt;<i> &gt; + unsigned int rx_link[MAX_MSG_OBJ];
</I>&gt;<i> &gt; + unsigned int int_enables;
</I>&gt;<i> &gt; + unsigned int int_stat;
</I>&gt;<i> &gt; + unsigned int bus_off_interrupt;
</I>&gt;<i> &gt; + struct net_device *ndev;
</I>&gt;<i> &gt; + spinlock_t msgif_reg_lock; /* Message Interface Registers Access Lock*/
</I>&gt;<i> &gt; + unsigned int msg_obj[MAX_MSG_OBJ];
</I>&gt;<i> &gt; + struct pch_can_regs *regs;
</I>&gt;<i>
</I>&gt;<i> Please add __iomem. Do you need both, regs *and* base?
</I>&gt;<i>
</I>&gt;<i> &gt; +};
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static struct can_bittiming_const pch_can_bittiming_const = {
</I>&gt;<i> &gt; + .name = KBUILD_MODNAME,
</I>&gt;<i>
</I>&gt;<i> Not sure what KBUILD_MODNAME is. Should be &quot;pch_can&quot;, the name of the
</I>&gt;<i> driver.
</I>&gt;<i>
</I>&gt;<i> &gt; + .tseg1_min = 1,
</I>&gt;<i> &gt; + .tseg1_max = 16,
</I>&gt;<i> &gt; + .tseg2_min = 1,
</I>&gt;<i> &gt; + .tseg2_max = 8,
</I>&gt;<i> &gt; + .sjw_max = 4,
</I>&gt;<i> &gt; + .brp_min = 1,
</I>&gt;<i> &gt; + .brp_max = 1024, /* 6bit + extended 4bit */
</I>&gt;<i> &gt; + .brp_inc = 1,
</I>&gt;<i> &gt; +};
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static const struct pci_device_id pch_can_pcidev_id[] __devinitdata = {
</I>&gt;<i> &gt; + {PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_PCH1_CAN)},
</I>&gt;<i> &gt; + {}
</I>&gt;<i> &gt; +};
</I>&gt;<i>
</I>&gt;<i> Please use DEFINE_PCI_DEVICE_TABLE.
</I>&gt;<i>
</I>&gt;<i> &gt; +static inline void pch_can_bit_set(u32 *addr, u32 mask)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + iowrite32((ioread32(addr) | mask), addr);
</I>&gt;<i>
</I>&gt;<i> Outer brackets not needed!
</I>&gt;<i>
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static inline void pch_can_bit_clear(u32 *addr, u32 mask)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + iowrite32((ioread32(addr) &amp; ~(mask)), addr);
</I>&gt;<i>
</I>&gt;<i> Ditto.
</I>&gt;<i>
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_set_run_mode(struct pch_can_priv *priv, u32 mode)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + switch (mode) {
</I>&gt;<i> &gt; + case PCH_CAN_RUN:
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_INIT);
</I>&gt;<i> &gt; + break;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + case PCH_CAN_STOP:
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_INIT);
</I>&gt;<i> &gt; + break;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + default:
</I>&gt;<i> &gt; + dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;%s -&gt; Invalid Mode.\n&quot;, __func__);
</I>&gt;<i> &gt; + break;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_get_run_mode(struct pch_can_priv *priv, u32 *mode)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + u32 reg_val = ioread32(&amp;(priv-&gt;regs)-&gt;cont);
</I>&gt;<i>
</I>&gt;<i> I don't think you need the brackets around &quot;priv-&gt;regs&quot;. Therefore I
</I>&gt;<i> suggest s/&amp;(priv-&gt;regs)/&amp;priv-&gt;regs/ for the whole file.
</I>&gt;<i>
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (reg_val &amp; CAN_CTRL_INIT)
</I>&gt;<i> &gt; + *mode = PCH_CAN_STOP;
</I>&gt;<i> &gt; + else
</I>&gt;<i> &gt; + *mode = PCH_CAN_RUN;
</I>&gt;<i> &gt; +}
</I>&gt;<i>
</I>&gt;<i> These are the helper functions I complained about above. And reg_val is
</I>&gt;<i> not really needed.
</I>&gt;<i>
</I>&gt;<i> &gt; +static void pch_can_set_optmode(struct pch_can_priv *priv)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + u32 reg_val = ioread32(&amp;(priv-&gt;regs)-&gt;opt);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LISTENONLY)
</I>&gt;<i> &gt; + reg_val |= CAN_OPT_SILENT;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LOOPBACK)
</I>&gt;<i> &gt; + reg_val |= CAN_OPT_LBACK;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_OPT);
</I>&gt;<i> &gt; + iowrite32(reg_val, &amp;(priv-&gt;regs)-&gt;opt);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_set_int_custom(struct pch_can_priv *priv)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + /* Clearing the IE, SIE and EIE bits of Can control register. */
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_IE_SIE_EIE);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Appropriately setting them. */
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;cont,
</I>&gt;<i> &gt; + ((priv-&gt;int_enables &amp; MSK_CTRL_IE_SIE_EIE) &lt;&lt; 1));
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* This function retrieves interrupt enabled for the CAN device. */
</I>&gt;<i> &gt; +static void pch_can_get_int_enables(struct pch_can_priv *priv, u32 *enables)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + u32 reg_ctrl_val = ioread32(&amp;(priv-&gt;regs)-&gt;cont);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Obtaining the status of IE, SIE and EIE interrupt bits. */
</I>&gt;<i> &gt; + *enables = ((reg_ctrl_val &amp; CAN_CTRL_IE_SIE_EIE) &gt;&gt; 1);
</I>&gt;<i>
</I>&gt;<i> Do you really need an extra variable?
</I>&gt;<i>
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_set_int_enables(struct pch_can_priv *priv, u32 interrupt_no)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + switch (interrupt_no) {
</I>&gt;<i> &gt; + case PCH_CAN_ENABLE:
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_IE);
</I>&gt;<i> &gt; + break;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + case PCH_CAN_DISABLE:
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_IE);
</I>&gt;<i> &gt; + break;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + case PCH_CAN_ALL:
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_IE_SIE_EIE);
</I>&gt;<i> &gt; + break;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + case PCH_CAN_NONE:
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_IE_SIE_EIE);
</I>&gt;<i> &gt; + break;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + default:
</I>&gt;<i> &gt; + dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;Invalid interrupt number.\n&quot;);
</I>&gt;<i> &gt; + break;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_check_if1_busy(struct pch_can_priv *priv, u32 num)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + u32 counter = COUNTER_LIMIT;
</I>&gt;<i> &gt; + u32 if1_creq;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + iowrite32(num, &amp;(priv-&gt;regs)-&gt;if1_creq);
</I>&gt;<i> &gt; + while (counter) {
</I>&gt;<i> &gt; + if1_creq = (ioread32(&amp;(priv-&gt;regs)-&gt;if1_creq)) &amp;
</I>&gt;<i> &gt; +      CAN_IF_CREQ_BUSY;
</I>&gt;<i> &gt; + if (!if1_creq)
</I>&gt;<i> &gt; + break;
</I>&gt;<i> &gt; + counter--;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + if (!counter)
</I>&gt;<i> &gt; + dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;IF1 BUSY Flag is set forever.\n&quot;);
</I>&gt;<i>
</I>&gt;<i> Please use a defined delay for the above timeout. How long does it
</I>&gt;<i> usually take the bit to toggle? A small delay, e.g. udelay(1) could be
</I>&gt;<i> fine. This function is called in the time critical path!
</I>&gt;<i>
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_check_if2_busy(struct pch_can_priv *priv, u32 num)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + u32 counter = COUNTER_LIMIT;
</I>&gt;<i> &gt; + u32 if2_creq;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + iowrite32(num, &amp;(priv-&gt;regs)-&gt;if2_creq);
</I>&gt;<i> &gt; + while (counter) {
</I>&gt;<i> &gt; + if2_creq = (ioread32(&amp;(priv-&gt;regs)-&gt;if2_creq)) &amp;
</I>&gt;<i> &gt; +      CAN_IF_CREQ_BUSY;
</I>&gt;<i> &gt; + if (!if2_creq)
</I>&gt;<i> &gt; + break;
</I>&gt;<i> &gt; + counter--;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + if (!counter)
</I>&gt;<i> &gt; + dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;IF2 BUSY Flag is set forever.\n&quot;);
</I>&gt;<i> &gt; +}
</I>&gt;<i>
</I>&gt;<i> Duplicated code!
</I>&gt;<i>
</I>&gt;<i> &gt; +static void pch_can_set_rx_enable(struct pch_can_priv *priv, u32 buff_num,
</I>&gt;<i> &gt; +   u32 set)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + unsigned long flags;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt; + /*Reading the receive buffer data from RAM to Interface1 registers */
</I>&gt;<i>
</I>&gt;<i> Space after /* ?
</I>&gt;<i>
</I>&gt;<i> &gt; + iowrite32(CAN_CMASK_RX_TX_GET, &amp;(priv-&gt;regs)-&gt;if1_cmask);
</I>&gt;<i> &gt; + pch_can_check_if1_busy(priv, buff_num); /* Read from MsgRAN */
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Setting the IF1MASK1 register to access MsgVal and RxIE bits */
</I>&gt;<i> &gt; + iowrite32((CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL),
</I>&gt;<i> &gt; +   (&amp;(priv-&gt;regs)-&gt;if1_cmask));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (set == ENABLE) {
</I>&gt;<i> &gt; + /* Setting the MsgVal and RxIE bits */
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_mcont, CAN_IF_MCONT_RXIE);
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_id2, CAN_ID_MSGVAL);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + } else if (set == DISABLE) {
</I>&gt;<i> &gt; + /* Resetting the MsgVal and RxIE bits */
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_mcont, CAN_IF_MCONT_RXIE);
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_id2, CAN_ID_MSGVAL);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + pch_can_check_if1_busy(priv, buff_num); /* Write to MsgRAM */
</I>&gt;<i> &gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_rx_enable_all(struct pch_can_priv *priv)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + u32 i;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Traversing to obtain the object configured as receivers. */
</I>&gt;<i> &gt; + for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> &gt; + if (priv-&gt;msg_obj[i] == MSG_OBJ_RX)
</I>&gt;<i> &gt; + pch_can_set_rx_enable(priv, i + 1, ENABLE);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_rx_disable_all(struct pch_can_priv *priv)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + u32 i;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Traversing to obtain the object configured as receivers. */
</I>&gt;<i> &gt; + for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> &gt; + if (priv-&gt;msg_obj[i] == MSG_OBJ_RX)
</I>&gt;<i> &gt; + pch_can_set_rx_enable(priv, (i + 1), DISABLE);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_set_tx_enable(struct pch_can_priv *priv, u32 buff_num,
</I>&gt;<i> &gt; + u32 set)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + unsigned long flags;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt; + /* Reading the Msg buffer from Message RAM to Interface2 registers. */
</I>&gt;<i> &gt; + iowrite32(CAN_CMASK_RX_TX_GET, (&amp;(priv-&gt;regs)-&gt;if1_cmask));
</I>&gt;<i> &gt; + pch_can_check_if1_busy(priv, buff_num);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Setting the IF2CMASK register for accessing the
</I>&gt;<i> &gt; + MsgVal and TxIE bits */
</I>&gt;<i> &gt; + iowrite32((CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL),
</I>&gt;<i> &gt; + (&amp;(priv-&gt;regs)-&gt;if1_cmask));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (set == ENABLE) {
</I>&gt;<i> &gt; + /* Setting the MsgVal and TxIE bits */
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_mcont, CAN_IF_MCONT_TXIE);
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_id2, CAN_ID_MSGVAL);
</I>&gt;<i> &gt; + } else if (set == DISABLE) {
</I>&gt;<i> &gt; + /* Resetting the MsgVal and TxIE bits. */
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_mcont, CAN_IF_MCONT_TXIE);
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_id2, CAN_ID_MSGVAL);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + pch_can_check_if1_busy(priv, buff_num); /* Write to MsgRAM */
</I>&gt;<i> &gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_tx_enable_all(struct pch_can_priv *priv)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + u32 i;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Traversing to obtain the object configured as transmit object. */
</I>&gt;<i> &gt; + for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> &gt; + if (priv-&gt;msg_obj[i] == MSG_OBJ_TX)
</I>&gt;<i> &gt; + pch_can_set_tx_enable(priv, (i + 1), ENABLE);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_tx_disable_all(struct pch_can_priv *priv)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + u32 i;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Traversing to obtain the object configured as transmit object. */
</I>&gt;<i> &gt; + for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> &gt; + if (priv-&gt;msg_obj[i] == MSG_OBJ_TX)
</I>&gt;<i> &gt; + pch_can_set_tx_enable(priv, (i + 1), DISABLE);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_get_rx_enable(struct pch_can_priv *priv, u32 buff_num,
</I>&gt;<i> &gt; + u32 *enable)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + unsigned long flags;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt; + iowrite32(CAN_CMASK_RX_TX_GET, (&amp;(priv-&gt;regs)-&gt;if1_cmask));
</I>&gt;<i> &gt; + pch_can_check_if1_busy(priv, buff_num);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (((ioread32(&amp;(priv-&gt;regs)-&gt;if1_id2)) &amp; CAN_ID_MSGVAL) &amp;&amp;
</I>&gt;<i> &gt; + ((ioread32(&amp;(priv-&gt;regs)-&gt;if1_mcont)) &amp;
</I>&gt;<i> &gt; + CAN_IF_MCONT_RXIE))
</I>&gt;<i> &gt; + *enable = ENABLE;
</I>&gt;<i> &gt; + else
</I>&gt;<i> &gt; + *enable = DISABLE;
</I>&gt;<i> &gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_get_tx_enable(struct pch_can_priv *priv, u32 buff_num,
</I>&gt;<i> &gt; + u32 *enable)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + unsigned long flags;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt; + iowrite32(CAN_CMASK_RX_TX_GET, &amp;(priv-&gt;regs)-&gt;if1_cmask);
</I>&gt;<i> &gt; + pch_can_check_if1_busy(priv, buff_num);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (((ioread32(&amp;(priv-&gt;regs)-&gt;if1_id2)) &amp; CAN_ID_MSGVAL) &amp;&amp;
</I>&gt;<i> &gt; + ((ioread32(&amp;(priv-&gt;regs)-&gt;if1_mcont)) &amp;
</I>&gt;<i> &gt; + CAN_IF_MCONT_TXIE)) {
</I>&gt;<i> &gt; + *enable = ENABLE;
</I>&gt;<i> &gt; + } else {
</I>&gt;<i> &gt; + *enable = DISABLE;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int pch_can_int_pending(struct pch_can_priv *priv)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + return ioread32(&amp;(priv-&gt;regs)-&gt;intr) &amp; 0xffff;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_set_rx_buffer_link(struct pch_can_priv *priv,
</I>&gt;<i> &gt; +        u32 buffer_num, u32 set)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + unsigned long flags;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt; + iowrite32(CAN_CMASK_RX_TX_GET, &amp;(priv-&gt;regs)-&gt;if1_cmask);
</I>&gt;<i> &gt; + pch_can_check_if1_busy(priv, buffer_num);
</I>&gt;<i> &gt; + iowrite32((CAN_CMASK_RDWR | CAN_CMASK_CTRL), &amp;(priv-&gt;regs)-&gt;if1_cmask);
</I>&gt;<i> &gt; + if (set == ENABLE)
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_mcont, CAN_IF_MCONT_EOB);
</I>&gt;<i> &gt; + else
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_mcont, CAN_IF_MCONT_EOB);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + pch_can_check_if1_busy(priv, buffer_num);
</I>&gt;<i> &gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_get_rx_buffer_link(struct pch_can_priv *priv,
</I>&gt;<i> &gt; +        u32 buffer_num, u32 *link)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + u32 reg_val;
</I>&gt;<i>
</I>&gt;<i> Really needed?
</I>&gt;<i>
</I>&gt;<i> &gt; + unsigned long flags;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt; + iowrite32(CAN_CMASK_RX_TX_GET, &amp;(priv-&gt;regs)-&gt;if1_cmask);
</I>&gt;<i> &gt; + pch_can_check_if1_busy(priv, buffer_num);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + reg_val = ioread32(&amp;(priv-&gt;regs)-&gt;if1_mcont);
</I>&gt;<i> &gt; + if (reg_val &amp; CAN_IF_MCONT_EOB)
</I>&gt;<i> &gt; + *link = DISABLE;
</I>&gt;<i> &gt; + else
</I>&gt;<i> &gt; + *link = ENABLE;
</I>&gt;<i> &gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_clear_buffers(struct pch_can_priv *priv)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + u32 i;
</I>&gt;<i> &gt; + u32 rx_buff_num;
</I>&gt;<i> &gt; + u32 tx_buff_num;
</I>&gt;<i>
</I>&gt;<i> Really needed?
</I>&gt;<i>
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + iowrite32(CAN_CMASK_RX_TX_SET, &amp;(priv-&gt;regs)-&gt;if1_cmask);
</I>&gt;<i> &gt; + iowrite32(CAN_CMASK_RX_TX_SET, &amp;(priv-&gt;regs)-&gt;if2_cmask);
</I>&gt;<i> &gt; + iowrite32(0xffff, &amp;(priv-&gt;regs)-&gt;if1_mask1);
</I>&gt;<i> &gt; + iowrite32(0xffff, &amp;(priv-&gt;regs)-&gt;if1_mask2);
</I>&gt;<i> &gt; + iowrite32(0xffff, &amp;(priv-&gt;regs)-&gt;if2_mask1);
</I>&gt;<i> &gt; + iowrite32(0xffff, &amp;(priv-&gt;regs)-&gt;if2_mask2);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if1_id1);
</I>&gt;<i> &gt; + iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if1_id2);
</I>&gt;<i> &gt; + iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if2_id1);
</I>&gt;<i> &gt; + iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if2_id2);
</I>&gt;<i> &gt; + iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if1_mcont);
</I>&gt;<i> &gt; + iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if2_mcont);
</I>&gt;<i> &gt; + iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if1_dataa1);
</I>&gt;<i> &gt; + iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if1_dataa2);
</I>&gt;<i> &gt; + iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if1_datab1);
</I>&gt;<i> &gt; + iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if1_datab2);
</I>&gt;<i> &gt; + iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if2_dataa1);
</I>&gt;<i> &gt; + iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if2_dataa2);
</I>&gt;<i> &gt; + iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if2_datab1);
</I>&gt;<i> &gt; + iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if2_datab2);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + for (i = 1; i &lt;= (MAX_MSG_OBJ / 2); i++) {
</I>&gt;<i> &gt; + rx_buff_num = 2 * i;
</I>&gt;<i> &gt; + tx_buff_num = (2 * i) - 1;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + iowrite32(rx_buff_num, &amp;(priv-&gt;regs)-&gt;if1_creq);
</I>&gt;<i> &gt; + iowrite32(tx_buff_num, &amp;(priv-&gt;regs)-&gt;if2_creq);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + mdelay(10);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + u32 i;
</I>&gt;<i> &gt; + unsigned long flags;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt; + /* For accssing MsgVal, ID and EOB bit */
</I>&gt;<i> &gt; + iowrite32((CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL),
</I>&gt;<i> &gt; + (&amp;(priv-&gt;regs)-&gt;if1_cmask));
</I>&gt;<i> &gt; + iowrite32((CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL),
</I>&gt;<i> &gt; + (&amp;(priv-&gt;regs)-&gt;if2_cmask));
</I>&gt;<i> &gt; + iowrite32(0x0, (&amp;(priv-&gt;regs)-&gt;if1_id1));
</I>&gt;<i> &gt; + iowrite32(0x0, (&amp;(priv-&gt;regs)-&gt;if1_id2));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Resetting DIR bit for reception */
</I>&gt;<i> &gt; + iowrite32(0x0, (&amp;(priv-&gt;regs)-&gt;if2_id1));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Setting DIR bit for transmission */
</I>&gt;<i> &gt; + iowrite32((CAN_ID2_DIR | (0x7ff &lt;&lt; 2)),
</I>&gt;<i> &gt; + (&amp;(priv-&gt;regs)-&gt;if2_id2));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Setting EOB bit for receiver */
</I>&gt;<i> &gt; + iowrite32(CAN_IF_MCONT_EOB, &amp;(priv-&gt;regs)-&gt;if1_mcont);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Setting EOB bit for transmitter */
</I>&gt;<i> &gt; + iowrite32(CAN_IF_MCONT_EOB, (&amp;(priv-&gt;regs)-&gt;if2_mcont));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> &gt; + if (priv-&gt;msg_obj[i] == MSG_OBJ_RX)
</I>&gt;<i> &gt; + pch_can_check_if1_busy(priv, i + 1);
</I>&gt;<i> &gt; + else if (priv-&gt;msg_obj[i] == MSG_OBJ_TX)
</I>&gt;<i> &gt; + pch_can_check_if2_busy(priv, i + 1);
</I>&gt;<i> &gt; + else
</I>&gt;<i> &gt; + dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;Invalid OBJ\n&quot;);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> &gt; + if (priv-&gt;msg_obj[i] == MSG_OBJ_RX) {
</I>&gt;<i> &gt; + iowrite32(CAN_CMASK_RX_TX_GET,
</I>&gt;<i> &gt; + &amp;(priv-&gt;regs)-&gt;if1_cmask);
</I>&gt;<i> &gt; + pch_can_check_if1_busy(priv, i+1);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_id2, 0x1fff);
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_id2, CAN_ID2_XTD);
</I>&gt;<i>
</I>&gt;<i> Could'nt it be set just by one call?
</I>&gt;<i>
</I>&gt;<i> &gt; + iowrite32(0, (&amp;(priv-&gt;regs)-&gt;if1_id1));
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_id2, 0);
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_mcont,
</I>&gt;<i> &gt; + CAN_IF_MCONT_UMASK);
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if2_mcont,
</I>&gt;<i> &gt; + CAN_IF_MCONT_UMASK);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + iowrite32(0, &amp;(priv-&gt;regs)-&gt;if1_mask1);
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_mask2, 0x1fff);
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_mask2,
</I>&gt;<i> &gt; +   CAN_MASK2_MDIR_MXTD);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + iowrite32(0, &amp;(priv-&gt;regs)-&gt;if2_mask1);
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if2_mask2, 0x1fff);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Setting CMASK for writing */
</I>&gt;<i> &gt; + iowrite32((CAN_CMASK_RDWR | CAN_CMASK_MASK |
</I>&gt;<i> &gt; +    CAN_CMASK_ARB | CAN_CMASK_CTRL),
</I>&gt;<i> &gt; +   (&amp;(priv-&gt;regs)-&gt;if1_cmask));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + pch_can_check_if1_busy(priv, i+1);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_open(struct pch_can_priv *priv)
</I>&gt;<i>
</I>&gt;<i> Probably pch_can_init is the better name.
</I>&gt;<i>
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + /* Stopping the Can device. */
</I>&gt;<i> &gt; + pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Clearing all the message object buffers. */
</I>&gt;<i> &gt; + pch_can_clear_buffers(priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Configuring the respective message object as either rx/tx object. */
</I>&gt;<i> &gt; + pch_can_config_rx_tx_buffers(priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Enabling all receive objects. */
</I>&gt;<i> &gt; + pch_can_rx_enable_all(priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Enabling all transmit objects. */
</I>&gt;<i> &gt; + pch_can_tx_enable_all(priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Enabling the interrupts. */
</I>&gt;<i> &gt; + pch_can_set_int_enables(priv, PCH_CAN_ALL);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Setting the CAN to run mode. */
</I>&gt;<i> &gt; + pch_can_set_run_mode(priv, PCH_CAN_RUN);
</I>&gt;<i>
</I>&gt;<i> Hm, you start the controller here... more later.
</I>&gt;<i>
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_release(struct pch_can_priv *priv)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + /* Stooping the CAN device. */
</I>&gt;<i> &gt; + pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Disabling the interrupts. */
</I>&gt;<i> &gt; + pch_can_set_int_enables(priv, PCH_CAN_NONE);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Disabling all the receive object. */
</I>&gt;<i> &gt; + pch_can_rx_disable_all(priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Disabling all the transmit object. */
</I>&gt;<i> &gt; + pch_can_tx_disable_all(priv);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* This function clears interrupt(s) from the CAN device. */
</I>&gt;<i> &gt; +static void pch_can_int_clr(struct pch_can_priv *priv, u32 mask)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + if (mask == CAN_STATUS_INT) {
</I>&gt;<i> &gt; + ioread32(&amp;(priv-&gt;regs)-&gt;stat);
</I>&gt;<i> &gt; + return;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Clear interrupt for transmit object */
</I>&gt;<i> &gt; + if (priv-&gt;msg_obj[mask - 1] == MSG_OBJ_TX) {
</I>&gt;<i> &gt; + /* Setting CMASK for clearing interrupts for
</I>&gt;<i> &gt; + frame transmission. */
</I>&gt;<i> &gt; + iowrite32((CAN_CMASK_RDWR | CAN_CMASK_CTRL | CAN_CMASK_ARB),
</I>&gt;<i> &gt; + (&amp;(priv-&gt;regs)-&gt;if2_cmask));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Resetting the ID registers. */
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if2_id2,
</I>&gt;<i> &gt; +        (CAN_ID2_DIR | (0x7ff &lt;&lt; 2)));
</I>&gt;<i> &gt; + iowrite32(0x0, (&amp;(priv-&gt;regs)-&gt;if2_id1));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Claring NewDat, TxRqst &amp; IntPnd */
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if2_mcont,
</I>&gt;<i> &gt; +   (CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND |
</I>&gt;<i> &gt; +    CAN_IF_MCONT_TXRQXT));
</I>&gt;<i> &gt; + pch_can_check_if2_busy(priv, mask);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + /* Clear interrupt for receive object */
</I>&gt;<i> &gt; + else if (priv-&gt;msg_obj[mask - 1] == MSG_OBJ_RX) {
</I>&gt;<i>
</I>&gt;<i> Should be &quot;} else if ...&quot;
</I>&gt;<i>
</I>&gt;<i> &gt; + /* Setting CMASK for clearing the reception interrupts. */
</I>&gt;<i> &gt; + iowrite32((CAN_CMASK_RDWR | CAN_CMASK_CTRL | CAN_CMASK_ARB),
</I>&gt;<i> &gt; +   (&amp;(priv-&gt;regs)-&gt;if2_cmask));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Clearing the Dir bit. */
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if2_id2, CAN_ID2_DIR);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Clearing NewDat &amp; IntPnd */
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if2_mcont,
</I>&gt;<i> &gt; +   (CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + pch_can_check_if2_busy(priv, mask);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int pch_can_get_buffer_status(struct pch_can_priv *priv)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + u32 reg_treq1;
</I>&gt;<i> &gt; + u32 reg_treq2;
</I>&gt;<i>
</I>&gt;<i> Really needed?
</I>&gt;<i>
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Reading the transmission request registers. */
</I>&gt;<i> &gt; + reg_treq1 = (ioread32(&amp;(priv-&gt;regs)-&gt;treq1) &amp; 0xffff);
</I>&gt;<i> &gt; + reg_treq2 = ((ioread32(&amp;(priv-&gt;regs)-&gt;treq2) &amp; 0xffff) &lt;&lt; 16);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + return reg_treq1 | reg_treq2;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_reset(struct pch_can_priv *priv)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + /* write to sw reset register */
</I>&gt;<i> &gt; + iowrite32(1, (&amp;(priv-&gt;regs)-&gt;srst));
</I>&gt;<i> &gt; + iowrite32(0, (&amp;(priv-&gt;regs)-&gt;srst));
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_msg_obj(struct net_device *ndev, u32 status)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt; + u32 reg;
</I>&gt;<i> &gt; + struct sk_buff *skb;
</I>&gt;<i> &gt; + struct can_frame *cf;
</I>&gt;<i> &gt; + canid_t id;
</I>&gt;<i> &gt; + u32 ide;
</I>&gt;<i> &gt; + u32 rtr;
</I>&gt;<i> &gt; + int i, j;
</I>&gt;<i> &gt; + struct net_device_stats *stats = &amp;(priv-&gt;ndev-&gt;stats);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Reading the messsage object from the Message RAM */
</I>&gt;<i> &gt; + iowrite32(CAN_CMASK_RX_TX_GET, &amp;(priv-&gt;regs)-&gt;if2_cmask);
</I>&gt;<i> &gt; + pch_can_check_if2_busy(priv, status);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Reading the MCONT register. */
</I>&gt;<i> &gt; + reg = ioread32(&amp;(priv-&gt;regs)-&gt;if2_mcont);
</I>&gt;<i> &gt; + reg &amp;= 0xffff;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* If MsgLost bit set. */
</I>&gt;<i> &gt; + if (reg &amp; CAN_IF_MCONT_MSGLOST) {
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if2_mcont,
</I>&gt;<i> &gt; +   CAN_IF_MCONT_MSGLOST);
</I>&gt;<i> &gt; + dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;Msg Obj is overwritten.\n&quot;);
</I>&gt;<i>
</I>&gt;<i> That should create an error message as well.
</I>&gt;<i>
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + /* Read the direction bit for determination of remote frame . */
</I>&gt;<i> &gt; + rtr = (ioread32((&amp;(priv-&gt;regs)-&gt;if2_id2)) &amp;  CAN_ID2_DIR);
</I>&gt;<i> &gt; + /* Clearing interrupts. */
</I>&gt;<i> &gt; + pch_can_int_clr(priv, status);
</I>&gt;<i> &gt; + /* Hanlde reception interrupt */
</I>&gt;<i>
</I>&gt;<i> Typo!
</I>&gt;<i>
</I>&gt;<i> &gt; + if (priv-&gt;msg_obj[status - 1] == MSG_OBJ_RX) {
</I>&gt;<i> &gt; + if (!(reg &amp; CAN_IF_MCONT_NEWDAT)) {
</I>&gt;<i> &gt; + dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;MCONT_NEWDAT isn't SET.\n&quot;);
</I>&gt;<i> &gt; + return;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + skb = alloc_can_skb(priv-&gt;ndev, &amp;cf);
</I>&gt;<i> &gt; + if (!skb)
</I>&gt;<i> &gt; + return;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + ide = ((ioread32(&amp;(priv-&gt;regs)-&gt;if2_id2)) &amp; CAN_ID2_XTD) &gt;&gt; 14;
</I>&gt;<i> &gt; + if (ide) {
</I>&gt;<i> &gt; + id = (ioread32(&amp;(priv-&gt;regs)-&gt;if2_id1) &amp; 0xffff);
</I>&gt;<i> &gt; + id |= (((ioread32(&amp;(priv-&gt;regs)-&gt;if2_id2)) &amp;
</I>&gt;<i> &gt; +     0x1fff) &lt;&lt; 16);
</I>&gt;<i> &gt; + cf-&gt;can_id = (id &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
</I>&gt;<i> &gt; + } else {
</I>&gt;<i> &gt; + id = (((ioread32(&amp;(priv-&gt;regs)-&gt;if2_id2)) &amp;
</I>&gt;<i> &gt; +   (CAN_SFF_MASK &lt;&lt; 2)) &gt;&gt; 2);
</I>&gt;<i> &gt; + cf-&gt;can_id = (id &amp; CAN_SFF_MASK);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (rtr) {
</I>&gt;<i> &gt; + cf-&gt;can_dlc = 0;
</I>&gt;<i> &gt; + cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> &gt; + } else {
</I>&gt;<i> &gt; + cf-&gt;can_dlc = ((ioread32(&amp;(priv-&gt;regs)-&gt;if2_mcont)) &amp;
</I>&gt;<i> &gt; +    0x0f);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Reading back the data. */
</I>&gt;<i> &gt; + for (i = 0, j = 0; i &lt; cf-&gt;can_dlc; j++) {
</I>&gt;<i> &gt; + reg = ioread32(&amp;(priv-&gt;regs)-&gt;if2_dataa1 + j*4);
</I>&gt;<i> &gt; + cf-&gt;data[i++] = cpu_to_le32(reg &amp; 0xff);
</I>&gt;<i> &gt; + if (i == cf-&gt;can_dlc)
</I>&gt;<i> &gt; + break;
</I>&gt;<i> &gt; + cf-&gt;data[i++] = cpu_to_le32((reg &amp; (0xff &lt;&lt; 8)) &gt;&gt; 8);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + netif_rx(skb);
</I>&gt;<i> &gt; + stats-&gt;rx_packets++;
</I>&gt;<i> &gt; + stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> &gt; + } else if (priv-&gt;msg_obj[status - 1] == MSG_OBJ_TX) {
</I>&gt;<i> &gt; + /* Hanlde transmission interrupt */
</I>&gt;<i>
</I>&gt;<i> Typo!
</I>&gt;<i>
</I>&gt;<i> &gt; + can_get_echo_skb(priv-&gt;ndev, 0);
</I>&gt;<i> &gt; + netif_wake_queue(priv-&gt;ndev);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_error(struct net_device *ndev, u32 status)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + struct sk_buff *skb;
</I>&gt;<i> &gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt; + struct can_frame *cf;
</I>&gt;<i> &gt; + u32 errc;
</I>&gt;<i> &gt; + struct net_device_stats *stats = &amp;(priv-&gt;ndev-&gt;stats);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + skb = alloc_can_err_skb(ndev, &amp;cf);
</I>&gt;<i> &gt; + if (!skb) {
</I>&gt;<i> &gt; + dev_err(&amp;ndev-&gt;dev, &quot;%s -&gt; No memory.\n&quot;, __func__);
</I>&gt;<i>
</I>&gt;<i> Please drop the error message.
</I>&gt;<i>
</I>&gt;<i> &gt; + return;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (status &amp; PCH_BUS_OFF) {
</I>&gt;<i> &gt; + if (!priv-&gt;bus_off_interrupt) {
</I>&gt;<i> &gt; + pch_can_tx_disable_all(priv);
</I>&gt;<i> &gt; + pch_can_rx_disable_all(priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + priv-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> &gt; + cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> &gt; + can_bus_off(ndev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + priv-&gt;bus_off_interrupt = 1;
</I>&gt;<i> &gt; + pch_can_set_run_mode(priv, PCH_CAN_RUN);
</I>&gt;<i>
</I>&gt;<i> Hm, you automatically restart the contoller after a bus-off. That's not
</I>&gt;<i> the intended behaviour. It's up to the user to define how and when the
</I>&gt;<i> device should recover from bus-off. For further information read
</I>&gt;<i>
</I>&gt;<i> <A HREF="http://lxr.linux.no/#linux+v2.6.35.7/Documentation/networking/can.txt#L767">http://lxr.linux.no/#linux+v2.6.35.7/Documentation/networking/can.txt#L767</A>
</I>&gt;<i>
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + }
</I>&gt;<i>
</I>&gt;<i> &gt; + /* Warning interrupt. */
</I>&gt;<i> &gt; + if (status &amp; PCH_EWARN) {
</I>&gt;<i> &gt; + priv-&gt;can.state = CAN_STATE_ERROR_WARNING;
</I>&gt;<i> &gt; + priv-&gt;can.can_stats.error_warning++;
</I>&gt;<i> &gt; + cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> &gt; + errc = ioread32((&amp;(priv-&gt;regs)-&gt;errc));
</I>&gt;<i> &gt; + if (((errc &amp; CAN_REC) &gt;&gt; 8) &gt; 96)
</I>&gt;<i> &gt; + cf-&gt;data[1] |= CAN_ERR_CRTL_RX_WARNING;
</I>&gt;<i> &gt; + if ((errc &amp; CAN_TEC) &gt; 96)
</I>&gt;<i> &gt; + cf-&gt;data[1] |= CAN_ERR_CRTL_TX_WARNING;
</I>&gt;<i> &gt; + dev_warn(&amp;ndev-&gt;dev, &quot;%s -&gt; Warning interrupt.\n&quot;, __func__);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + /* Error passive interrupt. */
</I>&gt;<i> &gt; + if (status &amp; PCH_EPASSIV) {
</I>&gt;<i> &gt; + priv-&gt;can.can_stats.error_passive++;
</I>&gt;<i> &gt; + priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> &gt; + cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> &gt; + errc = ioread32((&amp;(priv-&gt;regs)-&gt;errc));
</I>&gt;<i> &gt; + if (((errc &amp; CAN_REC) &gt;&gt; 8) &gt; 127)
</I>&gt;<i> &gt; + cf-&gt;data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> &gt; + if ((errc &amp; CAN_TEC) &gt; 127)
</I>&gt;<i> &gt; + cf-&gt;data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
</I>&gt;<i> &gt; + dev_err(&amp;ndev-&gt;dev,
</I>&gt;<i> &gt; + &quot;%s -&gt; Error interrupt.\n&quot;, __func__);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (status &amp; PCH_STUF_ERR)
</I>&gt;<i> &gt; + cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (status &amp; PCH_FORM_ERR)
</I>&gt;<i> &gt; + cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (status &amp; PCH_ACK_ERR)
</I>&gt;<i> &gt; + cf-&gt;data[2] |= CAN_ERR_PROT_LOC_ACK | CAN_ERR_PROT_LOC_ACK_DEL;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if ((status &amp; PCH_BIT1_ERR) || (status &amp; PCH_BIT0_ERR))
</I>&gt;<i> &gt; + cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (status &amp; PCH_CRC_ERR)
</I>&gt;<i> &gt; + cf-&gt;data[2] |= CAN_ERR_PROT_LOC_CRC_SEQ |
</I>&gt;<i> &gt; + CAN_ERR_PROT_LOC_CRC_DEL;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (status &amp; PCH_LEC_ALL)
</I>&gt;<i> &gt; + iowrite32(status | PCH_LEC_ALL,
</I>&gt;<i> &gt; +   &amp;(priv-&gt;regs)-&gt;stat);
</I>&gt;<i>
</I>&gt;<i> A bit-wise test of the above values is wrong, I believe. Please use the
</I>&gt;<i> switch statement instead.
</I>&gt;<i>
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + stats-&gt;rx_packets++;
</I>&gt;<i> &gt; + stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> &gt; + netif_rx(skb);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static irqreturn_t pch_can_handler(int irq, void *dev_id)
</I>&gt;<i>
</I>&gt;<i> A better name making clear that it's the interrupt handler would be nice.
</I>&gt;<i>
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + u32 int_stat;
</I>&gt;<i> &gt; + u32 reg_stat;
</I>&gt;<i> &gt; + struct net_device *ndev = (struct net_device *)dev_id;
</I>&gt;<i> &gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt; + int_stat = pch_can_int_pending(priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (!int_stat)
</I>&gt;<i> &gt; + return IRQ_NONE;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (int_stat == CAN_STATUS_INT) {
</I>&gt;<i> &gt; + reg_stat = ioread32((&amp;(priv-&gt;regs)-&gt;stat));
</I>&gt;<i> &gt; + if (reg_stat &amp; (PCH_BUS_OFF | PCH_LEC_ALL | PCH_EWARN |
</I>&gt;<i> &gt; + PCH_EPASSIV)) {
</I>&gt;<i> &gt; + if ((reg_stat &amp; PCH_LEC_ALL) != PCH_LEC_ALL)
</I>&gt;<i> &gt; + pch_can_error(ndev, reg_stat);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Recover from Bus Off */
</I>&gt;<i> &gt; + if (!reg_stat &amp;&amp; priv-&gt;bus_off_interrupt) {
</I>&gt;<i> &gt; + priv-&gt;bus_off_interrupt = 0;
</I>&gt;<i> &gt; + pch_can_tx_enable_all(priv);
</I>&gt;<i> &gt; + pch_can_rx_enable_all(priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + dev_info(&amp;priv-&gt;ndev-&gt;dev, &quot;BusOff stage recovered.\n&quot;);
</I>&gt;<i>
</I>&gt;<i> Bogus bus-off handling, more later...
</I>&gt;<i>
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (reg_stat &amp; PCH_RX_OK)
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;stat, PCH_RX_OK);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (reg_stat &amp; PCH_TX_OK)
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;stat, PCH_TX_OK);
</I>&gt;<i>
</I>&gt;<i> Could be done in one call, I think.
</I>&gt;<i>
</I>&gt;<i> &gt; + int_stat = pch_can_int_pending(priv);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if ((int_stat &gt; 0) &amp;&amp; (int_stat &lt;= MAX_MSG_OBJ))
</I>&gt;<i> &gt; + pch_can_msg_obj(ndev, int_stat);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + return IRQ_HANDLED;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int pch_set_bittiming(struct net_device *ndev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt; + const struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> &gt; + u32 curr_mode;
</I>&gt;<i> &gt; + u32 reg1; /* CANBIT */
</I>&gt;<i> &gt; + u32 reg2; /* BEPE */
</I>&gt;<i>
</I>&gt;<i> Why not &quot;u32 canbit&quot; then?
</I>&gt;<i>
</I>&gt;<i> &gt; + u32 brp;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + pch_can_get_run_mode(priv, &amp;curr_mode);
</I>&gt;<i> &gt; + if (curr_mode == PCH_CAN_RUN)
</I>&gt;<i> &gt; + pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;<i>
</I>&gt;<i> The device is stopped when this function is called. Please remove.
</I>&gt;<i>
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Setting the CCE bit for accessing the Can Timing register. */
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_CCE);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + brp = (bt-&gt;tq) / (1000000/PCH_CAN_CLK) - 1;
</I>&gt;<i> &gt; + reg1 = brp &amp; MSK_BITT_BRP;
</I>&gt;<i> &gt; + reg1 |= (bt-&gt;sjw - 1) &lt;&lt; BIT_BITT_SJW;
</I>&gt;<i> &gt; + reg1 |= (bt-&gt;phase_seg1 + bt-&gt;prop_seg - 1) &lt;&lt; BIT_BITT_TSEG1;
</I>&gt;<i> &gt; + reg1 |= (bt-&gt;phase_seg2 - 1) &lt;&lt; BIT_BITT_TSEG2;
</I>&gt;<i> &gt; + reg2 = (brp &amp; MSK_BRPE_BRPE) &gt;&gt; BIT_BRPE_BRPE;
</I>&gt;<i> &gt; + iowrite32(reg1, (&amp;(priv-&gt;regs)-&gt;bitt));
</I>&gt;<i> &gt; + iowrite32(reg2, (&amp;(priv-&gt;regs)-&gt;brpe));
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_CCE);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (curr_mode == PCH_CAN_RUN)
</I>&gt;<i> &gt; + pch_can_set_run_mode(priv, PCH_CAN_RUN);
</I>&gt;<i>
</I>&gt;<i> Ditto.
</I>&gt;<i>
</I>&gt;<i> &gt; + return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void pch_can_start(struct net_device *ndev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (priv-&gt;can.state != CAN_STATE_STOPPED)
</I>&gt;<i> &gt; + pch_can_reset(priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + pch_set_bittiming(ndev);
</I>&gt;<i> &gt; + pch_can_set_optmode(priv);
</I>&gt;<i> &gt; + priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i>
</I>&gt;<i> Hm, where do you really start the controller. I'm missing
</I>&gt;<i> pch_can_set_run_mode(priv, PCH_CAN_RUN).
</I>&gt;<i>
</I>&gt;<i> &gt; + return;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int pch_can_do_set_mode(struct net_device *ndev, enum can_mode mode)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + int ret = 0;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + switch (mode) {
</I>&gt;<i> &gt; + case CAN_MODE_START:
</I>&gt;<i> &gt; + pch_can_start(ndev);
</I>&gt;<i> &gt; + netif_wake_queue(ndev);
</I>&gt;<i> &gt; + break;
</I>&gt;<i> &gt; + default:
</I>&gt;<i> &gt; + ret = -EOPNOTSUPP;
</I>&gt;<i> &gt; + break;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + return ret;
</I>&gt;<i> &gt; +}
</I>&gt;<i>
</I>&gt;<i> Note that this function is called when the device will recover from bus-off.
</I>&gt;<i>
</I>&gt;<i> &gt; +static int pch_can_get_state(const struct net_device *ndev,
</I>&gt;<i> &gt; +      enum can_state *state)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + *state = priv-&gt;can.state;
</I>&gt;<i> &gt; + return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i>
</I>&gt;<i> There is no need for that function as the driver handles state changes
</I>&gt;<i> in the interrupt handler.
</I>&gt;<i>
</I>&gt;<i> &gt; +static int pch_open(struct net_device *ndev)
</I>&gt;<i>
</I>&gt;<i> That's confussing! Please use the prefix pch_can throught this file.
</I>&gt;<i>
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt; + int retval;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + pch_can_open(priv);
</I>&gt;<i>
</I>&gt;<i> This function already starts the controller, which is too *early*.
</I>&gt;<i>
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + retval = pci_enable_msi(priv-&gt;dev);
</I>&gt;<i> &gt; + if (retval) {
</I>&gt;<i> &gt; + dev_err(&amp;ndev-&gt;dev, &quot;Unable to allocate MSI ret=%d\n&quot;, retval);
</I>&gt;<i> &gt; + goto pci_en_msi_err;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Regsitering the interrupt. */
</I>&gt;<i> &gt; + retval = request_irq(priv-&gt;dev-&gt;irq, pch_can_handler, IRQF_SHARED,
</I>&gt;<i> &gt; +      ndev-&gt;name, ndev);
</I>&gt;<i> &gt; + if (retval) {
</I>&gt;<i> &gt; + dev_err(&amp;ndev-&gt;dev, &quot;request_irq failed.\n&quot;);
</I>&gt;<i> &gt; + goto req_irq_err;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Assuming that no bus off interrupt. */
</I>&gt;<i> &gt; + priv-&gt;bus_off_interrupt = 0;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Open common can device */
</I>&gt;<i> &gt; + retval = open_candev(ndev);
</I>&gt;<i> &gt; + if (retval) {
</I>&gt;<i> &gt; + dev_err(ndev-&gt;dev.parent, &quot;open_candev() failed %d\n&quot;, retval);
</I>&gt;<i> &gt; + goto err_open_candev;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + pch_can_start(ndev);
</I>&gt;<i>
</I>&gt;<i> Thde above function should finally start the controller.
</I>&gt;<i>
</I>&gt;<i> &gt; + netif_start_queue(ndev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + return 0;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +err_open_candev:
</I>&gt;<i> &gt; + free_irq(priv-&gt;dev-&gt;irq, ndev);
</I>&gt;<i> &gt; +req_irq_err:
</I>&gt;<i> &gt; + pci_disable_msi(priv-&gt;dev);
</I>&gt;<i> &gt; +pci_en_msi_err:
</I>&gt;<i> &gt; + pch_can_release(priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + return retval;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int pch_close(struct net_device *ndev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + netif_stop_queue(ndev);
</I>&gt;<i> &gt; + pch_can_release(priv);
</I>&gt;<i> &gt; + free_irq(priv-&gt;dev-&gt;irq, ndev);
</I>&gt;<i> &gt; + pci_disable_msi(priv-&gt;dev);
</I>&gt;<i> &gt; + close_candev(ndev);
</I>&gt;<i> &gt; + priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> &gt; + return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int pch_get_free_msg_obj(struct net_device *ndev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + u32 buffer_status = 0;
</I>&gt;<i> &gt; + u32 tx_disable_counter = 0;
</I>&gt;<i> &gt; + u32 tx_buffer_avail = 0;
</I>&gt;<i> &gt; + u32 status;
</I>&gt;<i> &gt; + s32 i;
</I>&gt;<i> &gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Getting the message object status. */
</I>&gt;<i> &gt; + buffer_status = (u32) pch_can_get_buffer_status(priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Getting the free transmit message object. */
</I>&gt;<i> &gt; + for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> &gt; + if ((priv-&gt;msg_obj[i] == MSG_OBJ_TX)) {
</I>&gt;<i> &gt; + /* Checking whether the object is enabled. */
</I>&gt;<i> &gt; + pch_can_get_tx_enable(priv, i + 1, &amp;status);
</I>&gt;<i> &gt; + if (status == ENABLE) {
</I>&gt;<i> &gt; + if (!((buffer_status &gt;&gt; i) &amp; 1)) {
</I>&gt;<i> &gt; + tx_buffer_avail = (i + 1);
</I>&gt;<i> &gt; + break;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + } else {
</I>&gt;<i> &gt; + tx_disable_counter++;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* If no transmit object available. */
</I>&gt;<i> &gt; + if (!tx_buffer_avail) {
</I>&gt;<i> &gt; + /* If no object is enabled. */
</I>&gt;<i> &gt; + if ((tx_disable_counter == PCH_TX_OBJ_NUM)) {
</I>&gt;<i> &gt; + dev_err(&amp;ndev-&gt;dev, &quot;All tx buffers are disabled.\n&quot;);
</I>&gt;<i> &gt; + return -EPERM;
</I>&gt;<i> &gt; + } else {
</I>&gt;<i> &gt; + dev_err(&amp;ndev-&gt;dev, &quot;%s:No tx buf free.\n&quot;, __func__);
</I>&gt;<i> &gt; + return -PCH_CAN_NO_TX_BUFF;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + return tx_buffer_avail;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + canid_t id;
</I>&gt;<i> &gt; + u32 id1 = 0;
</I>&gt;<i> &gt; + u32 id2 = 0;
</I>&gt;<i>
</I>&gt;<i> Need these values to be preset?
</I>&gt;<i>
</I>&gt;<i> &gt; + u32 run_mode;
</I>&gt;<i> &gt; + u32 i, j;
</I>&gt;<i>
</I>&gt;<i> It's common to use type &quot;int&quot; for the usual incrementer value... as you
</I>&gt;<i> do in other places as well. Please check!
</I>&gt;<i>
</I>&gt;<i> &gt; + unsigned long flags;
</I>&gt;<i> &gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt; + struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> &gt; + struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> &gt; + u32 tx_buffer_avail = 0;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + if (can_dropped_invalid_skb(ndev, skb))
</I>&gt;<i> &gt; + return NETDEV_TX_OK;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Getting the current CAN mode. */
</I>&gt;<i> &gt; + pch_can_get_run_mode(priv, &amp;run_mode);
</I>&gt;<i> &gt; + if (run_mode != PCH_CAN_RUN) {
</I>&gt;<i> &gt; + dev_err(&amp;ndev-&gt;dev, &quot;CAN stopped on transmit attempt.\n&quot;);
</I>&gt;<i> &gt; + return -EPERM;
</I>&gt;<i> &gt; + }
</I>&gt;<i>
</I>&gt;<i> Can this happen? I think this check can be removed. Anyway, -EPERM is
</I>&gt;<i> not a valid return value for that function.
</I>&gt;<i>
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + tx_buffer_avail = pch_get_free_msg_obj(ndev);
</I>&gt;<i> &gt; + if (tx_buffer_avail &lt; 0)
</I>&gt;<i> &gt; + return tx_buffer_avail;
</I>&gt;<i>
</I>&gt;<i> Wrong return value?
</I>&gt;<i>
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Attaining the lock. */
</I>&gt;<i> &gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Reading the Msg Obj from the Msg RAM to the Interface register. */
</I>&gt;<i> &gt; + iowrite32(CAN_CMASK_RX_TX_GET, &amp;(priv-&gt;regs)-&gt;if1_cmask);
</I>&gt;<i> &gt; + pch_can_check_if1_busy(priv, tx_buffer_avail);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Setting the CMASK register. */
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_cmask, CAN_CMASK_ALL);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* If ID extended is set. */
</I>&gt;<i> &gt; + if (cf-&gt;can_id &amp; CAN_EFF_FLAG) {
</I>&gt;<i> &gt; + id =  cf-&gt;can_id &amp; CAN_EFF_MASK;
</I>&gt;<i> &gt; + id1 = id &amp; 0xffff;
</I>&gt;<i> &gt; + id2 = ((id &amp; (0x1fff &lt;&lt; 16)) &gt;&gt; 16) | CAN_ID2_XTD;
</I>&gt;<i>
</I>&gt;<i> Please use some more macro definitions for the sake of readability.
</I>&gt;<i>
</I>&gt;<i> &gt; + } else {
</I>&gt;<i> &gt; + id =  cf-&gt;can_id &amp; CAN_SFF_MASK;
</I>&gt;<i> &gt; + id1 = 0;
</I>&gt;<i> &gt; + id2 = ((id &amp; CAN_SFF_MASK) &lt;&lt; 2);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_id1, 0xffff);
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_id2, 0x1fff | CAN_ID2_XTD);
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_id1, id1);
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_id2, id2);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* If remote frame has to be transmitted.. */
</I>&gt;<i> &gt; + if (cf-&gt;can_id &amp; CAN_RTR_FLAG)
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_id2, CAN_ID2_DIR);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + for (i = 0, j = 0; i &lt; cf-&gt;can_dlc; j++) {
</I>&gt;<i> &gt; + iowrite32(le32_to_cpu(cf-&gt;data[i++]),
</I>&gt;<i> &gt; + (&amp;(priv-&gt;regs)-&gt;if1_dataa1) + j*4);
</I>&gt;<i> &gt; + if (i == cf-&gt;can_dlc)
</I>&gt;<i> &gt; + break;
</I>&gt;<i> &gt; + iowrite32(le32_to_cpu(cf-&gt;data[i++] &lt;&lt; 8),
</I>&gt;<i> &gt; + (&amp;(priv-&gt;regs)-&gt;if1_dataa1) + j*4);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + can_put_echo_skb(skb, ndev, 0);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Updating the size of the data. */
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_mcont, 0x0f);
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_mcont, cf-&gt;can_dlc);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Clearing IntPend, NewDat &amp; TxRqst */
</I>&gt;<i> &gt; + pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_mcont,
</I>&gt;<i> &gt; +    (CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND |
</I>&gt;<i> &gt; +     CAN_IF_MCONT_TXRQXT));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Setting NewDat, TxRqst bits */
</I>&gt;<i> &gt; + pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_mcont,
</I>&gt;<i> &gt; + (CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_TXRQXT));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + pch_can_check_if1_busy(priv, tx_buffer_avail);
</I>&gt;<i> &gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + stats-&gt;tx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> &gt; + stats-&gt;tx_packets++;
</I>&gt;<i>
</I>&gt;<i> That shoould be incremented when the TX done interrupt is handled.
</I>&gt;<i>
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + return NETDEV_TX_OK;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static const struct net_device_ops pch_can_netdev_ops = {
</I>&gt;<i> &gt; + .ndo_open = pch_open,
</I>&gt;<i> &gt; + .ndo_stop = pch_close,
</I>&gt;<i> &gt; + .ndo_start_xmit = pch_xmit,
</I>&gt;<i> &gt; +};
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void __devexit pch_can_remove(struct pci_dev *pdev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + struct net_device *ndev = pci_get_drvdata(pdev);
</I>&gt;<i> &gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + unregister_candev(priv-&gt;ndev);
</I>&gt;<i> &gt; + free_candev(priv-&gt;ndev);
</I>&gt;<i> &gt; + pci_iounmap(pdev, priv-&gt;base);
</I>&gt;<i> &gt; + pci_release_regions(pdev);
</I>&gt;<i> &gt; + pci_disable_device(pdev);
</I>&gt;<i> &gt; + pci_set_drvdata(pdev, NULL);
</I>&gt;<i> &gt; + pch_can_reset(priv);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#ifdef CONFIG_PM
</I>&gt;<i> &gt; +static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + int i; /* Counter variable. */
</I>&gt;<i> &gt; + int retval; /* Return value. */
</I>&gt;<i> &gt; + u32 buf_stat; /* Variable for reading the transmit buffer status. */
</I>&gt;<i> &gt; + u32 counter = 0xFFFFFF;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + struct net_device *dev = pci_get_drvdata(pdev);
</I>&gt;<i> &gt; + struct pch_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Stop the CAN controller */
</I>&gt;<i> &gt; + pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Indicate that we are aboutto/in suspend */
</I>&gt;<i> &gt; + priv-&gt;can.state = CAN_STATE_SLEEPING;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Waiting for all transmission to complete. */
</I>&gt;<i> &gt; + while (counter) {
</I>&gt;<i> &gt; + buf_stat = pch_can_get_buffer_status(priv);
</I>&gt;<i> &gt; + if (!buf_stat)
</I>&gt;<i> &gt; + break;
</I>&gt;<i> &gt; + counter--;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + if (!counter)
</I>&gt;<i> &gt; + dev_err(&amp;pdev-&gt;dev, &quot;%s -&gt; Transmission time out.\n&quot;, __func__);
</I>&gt;<i>
</I>&gt;<i> Timeout without defined delay!
</I>&gt;<i>
</I>&gt;<i> &gt; + /* Save interrupt configuration and then disable them */
</I>&gt;<i> &gt; + pch_can_get_int_enables(priv, &amp;(priv-&gt;int_enables));
</I>&gt;<i> &gt; + pch_can_set_int_enables(priv, PCH_CAN_DISABLE);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Save Tx buffer enable state */
</I>&gt;<i> &gt; + for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> &gt; + if (priv-&gt;msg_obj[i] == MSG_OBJ_TX)
</I>&gt;<i> &gt; + pch_can_get_tx_enable(priv, (i + 1),
</I>&gt;<i> &gt; +       &amp;(priv-&gt;tx_enable[i]));
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Disable all Transmit buffers */
</I>&gt;<i> &gt; + pch_can_tx_disable_all(priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Save Rx buffer enable state */
</I>&gt;<i> &gt; + for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> &gt; + if (priv-&gt;msg_obj[i] == MSG_OBJ_RX) {
</I>&gt;<i> &gt; + pch_can_get_rx_enable(priv, (i + 1),
</I>&gt;<i> &gt; + &amp;(priv-&gt;rx_enable[i]));
</I>&gt;<i> &gt; + pch_can_get_rx_buffer_link(priv, (i + 1),
</I>&gt;<i> &gt; + &amp;(priv-&gt;rx_link[i]));
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Disable all Receive buffers */
</I>&gt;<i> &gt; + pch_can_rx_disable_all(priv);
</I>&gt;<i> &gt; + retval = pci_save_state(pdev);
</I>&gt;<i> &gt; + if (retval) {
</I>&gt;<i> &gt; + dev_err(&amp;pdev-&gt;dev, &quot;pci_save_state failed.\n&quot;);
</I>&gt;<i> &gt; + } else {
</I>&gt;<i> &gt; + pci_enable_wake(pdev, PCI_D3hot, 0);
</I>&gt;<i> &gt; + pci_disable_device(pdev);
</I>&gt;<i> &gt; + pci_set_power_state(pdev, pci_choose_state(pdev, state));
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + return retval;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int pch_can_resume(struct pci_dev *pdev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + int i; /* Counter variable. */
</I>&gt;<i> &gt; + int retval; /* Return variable. */
</I>&gt;<i> &gt; + struct net_device *dev = pci_get_drvdata(pdev);
</I>&gt;<i> &gt; + struct pch_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + pci_set_power_state(pdev, PCI_D0);
</I>&gt;<i> &gt; + pci_restore_state(pdev);
</I>&gt;<i> &gt; + retval = pci_enable_device(pdev);
</I>&gt;<i> &gt; + if (retval) {
</I>&gt;<i> &gt; + dev_err(&amp;pdev-&gt;dev, &quot;pci_enable_device failed.\n&quot;);
</I>&gt;<i> &gt; + return retval;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + pci_enable_wake(pdev, PCI_D3hot, 0);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Disabling all interrupts. */
</I>&gt;<i> &gt; + pch_can_set_int_enables(priv, PCH_CAN_DISABLE);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Setting the CAN device in Stop Mode. */
</I>&gt;<i> &gt; + pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Configuring the transmit and receive buffers. */
</I>&gt;<i> &gt; + pch_can_config_rx_tx_buffers(priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Restore the CAN state */
</I>&gt;<i> &gt; + pch_set_bittiming(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Listen/Active */
</I>&gt;<i> &gt; + pch_can_set_optmode(priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Enabling the transmit buffer. */
</I>&gt;<i> &gt; + for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> &gt; + if (priv-&gt;msg_obj[i] == MSG_OBJ_TX) {
</I>&gt;<i> &gt; + pch_can_set_tx_enable(priv, i + 1,
</I>&gt;<i> &gt; +       priv-&gt;tx_enable[i]);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Configuring the receive buffer and enabling them. */
</I>&gt;<i> &gt; + for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> &gt; + if (priv-&gt;msg_obj[i] == MSG_OBJ_RX) {
</I>&gt;<i> &gt; + /* Restore buffer link */
</I>&gt;<i> &gt; + pch_can_set_rx_buffer_link(priv, i + 1,
</I>&gt;<i> &gt; +    priv-&gt;rx_link[i]);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Restore buffer enables */
</I>&gt;<i> &gt; + pch_can_set_rx_enable(priv, i + 1, priv-&gt;rx_enable[i]);
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Enable CAN Interrupts */
</I>&gt;<i> &gt; + pch_can_set_int_custom(priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + /* Restore Run Mode */
</I>&gt;<i> &gt; + pch_can_set_run_mode(priv, PCH_CAN_RUN);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + return retval;
</I>&gt;<i> &gt; +}
</I>&gt;<i>
</I>&gt;<i> Are the suspend and resume functions tested?
</I>&gt;<i>
</I>&gt;<i> &gt; +#else
</I>&gt;<i> &gt; +#define pch_can_suspend NULL
</I>&gt;<i> &gt; +#define pch_can_resume NULL
</I>&gt;<i> &gt; +#endif
</I>&gt;<i>
</I>&gt;<i> Add empty line here
</I>&gt;<i>
</I>&gt;<i> &gt; +static int __devinit pch_can_probe(struct pci_dev *pdev,
</I>&gt;<i> &gt; +    const struct pci_device_id *id)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + struct net_device *ndev;
</I>&gt;<i> &gt; + struct pch_can_priv *priv;
</I>&gt;<i> &gt; + int rc;
</I>&gt;<i> &gt; + int index;
</I>&gt;<i> &gt; + void __iomem *addr;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + rc = pci_enable_device(pdev);
</I>&gt;<i> &gt; + if (rc) {
</I>&gt;<i> &gt; + dev_err(&amp;pdev-&gt;dev, &quot;Failed pci_enable_device %d\n&quot;, rc);
</I>&gt;<i> &gt; + goto probe_exit_endev;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + rc = pci_request_regions(pdev, KBUILD_MODNAME);
</I>&gt;<i> &gt; + if (rc) {
</I>&gt;<i> &gt; + dev_err(&amp;pdev-&gt;dev, &quot;Failed pci_request_regions %d\n&quot;, rc);
</I>&gt;<i> &gt; + goto probe_exit_pcireq;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + addr = pci_iomap(pdev, 1, 0);
</I>&gt;<i> &gt; + if (!addr) {
</I>&gt;<i> &gt; + rc = -EIO;
</I>&gt;<i> &gt; + dev_err(&amp;pdev-&gt;dev, &quot;Failed pci_iomap\n&quot;);
</I>&gt;<i> &gt; + goto probe_exit_ipmap;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + ndev = alloc_candev(sizeof(struct pch_can_priv), 1);
</I>&gt;<i> &gt; + if (!ndev) {
</I>&gt;<i> &gt; + rc = -ENOMEM;
</I>&gt;<i> &gt; + dev_err(&amp;pdev-&gt;dev, &quot;Failed alloc_candev\n&quot;);
</I>&gt;<i> &gt; + goto probe_exit_alloc_candev;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + priv = netdev_priv(ndev);
</I>&gt;<i> &gt; + priv-&gt;ndev = ndev;
</I>&gt;<i> &gt; + priv-&gt;base = addr;
</I>&gt;<i> &gt; + priv-&gt;regs = addr;
</I>&gt;<i> &gt; + priv-&gt;dev = pdev;
</I>&gt;<i> &gt; + priv-&gt;can.bittiming_const = &amp;pch_can_bittiming_const;
</I>&gt;<i> &gt; + priv-&gt;can.do_set_mode = pch_can_do_set_mode;
</I>&gt;<i> &gt; + priv-&gt;can.do_get_state = pch_can_get_state;
</I>&gt;<i>
</I>&gt;<i> Not needed! See above.
</I>&gt;<i>
</I>&gt;<i> Could you please also implement do_get_berr_counter().
</I>&gt;<i>
</I>&gt;<i> &gt; + priv-&gt;can.ctrlmode_supported = CAN_CTRLMODE_LISTENONLY |
</I>&gt;<i> &gt; +        CAN_CTRLMODE_LOOPBACK;
</I>&gt;<i> &gt; + ndev-&gt;irq = pdev-&gt;irq;
</I>&gt;<i> &gt; + ndev-&gt;flags |= IFF_ECHO;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + pci_set_drvdata(pdev, ndev);
</I>&gt;<i> &gt; + SET_NETDEV_DEV(ndev, &amp;pdev-&gt;dev);
</I>&gt;<i> &gt; + ndev-&gt;netdev_ops = &amp;pch_can_netdev_ops;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + priv-&gt;can.clock.freq = PCH_CAN_CLK * 1000; /* Hz to KHz) */
</I>&gt;<i> &gt; + for (index = 0; index &lt; PCH_RX_OBJ_NUM;)
</I>&gt;<i> &gt; + priv-&gt;msg_obj[index++] = MSG_OBJ_RX;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + for (index = index;  index &lt; PCH_OBJ_NUM;)
</I>&gt;<i> &gt; + priv-&gt;msg_obj[index++] = MSG_OBJ_TX;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + rc = register_candev(ndev);
</I>&gt;<i> &gt; + if (rc) {
</I>&gt;<i> &gt; + dev_err(&amp;pdev-&gt;dev, &quot;Failed register_candev %d\n&quot;, rc);
</I>&gt;<i> &gt; + goto probe_exit_reg_candev;
</I>&gt;<i> &gt; + }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; + return 0;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +probe_exit_reg_candev:
</I>&gt;<i> &gt; + free_candev(ndev);
</I>&gt;<i> &gt; +probe_exit_alloc_candev:
</I>&gt;<i> &gt; + pci_iounmap(pdev, addr);
</I>&gt;<i> &gt; +probe_exit_ipmap:
</I>&gt;<i> &gt; + pci_release_regions(pdev);
</I>&gt;<i> &gt; +probe_exit_pcireq:
</I>&gt;<i> &gt; + pci_disable_device(pdev);
</I>&gt;<i> &gt; +probe_exit_endev:
</I>&gt;<i> &gt; + return rc;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static struct pci_driver pch_can_pcidev = {
</I>&gt;<i> &gt; + .name = KBUILD_MODNAME,
</I>&gt;<i> &gt; + .id_table = pch_can_pcidev_id,
</I>&gt;<i> &gt; + .probe = pch_can_probe,
</I>&gt;<i> &gt; + .remove = __devexit_p(pch_can_remove),
</I>&gt;<i> &gt; + .suspend = pch_can_suspend,
</I>&gt;<i> &gt; + .resume = pch_can_resume,
</I>&gt;<i> &gt; +};
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int __init pch_can_pci_init(void)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + return pci_register_driver(&amp;pch_can_pcidev);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +module_init(pch_can_pci_init);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void __exit pch_can_pci_exit(void)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; + pci_unregister_driver(&amp;pch_can_pcidev);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +module_exit(pch_can_pci_exit);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +MODULE_DESCRIPTION(&quot;Controller Area Network Driver&quot;);
</I>&gt;<i> &gt; +MODULE_LICENSE(&quot;GPL&quot;);
</I>&gt;<i>
</I>&gt;<i> GPL v2 ?
</I>&gt;<i>
</I>&gt;<i> &gt; +MODULE_VERSION(&quot;0.94&quot;);
</I>&gt;<i> &gt; +MODULE_DEVICE_TABLE(pci, pch_can_pcidev_id);
</I>&gt;<i>
</I>&gt;<i> Please add it below the declaration of pch_can_pcidev_id.
</I>&gt;<i>
</I>&gt;<i> In this driver you are using just *one* RX object. This means that the
</I>&gt;<i> CPU must handle new messages as quickly as possible otherwise message
</I>&gt;<i> losses will happen, right?. For sure, this will not make user's happy.
</I>&gt;<i> Any chance to use more RX objects in FIFO mode?
</I>&gt;<i>
</I>&gt;<i> Thanks,
</I>&gt;<i>
</I>&gt;<i> Wolfgang.
</I>&gt;<i> --
</I>&gt;<i> To unsubscribe from this list: send the line &quot;unsubscribe netdev&quot; in
</I>&gt;<i> the body of a message to <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">majordomo at vger.kernel.org</A>
</I>&gt;<i> More majordomo info at  <A HREF="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</A>
</I>&gt;<i>
</I>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="004687.html">[MeeGo-Dev][PATCH v3] Topcliff: Update PCH_CAN driver to 2.6.35
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4686">[ date ]</a>
              <a href="thread.html#4686">[ thread ]</a>
              <a href="subject.html#4686">[ subject ]</a>
              <a href="author.html#4686">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
