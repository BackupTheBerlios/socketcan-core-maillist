<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH v3] at91_can
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20v3%5D%20at91_can&In-Reply-To=%3C4AAE4EBA.9020402%40pengutronix.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003087.html">
   <LINK REL="Next"  HREF="003078.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH v3] at91_can</H1>
    <B>Marc Kleine-Budde</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20v3%5D%20at91_can&In-Reply-To=%3C4AAE4EBA.9020402%40pengutronix.de%3E"
       TITLE="[PATCH v3] at91_can">mkl at pengutronix.de
       </A><BR>
    <I>Mon Sep 14 16:10:02 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003087.html">[PATCH 2/2] ems_usb: Added support for EMS CPC-USB/ARM7 CAN/USB	interface
</A></li>
        <LI>Next message: <A HREF="003078.html">[PATCH v3] at91_can
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3066">[ date ]</a>
              <a href="thread.html#3066">[ thread ]</a>
              <a href="subject.html#3066">[ subject ]</a>
              <a href="author.html#3066">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

here again a &quot;./strip-src -m -i -v 2.6.31&quot; version of the at91 driver,
featuring:
- reworked RX-path
  now Vladislavs-safe :)
- improved bus off handling
  removed work queue
  honours restart_ms
- fixed coding style

cheers, Marc

&gt;<i> /*
</I>&gt;<i>  * at91_can.c - CAN network driver for AT91 SoC CAN controller
</I>&gt;<i>  *
</I>&gt;<i>  * (C) 2007 by Hans J. Koch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">hjk at linutronix.de</A>&gt;
</I>&gt;<i>  * (C) 2008, 2009 by Marc Kleine-Budde &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kernel at pengutronix.de</A>&gt;
</I>&gt;<i>  *
</I>&gt;<i>  * This software may be distributed under the terms of the GNU General
</I>&gt;<i>  * Public License (&quot;GPL&quot;) version 2 as distributed in the 'COPYING'
</I>&gt;<i>  * file from the main directory of the linux kernel source.
</I>&gt;<i>  *
</I>&gt;<i>  * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">socketcan-users at lists.berlios.de</A>&gt;
</I>&gt;<i>  *
</I>&gt;<i>  */
</I>&gt;<i> 
</I>&gt;<i> #include &lt;linux/clk.h&gt;
</I>&gt;<i> #include &lt;linux/errno.h&gt;
</I>&gt;<i> #include &lt;linux/if_arp.h&gt;
</I>&gt;<i> #include &lt;linux/init.h&gt;
</I>&gt;<i> #include &lt;linux/interrupt.h&gt;
</I>&gt;<i> #include &lt;linux/kernel.h&gt;
</I>&gt;<i> #include &lt;linux/module.h&gt;
</I>&gt;<i> #include &lt;linux/netdevice.h&gt;
</I>&gt;<i> #include &lt;linux/platform_device.h&gt;
</I>&gt;<i> #include &lt;linux/skbuff.h&gt;
</I>&gt;<i> #include &lt;linux/spinlock.h&gt;
</I>&gt;<i> #include &lt;linux/string.h&gt;
</I>&gt;<i> #include &lt;linux/types.h&gt;
</I>&gt;<i> 
</I>&gt;<i> #include &lt;socketcan/can.h&gt;
</I>&gt;<i> #include &lt;socketcan/can/dev.h&gt;
</I>&gt;<i> #include &lt;socketcan/can/error.h&gt;
</I>&gt;<i> 
</I>&gt;<i> #include &lt;mach/board.h&gt;
</I>&gt;<i> 
</I>&gt;<i> #define DRV_NAME		&quot;at91_can&quot;
</I>&gt;<i> #define AT91_NAPI_WEIGHT	12
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * RX/TX Mailbox split
</I>&gt;<i>  * don't dare to touch
</I>&gt;<i>  */
</I>&gt;<i> #define AT91_MB_RX_NUM		12
</I>&gt;<i> #define AT91_MB_TX_SHIFT	2
</I>&gt;<i> 
</I>&gt;<i> #define AT91_MB_RX_FIRST	0
</I>&gt;<i> #define AT91_MB_RX_LAST		(AT91_MB_RX_FIRST + AT91_MB_RX_NUM - 1)
</I>&gt;<i> 
</I>&gt;<i> #define AT91_MB_RX_MASK(i)	((1 &lt;&lt; (i)) - 1)
</I>&gt;<i> #define AT91_MB_RX_SPLIT	8
</I>&gt;<i> #define AT91_MB_RX_LOW_LAST	(AT91_MB_RX_SPLIT - 1)
</I>&gt;<i> #define AT91_MB_RX_LOW_MASK	(AT91_MB_RX_MASK(AT91_MB_RX_SPLIT))
</I>&gt;<i> 
</I>&gt;<i> #define AT91_MB_TX_NUM		(1 &lt;&lt; AT91_MB_TX_SHIFT)
</I>&gt;<i> #define AT91_MB_TX_FIRST	(AT91_MB_RX_LAST + 1)
</I>&gt;<i> #define AT91_MB_TX_LAST		(AT91_MB_TX_FIRST + AT91_MB_TX_NUM - 1)
</I>&gt;<i> 
</I>&gt;<i> #define AT91_NEXT_PRIO_SHIFT	(AT91_MB_TX_SHIFT)
</I>&gt;<i> #define AT91_NEXT_PRIO_MASK	(0xf &lt;&lt; AT91_MB_TX_SHIFT)
</I>&gt;<i> #define AT91_NEXT_MB_MASK	(AT91_MB_TX_NUM - 1)
</I>&gt;<i> #define AT91_NEXT_MASK		((AT91_MB_TX_NUM - 1) | AT91_NEXT_PRIO_MASK)
</I>&gt;<i> 
</I>&gt;<i> /* Common registers */
</I>&gt;<i> enum at91_reg {
</I>&gt;<i> 	AT91_MR		= 0x000,
</I>&gt;<i> 	AT91_IER	= 0x004,
</I>&gt;<i> 	AT91_IDR	= 0x008,
</I>&gt;<i> 	AT91_IMR	= 0x00C,
</I>&gt;<i> 	AT91_SR		= 0x010,
</I>&gt;<i> 	AT91_BR		= 0x014,
</I>&gt;<i> 	AT91_TIM	= 0x018,
</I>&gt;<i> 	AT91_TIMESTP	= 0x01C,
</I>&gt;<i> 	AT91_ECR	= 0x020,
</I>&gt;<i> 	AT91_TCR	= 0x024,
</I>&gt;<i> 	AT91_ACR	= 0x028,
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> /* Mailbox registers (0 &lt;= i &lt;= 15) */
</I>&gt;<i> #define AT91_MMR(i)		(enum at91_reg)(0x200 + ((i) * 0x20))
</I>&gt;<i> #define AT91_MAM(i)		(enum at91_reg)(0x204 + ((i) * 0x20))
</I>&gt;<i> #define AT91_MID(i)		(enum at91_reg)(0x208 + ((i) * 0x20))
</I>&gt;<i> #define AT91_MFID(i)		(enum at91_reg)(0x20C + ((i) * 0x20))
</I>&gt;<i> #define AT91_MSR(i)		(enum at91_reg)(0x210 + ((i) * 0x20))
</I>&gt;<i> #define AT91_MDL(i)		(enum at91_reg)(0x214 + ((i) * 0x20))
</I>&gt;<i> #define AT91_MDH(i)		(enum at91_reg)(0x218 + ((i) * 0x20))
</I>&gt;<i> #define AT91_MCR(i)		(enum at91_reg)(0x21C + ((i) * 0x20))
</I>&gt;<i> 
</I>&gt;<i> /* Register bits */
</I>&gt;<i> #define AT91_MR_CANEN		BIT(0)
</I>&gt;<i> #define AT91_MR_LPM		BIT(1)
</I>&gt;<i> #define AT91_MR_ABM		BIT(2)
</I>&gt;<i> #define AT91_MR_OVL		BIT(3)
</I>&gt;<i> #define AT91_MR_TEOF		BIT(4)
</I>&gt;<i> #define AT91_MR_TTM		BIT(5)
</I>&gt;<i> #define AT91_MR_TIMFRZ		BIT(6)
</I>&gt;<i> #define AT91_MR_DRPT		BIT(7)
</I>&gt;<i> 
</I>&gt;<i> #define AT91_SR_RBSY		BIT(29)
</I>&gt;<i> 
</I>&gt;<i> #define AT91_MMR_PRIO_SHIFT	(16)
</I>&gt;<i> 
</I>&gt;<i> #define AT91_MID_MIDE		BIT(29)
</I>&gt;<i> 
</I>&gt;<i> #define AT91_MSR_MRTR		BIT(20)
</I>&gt;<i> #define AT91_MSR_MABT		BIT(22)
</I>&gt;<i> #define AT91_MSR_MRDY		BIT(23)
</I>&gt;<i> #define AT91_MSR_MMI		BIT(24)
</I>&gt;<i> 
</I>&gt;<i> #define AT91_MCR_MRTR		BIT(20)
</I>&gt;<i> #define AT91_MCR_MTCR		BIT(23)
</I>&gt;<i> 
</I>&gt;<i> /* Mailbox Modes */
</I>&gt;<i> enum at91_mb_mode {
</I>&gt;<i> 	AT91_MB_MODE_DISABLED	= 0,
</I>&gt;<i> 	AT91_MB_MODE_RX		= 1,
</I>&gt;<i> 	AT91_MB_MODE_RX_OVRWR	= 2,
</I>&gt;<i> 	AT91_MB_MODE_TX		= 3,
</I>&gt;<i> 	AT91_MB_MODE_CONSUMER	= 4,
</I>&gt;<i> 	AT91_MB_MODE_PRODUCER	= 5,
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> /* Interrupt mask bits */
</I>&gt;<i> #define AT91_IRQ_MB_RX		((1 &lt;&lt; (AT91_MB_RX_LAST + 1)) \
</I>&gt;<i> 				 - (1 &lt;&lt; AT91_MB_RX_FIRST))
</I>&gt;<i> #define AT91_IRQ_MB_TX		((1 &lt;&lt; (AT91_MB_TX_LAST + 1)) \
</I>&gt;<i> 				 - (1 &lt;&lt; AT91_MB_TX_FIRST))
</I>&gt;<i> #define AT91_IRQ_MB_ALL		(AT91_IRQ_MB_RX | AT91_IRQ_MB_TX)
</I>&gt;<i> 
</I>&gt;<i> #define AT91_IRQ_ERRA		(1 &lt;&lt; 16)
</I>&gt;<i> #define AT91_IRQ_WARN		(1 &lt;&lt; 17)
</I>&gt;<i> #define AT91_IRQ_ERRP		(1 &lt;&lt; 18)
</I>&gt;<i> #define AT91_IRQ_BOFF		(1 &lt;&lt; 19)
</I>&gt;<i> #define AT91_IRQ_SLEEP		(1 &lt;&lt; 20)
</I>&gt;<i> #define AT91_IRQ_WAKEUP		(1 &lt;&lt; 21)
</I>&gt;<i> #define AT91_IRQ_TOVF		(1 &lt;&lt; 22)
</I>&gt;<i> #define AT91_IRQ_TSTP		(1 &lt;&lt; 23)
</I>&gt;<i> #define AT91_IRQ_CERR		(1 &lt;&lt; 24)
</I>&gt;<i> #define AT91_IRQ_SERR		(1 &lt;&lt; 25)
</I>&gt;<i> #define AT91_IRQ_AERR		(1 &lt;&lt; 26)
</I>&gt;<i> #define AT91_IRQ_FERR		(1 &lt;&lt; 27)
</I>&gt;<i> #define AT91_IRQ_BERR		(1 &lt;&lt; 28)
</I>&gt;<i> 
</I>&gt;<i> #define AT91_IRQ_ERR_ALL	(0x1fff0000)
</I>&gt;<i> #define AT91_IRQ_ERR_FRAME	(AT91_IRQ_CERR | AT91_IRQ_SERR | \
</I>&gt;<i> 				 AT91_IRQ_AERR | AT91_IRQ_FERR | AT91_IRQ_BERR)
</I>&gt;<i> #define AT91_IRQ_ERR_LINE	(AT91_IRQ_ERRA | AT91_IRQ_WARN | \
</I>&gt;<i> 				 AT91_IRQ_ERRP | AT91_IRQ_BOFF)
</I>&gt;<i> 
</I>&gt;<i> #define AT91_IRQ_ALL		(0x1fffffff)
</I>&gt;<i> 
</I>&gt;<i> struct at91_priv {
</I>&gt;<i> 	struct can_priv		can;	   /* must be the first member! */
</I>&gt;<i> 	struct net_device	*dev;
</I>&gt;<i> 	struct napi_struct	napi;
</I>&gt;<i> 
</I>&gt;<i> 	void __iomem		*reg_base;
</I>&gt;<i> 
</I>&gt;<i> 	u32			reg_sr;
</I>&gt;<i> 	unsigned int		tx_next;
</I>&gt;<i> 	unsigned int		tx_echo;
</I>&gt;<i> 	unsigned int		rx_next;
</I>&gt;<i> 
</I>&gt;<i> 	struct clk		*clk;
</I>&gt;<i> 	struct at91_can_data	*pdata;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> static struct can_bittiming_const at91_bittiming_const = {
</I>&gt;<i> 	.tseg1_min	= 4,
</I>&gt;<i> 	.tseg1_max	= 16,
</I>&gt;<i> 	.tseg2_min	= 2,
</I>&gt;<i> 	.tseg2_max	= 8,
</I>&gt;<i> 	.sjw_max	= 4,
</I>&gt;<i> 	.brp_min 	= 2,
</I>&gt;<i> 	.brp_max	= 128,
</I>&gt;<i> 	.brp_inc	= 1,
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> static inline int get_tx_next_mb(const struct at91_priv *priv)
</I>&gt;<i> {
</I>&gt;<i> 	return (priv-&gt;tx_next &amp; AT91_NEXT_MB_MASK) + AT91_MB_TX_FIRST;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static inline int get_tx_next_prio(const struct at91_priv *priv)
</I>&gt;<i> {
</I>&gt;<i> 	return (priv-&gt;tx_next &gt;&gt; AT91_NEXT_PRIO_SHIFT) &amp; 0xf;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static inline int get_tx_echo_mb(const struct at91_priv *priv)
</I>&gt;<i> {
</I>&gt;<i> 	return (priv-&gt;tx_echo &amp; AT91_NEXT_MB_MASK) + AT91_MB_TX_FIRST;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static inline u32 at91_read(const struct at91_priv *priv, enum at91_reg reg)
</I>&gt;<i> {
</I>&gt;<i> 	return readl(priv-&gt;reg_base + reg);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static inline void at91_write(const struct at91_priv *priv, enum at91_reg reg,
</I>&gt;<i> 		u32 value)
</I>&gt;<i> {
</I>&gt;<i> 	writel(value, priv-&gt;reg_base + reg);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static inline void set_mb_mode_prio(const struct at91_priv *priv,
</I>&gt;<i> 		unsigned int mb, enum at91_mb_mode mode, int prio)
</I>&gt;<i> {
</I>&gt;<i> 	at91_write(priv, AT91_MMR(mb), (mode &lt;&lt; 24) | (prio &lt;&lt; 16));
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static inline void set_mb_mode(const struct at91_priv *priv, unsigned int mb,
</I>&gt;<i> 		enum at91_mb_mode mode)
</I>&gt;<i> {
</I>&gt;<i> 	set_mb_mode_prio(priv, mb, mode, 0);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static struct sk_buff *alloc_can_skb(struct net_device *dev,
</I>&gt;<i> 	struct can_frame **cf)
</I>&gt;<i> {
</I>&gt;<i> 	struct sk_buff *skb;
</I>&gt;<i> 
</I>&gt;<i> 	skb = netdev_alloc_skb(dev, sizeof(struct can_frame));
</I>&gt;<i> 	if (unlikely(!skb))
</I>&gt;<i> 		return NULL;
</I>&gt;<i> 
</I>&gt;<i> 	skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;<i> 	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
</I>&gt;<i> 	*cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
</I>&gt;<i> 
</I>&gt;<i> 	return skb;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static struct sk_buff *alloc_can_err_skb(struct net_device *dev,
</I>&gt;<i> 		struct can_frame **cf)
</I>&gt;<i> {
</I>&gt;<i> 	struct sk_buff *skb;
</I>&gt;<i> 
</I>&gt;<i> 	skb = alloc_can_skb(dev, cf);
</I>&gt;<i> 	if (unlikely(!skb))
</I>&gt;<i> 		return NULL;
</I>&gt;<i> 
</I>&gt;<i> 	memset(*cf, 0, sizeof(struct can_frame));
</I>&gt;<i> 	(*cf)-&gt;can_id = CAN_ERR_FLAG;
</I>&gt;<i> 	(*cf)-&gt;can_dlc = CAN_ERR_DLC;
</I>&gt;<i> 
</I>&gt;<i> 	return skb;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * Swtich transceiver on or off
</I>&gt;<i>  */
</I>&gt;<i> static void at91_transceiver_switch(const struct at91_priv *priv, int on)
</I>&gt;<i> {
</I>&gt;<i> 	if (priv-&gt;pdata &amp;&amp; priv-&gt;pdata-&gt;transceiver_switch)
</I>&gt;<i> 		priv-&gt;pdata-&gt;transceiver_switch(on);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void at91_setup_mailboxes(struct net_device *dev)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	unsigned int i;
</I>&gt;<i> 
</I>&gt;<i> 	/*
</I>&gt;<i> 	 * The first 12 mailboxes are used as a reception FIFO. The
</I>&gt;<i> 	 * last mailbox is configured with overwrite option. The
</I>&gt;<i> 	 * overwrite flag indicates a FIFO overflow.
</I>&gt;<i> 	 */
</I>&gt;<i> 	for (i = AT91_MB_RX_FIRST; i &lt; AT91_MB_RX_LAST; i++)
</I>&gt;<i> 		set_mb_mode(priv, i, AT91_MB_MODE_RX);
</I>&gt;<i> 	set_mb_mode(priv, AT91_MB_RX_LAST, AT91_MB_MODE_RX_OVRWR);
</I>&gt;<i> 
</I>&gt;<i> 	/* The last 4 mailboxes are used for transmitting. */
</I>&gt;<i> 	for (i = AT91_MB_TX_FIRST; i &lt;= AT91_MB_TX_LAST; i++)
</I>&gt;<i> 		set_mb_mode_prio(priv, i, AT91_MB_MODE_TX, 0);
</I>&gt;<i> 
</I>&gt;<i> 	/* Reset tx and rx helper pointers */
</I>&gt;<i> 	priv-&gt;tx_next = priv-&gt;tx_echo = priv-&gt;rx_next = 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static int at91_set_bittiming(struct net_device *dev)
</I>&gt;<i> {
</I>&gt;<i> 	const struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	const struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> 	u32 reg_br;
</I>&gt;<i> 
</I>&gt;<i> 	reg_br = ((priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES) &lt;&lt; 24) |
</I>&gt;<i> 		((bt-&gt;brp - 1) &lt;&lt; 16) |	((bt-&gt;sjw - 1) &lt;&lt; 12) |
</I>&gt;<i> 		((bt-&gt;prop_seg - 1) &lt;&lt; 8) | ((bt-&gt;phase_seg1 - 1) &lt;&lt; 4) |
</I>&gt;<i> 		((bt-&gt;phase_seg2 - 1) &lt;&lt; 0);
</I>&gt;<i> 
</I>&gt;<i> 	dev_info(ND2D(dev), &quot;writing AT91_BR: 0x%08x\n&quot;, reg_br);
</I>&gt;<i> 
</I>&gt;<i> 	at91_write(priv, AT91_BR, reg_br);
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void at91_chip_start(struct net_device *dev)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	u32 reg_mr, reg_ier;
</I>&gt;<i> 
</I>&gt;<i> 	/* disable interrupts */
</I>&gt;<i> 	at91_write(priv, AT91_IDR, AT91_IRQ_ALL);
</I>&gt;<i> 
</I>&gt;<i> 	/* disable chip */
</I>&gt;<i> 	reg_mr = at91_read(priv, AT91_MR);
</I>&gt;<i> 	at91_write(priv, AT91_MR, reg_mr &amp; ~AT91_MR_CANEN);
</I>&gt;<i> 
</I>&gt;<i> 	at91_setup_mailboxes(dev);
</I>&gt;<i> 	at91_transceiver_switch(priv, 1);
</I>&gt;<i> 
</I>&gt;<i> 	/* enable chip */
</I>&gt;<i> 	at91_write(priv, AT91_MR, AT91_MR_CANEN);
</I>&gt;<i> 
</I>&gt;<i> 	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> 
</I>&gt;<i> 	/* Enable interrupts */
</I>&gt;<i> 	reg_ier = AT91_IRQ_MB_RX | AT91_IRQ_ERRP | AT91_IRQ_ERR_FRAME;
</I>&gt;<i> 	at91_write(priv, AT91_IDR, AT91_IRQ_ALL);
</I>&gt;<i> 	at91_write(priv, AT91_IER, reg_ier);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void at91_chip_stop(struct net_device *dev, enum can_state state)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	u32 reg_mr;
</I>&gt;<i> 
</I>&gt;<i> 	/* disable interrupts */
</I>&gt;<i> 	at91_write(priv, AT91_IDR, AT91_IRQ_ALL);
</I>&gt;<i> 
</I>&gt;<i> 	reg_mr = at91_read(priv, AT91_MR);
</I>&gt;<i> 	at91_write(priv, AT91_MR, reg_mr &amp; ~AT91_MR_CANEN);
</I>&gt;<i> 
</I>&gt;<i> 	at91_transceiver_switch(priv, 0);
</I>&gt;<i> 	priv-&gt;can.state = state;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * theory of operation:
</I>&gt;<i>  *
</I>&gt;<i>  * According to the datasheet priority 0 is the highest priority, 15
</I>&gt;<i>  * is the lowest. If two mailboxes have the same priority level the
</I>&gt;<i>  * message of the mailbox with the lowest number is sent first.
</I>&gt;<i>  *
</I>&gt;<i>  * We use the first TX mailbox (AT91_MB_TX_FIRST) with prio 0, then
</I>&gt;<i>  * the next mailbox with prio 0, and so on, until all mailboxes are
</I>&gt;<i>  * used. Then we start from the beginning with mailbox
</I>&gt;<i>  * AT91_MB_TX_FIRST, but with prio 1, mailbox AT91_MB_TX_FIRST + 1
</I>&gt;<i>  * prio 1. When we reach the last mailbox with prio 15, we have to
</I>&gt;<i>  * stop sending, waiting for all messages to be delivered, then start
</I>&gt;<i>  * again with mailbox AT91_MB_TX_FIRST prio 0.
</I>&gt;<i>  *
</I>&gt;<i>  * We use the priv-&gt;tx_next as counter for the next transmission
</I>&gt;<i>  * mailbox, but without the offset AT91_MB_TX_FIRST. The lower bits
</I>&gt;<i>  * encode the mailbox number, the upper 4 bits the mailbox priority:
</I>&gt;<i>  *
</I>&gt;<i>  * priv-&gt;tx_next = (prio &lt;&lt; AT91_NEXT_PRIO_SHIFT) ||
</I>&gt;<i>  *                 (mb - AT91_MB_TX_FIRST);
</I>&gt;<i>  *
</I>&gt;<i>  */
</I>&gt;<i> static int at91_start_xmit(struct sk_buff *skb, struct net_device *dev)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> 	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> 	unsigned int mb, prio;
</I>&gt;<i> 	u32 reg_mid, reg_mcr;
</I>&gt;<i> 
</I>&gt;<i> 	mb = get_tx_next_mb(priv);
</I>&gt;<i> 	prio = get_tx_next_prio(priv);
</I>&gt;<i> 
</I>&gt;<i> 	if (unlikely(!(at91_read(priv, AT91_MSR(mb)) &amp; AT91_MSR_MRDY))) {
</I>&gt;<i> 		netif_stop_queue(dev);
</I>&gt;<i> 
</I>&gt;<i> 		dev_err(ND2D(dev), &quot;BUG! TX buffer full when queue awake!\n&quot;);
</I>&gt;<i> 		return NETDEV_TX_BUSY;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	if (cf-&gt;can_id &amp; CAN_EFF_FLAG)
</I>&gt;<i> 		reg_mid = (cf-&gt;can_id &amp; CAN_EFF_MASK) | AT91_MID_MIDE;
</I>&gt;<i> 	else
</I>&gt;<i> 		reg_mid = (cf-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; 18;
</I>&gt;<i> 
</I>&gt;<i> 	reg_mcr = ((cf-&gt;can_id &amp; CAN_RTR_FLAG) ? AT91_MCR_MRTR : 0) |
</I>&gt;<i> 		(cf-&gt;can_dlc &lt;&lt; 16) | AT91_MCR_MTCR;
</I>&gt;<i> 
</I>&gt;<i> 	/* disable MB while writing ID (see datasheet) */
</I>&gt;<i> 	set_mb_mode(priv, mb, AT91_MB_MODE_DISABLED);
</I>&gt;<i> 	at91_write(priv, AT91_MID(mb), reg_mid);
</I>&gt;<i> 	set_mb_mode_prio(priv, mb, AT91_MB_MODE_TX, prio);
</I>&gt;<i> 
</I>&gt;<i> 	at91_write(priv, AT91_MDL(mb), *(u32 *)(cf-&gt;data + 0));
</I>&gt;<i> 	at91_write(priv, AT91_MDH(mb), *(u32 *)(cf-&gt;data + 4));
</I>&gt;<i> 
</I>&gt;<i> 	/* This triggers transmission */
</I>&gt;<i> 	at91_write(priv, AT91_MCR(mb), reg_mcr);
</I>&gt;<i> 
</I>&gt;<i> 	stats-&gt;tx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> 	dev-&gt;trans_start = jiffies;
</I>&gt;<i> 
</I>&gt;<i> 	/* _NOTE_: substract AT91_MB_TX_FIRST offset from mb! */
</I>&gt;<i> 	can_put_echo_skb(skb, dev, mb - AT91_MB_TX_FIRST);
</I>&gt;<i> 
</I>&gt;<i> 	/*
</I>&gt;<i> 	 * we have to stop the queue and deliver all messages in case
</I>&gt;<i> 	 * of a prio+mb counter wrap around. This is the case if
</I>&gt;<i> 	 * tx_next buffer prio and mailbox equals 0.
</I>&gt;<i> 	 *
</I>&gt;<i> 	 * also stop the queue if next buffer is still in use
</I>&gt;<i> 	 * (== not ready)
</I>&gt;<i> 	 */
</I>&gt;<i> 	priv-&gt;tx_next++;
</I>&gt;<i> 	if (!(at91_read(priv, AT91_MSR(get_tx_next_mb(priv))) &amp;
</I>&gt;<i> 	      AT91_MSR_MRDY) ||
</I>&gt;<i> 	    (priv-&gt;tx_next &amp; AT91_NEXT_MASK) == 0)
</I>&gt;<i> 		netif_stop_queue(dev);
</I>&gt;<i> 
</I>&gt;<i> 	/* Enable interrupt for this mailbox */
</I>&gt;<i> 	at91_write(priv, AT91_IER, 1 &lt;&lt; mb);
</I>&gt;<i> 
</I>&gt;<i> 	return NETDEV_TX_OK;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /**
</I>&gt;<i>  * at91_activate_rx_low - activate lower rx mailboxes
</I>&gt;<i>  * @priv: a91 context
</I>&gt;<i>  *
</I>&gt;<i>  * Reenables the lower mailboxes for reception of new CAN messages
</I>&gt;<i>  */
</I>&gt;<i> static inline void at91_activate_rx_low(const struct at91_priv *priv)
</I>&gt;<i> {
</I>&gt;<i> 	u32 mask = AT91_MB_RX_LOW_MASK;
</I>&gt;<i> 	at91_write(priv, AT91_TCR, mask);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /**
</I>&gt;<i>  * at91_activate_rx_mb - reactive single rx mailbox
</I>&gt;<i>  * @priv: a91 context
</I>&gt;<i>  * @mb: mailbox to reactivate
</I>&gt;<i>  *
</I>&gt;<i>  * Reenables given mailbox for reception of new CAN messages
</I>&gt;<i>  */
</I>&gt;<i> static inline void at91_activate_rx_mb(const struct at91_priv *priv,
</I>&gt;<i> 		unsigned int mb)
</I>&gt;<i> {
</I>&gt;<i> 	u32 mask = 1 &lt;&lt; mb;
</I>&gt;<i> 	at91_write(priv, AT91_TCR, mask);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /**
</I>&gt;<i>  * at91_rx_overflow_err - send error frame due to rx overflow
</I>&gt;<i>  * @dev: net device
</I>&gt;<i>  */
</I>&gt;<i> static void at91_rx_overflow_err(struct net_device *dev)
</I>&gt;<i> {
</I>&gt;<i> 	struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> 	struct sk_buff *skb;
</I>&gt;<i> 	struct can_frame *cf;
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(ND2D(dev), &quot;RX buffer overflow\n&quot;);
</I>&gt;<i> 	stats-&gt;rx_over_errors++;
</I>&gt;<i> 	stats-&gt;rx_errors++;
</I>&gt;<i> 
</I>&gt;<i> 	skb = alloc_can_err_skb(dev, &amp;cf);
</I>&gt;<i> 	if (unlikely(!skb))
</I>&gt;<i> 		return;
</I>&gt;<i> 
</I>&gt;<i> 	cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> 	cf-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
</I>&gt;<i> 	netif_rx(skb);
</I>&gt;<i> 
</I>&gt;<i> 	dev-&gt;last_rx = jiffies;
</I>&gt;<i> 	stats-&gt;rx_packets++;
</I>&gt;<i> 	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /**
</I>&gt;<i>  * at91_read_mb - read CAN msg from mailbox (lowlevel impl)
</I>&gt;<i>  * @dev: net device
</I>&gt;<i>  * @mb: mailbox number to read from
</I>&gt;<i>  * @cf: can frame where to store message
</I>&gt;<i>  *
</I>&gt;<i>  * Reads a CAN message from the given mailbox and stores data into
</I>&gt;<i>  * given can frame. &quot;mb&quot; and &quot;cf&quot; must be valid.
</I>&gt;<i>  */
</I>&gt;<i> static void at91_read_mb(struct net_device *dev, unsigned int mb,
</I>&gt;<i> 		struct can_frame *cf)
</I>&gt;<i> {
</I>&gt;<i> 	const struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	u32 reg_msr, reg_mid;
</I>&gt;<i> 
</I>&gt;<i> 	reg_mid = at91_read(priv, AT91_MID(mb));
</I>&gt;<i> 	if (reg_mid &amp; AT91_MID_MIDE)
</I>&gt;<i> 		cf-&gt;can_id = ((reg_mid &gt;&gt; 0) &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
</I>&gt;<i> 	else
</I>&gt;<i> 		cf-&gt;can_id = (reg_mid &gt;&gt; 18) &amp; CAN_SFF_MASK;
</I>&gt;<i> 
</I>&gt;<i> 	reg_msr = at91_read(priv, AT91_MSR(mb));
</I>&gt;<i> 	if (reg_msr &amp; AT91_MSR_MRTR)
</I>&gt;<i> 		cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> 	cf-&gt;can_dlc = min_t(__u8, (reg_msr &gt;&gt; 16) &amp; 0xf, 8);
</I>&gt;<i> 
</I>&gt;<i> 	*(u32 *)(cf-&gt;data + 0) = at91_read(priv, AT91_MDL(mb));
</I>&gt;<i> 	*(u32 *)(cf-&gt;data + 4) = at91_read(priv, AT91_MDH(mb));
</I>&gt;<i> 
</I>&gt;<i> 	if (unlikely(mb == AT91_MB_RX_LAST &amp;&amp; reg_msr &amp; AT91_MSR_MMI))
</I>&gt;<i> 		at91_rx_overflow_err(dev);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /**
</I>&gt;<i>  * at91_read_msg - read CAN message from mailbox
</I>&gt;<i>  * @dev: net device
</I>&gt;<i>  * @mb: mail box to read from
</I>&gt;<i>  *
</I>&gt;<i>  * Reads a CAN message from given mailbox, and put into linux network
</I>&gt;<i>  * RX queue, does all housekeeping chores (stats, ...)
</I>&gt;<i>  */
</I>&gt;<i> static void at91_read_msg(struct net_device *dev, unsigned int mb)
</I>&gt;<i> {
</I>&gt;<i> 	struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> 	struct can_frame *cf;
</I>&gt;<i> 	struct sk_buff *skb;
</I>&gt;<i> 
</I>&gt;<i> 	skb = alloc_can_skb(dev, &amp;cf);
</I>&gt;<i> 	if (unlikely(!skb)) {
</I>&gt;<i> 		stats-&gt;rx_dropped++;
</I>&gt;<i> 		return;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	at91_read_mb(dev, mb, cf);
</I>&gt;<i> 	netif_rx(skb);
</I>&gt;<i> 
</I>&gt;<i> 	dev-&gt;last_rx = jiffies;
</I>&gt;<i> 	stats-&gt;rx_packets++;
</I>&gt;<i> 	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /**
</I>&gt;<i>  * at91_poll_rx - read multiple CAN messages from mailboxes
</I>&gt;<i>  * @dev: net device
</I>&gt;<i>  * @quota: max number of pkgs we're allowed to receive
</I>&gt;<i>  *
</I>&gt;<i>  * Theory of Operation:
</I>&gt;<i>  *
</I>&gt;<i>  * 12 of the 16 mailboxes on the chip are reserved for RX. we split
</I>&gt;<i>  * them into 2 groups. The lower group holds 8 and upper 4 mailboxes.
</I>&gt;<i>  *
</I>&gt;<i>  * Like it or not, but the chip always saves a received CAN message
</I>&gt;<i>  * into the first free mailbox it finds (starting with the
</I>&gt;<i>  * lowest). This makes it very difficult to read the messages in the
</I>&gt;<i>  * right order from the chip. This is how we work around that problem:
</I>&gt;<i>  *
</I>&gt;<i>  * The first message goes into mb nr. 0 and issues an interrupt. All
</I>&gt;<i>  * rx ints are disabled in the interrupt handler and a napi poll is
</I>&gt;<i>  * scheduled. We read the mailbox, but do _not_ reenable the mb (to
</I>&gt;<i>  * receive another message).
</I>&gt;<i>  *
</I>&gt;<i>  *    lower mbxs      upper
</I>&gt;<i>  *   ______^______    __^__
</I>&gt;<i>  *  /             \  /     \
</I>&gt;<i>  * +-+-+-+-+-+-+-+-++-+-+-+-+
</I>&gt;<i>  * |x|x|x|x|x|x|x|x|| | | | |
</I>&gt;<i>  * +-+-+-+-+-+-+-+-++-+-+-+-+
</I>&gt;<i>  *  0 0 0 0 0 0  0 0 0 0 1 1  \ mail
</I>&gt;<i>  *  0 1 2 3 4 5  6 7 8 9 0 1  / box
</I>&gt;<i>  *
</I>&gt;<i>  * The variable priv-&gt;rx_next points to the next mailbox to read a
</I>&gt;<i>  * message from. As long we're in the lower mailboxes we just read the
</I>&gt;<i>  * mailbox but not reenable it.
</I>&gt;<i>  *
</I>&gt;<i>  * With completion of the last of the lower mailboxes, we reenable the
</I>&gt;<i>  * whole first group, but continue to look for filled mailboxes in the
</I>&gt;<i>  * upper mailboxes. Imagine the second group like overflow mailboxes,
</I>&gt;<i>  * which takes CAN messages if the lower goup is full. While in the
</I>&gt;<i>  * upper group we reenable the mailbox right after reading it. Giving
</I>&gt;<i>  * the chip more room to store messages.
</I>&gt;<i>  *
</I>&gt;<i>  * After finishing we look again in the lower group if we've still
</I>&gt;<i>  * quota.
</I>&gt;<i>  *
</I>&gt;<i>  */
</I>&gt;<i> static int at91_poll_rx(struct net_device *dev, int quota)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	u32 reg_sr = at91_read(priv, AT91_SR);
</I>&gt;<i> 	const unsigned long *addr = (unsigned long *)&amp;reg_sr;
</I>&gt;<i> 	unsigned int mb;
</I>&gt;<i> 	int received = 0;
</I>&gt;<i> 
</I>&gt;<i> 	if (priv-&gt;rx_next &gt; AT91_MB_RX_LOW_LAST &amp;&amp;
</I>&gt;<i> 	    reg_sr &amp; AT91_MB_RX_LOW_MASK)
</I>&gt;<i> 		dev_info(ND2D(dev),
</I>&gt;<i> 			 &quot;order of incoming frames cannot be guaranteed\n&quot;);
</I>&gt;<i> 
</I>&gt;<i>  again:
</I>&gt;<i> 	for (mb = find_next_bit(addr, AT91_MB_RX_NUM, priv-&gt;rx_next);
</I>&gt;<i> 	     mb &lt; AT91_MB_RX_NUM &amp;&amp; quota &gt; 0;
</I>&gt;<i> 	     reg_sr = at91_read(priv, AT91_SR),
</I>&gt;<i> 	     mb = find_next_bit(addr, AT91_MB_RX_NUM, ++priv-&gt;rx_next)) {
</I>&gt;<i> 		at91_read_msg(dev, mb);
</I>&gt;<i> 
</I>&gt;<i> 		/* reactivate mailboxes */
</I>&gt;<i> 		if (mb == AT91_MB_RX_LOW_LAST)
</I>&gt;<i> 			/* all lower mailboxed, if just finished it */
</I>&gt;<i> 			at91_activate_rx_low(priv);
</I>&gt;<i> 		else if (mb &gt; AT91_MB_RX_LOW_LAST)
</I>&gt;<i> 			/* only the mailbox we read */
</I>&gt;<i> 			at91_activate_rx_mb(priv, mb);
</I>&gt;<i> 
</I>&gt;<i> 		received++;
</I>&gt;<i> 		quota--;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* upper group completed, look again in lower */
</I>&gt;<i> 	if (priv-&gt;rx_next &gt; AT91_MB_RX_LOW_LAST &amp;&amp;
</I>&gt;<i> 	    quota &gt; 0 &amp;&amp; mb &gt;= AT91_MB_RX_NUM) {
</I>&gt;<i> 		priv-&gt;rx_next = 0;
</I>&gt;<i> 		goto again;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	return received;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void at91_poll_err_frame(struct net_device *dev,
</I>&gt;<i> 		struct can_frame *cf, u32 reg_sr)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 
</I>&gt;<i> 	/* CRC error */
</I>&gt;<i> 	if (reg_sr &amp; AT91_IRQ_CERR) {
</I>&gt;<i> 		dev_dbg(ND2D(dev), &quot;CERR irq\n&quot;);
</I>&gt;<i> 		dev-&gt;stats.rx_errors++;
</I>&gt;<i> 		priv-&gt;can.can_stats.bus_error++;
</I>&gt;<i> 		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* Stuffing Error */
</I>&gt;<i> 	if (reg_sr &amp; AT91_IRQ_SERR) {
</I>&gt;<i> 		dev_dbg(ND2D(dev), &quot;SERR irq\n&quot;);
</I>&gt;<i> 		dev-&gt;stats.rx_errors++;
</I>&gt;<i> 		priv-&gt;can.can_stats.bus_error++;
</I>&gt;<i> 		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
</I>&gt;<i> 		cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* Acknowledgement Error */
</I>&gt;<i> 	if (reg_sr &amp; AT91_IRQ_AERR) {
</I>&gt;<i> 		dev_dbg(ND2D(dev), &quot;AERR irq\n&quot;);
</I>&gt;<i> 		dev-&gt;stats.tx_errors++;
</I>&gt;<i> 		cf-&gt;can_id |= CAN_ERR_ACK;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* Form error */
</I>&gt;<i> 	if (reg_sr &amp; AT91_IRQ_FERR) {
</I>&gt;<i> 		dev_dbg(ND2D(dev), &quot;FERR irq\n&quot;);
</I>&gt;<i> 		dev-&gt;stats.rx_errors++;
</I>&gt;<i> 		priv-&gt;can.can_stats.bus_error++;
</I>&gt;<i> 		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
</I>&gt;<i> 		cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* Bit Error */
</I>&gt;<i> 	if (reg_sr &amp; AT91_IRQ_BERR) {
</I>&gt;<i> 		dev_dbg(ND2D(dev), &quot;BERR irq\n&quot;);
</I>&gt;<i> 		dev-&gt;stats.tx_errors++;
</I>&gt;<i> 		priv-&gt;can.can_stats.bus_error++;
</I>&gt;<i> 		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
</I>&gt;<i> 		cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static int at91_poll_err(struct net_device *dev, int quota, u32 reg_sr)
</I>&gt;<i> {
</I>&gt;<i> 	struct sk_buff *skb;
</I>&gt;<i> 	struct can_frame *cf;
</I>&gt;<i> 
</I>&gt;<i> 	if (quota == 0)
</I>&gt;<i> 		return 0;
</I>&gt;<i> 
</I>&gt;<i> 	skb = alloc_can_err_skb(dev, &amp;cf);
</I>&gt;<i> 	if (unlikely(!skb))
</I>&gt;<i> 		return 0;
</I>&gt;<i> 
</I>&gt;<i> 	at91_poll_err_frame(dev, cf, reg_sr);
</I>&gt;<i> 	netif_rx(skb);
</I>&gt;<i> 
</I>&gt;<i> 	dev-&gt;last_rx = jiffies;
</I>&gt;<i> 	dev-&gt;stats.rx_packets++;
</I>&gt;<i> 	dev-&gt;stats.rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> 
</I>&gt;<i> 	return 1;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static int at91_poll(struct napi_struct *napi, int quota)
</I>&gt;<i> {
</I>&gt;<i> 	struct net_device *dev = napi-&gt;dev;
</I>&gt;<i> 	const struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	u32 reg_sr = at91_read(priv, AT91_SR);
</I>&gt;<i> 	int work_done = 0;
</I>&gt;<i> 
</I>&gt;<i> 	if (reg_sr &amp; AT91_IRQ_MB_RX)
</I>&gt;<i> 		work_done += at91_poll_rx(dev, quota - work_done);
</I>&gt;<i> 
</I>&gt;<i> 	/*
</I>&gt;<i> 	 * The error bits are clear on read,
</I>&gt;<i> 	 * so use saved value from irq handler.
</I>&gt;<i> 	 */
</I>&gt;<i> 	reg_sr |= priv-&gt;reg_sr;
</I>&gt;<i> 	if (reg_sr &amp; AT91_IRQ_ERR_FRAME)
</I>&gt;<i> 		work_done += at91_poll_err(dev, quota - work_done, reg_sr);
</I>&gt;<i> 
</I>&gt;<i> 	if (work_done &lt; quota) {
</I>&gt;<i> 		/* enable IRQs for frame errors and all mailboxes &gt;= rx_next */
</I>&gt;<i> 		u32 reg_ier = AT91_IRQ_ERR_FRAME;
</I>&gt;<i> 		reg_ier |= AT91_IRQ_MB_RX &amp; ~AT91_MB_RX_MASK(priv-&gt;rx_next);
</I>&gt;<i> 
</I>&gt;<i> 		napi_complete(napi);
</I>&gt;<i> 		at91_write(priv, AT91_IER, reg_ier);
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	return work_done;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * theory of operation:
</I>&gt;<i>  *
</I>&gt;<i>  * priv-&gt;tx_echo holds the number of the oldest can_frame put for
</I>&gt;<i>  * transmission into the hardware, but not yet ACKed by the CAN tx
</I>&gt;<i>  * complete IRQ.
</I>&gt;<i>  *
</I>&gt;<i>  * We iterate from priv-&gt;tx_echo to priv-&gt;tx_next and check if the
</I>&gt;<i>  * packet has been transmitted, echo it back to the CAN framework. If
</I>&gt;<i>  * we discover a not yet transmitted package, stop looking for more.
</I>&gt;<i>  *
</I>&gt;<i>  */
</I>&gt;<i> static void at91_irq_tx(struct net_device *dev, u32 reg_sr)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	u32 reg_msr;
</I>&gt;<i> 	unsigned int mb;
</I>&gt;<i> 
</I>&gt;<i> 	/* masking of reg_sr not needed, already done by at91_irq */
</I>&gt;<i> 
</I>&gt;<i> 	for (/* nix */; (priv-&gt;tx_next - priv-&gt;tx_echo) &gt; 0; priv-&gt;tx_echo++) {
</I>&gt;<i> 		mb = get_tx_echo_mb(priv);
</I>&gt;<i> 
</I>&gt;<i> 		/* no event in mailbox? */
</I>&gt;<i> 		if (!(reg_sr &amp; (1 &lt;&lt; mb)))
</I>&gt;<i> 			break;
</I>&gt;<i> 
</I>&gt;<i> 		/* Disable irq for this TX mailbox */
</I>&gt;<i> 		at91_write(priv, AT91_IDR, 1 &lt;&lt; mb);
</I>&gt;<i> 
</I>&gt;<i> 		/*
</I>&gt;<i> 		 * only echo if mailbox signals us a transfer
</I>&gt;<i> 		 * complete (MSR_MRDY). Otherwise it's a tansfer
</I>&gt;<i> 		 * abort. &quot;can_bus_off()&quot; takes care about the skbs
</I>&gt;<i> 		 * parked in the echo queue.
</I>&gt;<i> 		 */
</I>&gt;<i> 		reg_msr = at91_read(priv, AT91_MSR(mb));
</I>&gt;<i> 		if (likely(reg_msr &amp; AT91_MSR_MRDY &amp;&amp;
</I>&gt;<i> 			   ~reg_msr &amp; AT91_MSR_MABT)) {
</I>&gt;<i> 			/* _NOTE_: substract AT91_MB_TX_FIRST offset from mb! */
</I>&gt;<i> 			can_get_echo_skb(dev, mb - AT91_MB_TX_FIRST);
</I>&gt;<i> 			dev-&gt;stats.tx_packets++;
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/*
</I>&gt;<i> 	 * restart queue if we don't have a wrap around but restart if
</I>&gt;<i> 	 * we get a TX int for the last can frame directly before a
</I>&gt;<i> 	 * wrap around.
</I>&gt;<i> 	 */
</I>&gt;<i> 	if ((priv-&gt;tx_next &amp; AT91_NEXT_MASK) != 0 ||
</I>&gt;<i> 	    (priv-&gt;tx_echo &amp; AT91_NEXT_MASK) == 0)
</I>&gt;<i> 		netif_wake_queue(dev);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void at91_irq_err_state(struct net_device *dev,
</I>&gt;<i> 		struct can_frame *cf, enum can_state new_state)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	u32 reg_idr, reg_ier, reg_ecr;
</I>&gt;<i> 	u8 tec, rec;
</I>&gt;<i> 
</I>&gt;<i> 	reg_ecr = at91_read(priv, AT91_ECR);
</I>&gt;<i> 	rec = reg_ecr &amp; 0xff;
</I>&gt;<i> 	tec = reg_ecr &gt;&gt; 16;
</I>&gt;<i> 
</I>&gt;<i> 	switch (priv-&gt;can.state) {
</I>&gt;<i> 	case CAN_STATE_ERROR_ACTIVE:
</I>&gt;<i> 		/*
</I>&gt;<i> 		 * from: ERROR_ACTIVE
</I>&gt;<i> 		 * to  : ERROR_WARNING, ERROR_PASSIVE, BUS_OFF
</I>&gt;<i> 		 * =&gt;  : there was a warning int
</I>&gt;<i> 		 */
</I>&gt;<i> 		if (new_state &gt;= CAN_STATE_ERROR_WARNING &amp;&amp;
</I>&gt;<i> 		    new_state &lt;= CAN_STATE_BUS_OFF) {
</I>&gt;<i> 			dev_dbg(ND2D(dev), &quot;Error Warning IRQ\n&quot;);
</I>&gt;<i> 			priv-&gt;can.can_stats.error_warning++;
</I>&gt;<i> 
</I>&gt;<i> 			cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> 			cf-&gt;data[1] = (tec &gt; rec) ?
</I>&gt;<i> 				CAN_ERR_CRTL_TX_WARNING :
</I>&gt;<i> 				CAN_ERR_CRTL_RX_WARNING;
</I>&gt;<i> 		}
</I>&gt;<i> 	case CAN_STATE_ERROR_WARNING:	/* fallthrough */
</I>&gt;<i> 		/*
</I>&gt;<i> 		 * from: ERROR_ACTIVE, ERROR_WARNING
</I>&gt;<i> 		 * to  : ERROR_PASSIVE, BUS_OFF
</I>&gt;<i> 		 * =&gt;  : error passive int
</I>&gt;<i> 		 */
</I>&gt;<i> 		if (new_state &gt;= CAN_STATE_ERROR_PASSIVE &amp;&amp;
</I>&gt;<i> 		    new_state &lt;= CAN_STATE_BUS_OFF) {
</I>&gt;<i> 			dev_dbg(ND2D(dev), &quot;Error Passive IRQ\n&quot;);
</I>&gt;<i> 			priv-&gt;can.can_stats.error_passive++;
</I>&gt;<i> 
</I>&gt;<i> 			cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> 			cf-&gt;data[1] = (tec &gt; rec) ?
</I>&gt;<i> 				CAN_ERR_CRTL_TX_PASSIVE :
</I>&gt;<i> 				CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> 		}
</I>&gt;<i> 		break;
</I>&gt;<i> 	case CAN_STATE_BUS_OFF:
</I>&gt;<i> 		/*
</I>&gt;<i> 		 * from: BUS_OFF
</I>&gt;<i> 		 * to  : ERROR_ACTIVE, ERROR_WARNING, ERROR_PASSIVE
</I>&gt;<i> 		 */
</I>&gt;<i> 		if (new_state &lt;= CAN_STATE_ERROR_PASSIVE) {
</I>&gt;<i> 			cf-&gt;can_id |= CAN_ERR_RESTARTED;
</I>&gt;<i> 
</I>&gt;<i> 			dev_dbg(dev-&gt;dev.parent, &quot;restarted\n&quot;);
</I>&gt;<i> 			priv-&gt;can.can_stats.restarts++;
</I>&gt;<i> 
</I>&gt;<i> 			netif_carrier_on(dev);
</I>&gt;<i> 			netif_wake_queue(dev);
</I>&gt;<i> 		}
</I>&gt;<i> 		break;
</I>&gt;<i> 	default:
</I>&gt;<i> 		break;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 	/* process state changes depending on the new state */
</I>&gt;<i> 	switch (new_state) {
</I>&gt;<i> 	case CAN_STATE_ERROR_ACTIVE:
</I>&gt;<i> 		/*
</I>&gt;<i> 		 * actually we want to enable AT91_IRQ_WARN here, but
</I>&gt;<i> 		 * it screws up the system under certain
</I>&gt;<i> 		 * circumstances. so just enable AT91_IRQ_ERRP, thus
</I>&gt;<i> 		 * the &quot;fallthrough&quot;
</I>&gt;<i> 		 */
</I>&gt;<i> 		dev_dbg(ND2D(dev), &quot;Error Active\n&quot;);
</I>&gt;<i> 		cf-&gt;can_id |= CAN_ERR_PROT;
</I>&gt;<i> 		cf-&gt;data[2] = CAN_ERR_PROT_ACTIVE;
</I>&gt;<i> 	case CAN_STATE_ERROR_WARNING:	/* fallthrough */
</I>&gt;<i> 		reg_idr = AT91_IRQ_ERRA | AT91_IRQ_WARN | AT91_IRQ_BOFF;
</I>&gt;<i> 		reg_ier = AT91_IRQ_ERRP;
</I>&gt;<i> 		break;
</I>&gt;<i> 	case CAN_STATE_ERROR_PASSIVE:
</I>&gt;<i> 		reg_idr = AT91_IRQ_ERRA | AT91_IRQ_WARN | AT91_IRQ_ERRP;
</I>&gt;<i> 		reg_ier = AT91_IRQ_BOFF;
</I>&gt;<i> 		break;
</I>&gt;<i> 	case CAN_STATE_BUS_OFF:
</I>&gt;<i> 		reg_idr = AT91_IRQ_ERRA | AT91_IRQ_ERRP |
</I>&gt;<i> 			AT91_IRQ_WARN | AT91_IRQ_BOFF;
</I>&gt;<i> 		reg_ier = 0;
</I>&gt;<i> 
</I>&gt;<i> 		cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> 
</I>&gt;<i> 		dev_dbg(ND2D(dev), &quot;bus-off\n&quot;);
</I>&gt;<i> 		netif_carrier_off(dev);
</I>&gt;<i> 		priv-&gt;can.can_stats.bus_off++;
</I>&gt;<i> 
</I>&gt;<i> 		/* turn off chip, if restart is disabled */
</I>&gt;<i> 		if (!priv-&gt;can.restart_ms) {
</I>&gt;<i> 			at91_chip_stop(dev, CAN_STATE_BUS_OFF);
</I>&gt;<i> 			return;
</I>&gt;<i> 		}
</I>&gt;<i> 		break;
</I>&gt;<i> 	default:
</I>&gt;<i> 		break;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	at91_write(priv, AT91_IDR, reg_idr);
</I>&gt;<i> 	at91_write(priv, AT91_IER, reg_ier);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void at91_irq_err(struct net_device *dev)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	struct sk_buff *skb;
</I>&gt;<i> 	struct can_frame *cf;
</I>&gt;<i> 	enum can_state new_state;
</I>&gt;<i> 	u32 reg_sr;
</I>&gt;<i> 
</I>&gt;<i> 	reg_sr = at91_read(priv, AT91_SR);
</I>&gt;<i> 
</I>&gt;<i> 	/* we need to look at the unmasked reg_sr */
</I>&gt;<i> 	if (unlikely(reg_sr &amp; AT91_IRQ_BOFF))
</I>&gt;<i> 		new_state = CAN_STATE_BUS_OFF;
</I>&gt;<i> 	else if (unlikely(reg_sr &amp; AT91_IRQ_ERRP))
</I>&gt;<i> 		new_state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> 	else if (unlikely(reg_sr &amp; AT91_IRQ_WARN))
</I>&gt;<i> 		new_state = CAN_STATE_ERROR_WARNING;
</I>&gt;<i> 	else if (likely(reg_sr &amp; AT91_IRQ_ERRA))
</I>&gt;<i> 		new_state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> 	else {
</I>&gt;<i> 		dev_err(ND2D(dev), &quot;BUG! hardware in undefined state\n&quot;);
</I>&gt;<i> 		return;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* state hasn't changed */
</I>&gt;<i> 	if (likely(new_state == priv-&gt;can.state))
</I>&gt;<i> 		return;
</I>&gt;<i> 
</I>&gt;<i> 	skb = alloc_can_err_skb(dev, &amp;cf);
</I>&gt;<i> 	if (unlikely(!skb))
</I>&gt;<i> 		return;
</I>&gt;<i> 
</I>&gt;<i> 	at91_irq_err_state(dev, cf, new_state);
</I>&gt;<i> 	netif_rx(skb);
</I>&gt;<i> 
</I>&gt;<i> 	dev-&gt;last_rx = jiffies;
</I>&gt;<i> 	dev-&gt;stats.rx_packets++;
</I>&gt;<i> 	dev-&gt;stats.rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> 
</I>&gt;<i> 	priv-&gt;can.state = new_state;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * interrupt handler
</I>&gt;<i>  */
</I>&gt;<i> static irqreturn_t at91_irq(int irq, void *dev_id)
</I>&gt;<i> {
</I>&gt;<i> 	struct net_device *dev = dev_id;
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	irqreturn_t handled = IRQ_NONE;
</I>&gt;<i> 	u32 reg_sr, reg_imr;
</I>&gt;<i> 
</I>&gt;<i> 	reg_sr = at91_read(priv, AT91_SR);
</I>&gt;<i> 	reg_imr = at91_read(priv, AT91_IMR);
</I>&gt;<i> 
</I>&gt;<i> 	/* Ignore masked interrupts */
</I>&gt;<i> 	reg_sr &amp;= reg_imr;
</I>&gt;<i> 	if (!reg_sr)
</I>&gt;<i> 		goto exit;
</I>&gt;<i> 
</I>&gt;<i> 	handled = IRQ_HANDLED;
</I>&gt;<i> 
</I>&gt;<i> 	/* Receive or error interrupt? -&gt; napi */
</I>&gt;<i> 	if (reg_sr &amp; (AT91_IRQ_MB_RX | AT91_IRQ_ERR_FRAME)) {
</I>&gt;<i> 		/*
</I>&gt;<i> 		 * The error bits are clear on read,
</I>&gt;<i> 		 * save for later use.
</I>&gt;<i> 		 */
</I>&gt;<i> 		priv-&gt;reg_sr = reg_sr;
</I>&gt;<i> 		at91_write(priv, AT91_IDR,
</I>&gt;<i> 			   AT91_IRQ_MB_RX | AT91_IRQ_ERR_FRAME);
</I>&gt;<i> 		napi_schedule(&amp;priv-&gt;napi);
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* Transmission complete interrupt */
</I>&gt;<i> 	if (reg_sr &amp; AT91_IRQ_MB_TX)
</I>&gt;<i> 		at91_irq_tx(dev, reg_sr);
</I>&gt;<i> 
</I>&gt;<i> 	at91_irq_err(dev);
</I>&gt;<i> 
</I>&gt;<i>  exit:
</I>&gt;<i> 	return handled;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static int at91_open(struct net_device *dev)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	int err;
</I>&gt;<i> 
</I>&gt;<i> 	clk_enable(priv-&gt;clk);
</I>&gt;<i> 
</I>&gt;<i> 	/* check or determine and set bittime */
</I>&gt;<i> 	err = open_candev(dev);
</I>&gt;<i> 	if (err)
</I>&gt;<i> 		goto out;
</I>&gt;<i> 
</I>&gt;<i> 	/* register interrupt handler */
</I>&gt;<i> 	if (request_irq(dev-&gt;irq, at91_irq, IRQF_SHARED,
</I>&gt;<i> 			dev-&gt;name, dev)) {
</I>&gt;<i> 		err = -EAGAIN;
</I>&gt;<i> 		goto out_close;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* start chip and queuing */
</I>&gt;<i> 	at91_chip_start(dev);
</I>&gt;<i> 	napi_enable(&amp;priv-&gt;napi);
</I>&gt;<i> 	netif_start_queue(dev);
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> 
</I>&gt;<i>  out_close:
</I>&gt;<i> 	close_candev(dev);
</I>&gt;<i>  out:
</I>&gt;<i> 	clk_disable(priv-&gt;clk);
</I>&gt;<i> 
</I>&gt;<i> 	return err;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * stop CAN bus activity
</I>&gt;<i>  */
</I>&gt;<i> static int at91_close(struct net_device *dev)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 
</I>&gt;<i> 	netif_stop_queue(dev);
</I>&gt;<i> 	napi_disable(&amp;priv-&gt;napi);
</I>&gt;<i> 	at91_chip_stop(dev, CAN_STATE_STOPPED);
</I>&gt;<i> 
</I>&gt;<i> 	free_irq(dev-&gt;irq, dev);
</I>&gt;<i> 	clk_disable(priv-&gt;clk);
</I>&gt;<i> 
</I>&gt;<i> 	close_candev(dev);
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static int at91_set_mode(struct net_device *dev, enum can_mode mode)
</I>&gt;<i> {
</I>&gt;<i> 	switch (mode) {
</I>&gt;<i> 	case CAN_MODE_START:
</I>&gt;<i> 		at91_chip_start(dev);
</I>&gt;<i> 		netif_wake_queue(dev);
</I>&gt;<i> 		break;
</I>&gt;<i> 
</I>&gt;<i> 	default:
</I>&gt;<i> 		return -EOPNOTSUPP;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static const struct net_device_ops at91_netdev_ops = {
</I>&gt;<i> 	.ndo_open	= at91_open,
</I>&gt;<i> 	.ndo_stop	= at91_close,
</I>&gt;<i> 	.ndo_start_xmit	= at91_start_xmit,
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> static int __init at91_can_probe(struct platform_device *pdev)
</I>&gt;<i> {
</I>&gt;<i> 	struct net_device *dev;
</I>&gt;<i> 	struct at91_priv *priv;
</I>&gt;<i> 	struct resource *res;
</I>&gt;<i> 	struct clk *clk;
</I>&gt;<i> 	void __iomem *addr;
</I>&gt;<i> 	int err, irq;
</I>&gt;<i> 
</I>&gt;<i> 	clk = clk_get(&amp;pdev-&gt;dev, &quot;can_clk&quot;);
</I>&gt;<i> 	if (IS_ERR(clk)) {
</I>&gt;<i> 		dev_err(&amp;pdev-&gt;dev, &quot;no clock defined\n&quot;);
</I>&gt;<i> 		err = -ENODEV;
</I>&gt;<i> 		goto exit;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;<i> 	irq = platform_get_irq(pdev, 0);
</I>&gt;<i> 	if (!res || !irq) {
</I>&gt;<i> 		err = -ENODEV;
</I>&gt;<i> 		goto exit_put;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	if (!request_mem_region(res-&gt;start,
</I>&gt;<i> 				resource_size(res),
</I>&gt;<i> 				pdev-&gt;name)) {
</I>&gt;<i> 		err = -EBUSY;
</I>&gt;<i> 		goto exit_put;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	addr = ioremap_nocache(res-&gt;start, resource_size(res));
</I>&gt;<i> 	if (!addr) {
</I>&gt;<i> 		err = -ENOMEM;
</I>&gt;<i> 		goto exit_release;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	dev = alloc_candev(sizeof(struct at91_priv));
</I>&gt;<i> 	if (!dev) {
</I>&gt;<i> 		err = -ENOMEM;
</I>&gt;<i> 		goto exit_iounmap;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	dev-&gt;netdev_ops	= &amp;at91_netdev_ops;
</I>&gt;<i> 	dev-&gt;irq = irq;
</I>&gt;<i> 	dev-&gt;flags |= IFF_ECHO;
</I>&gt;<i> 
</I>&gt;<i> 	priv = netdev_priv(dev);
</I>&gt;<i> 	priv-&gt;can.clock.freq = clk_get_rate(clk);
</I>&gt;<i> 	priv-&gt;can.bittiming_const = &amp;at91_bittiming_const;
</I>&gt;<i> 	priv-&gt;can.do_set_bittiming = at91_set_bittiming;
</I>&gt;<i> 	priv-&gt;can.do_set_mode = at91_set_mode;
</I>&gt;<i> 	priv-&gt;reg_base = addr;
</I>&gt;<i> 	priv-&gt;dev = dev;
</I>&gt;<i> 	priv-&gt;clk = clk;
</I>&gt;<i> 	priv-&gt;pdata = pdev-&gt;dev.platform_data;
</I>&gt;<i> 
</I>&gt;<i> 	netif_napi_add(dev, &amp;priv-&gt;napi, at91_poll, AT91_NAPI_WEIGHT);
</I>&gt;<i> 
</I>&gt;<i> 	dev_set_drvdata(&amp;pdev-&gt;dev, dev);
</I>&gt;<i> 	SET_NETDEV_DEV(dev, &amp;pdev-&gt;dev);
</I>&gt;<i> 
</I>&gt;<i> 	err = register_candev(dev);
</I>&gt;<i> 	if (err) {
</I>&gt;<i> 		dev_err(&amp;pdev-&gt;dev, &quot;registering netdev failed\n&quot;);
</I>&gt;<i> 		goto exit_free;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	dev_info(&amp;pdev-&gt;dev, &quot;device registered (reg_base=%p, irq=%d)\n&quot;,
</I>&gt;<i> 		 priv-&gt;reg_base, dev-&gt;irq);
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> 
</I>&gt;<i>  exit_free:
</I>&gt;<i> 	free_netdev(dev);
</I>&gt;<i>  exit_iounmap:
</I>&gt;<i> 	iounmap(addr);
</I>&gt;<i>  exit_release:
</I>&gt;<i> 	release_mem_region(res-&gt;start, resource_size(res));
</I>&gt;<i>  exit_put:
</I>&gt;<i> 	clk_put(clk);
</I>&gt;<i>  exit:
</I>&gt;<i> 	return err;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static int __devexit at91_can_remove(struct platform_device *pdev)
</I>&gt;<i> {
</I>&gt;<i> 	struct net_device *dev = platform_get_drvdata(pdev);
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	struct resource *res;
</I>&gt;<i> 
</I>&gt;<i> 	unregister_netdev(dev);
</I>&gt;<i> 
</I>&gt;<i> 	platform_set_drvdata(pdev, NULL);
</I>&gt;<i> 
</I>&gt;<i> 	free_netdev(dev);
</I>&gt;<i> 
</I>&gt;<i> 	iounmap(priv-&gt;reg_base);
</I>&gt;<i> 
</I>&gt;<i> 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;<i> 	release_mem_region(res-&gt;start, resource_size(res));
</I>&gt;<i> 
</I>&gt;<i> 	clk_put(priv-&gt;clk);
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static struct platform_driver at91_can_driver = {
</I>&gt;<i> 	.probe		= at91_can_probe,
</I>&gt;<i> 	.remove		= __devexit_p(at91_can_remove),
</I>&gt;<i> 	.driver		= {
</I>&gt;<i> 		.name	= DRV_NAME,
</I>&gt;<i> 		.owner	= THIS_MODULE,
</I>&gt;<i> 	},
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> static int __init at91_can_module_init(void)
</I>&gt;<i> {
</I>&gt;<i> 	printk(KERN_INFO &quot;%s netdevice driver\n&quot;, DRV_NAME);
</I>&gt;<i> 	return platform_driver_register(&amp;at91_can_driver);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void __exit at91_can_module_exit(void)
</I>&gt;<i> {
</I>&gt;<i> 	platform_driver_unregister(&amp;at91_can_driver);
</I>&gt;<i> 	printk(KERN_INFO &quot;%s: driver removed\n&quot;, DRV_NAME);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> module_init(at91_can_module_init);
</I>&gt;<i> module_exit(at91_can_module_exit);
</I>&gt;<i> 
</I>&gt;<i> MODULE_AUTHOR(&quot;Marc Kleine-Budde &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">mkl at pengutronix.de</A>&gt;&quot;);
</I>&gt;<i> MODULE_LICENSE(&quot;GPL v2&quot;);
</I>&gt;<i> MODULE_DESCRIPTION(DRV_NAME &quot; CAN netdevice driver&quot;);
</I>
-- 
Pengutronix e.K.                         | Marc Kleine-Budde           |
Linux Solutions for Science and Industry | Phone: +49-231-2826-924     |
Vertretung West/Dortmund                 | Fax:   +49-5121-206917-5555 |
Amtsgericht Hildesheim, HRA 2686         | <A HREF="http://www.pengutronix.de">http://www.pengutronix.de</A>   |

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 260 bytes
Desc: OpenPGP digital signature
URL: &lt;<A HREF="https://lists.berlios.de/pipermail/socketcan-core/attachments/20090914/f726f0e2/attachment.pgp">https://lists.berlios.de/pipermail/socketcan-core/attachments/20090914/f726f0e2/attachment.pgp</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003087.html">[PATCH 2/2] ems_usb: Added support for EMS CPC-USB/ARM7 CAN/USB	interface
</A></li>
	<LI>Next message: <A HREF="003078.html">[PATCH v3] at91_can
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3066">[ date ]</a>
              <a href="thread.html#3066">[ thread ]</a>
              <a href="subject.html#3066">[ subject ]</a>
              <a href="author.html#3066">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
