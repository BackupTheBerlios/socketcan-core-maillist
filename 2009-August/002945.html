<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH] net-next:can: add TI CAN (HECC) driver
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-August/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20net-next%3Acan%3A%20add%20TI%20CAN%20%28HECC%29%20driver&In-Reply-To=%3C4A98D36E.9070903%40grandegger.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002937.html">
   <LINK REL="Next"  HREF="002938.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH] net-next:can: add TI CAN (HECC) driver</H1>
    <B>Wolfgang Grandegger</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20net-next%3Acan%3A%20add%20TI%20CAN%20%28HECC%29%20driver&In-Reply-To=%3C4A98D36E.9070903%40grandegger.com%3E"
       TITLE="[PATCH] net-next:can: add TI CAN (HECC) driver">wg at grandegger.com
       </A><BR>
    <I>Sat Aug 29 09:06:22 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002937.html">[PATCH] net-next:can: add TI CAN (HECC) driver
</A></li>
        <LI>Next message: <A HREF="002938.html">[PATCH] net-next:can: add TI CAN (HECC) driver
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2945">[ date ]</a>
              <a href="thread.html#2945">[ thread ]</a>
              <a href="subject.html#2945">[ subject ]</a>
              <a href="author.html#2945">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> TI HECC (High End CAN Controller) module is found on many TI devices. It has
</I>&gt;<i> 32 harwdare mailboxes with full implementation of CAN protocol version 2.0B
</I>&gt;<i> and bus speeds up to 1Mbps. The module specifications are available at TI web
</I>&gt;<i> &lt;<A HREF="http://www.ti.com">http://www.ti.com</A>&gt;.
</I>&gt;<i> 
</I>&gt;<i> This driver is tested on OMAP3517 EVM. Suspend/Resume not tested as yet.
</I>
Nice driver, even using the NAPI interface. First some general comments.
Please remove debugging code mainly useful for development, e.g. the
CONFIG_DEBUG_FS block, many dev_info calls and special statistics
counters. Also use dev_dbg for the remaining debug messages useful for
the normal user, like state changes. More comments inline.

&gt;<i> 
</I>&gt;<i> Signed-off-by: Anant Gole &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">anantgole at ti.com</A>&gt;
</I>&gt;<i> ---
</I>&gt;<i>  drivers/net/can/Kconfig                       |    9 +
</I>&gt;<i>  drivers/net/can/Makefile                      |    2 +
</I>&gt;<i>  drivers/net/can/ti_hecc.c                     | 1352 +++++++++++++++++++++++++
</I>&gt;<i>  include/linux/can/platform/ti_hecc_platform.h |   40 +
</I>&gt;<i>  4 files changed, 1403 insertions(+), 0 deletions(-)
</I>&gt;<i>  create mode 100644 drivers/net/can/ti_hecc.c
</I>&gt;<i>  create mode 100644 include/linux/can/platform/ti_hecc_platform.h
</I>&gt;<i> 
</I>&gt;<i> diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
</I>&gt;<i> index 30ae55d..fae62df 100644
</I>&gt;<i> --- a/drivers/net/can/Kconfig
</I>&gt;<i> +++ b/drivers/net/can/Kconfig
</I>&gt;<i> @@ -75,6 +75,15 @@ config CAN_KVASER_PCI
</I>&gt;<i>           This driver is for the the PCIcanx and PCIcan cards (1, 2 or
</I>&gt;<i>           4 channel) from Kvaser (<A HREF="http://www.kvaser.com">http://www.kvaser.com</A>).
</I>&gt;<i> 
</I>&gt;<i> +config CAN_TI_HECC
</I>&gt;<i> +        depends on CAN_DEV
</I>&gt;<i> +        tristate &quot;TI High End CAN Controller (HECC)&quot;
</I>&gt;<i> +        default N
</I>&gt;<i> +        ---help---
</I>&gt;<i> +         This driver adds support for TI High End CAN Controller module
</I>&gt;<i> +         found on many TI devices. The specifications of this module are
</I>&gt;<i> +         are available from TI web (<A HREF="http://www.ti.com">http://www.ti.com</A>)
</I>&gt;<i> +
</I>&gt;<i>  config CAN_DEBUG_DEVICES
</I>&gt;<i>         bool &quot;CAN devices debugging messages&quot;
</I>&gt;<i>         depends on CAN
</I>&gt;<i> diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
</I>&gt;<i> index 523a941..d923512 100644
</I>&gt;<i> --- a/drivers/net/can/Makefile
</I>&gt;<i> +++ b/drivers/net/can/Makefile
</I>&gt;<i> @@ -9,4 +9,6 @@ can-dev-y                       := dev.o
</I>&gt;<i> 
</I>&gt;<i>  obj-$(CONFIG_CAN_SJA1000)      += sja1000/
</I>&gt;<i> 
</I>&gt;<i> +obj-$(CONFIG_CAN_TI_HECC)      += ti_hecc.o
</I>&gt;<i> +
</I>&gt;<i>  ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
</I>&gt;<i> diff --git a/drivers/net/can/ti_hecc.c b/drivers/net/can/ti_hecc.c
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..4741b4a
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/ti_hecc.c
</I>&gt;<i> @@ -0,0 +1,1352 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * TI HECC (CAN) device driver
</I>&gt;<i> + *
</I>&gt;<i> + * This driver supports TI's HECC (High End CAN Controller module) and the
</I>&gt;<i> + * specs for the same is available at &lt;<A HREF="http://www.ti.com">http://www.ti.com</A>&gt;
</I>&gt;<i> + *
</I>&gt;<i> + * Copyright (C) 2009 Texas Instruments Incorporated - <A HREF="http://www.ti.com/">http://www.ti.com/</A>
</I>&gt;<i> + *
</I>&gt;<i> + * This program is free software; you can redistribute it and/or
</I>&gt;<i> + * modify it under the terms of the GNU General Public License as
</I>&gt;<i> + * published by the Free Software Foundation version 2.
</I>&gt;<i> + *
</I>&gt;<i> + * This program is distributed as is WITHOUT ANY WARRANTY of any
</I>&gt;<i> + * kind, whether express or implied; without even the implied warranty
</I>&gt;<i> + * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</I>&gt;<i> + * GNU General Public License for more details.
</I>&gt;<i> + *
</I>
It would be nice if you could mention the related platform data here,
similar to the mcp251x.c driver.

&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/module.h&gt;
</I>&gt;<i> +#include &lt;linux/init.h&gt;
</I>&gt;<i> +#include &lt;linux/kernel.h&gt;
</I>&gt;<i> +#include &lt;linux/sched.h&gt;
</I>&gt;<i> +#include &lt;linux/types.h&gt;
</I>&gt;<i> +#include &lt;linux/fcntl.h&gt;
</I>&gt;<i> +#include &lt;linux/interrupt.h&gt;
</I>&gt;<i> +#include &lt;linux/ptrace.h&gt;
</I>&gt;<i> +#include &lt;linux/string.h&gt;
</I>&gt;<i> +#include &lt;linux/errno.h&gt;
</I>&gt;<i> +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> +#include &lt;linux/if_arp.h&gt;
</I>&gt;<i> +#include &lt;linux/if_ether.h&gt;
</I>&gt;<i> +#include &lt;linux/skbuff.h&gt;
</I>&gt;<i> +#include &lt;linux/delay.h&gt;
</I>&gt;<i> +#include &lt;linux/platform_device.h&gt;
</I>&gt;<i> +#include &lt;linux/clk.h&gt;
</I>&gt;<i> +#include &lt;linux/io.h&gt;
</I>&gt;<i> +#include &lt;linux/debugfs.h&gt;
</I>&gt;<i> +#include &lt;linux/can.h&gt;
</I>&gt;<i> +#include &lt;linux/can/dev.h&gt;
</I>&gt;<i> +#include &lt;linux/can/error.h&gt;
</I>&gt;<i> +#include &lt;linux/can/platform/ti_hecc_platform.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#define DRV_NAME &quot;TI HECC&quot;
</I>
#define DRV_NAME &quot;ti_hecc&quot;

Other drivers also use the file name here.

&gt;<i> +#define HECC_MODULE_VERSION     &quot;0.2&quot;
</I>
A version number is will usually not maintained. May drivers have it but
it's never changed.

&gt;<i> +MODULE_VERSION(HECC_MODULE_VERSION);
</I>&gt;<i> +#define DRV_DESC &quot;TI High End CAN Controller Driver &quot; HECC_MODULE_VERSION
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_MAX_MAILBOXES     32      /* hardware mboxes - do not change */
</I>&gt;<i> +
</I>&gt;<i> +#if (CAN_ECHO_SKB_MAX &gt; 16)
</I>&gt;<i> +#define TI_HECC_MAX_TX_MBOX    16
</I>&gt;<i> +#else
</I>&gt;<i> +#define TI_HECC_MAX_TX_MBOX    CAN_ECHO_SKB_MAX
</I>&gt;<i> +#endif
</I>&gt;<i> +#define TI_HECC_MAX_RX_MBOX    (HECC_MAX_MAILBOXES - TI_HECC_MAX_TX_MBOX)
</I>&gt;<i> +
</I>&gt;<i> +#define TI_HECC_DEF_NAPI_WEIGHT        TI_HECC_MAX_RX_MBOX
</I>&gt;<i> +
</I>&gt;<i> +/* TI HECC module registers */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANME             0x0     /* Mailbox enable */
</I>&gt;<i> +#define HECC_CANMD             0x4     /* Mailbox direction */
</I>&gt;<i> +#define HECC_CANTRS            0x8     /* Transmit request set */
</I>&gt;<i> +#define HECC_CANTRR            0xC     /* Transmit request */
</I>&gt;<i> +#define HECC_CANTA             0x10    /* Transmission acknowledge */
</I>&gt;<i> +#define HECC_CANAA             0x14    /* Abort acknowledge */
</I>&gt;<i> +#define HECC_CANRMP            0x18    /* Receive message pending */
</I>&gt;<i> +#define HECC_CANRML            0x1C    /* Remote message lost */
</I>&gt;<i> +#define HECC_CANRFP            0x20    /* Remote frame pending */
</I>&gt;<i> +#define HECC_CANGAM            0x24    /* SECC only:Global acceptance mask */
</I>&gt;<i> +#define HECC_CANMC             0x28    /* Master control */
</I>&gt;<i> +#define HECC_CANBTC            0x2C    /* Bit timing configuration */
</I>&gt;<i> +#define HECC_CANES             0x30    /* Error and status */
</I>&gt;<i> +#define HECC_CANTEC            0x34    /* Transmit error counter */
</I>&gt;<i> +#define HECC_CANREC            0x38    /* Receive error counter */
</I>&gt;<i> +#define HECC_CANGIF0           0x3C    /* Global interrupt flag 0 */
</I>&gt;<i> +#define HECC_CANGIM            0x40    /* Global interrupt mask */
</I>&gt;<i> +#define HECC_CANGIF1           0x44    /* Global interrupt flag 1 */
</I>&gt;<i> +#define HECC_CANMIM            0x48    /* Mailbox interrupt mask */
</I>&gt;<i> +#define HECC_CANMIL            0x4C    /* Mailbox interrupt level */
</I>&gt;<i> +#define HECC_CANOPC            0x50    /* Overwrite protection control */
</I>&gt;<i> +#define HECC_CANTIOC           0x54    /* Transmit I/O control */
</I>&gt;<i> +#define HECC_CANRIOC           0x58    /* Receive I/O control */
</I>&gt;<i> +#define HECC_CANLNT            0x5C    /* HECC only: Local network time */
</I>&gt;<i> +#define HECC_CANTOC            0x60    /* HECC only: Time-out control */
</I>&gt;<i> +#define HECC_CANTOS            0x64    /* HECC only: Time-out status */
</I>&gt;<i> +#define HECC_CANTIOCE          0x68    /* SCC only:Enhanced TX I/O control */
</I>&gt;<i> +#define HECC_CANRIOCE          0x6C    /* SCC only:Enhanced RX I/O control */
</I>&gt;<i> +
</I>&gt;<i> +/* SCC only:Local acceptance registers */
</I>&gt;<i> +#define HECC_CANLAM0           (priv-&gt;scc_ram_offset + 0x0)
</I>&gt;<i> +#define HECC_CANLAM3           (priv-&gt;scc_ram_offset + 0xC)
</I>&gt;<i> +
</I>&gt;<i> +/* HECC only */
</I>&gt;<i> +#define HECC_CANLAM(mbxno)     (priv-&gt;hecc_ram_offset + ((mbxno) * 4))
</I>&gt;<i> +#define HECC_CANMOTS(mbxno)    (priv-&gt;hecc_ram_offset + ((mbxno) * 4) + 0x80)
</I>&gt;<i> +#define HECC_CANMOTO(mbxno)    (priv-&gt;hecc_ram_offset + ((mbxno) * 4) + 0x100)
</I>&gt;<i> +
</I>&gt;<i> +/* Mailbox registers */
</I>&gt;<i> +#define HECC_CANMID(mbxno)     (priv-&gt;mbox_offset + ((mbxno) * 0x10))
</I>&gt;<i> +#define HECC_CANMCF(mbxno)     (priv-&gt;mbox_offset + ((mbxno) * 0x10) + 0x4)
</I>&gt;<i> +#define HECC_CANMDL(mbxno)     (priv-&gt;mbox_offset + ((mbxno) * 0x10) + 0x8)
</I>&gt;<i> +#define HECC_CANMDH(mbxno)     (priv-&gt;mbox_offset + ((mbxno) * 0x10) + 0xC)
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_SET_REG           0xFFFFFFFF
</I>&gt;<i> +#define HECC_CANID_MASK                0x3FF   /* 18 bits mask for extended id's */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANMC_SCM         BIT(13) /* SCC compat mode */
</I>&gt;<i> +#define HECC_CANMC_CCR         BIT(12) /* Change config request */
</I>&gt;<i> +#define HECC_CANMC_PDR         BIT(11) /* Local Power down - for sleep mode */
</I>&gt;<i> +#define HECC_CANMC_ABO         BIT(7)  /* Auto Bus On */
</I>&gt;<i> +#define HECC_CANMC_STM         BIT(6)  /* Self test mode - loopback */
</I>&gt;<i> +#define HECC_CANMC_SRES                BIT(5)  /* Software reset */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANTIOC_EN                BIT(3)  /* Enable CAN TX I/O pin */
</I>&gt;<i> +#define HECC_CANRIOC_EN                BIT(3)  /* Enable CAN RX I/O pin */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANMID_IDE                BIT(31) /* Extended frame format */
</I>&gt;<i> +#define HECC_CANMID_AME                BIT(30) /* Acceptance mask enable */
</I>&gt;<i> +#define HECC_CANMID_AAM                BIT(29) /* Auto answer mode */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANES_FE          BIT(24) /* form error */
</I>&gt;<i> +#define HECC_CANES_BE          BIT(23) /* bit error */
</I>&gt;<i> +#define HECC_CANES_SA1         BIT(22) /* stuck at dominant error */
</I>&gt;<i> +#define HECC_CANES_CRCE                BIT(21) /* CRC error */
</I>&gt;<i> +#define HECC_CANES_SE          BIT(20) /* stuff bit error */
</I>&gt;<i> +#define HECC_CANES_ACKE                BIT(19) /* ack error */
</I>&gt;<i> +#define HECC_CANES_BO          BIT(18) /* Bus off status */
</I>&gt;<i> +#define HECC_CANES_EP          BIT(17) /* Error passive status */
</I>&gt;<i> +#define HECC_CANES_EW          BIT(16) /* Error warning status */
</I>&gt;<i> +#define HECC_CANES_SMA         BIT(5)  /* suspend mode ack */
</I>&gt;<i> +#define HECC_CANES_CCE         BIT(4)  /* Change config enabled */
</I>&gt;<i> +#define HECC_CANES_PDA         BIT(3)  /* Power down mode ack */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANBTC_SAM                BIT(7)  /* sample points */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_BUS_ERROR         (HECC_CANES_FE | HECC_CANES_BE |\
</I>&gt;<i> +                               HECC_CANES_CRCE | HECC_CANES_SE |\
</I>&gt;<i> +                               HECC_CANES_ACKE)
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANMCF_RTR                BIT(4)  /* Remote xmit request */
</I>&gt;<i> +
</I>&gt;<i> +#define HECC_CANGIF_MAIF       BIT(17) /* Message alarm interrupt */
</I>&gt;<i> +#define HECC_CANGIF_TCOIF      BIT(16) /* Timer counter overflow int */
</I>&gt;<i> +#define HECC_CANGIF_GMIF       BIT(15) /* Global mailbox interrupt */
</I>&gt;<i> +#define HECC_CANGIF_AAIF       BIT(14) /* Abort ack interrupt */
</I>&gt;<i> +#define HECC_CANGIF_WDIF       BIT(13) /* Write denied interrupt */
</I>&gt;<i> +#define HECC_CANGIF_WUIF       BIT(12) /* Wake up interrupt */
</I>&gt;<i> +#define HECC_CANGIF_RMLIF      BIT(11) /* Receive message lost interrupt */
</I>&gt;<i> +#define HECC_CANGIF_BOIF       BIT(10) /* Bus off interrupt */
</I>&gt;<i> +#define HECC_CANGIF_EPIF       BIT(9)  /* Error passive interrupt */
</I>&gt;<i> +#define HECC_CANGIF_WLIF       BIT(8)  /* Warning level interrupt */
</I>&gt;<i> +#define HECC_CANGIF_MBOX_MASK  0x1F    /* Mailbox number mask */
</I>&gt;<i> +#define HECC_CANGIM_I1EN       BIT(1)  /* Int line 1 enable */
</I>&gt;<i> +#define HECC_CANGIM_I0EN       BIT(0)  /* Int line 0 enable */
</I>&gt;<i> +#define HECC_CANGIM_DEF_MASK   0xFF00  /* all except maif and tcoif */
</I>&gt;<i> +#define HECC_CANGIM_SIL                BIT(2)  /* system interrupts to int line 1 */
</I>&gt;<i> +
</I>&gt;<i> +/* CAN Bittiming constants as per HECC specs */
</I>&gt;<i> +static struct can_bittiming_const ti_hecc_bittiming_const = {
</I>&gt;<i> +       .name = DRV_NAME,
</I>&gt;<i> +       .tseg1_min = 1,
</I>&gt;<i> +       .tseg1_max = 16,
</I>&gt;<i> +       .tseg2_min = 1,
</I>
Please check if tseg2_min is a valid value. Usually it's larger.

&gt;<i> +       .tseg2_max = 8,
</I>&gt;<i> +       .sjw_max = 4,
</I>&gt;<i> +       .brp_min = 1,
</I>&gt;<i> +       .brp_max = 256,
</I>&gt;<i> +       .brp_inc = 1,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct ti_hecc_priv {
</I>&gt;<i> +       struct can_priv can;
</I>
Please add &quot;must be the first member/field&quot;.

&gt;<i> +       struct napi_struct napi;
</I>&gt;<i> +       struct net_device *ndev;
</I>&gt;<i> +       struct clk *clk;
</I>&gt;<i> +       void __iomem *base;
</I>&gt;<i> +       unsigned int scc_ram_offset;
</I>&gt;<i> +       unsigned int hecc_ram_offset;
</I>&gt;<i> +       unsigned int mbox_offset;
</I>&gt;<i> +       unsigned int int_line;
</I>&gt;<i> +       DECLARE_BITMAP(tx_free_mbx, TI_HECC_MAX_TX_MBOX);
</I>&gt;<i> +       spinlock_t tx_lock;
</I>
Please document the spinlock tx_lock. What is it used for.

&gt;<i> +
</I>&gt;<i> +       /* Statistics */
</I>&gt;<i> +       unsigned out_of_tx_mbox;
</I>&gt;<i> +       unsigned write_denied_cnt;
</I>&gt;<i> +       unsigned message_lost_cnt;
</I>&gt;<i> +       unsigned wake_up_cnt;
</I>&gt;<i> +       unsigned message_alarm_cnt;
</I>&gt;<i> +       unsigned timer_overflow_cnt;#
</I>
Debugging!? Should be removed. There is no interface to list these fields.

&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static inline
</I>&gt;<i> +void hecc_write(struct ti_hecc_priv *priv, int reg, unsigned int val)
</I>&gt;<i> +{
</I>&gt;<i> +       __raw_writel(val, priv-&gt;base + reg);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline unsigned int hecc_read(struct ti_hecc_priv *priv, int reg)
</I>&gt;<i> +{
</I>&gt;<i> +       return __raw_readl(priv-&gt;base + reg);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline
</I>&gt;<i> +void hecc_set_bit(struct ti_hecc_priv *priv, int reg, unsigned bit)
</I>&gt;<i> +{
</I>&gt;<i> +       hecc_write(priv, reg, (hecc_read(priv, reg) | bit));
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline
</I>&gt;<i> +void hecc_clear_bit(struct ti_hecc_priv *priv, int reg, unsigned bit)
</I>&gt;<i> +{
</I>&gt;<i> +       hecc_write(priv, reg, (hecc_read(priv, reg) &amp; ~bit));
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline
</I>&gt;<i> +unsigned int hecc_get_bit(struct ti_hecc_priv *priv, int reg, int bit)
</I>&gt;<i> +{
</I>&gt;<i> +       return (hecc_read(priv, reg) &amp; bit) ? 1 : 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>[snip]
&gt;<i> +
</I>&gt;<i> +static int ti_hecc_get_state(const struct net_device *ndev,
</I>&gt;<i> +       enum can_state *state)
</I>&gt;<i> +{
</I>&gt;<i> +       struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +       *state = priv-&gt;can.state;
</I>&gt;<i> +       return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_set_bittiming(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +       struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +       struct can_bittiming *bit_timing = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> +       unsigned int can_btc = 0;
</I>&gt;<i> +
</I>&gt;<i> +       can_btc = ((bit_timing-&gt;phase_seg2 - 1) &amp; 0x7);
</I>&gt;<i> +       can_btc |= (((bit_timing-&gt;phase_seg1 + bit_timing-&gt;prop_seg - 1)
</I>&gt;<i> +                       &amp; 0xF) &lt;&lt; 3);
</I>&gt;<i> +       if (bit_timing-&gt;brp &gt; 4)
</I>&gt;<i> +               can_btc |= HECC_CANBTC_SAM;
</I>
Please use:

	if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES)
	          can_btc |= HECC_CANBTC_SAM;

CAN controller modes can be set via &quot;ip&quot; utility. Note that also
loopback and listen-only is supported.

&gt;<i> +       can_btc |= (((bit_timing-&gt;sjw - 1) &amp; 0x3) &lt;&lt; 8);
</I>&gt;<i> +       can_btc |= (((bit_timing-&gt;brp - 1) &amp; 0xFF) &lt;&lt; 16);
</I>&gt;<i> +
</I>&gt;<i> +       /* ERM being set to 0 by default meaning resync at falling edge */
</I>&gt;<i> +
</I>&gt;<i> +       hecc_write(priv, HECC_CANBTC, can_btc);
</I>
Other drivers use dev_info here:

	dev_info(ND2D(dev), &quot;setting CANBTC=%#x\n&quot;, can_btc);


&gt;<i> +       return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * ti_hecc_reset: Reset HECC module and set bit timings
</I>&gt;<i> + *
</I>&gt;<i> + * Resets HECC by writing to change config request bit and then sets
</I>&gt;<i> + * bit-timing registers in the module to enable the module for operation
</I>&gt;<i> + */
</I>&gt;<i> +static void ti_hecc_reset(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +#define HECC_CCE_WAIT_COUNT    1000
</I>&gt;<i> +       unsigned int cnt;
</I>&gt;<i> +       struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +       dev_dbg(ndev-&gt;dev.parent, &quot;resetting hecc ...\n&quot;);
</I>&gt;<i> +
</I>&gt;<i> +       hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_SRES);
</I>&gt;<i> +
</I>&gt;<i> +       /* if change control request not enabled */
</I>&gt;<i> +       if (!hecc_get_bit(priv, HECC_CANES, HECC_CANES_CCE)) {
</I>&gt;<i> +               /* Set change control request and wait till enabled */
</I>&gt;<i> +               hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
</I>&gt;<i> +
</I>&gt;<i> +               /* INFO: It has been observed that at times CCE bit may not be
</I>&gt;<i> +                * set and hw seems to be ok even if this bit is not set so
</I>&gt;<i> +                * timing out with a large counter to respect the specs
</I>&gt;<i> +                */
</I>&gt;<i> +               cnt = HECC_CCE_WAIT_COUNT;
</I>&gt;<i> +               while (!hecc_get_bit(priv, HECC_CANES, HECC_CANES_CCE)) {
</I>&gt;<i> +                       --cnt;
</I>&gt;<i> +                       if (0 == cnt) {
</I>&gt;<i> +                               dev_info(ndev-&gt;dev.parent,
</I>&gt;<i> +                                       &quot;timing out on CCE after reset\n&quot;);
</I>&gt;<i> +                               break;
</I>&gt;<i> +                       }
</I>&gt;<i> +                       if (printk_ratelimit())
</I>&gt;<i> +                               dev_dbg(ndev-&gt;dev.parent,
</I>&gt;<i> +                                       &quot;waiting CCE after reset\n&quot;);
</I>
I think you don't need the ratelimit if you check after the while loop.

&gt;<i> +               }
</I>
The while loop above does not use any defined delay and therefore the
timing depends on the processor speed. Adding udelay(1|10) would solve
the issue.

&gt;<i> +       }
</I>&gt;<i> +
</I>


&gt;<i> +       /* Set bit timing on the device */
</I>&gt;<i> +       ti_hecc_set_bittiming(priv-&gt;ndev);
</I>
Hm, you re-set the bittiming here!? It is alread done via netlink
interface before the device is opened/started.

&gt;<i> +
</I>&gt;<i> +       /* Clear CCR (and CANMC register) and wait for CCE = 0 enable */
</I>&gt;<i> +       hecc_write(priv, HECC_CANMC, 0);
</I>&gt;<i> +
</I>&gt;<i> +       /* INFO: CAN net stack handles bus off and hence disabling auto bus on
</I>&gt;<i> +       hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_ABO);
</I>&gt;<i> +       */
</I>
Right, automatic bus-off recovery should be disabled. To make that clear:

           hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_ABO);


&gt;<i> +       /* Wait till CCE bit clears */
</I>&gt;<i> +       /* INFO: It has been observed that at times CCE bit may not be
</I>&gt;<i> +        * set and hw seems to be ok even if this bit is not set so
</I>&gt;<i> +        * timing out with a large counter to respect the specs
</I>&gt;<i> +        */
</I>&gt;<i> +       cnt = HECC_CCE_WAIT_COUNT;
</I>&gt;<i> +       while (hecc_get_bit(priv, HECC_CANES, HECC_CANES_CCE)) {
</I>&gt;<i> +               --cnt;
</I>&gt;<i> +               if (0 == cnt) {
</I>&gt;<i> +                       dev_info(ndev-&gt;dev.parent,
</I>&gt;<i> +                               &quot;timing out on CCE after bittiming\n&quot;);
</I>&gt;<i> +                       break;
</I>&gt;<i> +               }
</I>&gt;<i> +               if (printk_ratelimit())
</I>&gt;<i> +                       dev_dbg(ndev-&gt;dev.parent,
</I>&gt;<i> +                               &quot;waiting CCE after bittiming\n&quot;);
</I>&gt;<i> +       }
</I>
Consider adding a udelay(1|10) as mentioned above.

&gt;<i> +       /* Enable TX and RX I/O Control pins */
</I>&gt;<i> +       hecc_write(priv, HECC_CANTIOC, HECC_CANTIOC_EN);
</I>&gt;<i> +       hecc_write(priv, HECC_CANRIOC, HECC_CANRIOC_EN);
</I>&gt;<i> +
</I>&gt;<i> +       /* Clear registers for clean operation */
</I>&gt;<i> +       hecc_write(priv, HECC_CANTA, HECC_SET_REG);
</I>&gt;<i> +       hecc_write(priv, HECC_CANRMP, HECC_SET_REG);
</I>&gt;<i> +       hecc_write(priv, HECC_CANGIF0, HECC_SET_REG);
</I>&gt;<i> +       hecc_write(priv, HECC_CANGIF1, HECC_SET_REG);
</I>&gt;<i> +       hecc_write(priv, HECC_CANME, 0);
</I>&gt;<i> +       hecc_write(priv, HECC_CANMD, 0);
</I>&gt;<i> +
</I>&gt;<i> +       /* SCC compat mode NOT supported (and not needed too) */
</I>&gt;<i> +       hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_SCM);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * ti_hecc_start: Starts HECC module
</I>&gt;<i> + *
</I>&gt;<i> + * If CAN state is not stopped, reset the module, init bit timings
</I>&gt;<i> + * and start the device for operation
</I>&gt;<i> + */
</I>&gt;<i> +static void ti_hecc_start(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +       struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +       int cnt, mbxno;
</I>&gt;<i> +
</I>&gt;<i> +       ti_hecc_reset(ndev);
</I>&gt;<i> +
</I>&gt;<i> +       bitmap_zero(priv-&gt;tx_free_mbx, TI_HECC_MAX_TX_MBOX);
</I>&gt;<i> +
</I>&gt;<i> +       /* Enable local and global acceptance mask registers */
</I>&gt;<i> +       hecc_write(priv, HECC_CANGAM, HECC_SET_REG);
</I>&gt;<i> +       hecc_write(priv, HECC_CANLAM0, HECC_SET_REG);
</I>&gt;<i> +       hecc_write(priv, HECC_CANLAM3, HECC_SET_REG);
</I>&gt;<i> +
</I>&gt;<i> +       /* Prepare configured mailboxes to receive messages */
</I>&gt;<i> +       for (cnt = 0; cnt &lt; TI_HECC_MAX_RX_MBOX; cnt++) {
</I>&gt;<i> +               mbxno = (HECC_MAX_MAILBOXES - 1 - cnt);
</I>&gt;<i> +               hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +               hecc_write(priv, HECC_CANMID(mbxno), HECC_CANMID_AME);
</I>&gt;<i> +               hecc_write(priv, HECC_CANLAM(mbxno), HECC_SET_REG);
</I>&gt;<i> +               hecc_set_bit(priv, HECC_CANMD, (1 &lt;&lt; mbxno));
</I>&gt;<i> +               hecc_set_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +               hecc_set_bit(priv, HECC_CANMIM, (1 &lt;&lt; mbxno));
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       /* Prevent message over-write &amp; Enable interrupts */
</I>&gt;<i> +       hecc_write(priv, HECC_CANTRS, 0);
</I>&gt;<i> +       hecc_write(priv, HECC_CANOPC, HECC_SET_REG);
</I>&gt;<i> +       if (priv-&gt;int_line) {
</I>&gt;<i> +               hecc_write(priv, HECC_CANMIL, HECC_SET_REG);
</I>&gt;<i> +               hecc_write(priv, HECC_CANGIM, (HECC_CANGIM_DEF_MASK |
</I>&gt;<i> +                       HECC_CANGIM_I1EN | HECC_CANGIM_SIL));
</I>&gt;<i> +       } else {
</I>&gt;<i> +               hecc_write(priv, HECC_CANMIL, 0);
</I>&gt;<i> +               hecc_write(priv, HECC_CANGIM,
</I>&gt;<i> +                       (HECC_CANGIM_DEF_MASK | HECC_CANGIM_I0EN));
</I>&gt;<i> +       }
</I>&gt;<i> +       priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void ti_hecc_stop(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +       struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +       /* Disable interrupts and disable mailboxes */
</I>&gt;<i> +       hecc_write(priv, HECC_CANGIM, 0);
</I>&gt;<i> +       hecc_write(priv, HECC_CANMIM, 0);
</I>&gt;<i> +       hecc_write(priv, HECC_CANME, 0);
</I>&gt;<i> +       priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_do_set_mode(struct net_device *ndev, enum can_mode mode)
</I>&gt;<i> +{
</I>&gt;<i> +       struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +       int ret = 0;
</I>&gt;<i> +
</I>&gt;<i> +       switch (mode) {
</I>&gt;<i> +       case CAN_MODE_SLEEP:
</I>&gt;<i> +               dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;device going to sleep\n&quot;);
</I>&gt;<i> +               if (netif_running(ndev)) {
</I>&gt;<i> +                       netif_stop_queue(ndev);
</I>&gt;<i> +                       netif_device_detach(ndev);
</I>&gt;<i> +                       /* Put HECC in low power mode */
</I>&gt;<i> +                       hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_PDR);
</I>&gt;<i> +               }
</I>&gt;<i> +               priv-&gt;can.state = CAN_STATE_SLEEPING;
</I>&gt;<i> +               break;
</I>
Has sleeping been tested? Actually, we do not have an interface yet to
enter sleep mode. Please remove. If there is a need for it, we should
work togehter to refine the interface and to provide a solution.

&gt;<i> +       case CAN_MODE_STOP:
</I>&gt;<i> +               dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;device stopping\n&quot;);
</I>&gt;<i> +               ti_hecc_stop(ndev);
</I>&gt;<i> +               break;
</I>
Only CAN_MODE_START is used by the CAN devicde interface for bus-off
recovery.

&gt;<i> +       case CAN_MODE_START:
</I>&gt;<i> +               dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;device (re)starting\n&quot;);
</I>&gt;<i> +               ++priv-&gt;can.can_stats.restarts;
</I>&gt;<i> +               ti_hecc_start(ndev);
</I>&gt;<i> +               if (netif_queue_stopped(ndev))
</I>&gt;<i> +                       netif_wake_queue(ndev);
</I>&gt;<i> +               break;
</I>&gt;<i> +       default:
</I>&gt;<i> +               ret = -EOPNOTSUPP;
</I>&gt;<i> +               break;
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       return ret;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_xmit(struct sk_buff *skb, struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +       struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +       struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> +       struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> +       u32 mbxno = 0;
</I>&gt;<i> +       u32 data;
</I>&gt;<i> +       unsigned long flags;
</I>&gt;<i> +
</I>&gt;<i> +       /* Find the first mailbox that is free for xmit */
</I>&gt;<i> +       spin_lock_irqsave(&amp;priv-&gt;tx_lock, flags);
</I>&gt;<i> +       mbxno = find_first_zero_bit(priv-&gt;tx_free_mbx, TI_HECC_MAX_TX_MBOX);
</I>&gt;<i> +       if (mbxno == TI_HECC_MAX_TX_MBOX) {
</I>&gt;<i> +               netif_stop_queue(ndev);
</I>&gt;<i> +               if (printk_ratelimit())
</I>&gt;<i> +                       dev_err(priv-&gt;ndev-&gt;dev.parent,
</I>&gt;<i> +                               &quot;Out of TX buffers ...\n&quot;);
</I>&gt;<i> +               spin_unlock_irqrestore(&amp;priv-&gt;tx_lock, flags);
</I>&gt;<i> +               return NETDEV_TX_BUSY;
</I>
Could'nt the NETDEV_TX_BUSY be avoided by stopping the queue earlier?

&gt;<i> +
</I>&gt;<i> +       }
</I>&gt;<i> +       set_bit(mbxno, priv-&gt;tx_free_mbx);
</I>&gt;<i> +       spin_unlock_irqrestore(&amp;priv-&gt;tx_lock, flags);
</I>
Hm, I wonder how the driver ensures that packages go out in order. How
does the CAN hardware schedule pending TX message objects? Vladislav
posted a test programs recently to check message ordering. See:

<A HREF="https://lists.berlios.de/pipermail/socketcan-core/2009-August/002871.html">https://lists.berlios.de/pipermail/socketcan-core/2009-August/002871.html</A>

&gt;<i> +
</I>&gt;<i> +       /* Prepare mailbox for transmission */
</I>&gt;<i> +       hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +       data = cf-&gt;can_dlc &amp; 0xF;
</I>&gt;<i> +       if (cf-&gt;can_id &amp; CAN_RTR_FLAG) /* Remote transmission request */
</I>&gt;<i> +               data |= HECC_CANMCF_RTR;
</I>&gt;<i> +       hecc_write(priv, HECC_CANMCF(mbxno), data);
</I>&gt;<i> +       if (cf-&gt;can_id &amp; CAN_EFF_FLAG) { /* Extended frame format */
</I>&gt;<i> +               data = ((cf-&gt;can_id &amp; CAN_EFF_MASK) | HECC_CANMID_IDE);
</I>&gt;<i> +       } else { /* Standard frame format */
</I>&gt;<i> +               data = ((cf-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; 18);
</I>&gt;<i> +       }
</I>&gt;<i> +       hecc_write(priv, HECC_CANMID(mbxno), data);
</I>&gt;<i> +       data = (cf-&gt;data[0] &lt;&lt; 24) | (cf-&gt;data[1] &lt;&lt; 16) |
</I>&gt;<i> +                       (cf-&gt;data[2] &lt;&lt; 8) | cf-&gt;data[3];
</I>&gt;<i> +       hecc_write(priv, HECC_CANMDL(mbxno), data);
</I>&gt;<i> +       if (cf-&gt;can_dlc &gt; 4) {
</I>&gt;<i> +               data = (cf-&gt;data[4] &lt;&lt; 24) | (cf-&gt;data[5] &lt;&lt; 16) |
</I>&gt;<i> +                       (cf-&gt;data[6] &lt;&lt; 8) | cf-&gt;data[7];
</I>&gt;<i> +               hecc_write(priv, HECC_CANMDH(mbxno), data);
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>[slip]
&gt;<i> +
</I>&gt;<i> +       /* Enable interrupt for mbox and start transmission */
</I>&gt;<i> +       hecc_clear_bit(priv, HECC_CANMD, (1 &lt;&lt; mbxno));
</I>&gt;<i> +       hecc_set_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +       hecc_set_bit(priv, HECC_CANMIM, (1 &lt;&lt; mbxno));
</I>&gt;<i> +       hecc_set_bit(priv, HECC_CANTRS, (1 &lt;&lt; mbxno));
</I>&gt;<i> +
</I>&gt;<i> +       stats-&gt;tx_bytes += cf-&gt;can_dlc;
</I>
Should be done when the TX done interrupr is handled.

&gt;<i> +       ndev-&gt;trans_start = jiffies;
</I>&gt;<i> +       can_put_echo_skb(skb, ndev, mbxno);
</I>
Please call can_put_echo_skb() before starting transmission.

&gt;<i> +
</I>&gt;<i> +       return NETDEV_TX_OK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_rx_pkt(struct ti_hecc_priv *priv, int mbxno)
</I>&gt;<i> +{
</I>&gt;<i> +       struct net_device_stats *stats = &amp;priv-&gt;ndev-&gt;stats;
</I>&gt;<i> +       struct can_frame *cf;
</I>&gt;<i> +       struct sk_buff *skb;
</I>&gt;<i> +       u32 data;
</I>&gt;<i> +
</I>&gt;<i> +       skb = dev_alloc_skb(sizeof(struct can_frame));
</I>&gt;<i> +       if (!skb) {
</I>&gt;<i> +               if (printk_ratelimit())
</I>&gt;<i> +                       dev_err(priv-&gt;ndev-&gt;dev.parent,
</I>&gt;<i> +                               &quot;dev_alloc_skb() failed\n&quot;);
</I>&gt;<i> +               return -ENOMEM;
</I>&gt;<i> +       }
</I>&gt;<i> +       skb-&gt;dev = priv-&gt;ndev;
</I>&gt;<i> +       skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;<i> +       skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
</I>&gt;<i> +
</I>&gt;<i> +       cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
</I>&gt;<i> +       memset(cf, 0, sizeof(struct can_frame));
</I>&gt;<i> +       data = hecc_read(priv, HECC_CANMID(mbxno));
</I>&gt;<i> +       if (data &amp; HECC_CANMID_IDE)
</I>&gt;<i> +               cf-&gt;can_id = (data &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
</I>&gt;<i> +       else
</I>&gt;<i> +               cf-&gt;can_id = ((data &gt;&gt; 18) &amp; CAN_SFF_MASK);
</I>&gt;<i> +       data = hecc_read(priv, HECC_CANMCF(mbxno));
</I>&gt;<i> +       if (data &amp; HECC_CANMCF_RTR)
</I>&gt;<i> +               cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> +       cf-&gt;can_dlc = data &amp; 0xF;
</I>&gt;<i> +       data = hecc_read(priv, HECC_CANMDL(mbxno));
</I>&gt;<i> +       /* The below statements are for readability sake */
</I>&gt;<i> +       cf-&gt;data[0] = ((data &amp; 0xFF000000) &gt;&gt; 24);
</I>&gt;<i> +       cf-&gt;data[1] = ((data &amp; 0xFF0000) &gt;&gt; 16);
</I>&gt;<i> +       cf-&gt;data[2] = ((data &amp; 0xFF00) &gt;&gt; 8);
</I>&gt;<i> +       cf-&gt;data[3] = (data &amp; 0xFF);
</I>&gt;<i> +       if (cf-&gt;can_dlc &gt; 4) {
</I>&gt;<i> +               data = hecc_read(priv, HECC_CANMDH(mbxno));
</I>&gt;<i> +               cf-&gt;data[4] = ((data &amp; 0xFF000000) &gt;&gt; 24);
</I>&gt;<i> +               cf-&gt;data[5] = ((data &amp; 0xFF0000) &gt;&gt; 16);
</I>&gt;<i> +               cf-&gt;data[6] = ((data &amp; 0xFF00) &gt;&gt; 8);
</I>&gt;<i> +               cf-&gt;data[7] = (data &amp; 0xFF);
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>[snip]
&gt;<i> +
</I>&gt;<i> +       /* prepare mailbox for next receive */
</I>&gt;<i> +       hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +       hecc_write(priv, HECC_CANMID(mbxno), HECC_CANMID_AME);
</I>&gt;<i> +       hecc_write(priv, HECC_CANLAM(mbxno), HECC_SET_REG);
</I>&gt;<i> +       hecc_set_bit(priv, HECC_CANMD, (1 &lt;&lt; mbxno));
</I>&gt;<i> +       hecc_set_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +
</I>&gt;<i> +       stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +       netif_rx(skb);
</I>
Hm, IIRC, netif_receive_skb(skb) should be used with NAPI.

&gt;<i> +       stats-&gt;rx_packets++;
</I>&gt;<i> +       priv-&gt;ndev-&gt;last_rx = jiffies;
</I>&gt;<i> +
</I>&gt;<i> +       return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_rx_poll(struct napi_struct *napi, int quota)
</I>&gt;<i> +{
</I>&gt;<i> +       struct net_device *ndev = napi-&gt;dev;
</I>&gt;<i> +       struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +       int num_pkts = 0;
</I>&gt;<i> +       unsigned long pending_pkts;
</I>&gt;<i> +       int mbxno;
</I>&gt;<i> +
</I>&gt;<i> +       if (!netif_running(ndev))
</I>&gt;<i> +               return 0;
</I>&gt;<i> +
</I>&gt;<i> +       pending_pkts = hecc_read(priv, HECC_CANRMP);
</I>&gt;<i> +       while (pending_pkts &amp;&amp; (num_pkts &lt; quota)) {
</I>&gt;<i> +               mbxno = find_first_bit(&amp;pending_pkts, HECC_MAX_MAILBOXES);
</I>
Here I also wonder if the messages are handled in the correct order.

&gt;<i> +               if (mbxno == HECC_MAX_MAILBOXES) {
</I>&gt;<i> +                       dev_info(priv-&gt;ndev-&gt;dev.parent,
</I>&gt;<i> +                               &quot;Reached max mailboxes. No rx pkts\n&quot;);
</I>&gt;<i> +                       return num_pkts;
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               if (ti_hecc_rx_pkt(priv, mbxno) &lt; 0)
</I>&gt;<i> +                       return num_pkts;
</I>&gt;<i> +
</I>&gt;<i> +               clear_bit(mbxno, &amp;pending_pkts);
</I>&gt;<i> +               hecc_set_bit(priv, HECC_CANRMP, (1 &lt;&lt; mbxno));
</I>&gt;<i> +               ++num_pkts;
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       /* Enable packet interrupt if all pkts are handled */
</I>&gt;<i> +       if (0 == hecc_read(priv, HECC_CANRMP)) {
</I>&gt;<i> +               napi_complete(napi);
</I>&gt;<i> +               /* Re-enable RX mailbox interrupts */
</I>&gt;<i> +               mbxno = hecc_read(priv, HECC_CANMIM);
</I>&gt;<i> +               mbxno |= (~((1 &lt;&lt; TI_HECC_MAX_TX_MBOX) - 1));
</I>&gt;<i> +               hecc_write(priv, HECC_CANMIM, mbxno);
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       return num_pkts;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * ti_hecc_error: TI HECC error routine
</I>&gt;<i> + *
</I>&gt;<i> + * Handles HECC error - handles error condition and send a packet up the stack
</I>&gt;<i> + */
</I>&gt;<i> +static int
</I>&gt;<i> +ti_hecc_error(struct net_device *ndev, int int_status, int err_status)
</I>&gt;<i> +{
</I>&gt;<i> +       struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +       struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> +       struct can_frame *cf;
</I>&gt;<i> +       struct sk_buff *skb;
</I>&gt;<i> +       int data;
</I>&gt;<i> +
</I>&gt;<i> +       /* propogate the error condition to the can stack */
</I>&gt;<i> +       skb = dev_alloc_skb(sizeof(struct can_frame));
</I>&gt;<i> +       if (!skb) {
</I>&gt;<i> +               if (printk_ratelimit())
</I>&gt;<i> +                       dev_err(priv-&gt;ndev-&gt;dev.parent,
</I>&gt;<i> +                               &quot;dev_alloc_skb() failed in err processing\n&quot;);
</I>&gt;<i> +               return -ENOMEM;
</I>&gt;<i> +       }
</I>&gt;<i> +       skb-&gt;dev = ndev;
</I>&gt;<i> +       skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;<i> +       cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
</I>&gt;<i> +       memset(cf, 0, sizeof(struct can_frame));
</I>&gt;<i> +       cf-&gt;can_id = CAN_ERR_FLAG;
</I>&gt;<i> +       cf-&gt;can_dlc = CAN_ERR_DLC;
</I>&gt;<i> +
</I>&gt;<i> +       if (int_status &amp; HECC_CANGIF_RMLIF) { /* Message lost interrupt */
</I>&gt;<i> +               data = hecc_read(priv, HECC_CANRML);
</I>&gt;<i> +               hecc_write(priv, HECC_CANRML, data);
</I>&gt;<i> +               ++priv-&gt;message_lost_cnt;
</I>
Debugging!?

&gt;<i> +               cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +               cf-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
</I>&gt;<i> +               stats-&gt;rx_over_errors++;
</I>&gt;<i> +               stats-&gt;rx_errors++;
</I>&gt;<i> +               dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;Message lost interrupt\n&quot;);
</I>
Debugging!?

&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       if (int_status &amp; HECC_CANGIF_WLIF) { /* warning level int */
</I>&gt;<i> +               if (0 == (int_status &amp; HECC_CANGIF_BOIF)) {
</I>&gt;<i> +                       priv-&gt;can.state = CAN_STATE_ERROR_WARNING;
</I>&gt;<i> +                       ++priv-&gt;can.can_stats.error_warning;
</I>&gt;<i> +                       cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +                       if (hecc_read(priv, HECC_CANTEC) &gt; 96)
</I>&gt;<i> +                               cf-&gt;data[1] |= CAN_ERR_CRTL_TX_WARNING;
</I>&gt;<i> +                       if (hecc_read(priv, HECC_CANREC) &gt; 96)
</I>&gt;<i> +                               cf-&gt;data[1] |= CAN_ERR_CRTL_RX_WARNING;
</I>&gt;<i> +               }
</I>&gt;<i> +               hecc_set_bit(priv, HECC_CANES, HECC_CANES_EW);
</I>&gt;<i> +               dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;Error Warning interrupt\n&quot;);
</I>&gt;<i> +               hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       if (int_status &amp; HECC_CANGIF_EPIF) { /* error passive int */
</I>&gt;<i> +               if (0 == (int_status &amp; HECC_CANGIF_BOIF)) {
</I>&gt;<i> +                       priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> +                       ++priv-&gt;can.can_stats.error_passive;
</I>&gt;<i> +                       cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +                       if (hecc_read(priv, HECC_CANTEC) &gt; 127)
</I>&gt;<i> +                               cf-&gt;data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
</I>&gt;<i> +                       if (hecc_read(priv, HECC_CANREC) &gt; 127)
</I>&gt;<i> +                               cf-&gt;data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> +               }
</I>&gt;<i> +               hecc_set_bit(priv, HECC_CANES, HECC_CANES_EP);
</I>&gt;<i> +               dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;Error passive interrupt\n&quot;);
</I>
Please use dev_dbg.

&gt;<i> +               hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       /* Need to check busoff condition in error status register too to
</I>&gt;<i> +        * ensure warning interrupts don't hog the system
</I>&gt;<i> +        */
</I>&gt;<i> +       if (int_status &amp; HECC_CANGIF_BOIF) {
</I>&gt;<i> +               priv-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +               cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> +               hecc_set_bit(priv, HECC_CANES, HECC_CANES_BO);
</I>&gt;<i> +               dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;Bus Off interrupt\n&quot;);
</I>
can_bus_off() already calls dev_dbg(&quot;bus-off&quot;).


&gt;<i> +               hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
</I>&gt;<i> +               can_bus_off(ndev);
</I>&gt;<i> +               /* Disable all interrupts in bus-off to avoid int hog */
</I>&gt;<i> +               hecc_write(priv, HECC_CANGIM, 0);
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       if (err_status &amp; HECC_CANES_BO) {
</I>&gt;<i> +               priv-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +               cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> +               hecc_set_bit(priv, HECC_CANES, HECC_CANES_BO);
</I>&gt;<i> +               dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;Bus Off condition\n&quot;);
</I>&gt;<i> +               hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
</I>&gt;<i> +               can_bus_off(ndev);
</I>&gt;<i> +               /* Disable all interrupts in bus-off to avoid int hog */
</I>&gt;<i> +               hecc_write(priv, HECC_CANGIM, 0);
</I>&gt;<i> +       }
</I>
I think the two if blocks above use idendical code. What is the
difference. Using if (a || b) would be more appropriate.

&gt;<i> +
</I>&gt;<i> +       if (err_status &amp; HECC_BUS_ERROR) {
</I>&gt;<i> +               ++priv-&gt;can.can_stats.bus_error;
</I>&gt;<i> +               cf-&gt;can_id |= (CAN_ERR_BUSERROR | CAN_ERR_PROT);
</I>&gt;<i> +               cf-&gt;data[2] |= CAN_ERR_PROT_UNSPEC;
</I>&gt;<i> +               if (err_status &amp; HECC_CANES_FE) {
</I>&gt;<i> +                       hecc_set_bit(priv, HECC_CANES, HECC_CANES_FE);
</I>&gt;<i> +                       cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;<i> +               }
</I>&gt;<i> +               if (err_status &amp; HECC_CANES_BE) {
</I>&gt;<i> +                       hecc_set_bit(priv, HECC_CANES, HECC_CANES_BE);
</I>&gt;<i> +                       cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
</I>&gt;<i> +               }
</I>&gt;<i> +               if (err_status &amp; HECC_CANES_SE) {
</I>&gt;<i> +                       hecc_set_bit(priv, HECC_CANES, HECC_CANES_SE);
</I>&gt;<i> +                       cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;<i> +               }
</I>&gt;<i> +               if (err_status &amp; HECC_CANES_CRCE) {
</I>&gt;<i> +                       hecc_set_bit(priv, HECC_CANES, HECC_CANES_CRCE);
</I>&gt;<i> +                       cf-&gt;data[2] |= (CAN_ERR_PROT_LOC_CRC_SEQ |
</I>&gt;<i> +                                       CAN_ERR_PROT_LOC_CRC_DEL);
</I>&gt;<i> +               }
</I>&gt;<i> +               if (err_status &amp; HECC_CANES_ACKE) {
</I>&gt;<i> +                       hecc_set_bit(priv, HECC_CANES, HECC_CANES_ACKE);
</I>&gt;<i> +                       cf-&gt;data[2] |= (CAN_ERR_PROT_LOC_ACK |
</I>&gt;<i> +                                       CAN_ERR_PROT_LOC_ACK_DEL);
</I>&gt;<i> +               }
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       netif_receive_skb(skb);
</I>
OK, here you use netif_receive_skb().

&gt;<i> +       ndev-&gt;last_rx = jiffies;
</I>&gt;<i> +       stats-&gt;rx_packets++;
</I>&gt;<i> +       stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +       return 0;
</I>&gt;<i> +}
</I>
At a first glance, error message creation looks good. I will have a
closer look some time later.

&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * ti_hecc_interrupt: TI HECC interrupt routine
</I>&gt;<i> + *
</I>&gt;<i> + * Handles HECC interrupts - disables interrupt if receive pkts that will
</I>&gt;<i> + * be enabled when rx pkts are compelte (napi_complete is done)
</I>&gt;<i> + */
</I>&gt;<i> +static irqreturn_t ti_hecc_interrupt(int irq, void *dev_id)
</I>&gt;<i> +{
</I>&gt;<i> +       struct net_device *ndev = (struct net_device *)dev_id;
</I>&gt;<i> +       struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +       struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> +       struct sk_buff *skb;
</I>&gt;<i> +       struct can_frame *cf;
</I>&gt;<i> +       unsigned int int_status;
</I>&gt;<i> +       unsigned long ack;
</I>&gt;<i> +       int mbxno;
</I>&gt;<i> +       unsigned long flags;
</I>&gt;<i> +
</I>&gt;<i> +       if (priv-&gt;int_line)
</I>&gt;<i> +               int_status = hecc_read(priv, HECC_CANGIF1);
</I>&gt;<i> +       else
</I>&gt;<i> +               int_status = hecc_read(priv, HECC_CANGIF0);
</I>&gt;<i> +
</I>&gt;<i> +       if (0 == int_status)
</I>&gt;<i> +               return IRQ_NONE;
</I>&gt;<i> +
</I>&gt;<i> +       /* Handle message alarm interrupt */
</I>&gt;<i> +       if (int_status &amp; HECC_CANGIF_MAIF) {
</I>&gt;<i> +               ++priv-&gt;message_alarm_cnt;
</I>&gt;<i> +               dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;Message alarm interrupt\n&quot;);
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       /* Handle local network timer counter overflow interrupt */
</I>&gt;<i> +       if (int_status &amp; HECC_CANGIF_TCOIF) {
</I>&gt;<i> +               ++priv-&gt;timer_overflow_cnt;
</I>&gt;<i> +               dev_info(priv-&gt;ndev-&gt;dev.parent,
</I>&gt;<i> +                       &quot;Local network timer counter overflow interrupt\n&quot;);
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       /* Handle write denied interrupt */
</I>&gt;<i> +       if (int_status &amp; HECC_CANGIF_WDIF) {
</I>&gt;<i> +               ++priv-&gt;write_denied_cnt;
</I>&gt;<i> +               dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;Write denied interrupt\n&quot;);
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       /* Handle wake up interrupt */
</I>&gt;<i> +       if (int_status &amp; HECC_CANGIF_WUIF) {
</I>&gt;<i> +               ++priv-&gt;wake_up_cnt;
</I>&gt;<i> +               dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;Wake up interrupt\n&quot;);
</I>&gt;<i> +       }
</I>
Do the interrupt sources above occur. Does it harm or even signal a
malfunctioning? If yes, use dev_err and dev_dbg otherwise. And as
mentioned above, the statistic counters are most likely for debugging
purposes only.

&gt;<i> +
</I>&gt;<i> +       ti_hecc_error(ndev, int_status, hecc_read(priv, HECC_CANES));
</I>
Hm, you create an error frame for each interrupt!? What do you see with:

 # candump any,0:0,#FFFFFFFF

&gt;<i> +
</I>&gt;<i> +       /* Handle Abort acknowledge interrupt */
</I>&gt;<i> +       if (int_status &amp; HECC_CANGIF_AAIF) {
</I>&gt;<i> +               ack = hecc_read(priv, HECC_CANAA);
</I>&gt;<i> +               while (ack) {
</I>&gt;<i> +                       mbxno = find_first_bit(&amp;ack, HECC_MAX_MAILBOXES);
</I>&gt;<i> +                       if (mbxno == HECC_MAX_MAILBOXES) {
</I>&gt;<i> +                               break;
</I>&gt;<i> +                       } else {
</I>&gt;<i> +                               clear_bit(mbxno, &amp;ack);
</I>&gt;<i> +                               /* release echo pkt &amp; update counters */
</I>&gt;<i> +                               hecc_set_bit(priv, HECC_CANAA, (1 &lt;&lt; mbxno));
</I>&gt;<i> +                               hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +                               /* FIXME: since net-next tree's dev.h does not
</I>&gt;<i> +                                * include can_free_echo_skb() doing equivalent
</I>&gt;<i> +                                * of can_free_echo_skb(ndev, mbxno);
</I>&gt;<i> +                                */
</I>&gt;<i> +                               if (priv-&gt;can.echo_skb[mbxno]) {
</I>&gt;<i> +                                       kfree_skb(priv-&gt;can.echo_skb[mbxno]);
</I>&gt;<i> +                                       priv-&gt;can.echo_skb[mbxno] = NULL;
</I>&gt;<i> +                               }
</I>&gt;<i> +                               if (netif_queue_stopped(ndev))
</I>&gt;<i> +                                       netif_wake_queue(ndev);
</I>&gt;<i> +                               spin_lock_irqsave(&amp;priv-&gt;tx_lock, flags);
</I>&gt;<i> +                               clear_bit(mbxno, priv-&gt;tx_free_mbx);
</I>&gt;<i> +                               spin_unlock_irqrestore(&amp;priv-&gt;tx_lock, flags);
</I>&gt;<i> +                       }
</I>&gt;<i> +               }
</I>&gt;<i> +       }
</I>
Can that interrupt happen? I have not found any code aborting messages.

&gt;<i> +
</I>&gt;<i> +       /* Handle mailbox interrupt */
</I>&gt;<i> +       if (int_status &amp; HECC_CANGIF_GMIF) {
</I>&gt;<i> +               ack = hecc_read(priv, HECC_CANTA);
</I>&gt;<i> +               while (ack) {
</I>&gt;<i> +                       mbxno = find_first_bit(&amp;ack, HECC_MAX_MAILBOXES);
</I>&gt;<i> +                       if (mbxno == HECC_MAX_MAILBOXES) {
</I>&gt;<i> +                               break;
</I>&gt;<i> +                       } else {
</I>&gt;<i> +                               clear_bit(mbxno, &amp;ack);
</I>&gt;<i> +                               hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
</I>&gt;<i> +                               hecc_set_bit(priv, HECC_CANTA, (1 &lt;&lt; mbxno));
</I>&gt;<i> +                               skb = priv-&gt;can.echo_skb[mbxno];
</I>&gt;<i> +                               cf = (struct can_frame *) (skb-&gt;data);
</I>
Please don't access the echo skb's directly. Try to get the dlc from the
hardware.

&gt;<i> +                               can_get_echo_skb(ndev, mbxno);
</I>&gt;<i> +                               stats-&gt;tx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +                               spin_lock_irqsave(&amp;priv-&gt;tx_lock, flags);
</I>&gt;<i> +                               clear_bit(mbxno, priv-&gt;tx_free_mbx);
</I>&gt;<i> +                               spin_unlock_irqrestore(&amp;priv-&gt;tx_lock, flags);
</I>&gt;<i> +                               stats-&gt;tx_packets++;
</I>&gt;<i> +                       }
</I>&gt;<i> +               }
</I>&gt;<i> +               if (netif_queue_stopped(ndev))
</I>&gt;<i> +                       netif_wake_queue(ndev);
</I>&gt;<i> +
</I>&gt;<i> +               /* Disable RX mailbox interrupts and let NAPI reenable them */
</I>&gt;<i> +               ack = hecc_read(priv, HECC_CANMIM);
</I>&gt;<i> +               ack &amp;= ((1 &lt;&lt; TI_HECC_MAX_TX_MBOX) - 1);
</I>&gt;<i> +               hecc_write(priv, HECC_CANMIM, ack);
</I>&gt;<i> +               napi_schedule(&amp;priv-&gt;napi);
</I>
You schedule an RX event even if no RX message is pending? This does not
look very efficient to me.

&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       /* clear all interrupt conditions - read back to avoid spurious ints */
</I>&gt;<i> +       if (priv-&gt;int_line) {
</I>&gt;<i> +               hecc_write(priv, HECC_CANGIF1, HECC_SET_REG);
</I>&gt;<i> +               int_status = hecc_read(priv, HECC_CANGIF1);
</I>&gt;<i> +       } else {
</I>&gt;<i> +               hecc_write(priv, HECC_CANGIF0, HECC_SET_REG);
</I>&gt;<i> +               int_status = hecc_read(priv, HECC_CANGIF0);
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       return IRQ_HANDLED;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/* NOTE: yet to test suspend/resume */
</I>
Please remove suspend/resume code if it's not tested.

&gt;<i> +static int ti_hecc_suspend(struct platform_device *pdev, pm_message_t state)
</I>&gt;<i> +{
</I>&gt;<i> +       struct net_device *ndev = platform_get_drvdata(pdev);
</I>&gt;<i> +       struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +       if (netif_running(ndev)) {
</I>&gt;<i> +               netif_stop_queue(ndev);
</I>&gt;<i> +               netif_device_detach(ndev);
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_PDR);
</I>&gt;<i> +       priv-&gt;can.state = CAN_STATE_SLEEPING;
</I>&gt;<i> +       clk_disable(priv-&gt;clk);
</I>&gt;<i> +
</I>&gt;<i> +       return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/* NOTE: yet to test suspend/resume */
</I>&gt;<i> +static int ti_hecc_resume(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +       struct net_device *ndev = platform_get_drvdata(pdev);
</I>&gt;<i> +       struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +       clk_enable(priv-&gt;clk);
</I>&gt;<i> +       hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_PDR);
</I>&gt;<i> +       priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +       if (netif_running(ndev)) {
</I>&gt;<i> +               netif_device_attach(ndev);
</I>&gt;<i> +               netif_start_queue(ndev);
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_open(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +       struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +       int err;
</I>&gt;<i> +
</I>&gt;<i> +       dev_info(ndev-&gt;dev.parent, &quot;opening device\n&quot;);
</I>&gt;<i> +
</I>&gt;<i> +       if (request_irq(ndev-&gt;irq, ti_hecc_interrupt, IRQF_DISABLED,
</I>&gt;<i> +                               ndev-&gt;name, ndev)) {
</I>&gt;<i> +               dev_err(ndev-&gt;dev.parent, &quot;error requesting interrupt\n&quot;);
</I>&gt;<i> +               return -EAGAIN;
</I>
Please return the error returned by request_irq.

&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       /* Open common can device */
</I>&gt;<i> +       err = open_candev(ndev);
</I>&gt;<i> +       if (err) {
</I>&gt;<i> +               dev_err(ndev-&gt;dev.parent, &quot;open_candev() failed %08X\n&quot;, err);
</I>
free_irq?

&gt;<i> +               return err;
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       /* Initialize device and start net queue */
</I>&gt;<i> +       spin_lock_init(&amp;priv-&gt;tx_lock);
</I>&gt;<i> +
</I>&gt;<i> +       clk_enable(priv-&gt;clk);
</I>&gt;<i> +       ti_hecc_start(ndev);
</I>&gt;<i> +       napi_enable(&amp;priv-&gt;napi);
</I>&gt;<i> +       netif_start_queue(ndev);
</I>&gt;<i> +
</I>&gt;<i> +       return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_close(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +       struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +       dev_info(ndev-&gt;dev.parent, &quot;closing device\n&quot;);
</I>&gt;<i> +       napi_disable(&amp;priv-&gt;napi);
</I>&gt;<i> +       netif_stop_queue(ndev);
</I>&gt;<i> +       ti_hecc_stop(ndev);
</I>&gt;<i> +       free_irq(ndev-&gt;irq, ndev);
</I>&gt;<i> +       clk_disable(priv-&gt;clk);
</I>&gt;<i> +       close_candev(ndev);
</I>&gt;<i> +
</I>&gt;<i> +       return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static const struct net_device_ops ti_hecc_netdev_ops = {
</I>&gt;<i> +       .ndo_open               = ti_hecc_open,
</I>&gt;<i> +       .ndo_stop               = ti_hecc_close,
</I>&gt;<i> +       .ndo_start_xmit         = ti_hecc_xmit,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int ti_hecc_probe(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +       struct net_device *ndev = (struct net_device *)0;
</I>&gt;<i> +       struct ti_hecc_priv *priv;
</I>&gt;<i> +       struct ti_hecc_platform_data *pdata;
</I>&gt;<i> +       struct resource *mem, *irq;
</I>&gt;<i> +       void __iomem *addr;
</I>&gt;<i> +       int err;
</I>&gt;<i> +
</I>&gt;<i> +       printk(KERN_INFO DRV_NAME &quot; probing devices...\n&quot;);
</I>&gt;<i> +       pdata = pdev-&gt;dev.platform_data;
</I>&gt;<i> +       if (!pdata) {
</I>&gt;<i> +               printk(KERN_ERR &quot;No platform data available - exiting\n&quot;);
</I>
dev_err here and below.is more appropriate.

&gt;<i> +               return -ENODEV;
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;<i> +       if (!mem) {
</I>&gt;<i> +               printk(KERN_ERR &quot;no mem resource?\n&quot;);
</I>&gt;<i> +               err = -ENODEV;
</I>&gt;<i> +               goto probe_exit;
</I>&gt;<i> +       }
</I>&gt;<i> +       irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
</I>&gt;<i> +       if (!irq) {
</I>&gt;<i> +               printk(KERN_ERR &quot;no irq resource?\n&quot;);
</I>&gt;<i> +               err = -ENODEV;
</I>&gt;<i> +               goto probe_exit;
</I>&gt;<i> +       }
</I>&gt;<i> +       if (!request_mem_region(mem-&gt;start, (mem-&gt;end - mem-&gt;start) + 1,
</I>&gt;<i> +               pdev-&gt;name)) {
</I>&gt;<i> +               printk(KERN_ERR &quot;HECC region already claimed\n&quot;);
</I>&gt;<i> +               err = -EBUSY;
</I>&gt;<i> +               goto probe_exit;
</I>&gt;<i> +       }
</I>&gt;<i> +       addr = ioremap(mem-&gt;start, mem-&gt;end - mem-&gt;start + 1);
</I>&gt;<i> +       if (!addr) {
</I>&gt;<i> +               printk(KERN_ERR &quot;ioremap failed\n&quot;);
</I>&gt;<i> +               err = -ENOMEM;
</I>&gt;<i> +               goto probe_exit_free_region;
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       ndev = alloc_candev(sizeof(struct ti_hecc_priv));
</I>&gt;<i> +       if (!ndev) {
</I>&gt;<i> +               printk(KERN_ERR &quot;alloc_candev failed\n&quot;);
</I>&gt;<i> +               err = -ENOMEM;
</I>&gt;<i> +               goto probe_exit_iounmap;
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       priv = netdev_priv(ndev);
</I>&gt;<i> +       priv-&gt;ndev = ndev;
</I>&gt;<i> +       priv-&gt;base = addr;
</I>&gt;<i> +       priv-&gt;scc_ram_offset = pdata-&gt;scc_ram_offset;
</I>&gt;<i> +       priv-&gt;hecc_ram_offset = pdata-&gt;hecc_ram_offset;
</I>&gt;<i> +       priv-&gt;mbox_offset = pdata-&gt;mbox_offset;
</I>&gt;<i> +       priv-&gt;int_line = pdata-&gt;int_line;
</I>&gt;<i> +
</I>&gt;<i> +       priv-&gt;can.bittiming_const       = &amp;ti_hecc_bittiming_const;
</I>&gt;<i> +       priv-&gt;can.do_set_bittiming      = ti_hecc_set_bittiming;
</I>&gt;<i> +       priv-&gt;can.do_set_mode           = ti_hecc_do_set_mode;
</I>&gt;<i> +       priv-&gt;can.do_get_state          = ti_hecc_get_state;
</I>
Coding style!?

&gt;<i> +       ndev-&gt;irq = irq-&gt;start;
</I>&gt;<i> +       ndev-&gt;flags |= IFF_ECHO;
</I>&gt;<i> +       platform_set_drvdata(pdev, ndev);
</I>&gt;<i> +       SET_NETDEV_DEV(ndev, &amp;pdev-&gt;dev);
</I>&gt;<i> +       ndev-&gt;netdev_ops = &amp;ti_hecc_netdev_ops;
</I>&gt;<i> +
</I>&gt;<i> +       /* Note: clk name would change using hecc_vbusp_ck temporarily */
</I>&gt;<i> +       priv-&gt;clk = clk_get(&amp;pdev-&gt;dev, &quot;hecc_vbusp_ck&quot;);
</I>&gt;<i> +       if (IS_ERR(priv-&gt;clk)) {
</I>&gt;<i> +               dev_err(ndev-&gt;dev.parent, &quot;no clock available\n&quot;);
</I>&gt;<i> +               err = PTR_ERR(priv-&gt;clk);
</I>&gt;<i> +               priv-&gt;clk = NULL;
</I>&gt;<i> +               goto probe_exit_candev;
</I>&gt;<i> +       }
</I>&gt;<i> +       priv-&gt;can.clock.freq = clk_get_rate(priv-&gt;clk);
</I>&gt;<i> +       netif_napi_add(ndev, &amp;priv-&gt;napi, ti_hecc_rx_poll,
</I>&gt;<i> +                       TI_HECC_DEF_NAPI_WEIGHT);
</I>&gt;<i> +
</I>&gt;<i> +       err = register_candev(ndev);
</I>&gt;<i> +       if (err) {
</I>&gt;<i> +               dev_err(ndev-&gt;dev.parent, &quot;register_candev() failed\n&quot;);
</I>&gt;<i> +               err = -ENODEV;
</I>&gt;<i> +               goto probe_exit_clk;
</I>&gt;<i> +       }
</I>&gt;<i> +       dev_info(ndev-&gt;dev.parent, &quot;regs=%p, irq=%d\n&quot;,
</I>&gt;<i> +               priv-&gt;base, (unsigned int) ndev-&gt;irq);
</I>
Please use a more meaningful message, e.g.:

	dev_info(&amp;pdev-&gt;dev,
	         &quot;device registered (reg_base=%#p, irq=%d)\n&quot;,
		 priv-&gt;reg_base, dev-&gt;irq);


&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_DEBUG_FS
</I>&gt;<i> +       hecc_debug_init(priv);
</I>&gt;<i> +#endif
</I>&gt;<i> +       return 0;
</I>&gt;<i> +
</I>&gt;<i> +probe_exit_clk:
</I>&gt;<i> +       clk_put(priv-&gt;clk);
</I>&gt;<i> +probe_exit_candev:
</I>&gt;<i> +       free_candev(ndev);
</I>&gt;<i> +probe_exit_iounmap:
</I>&gt;<i> +       iounmap(addr);
</I>&gt;<i> +probe_exit_free_region:
</I>&gt;<i> +       release_mem_region(mem-&gt;start, mem-&gt;end - mem-&gt;start + 1);
</I>&gt;<i> +probe_exit:
</I>&gt;<i> +       dev_err(ndev-&gt;dev.parent, &quot;probe error = %08X\n&quot;, err);
</I>&gt;<i> +       return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int __devexit ti_hecc_remove(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +       struct resource *res;
</I>&gt;<i> +       struct net_device *ndev = platform_get_drvdata(pdev);
</I>&gt;<i> +       struct ti_hecc_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_DEBUG_FS
</I>&gt;<i> +       hecc_debug_exit();
</I>&gt;<i> +#endif /* CONFIG_DEBUG_FS */
</I>&gt;<i> +
</I>&gt;<i> +       clk_put(priv-&gt;clk);
</I>&gt;<i> +       res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;<i> +       iounmap(priv-&gt;base);
</I>&gt;<i> +       release_mem_region(res-&gt;start, res-&gt;end - res-&gt;start + 1);
</I>&gt;<i> +       unregister_candev(ndev);
</I>&gt;<i> +       free_candev(ndev);
</I>&gt;<i> +       platform_set_drvdata(pdev, NULL);
</I>&gt;<i> +       dev_info(ndev-&gt;dev.parent, &quot;driver removed\n&quot;);
</I>&gt;<i> +
</I>&gt;<i> +       return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/* TI HECC netdevice driver: platform driver structure */
</I>&gt;<i> +static struct platform_driver ti_hecc_driver = {
</I>&gt;<i> +       .driver = {
</I>&gt;<i> +               .name    = &quot;ti_hecc&quot;,
</I>
Maybe:
                  .name    = DRV_NAME,


&gt;<i> +               .owner   = THIS_MODULE,
</I>&gt;<i> +       },
</I>&gt;<i> +       .probe = ti_hecc_probe,
</I>&gt;<i> +       .remove = __devexit_p(ti_hecc_remove),
</I>&gt;<i> +       .suspend = ti_hecc_suspend,
</I>&gt;<i> +       .resume = ti_hecc_resume,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int __init ti_hecc_init_driver(void)
</I>&gt;<i> +{
</I>&gt;<i> +       printk(KERN_INFO DRV_DESC &quot;\n&quot;);
</I>&gt;<i> +       return platform_driver_register(&amp;ti_hecc_driver);
</I>&gt;<i> +}
</I>&gt;<i> +module_init(ti_hecc_init_driver);
</I>&gt;<i> +
</I>&gt;<i> +static void __exit ti_hecc_exit_driver(void)
</I>&gt;<i> +{
</I>&gt;<i> +       printk(KERN_INFO DRV_DESC &quot; :Exit\n&quot;);
</I>&gt;<i> +       platform_driver_unregister(&amp;ti_hecc_driver);
</I>&gt;<i> +}
</I>&gt;<i> +module_exit(ti_hecc_exit_driver);
</I>&gt;<i> +
</I>&gt;<i> +MODULE_AUTHOR(&quot;Anant Gole &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">anantgole at ti.com</A>&gt;&quot;);
</I>&gt;<i> +MODULE_LICENSE(&quot;GPL v2&quot;);
</I>&gt;<i> +MODULE_DESCRIPTION(DRV_DESC);
</I>&gt;<i> diff --git a/include/linux/can/platform/ti_hecc_platform.h b/include/linux/can/platform/ti_hecc_platform.h
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..4a57daf
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/include/linux/can/platform/ti_hecc_platform.h
</I>&gt;<i> @@ -0,0 +1,40 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * TI HECC (High End CAN Controller) driver platform header
</I>&gt;<i> + *
</I>&gt;<i> + * Copyright (C) 2009 Texas Instruments Incorporated - <A HREF="http://www.ti.com/">http://www.ti.com/</A>
</I>&gt;<i> + *
</I>&gt;<i> + * This program is free software; you can redistribute it and/or
</I>&gt;<i> + * modify it under the terms of the GNU General Public License as
</I>&gt;<i> + * published by the Free Software Foundation version 2.
</I>&gt;<i> + *
</I>&gt;<i> + * This program is distributed as is WITHOUT ANY WARRANTY of any
</I>&gt;<i> + * kind, whether express or implied; without even the implied warranty
</I>&gt;<i> + * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</I>&gt;<i> + * GNU General Public License for more details.
</I>&gt;<i> + *
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * struct hecc_platform_data - HECC Platform Data
</I>&gt;<i> + *
</I>&gt;<i> + * @scc_hecc_offset:   mostly 0 - should really never change
</I>&gt;<i> + * @scc_ram_offset:    SCC RAM offset
</I>&gt;<i> + * @hecc_ram_offset:   HECC RAM offset
</I>&gt;<i> + * @mbox_offset:       Mailbox RAM offset
</I>&gt;<i> + * @int_line:          Interrupt line to use - 0 or 1
</I>&gt;<i> + * @version:           version for future use
</I>&gt;<i> + *
</I>&gt;<i> + * Platform data structure to get all platform specific settings.
</I>&gt;<i> + * this structure also accounts the fact that the IP may have different
</I>&gt;<i> + * RAM and mailbox offsets for different SOC's
</I>&gt;<i> + */
</I>&gt;<i> +struct ti_hecc_platform_data {
</I>&gt;<i> +       unsigned int scc_hecc_offset;
</I>&gt;<i> +       unsigned int scc_ram_offset;
</I>&gt;<i> +       unsigned int hecc_ram_offset;
</I>&gt;<i> +       unsigned int mbox_offset;
</I>&gt;<i> +       unsigned int int_line;
</I>&gt;<i> +       unsigned int version;
</I>&gt;<i> +};
</I>
Thanks for your contribution.

Wolfgang.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002937.html">[PATCH] net-next:can: add TI CAN (HECC) driver
</A></li>
	<LI>Next message: <A HREF="002938.html">[PATCH] net-next:can: add TI CAN (HECC) driver
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2945">[ date ]</a>
              <a href="thread.html#2945">[ thread ]</a>
              <a href="subject.html#2945">[ subject ]</a>
              <a href="author.html#2945">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
