<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [3/3] softing CANcard
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2008-June/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5B3/3%5D%20softing%20CANcard&In-Reply-To=%3C20080623185442.GA30550%40uranus.ravnborg.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001582.html">
   <LINK REL="Next"  HREF="001622.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[3/3] softing CANcard</H1>
    <B>Sam Ravnborg</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5B3/3%5D%20softing%20CANcard&In-Reply-To=%3C20080623185442.GA30550%40uranus.ravnborg.org%3E"
       TITLE="[3/3] softing CANcard">sam at ravnborg.org
       </A><BR>
    <I>Mon Jun 23 20:54:42 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001582.html">[3/3] softing CANcard
</A></li>
        <LI>Next message: <A HREF="001622.html">[3/3] softing CANcard
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1594">[ date ]</a>
              <a href="thread.html#1594">[ thread ]</a>
              <a href="subject.html#1594">[ subject ]</a>
              <a href="author.html#1594">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Kurt.
A few trivial comments.

&gt;<i> ===================================================================
</I>&gt;<i> --- kernel/2.6/drivers/net/can/softing/softing_cs.c	(revision 0)
</I>&gt;<i> +++ kernel/2.6/drivers/net/can/softing/softing_cs.c	(revision 0)
</I>&gt;<i> @@ -0,0 +1,576 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * softing_cs.c -  Softing Gmbh pcmcia driver module for socketCAN
</I>&gt;<i> + *
</I>&gt;<i> + * Copyright (c) 2008, Kurt Van Dijck, EIA Electronics, &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kurt.van.dijck at eia.be</A>&gt;
</I>
Copyright is fine, but
&gt;<i> + *
</I>&gt;<i> + * Based on original, non-'socketcan', driver from Softing Gmbh
</I>&gt;<i> + * Based on other linux XXX_cs.c files.
</I>&gt;<i> + *
</I>&gt;<i> + * Redistribution and use in source and binary forms, with or without
</I>&gt;<i> + * modification, are permitted provided that the following conditions
</I>&gt;<i> + * are met:
</I>&gt;<i> + * 1. Redistributions of source code must retain the above copyright
</I>&gt;<i> + *	   notice, this list of conditions and the following disclaimer.
</I>&gt;<i> + * 2. Redistributions in binary form must reproduce the above copyright
</I>&gt;<i> + *	   notice, this list of conditions and the following disclaimer in the
</I>&gt;<i> + *	   documentation and/or other materials provided with the distribution.
</I>&gt;<i> + * 3. Neither the name of EIA ELectronics nor the names of its contributors
</I>&gt;<i> + *	   may be used to endorse or promote products derived from this software
</I>&gt;<i> + *	   without specific prior written permission.
</I>&gt;<i> + *
</I>&gt;<i> + * Alternatively, provided that this notice is retained in full, this
</I>&gt;<i> + * software may be distributed under the terms of the GNU General
</I>&gt;<i> + * Public License (&quot;GPL&quot;) version 2, in which case the provisions of the
</I>&gt;<i> + * GPL apply INSTEAD OF those given above.
</I>&gt;<i> + *
</I>&gt;<i> + * The provided data structures and external interfaces from this code
</I>&gt;<i> + * are not restricted to be used by modules with a GPL compatible license.
</I>&gt;<i> + *
</I>&gt;<i> + * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
</I>&gt;<i> + * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
</I>&gt;<i> + * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</I>&gt;<i> + * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
</I>&gt;<i> + * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</I>&gt;<i> + * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
</I>&gt;<i> + * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
</I>&gt;<i> + * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
</I>&gt;<i> + * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</I>&gt;<i> + * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</I>&gt;<i> + * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
</I>&gt;<i> + * DAMAGE.
</I>&gt;<i> + *
</I>License is not good. We have plenty of files in the kernel
and they do not need the license all of them.

&gt;<i> + * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">socketcan-users at lists.berlios.de</A>&gt;
</I>
This ought to be in MAINTAINERS - but I see why you have it here.
But think about the day the list moves to vger...

&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/module.h&gt;
</I>&gt;<i> +#include &lt;linux/moduleparam.h&gt;
</I>&gt;<i> +#include &lt;linux/kernel.h&gt;
</I>&gt;<i> +#include &lt;linux/init.h&gt;
</I>&gt;<i> +#include &lt;linux/sched.h&gt;
</I>&gt;<i> +#include &lt;linux/ptrace.h&gt;
</I>&gt;<i> +#include &lt;linux/slab.h&gt;
</I>&gt;<i> +#include &lt;linux/string.h&gt;
</I>&gt;<i> +#include &lt;linux/timer.h&gt;
</I>&gt;<i> +#include &lt;linux/major.h&gt;
</I>&gt;<i> +#include &lt;asm/io.h&gt;
</I>&gt;<i> +#include &lt;asm/system.h&gt;
</I>
asm includes after pcmia includes.
&gt;<i> +
</I>&gt;<i> +#include &lt;pcmcia/cs_types.h&gt;
</I>&gt;<i> +#include &lt;pcmcia/cs.h&gt;
</I>&gt;<i> +#include &lt;pcmcia/cistpl.h&gt;
</I>&gt;<i> +#include &lt;pcmcia/ciscode.h&gt;
</I>&gt;<i> +#include &lt;pcmcia/ds.h&gt;
</I>&gt;<i> +#include &lt;pcmcia/cisreg.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#include &quot;softing.h&quot;
</I>

&gt;<i> +
</I>&gt;<i> +static __attribute__((unused))
</I>&gt;<i> +	const char *lookup_i2a(const struct lookup *lp, int i)
</I>&gt;<i> +{
</I>&gt;<i> +	for (; lp-&gt;a; ++lp) {
</I>&gt;<i> +		if (lp-&gt;i == i)
</I>&gt;<i> +			return lp-&gt;a;
</I>&gt;<i> +	}
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>
It is unused - so drop it.

&gt;<i> +
</I>&gt;<i> +static __attribute__((unused))
</I>&gt;<i> +	const char *lookup_mask(const struct lookup *lp, int *i)
</I>&gt;<i> +{
</I>&gt;<i> +	for (; lp-&gt;a; ++lp) {
</I>&gt;<i> +		if (lp-&gt;i &amp; *i) {
</I>&gt;<i> +			*i &amp;= ~lp-&gt;i;
</I>&gt;<i> +			return lp-&gt;a;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>Used three times - so drop the attribute.

&gt;<i> +
</I>&gt;<i> +static int card_reset_via_pcmcia(struct softing *sdev, int v)
</I>&gt;<i> +{
</I>&gt;<i> +	struct pcmcia_device *pcmcia = to_pcmcia_dev(sdev-&gt;dev);
</I>&gt;<i> +	conf_reg_t reg;
</I>&gt;<i> +	reg.Function = 0; /* socket */
</I>&gt;<i> +	reg.Action	 = CS_WRITE;
</I>&gt;<i> +	reg.Offset	 = 2;
</I>&gt;<i> +	reg.Value	 = v ? 0 : 0x20;
</I>&gt;<i> +	return pcmcia_access_configuration_register(pcmcia, &amp;reg);
</I>&gt;<i> +}
</I>Only used from the probe function - annotate __devinit?

&gt;<i> +
</I>&gt;<i> +static int card_reset_via_dpram(struct softing *sdev, int v)
</I>&gt;<i> +{
</I>&gt;<i> +	if (v) {
</I>&gt;<i> +		spin_lock_bh(&amp;sdev-&gt;spin);
</I>&gt;<i> +		sdev-&gt;dpram.virt[0xe00] &amp;= ~1;
</I>&gt;<i> +		spin_unlock_bh(&amp;sdev-&gt;spin);
</I>&gt;<i> +		card_reset_via_pcmcia(sdev, v);
</I>&gt;<i> +	} else {
</I>&gt;<i> +		card_reset_via_pcmcia(sdev, v);
</I>&gt;<i> +		spin_lock_bh(&amp;sdev-&gt;spin);
</I>&gt;<i> +		sdev-&gt;dpram.virt[0xe00] |=  1;
</I>&gt;<i> +		spin_unlock_bh(&amp;sdev-&gt;spin);
</I>&gt;<i> +	}
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>Only used from the probe function - annotate __devinit?

&gt;<i> +static int card_enable_irq_via_pcmcia(struct softing *sdev, int v)
</I>&gt;<i> +{
</I>&gt;<i> +	int r;
</I>&gt;<i> +	struct pcmcia_device *pcmcia = to_pcmcia_dev(sdev-&gt;dev);
</I>&gt;<i> +	conf_reg_t reg;
</I>&gt;<i> +	memset(&amp;reg, 0, sizeof(reg));
</I>&gt;<i> +	reg.Function = 0; /* socket */
</I>&gt;<i> +	reg.Action	 = CS_WRITE;
</I>&gt;<i> +	reg.Offset	 = 0;
</I>&gt;<i> +	reg.Value	 = v ? 0x60 : 0;
</I>&gt;<i> +	r = pcmcia_access_configuration_register(pcmcia, &amp;reg);
</I>&gt;<i> +	if (0 != r)
</I>&gt;<i> +		mod_alert(&quot;failed %u&quot;, r);
</I>&gt;<i> +	return r;
</I>&gt;<i> +}
</I>Only used from the probe function - annotate __devinit?

&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static const struct lookup pcmcia_io_attr [] = {
</I>&gt;<i> +   { IO_DATA_PATH_WIDTH_AUTO, &quot;[auto]&quot;   , },
</I>&gt;<i> +   { IO_DATA_PATH_WIDTH_8   , &quot;8bit&quot;      , },
</I>&gt;<i> +   { IO_DATA_PATH_WIDTH_16  , &quot;16bit&quot;   , },
</I>&gt;<i> +   { 0, 0, },
</I>&gt;<i> +};
</I>Only used from the probe function - annotate __devinitconst?
Loose the space before []?

&gt;<i> +
</I>&gt;<i> +static const struct lookup pcmcia_mem_attr [] = {
</I>&gt;<i> +   { WIN_ADDR_SPACE_IO      , &quot;IO&quot;      , },
</I>&gt;<i> +   { WIN_MEMORY_TYPE_AM     , &quot;typeAM&quot;   , },
</I>&gt;<i> +   { WIN_ENABLE             , &quot;enable&quot;   , },
</I>&gt;<i> +   { WIN_DATA_WIDTH_8       , &quot;8bit&quot;      , },
</I>&gt;<i> +   { WIN_DATA_WIDTH_16      , &quot;16bit&quot;   , },
</I>&gt;<i> +   { WIN_DATA_WIDTH_32      , &quot;32bit&quot;   , },
</I>&gt;<i> +   { WIN_PAGED              , &quot;paged&quot;   , },
</I>&gt;<i> +   { WIN_SHARED             , &quot;shared&quot;   , },
</I>&gt;<i> +   { WIN_FIRST_SHARED       , &quot;first_shared&quot;, },
</I>&gt;<i> +   { WIN_USE_WAIT           , &quot;wait&quot;      , },
</I>&gt;<i> +   { WIN_STRICT_ALIGN       , &quot;strict_align&quot;, },
</I>&gt;<i> +   { WIN_MAP_BELOW_1MB      , &quot;below_1MB&quot;   , },
</I>&gt;<i> +   { WIN_PREFETCH           , &quot;prefetch&quot;, },
</I>&gt;<i> +   { WIN_CACHEABLE          , &quot;cacheable&quot;, },
</I>&gt;<i> +	{ 0, 0, },
</I>&gt;<i> +};
</I>Only used from the probe function - annotate __devinitconst?
Loose the space before []?

&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +#define CS_CHECK(fn, ret) \
</I>&gt;<i> +	if (0 != ret) goto cs_failed;
</I>&gt;<i> +/*	do { \
</I>&gt;<i> +		last_fn = (fn); \
</I>&gt;<i> +		if ((last_ret = (ret)) != 0) \
</I>&gt;<i> +			goto cs_failed;
</I>&gt;<i> +	} while (0) */
</I>
This macro (even with commented code removed) are just too
ugly to survive. Please open code the test and the goto.

&gt;<i> +static int dev_config(struct pcmcia_device *pcmcia, struct softing_cs *csdev)
</I>Only used by the probe function - annotate __devinit?

&gt;<i> +{
</I>&gt;<i> +	struct softing *sdev = &amp;csdev-&gt;softing;
</I>&gt;<i> +	cistpl_cftable_entry_t *cf;
</I>&gt;<i> +	int r;
</I>&gt;<i> +	int last_ret = 0;
</I>&gt;<i> +	int last_fn  = 0;
</I>&gt;<i> +	struct {
</I>&gt;<i> +		tuple_t tuple;
</I>&gt;<i> +		unsigned char buff [64];
</I>&gt;<i> +		cisparse_t parse;
</I>&gt;<i> +	} cfg;
</I>Loose space before [64].

&gt;<i> +	config_info_t config;
</I>&gt;<i> +	cistpl_cftable_entry_t def_cf = { 0, };
</I>C99 init notation?


&gt;<i> +	win_req_t req;
</I>&gt;<i> +	memreq_t map;
</I>&gt;<i> +
</I>&gt;<i> +	mod_info(&quot;%s&quot;, pcmcia-&gt;devname);
</I>&gt;<i> +
</I>&gt;<i> +	cfg.tuple.Attributes		= 0;
</I>&gt;<i> +	cfg.tuple.TupleData		= (cisdata_t *)cfg.buff;
</I>&gt;<i> +	cfg.tuple.TupleDataMax	= sizeof(cfg.buff);
</I>&gt;<i> +	cfg.tuple.TupleOffset	= 0;
</I>&gt;<i> +	/* Get configuration register information */
</I>&gt;<i> +	cfg.tuple.DesiredTuple	= CISTPL_CONFIG;
</I>&gt;<i> +	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(pcmcia, &amp;cfg.tuple));
</I>&gt;<i> +	CS_CHECK(GetTupleData, pcmcia_get_tuple_data(pcmcia, &amp;cfg.tuple));
</I>&gt;<i> +	CS_CHECK(ParseTuple
</I>&gt;<i> +			, pcmcia_parse_tuple(pcmcia, &amp;cfg.tuple, &amp;cfg.parse));
</I>&gt;<i> +	csdev-&gt;conf.ConfigBase = cfg.parse.config.base;
</I>&gt;<i> +	csdev-&gt;conf.Present	  = cfg.parse.config.rmask[0];
</I>&gt;<i> +
</I>&gt;<i> +	/* get current Vcc */
</I>&gt;<i> +	r = pcmcia_get_configuration_info(pcmcia, &amp;config);
</I>&gt;<i> +	if (CS_SUCCESS != r)
</I>&gt;<i> +		return EINVAL;
</I>&gt;<i> +
</I>&gt;<i> +	cf = &amp;cfg.parse.cftable_entry;
</I>&gt;<i> +	cfg.tuple.DesiredTuple	= CISTPL_CFTABLE_ENTRY;
</I>&gt;<i> +
</I>&gt;<i> +	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(pcmcia, &amp;cfg.tuple));
</I>&gt;<i> +	do {
</I>&gt;<i> +		if (pcmcia_get_tuple_data(pcmcia, &amp;cfg.tuple)
</I>&gt;<i> +			|| pcmcia_parse_tuple(pcmcia, &amp;cfg.tuple, &amp;cfg.parse))
</I>&gt;<i> +			goto do_next;
</I>&gt;<i> +		if (cf-&gt;flags &amp; CISTPL_CFTABLE_DEFAULT)
</I>&gt;<i> +			def_cf = *cf;
</I>&gt;<i> +		if (0 == cf-&gt;index)
</I>&gt;<i> +			goto do_next;
</I>&gt;<i> +		csdev-&gt;conf.ConfigIndex = cf-&gt;index;
</I>&gt;<i> +		/* power settings (Vcc &amp; Vpp) */
</I>&gt;<i> +		#if HANDLE_VCC
</I>
Where does HANDLE_VCC come from?
Either it is a CONFIG_* definition or it shall go.


&gt;<i> +		if (cf-&gt;vcc.present &amp; (1 &lt;&lt; CISTPL_POWER_VNOM)) {
</I>&gt;<i> +			if (config.Vcc !=
</I>&gt;<i> +				cf-&gt;vcc.param[CISTPL_POWER_VNOM]/10000) {
</I>&gt;<i> +				mod_alert(&quot;%s: cf-&gt;Vcc mismatch\n&quot;, __FILE__);
</I>&gt;<i> +				goto do_next;
</I>&gt;<i> +			}
</I>&gt;<i> +		} else if (def_cf.vcc.present &amp; (1 &lt;&lt; CISTPL_POWER_VNOM)) {
</I>&gt;<i> +			if (config.Vcc !=
</I>&gt;<i> +				def_cf.vcc.param[CISTPL_POWER_VNOM]/10000) {
</I>&gt;<i> +				mod_alert(&quot;%s: cf-&gt;Vcc mismatch\n&quot;, __FILE__);
</I>&gt;<i> +				goto do_next;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +		if (cf-&gt;vpp1.present &amp; (1 &lt;&lt; CISTPL_POWER_VNOM))
</I>&gt;<i> +			config.Vpp1
</I>&gt;<i> +				= config.Vpp2
</I>&gt;<i> +				= cf-&gt;vpp1.param[CISTPL_POWER_VNOM] / 10000;
</I>&gt;<i> +
</I>&gt;<i> +		else if (def_cf.vpp1.present &amp; (1 &lt;&lt; CISTPL_POWER_VNOM))
</I>&gt;<i> +			config.Vpp1
</I>&gt;<i> +				= config.Vpp2
</I>&gt;<i> +				= def_cf.vpp1.param[CISTPL_POWER_VNOM] / 10000;
</I>&gt;<i> +		#endif
</I>&gt;<i> +
</I>&gt;<i> +		/* interrupt ? */
</I>&gt;<i> +		if (cf-&gt;irq.IRQInfo1 || def_cf.irq.IRQInfo1)
</I>&gt;<i> +			csdev-&gt;conf.Attributes |= CONF_ENABLE_IRQ;
</I>&gt;<i> +		/* IO window */
</I>&gt;<i> +		csdev-&gt;io.NumPorts1
</I>&gt;<i> +			= csdev-&gt;io.NumPorts2
</I>&gt;<i> +			= 0;
</I>&gt;<i> +		if ((cf-&gt;io.nwin &gt; 0) || (def_cf.io.nwin &gt; 0)) {
</I>&gt;<i> +			cistpl_io_t *io = (cf-&gt;io.nwin) ? &amp;cf-&gt;io : &amp;def_cf.io;
</I>&gt;<i> +			csdev-&gt;io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
</I>&gt;<i> +			if (!(io-&gt;flags &amp; CISTPL_IO_8BIT))
</I>&gt;<i> +				csdev-&gt;io.Attributes1 = IO_DATA_PATH_WIDTH_16;
</I>&gt;<i> +			if (!(io-&gt;flags &amp; CISTPL_IO_16BIT))
</I>&gt;<i> +				csdev-&gt;io.Attributes1 = IO_DATA_PATH_WIDTH_8;
</I>&gt;<i> +			csdev-&gt;io.IOAddrLines
</I>&gt;<i> +				= io-&gt;flags &amp; CISTPL_IO_LINES_MASK;
</I>&gt;<i> +			csdev-&gt;io.BasePort1 = io-&gt;win[0].base;
</I>&gt;<i> +			csdev-&gt;io.NumPorts1 = io-&gt;win[0].len ;
</I>&gt;<i> +			if (io-&gt;nwin &gt; 1) {
</I>&gt;<i> +				csdev-&gt;io.Attributes2 = csdev-&gt;io.Attributes1;
</I>&gt;<i> +				csdev-&gt;io.BasePort2	 = io-&gt;win[1].base;
</I>&gt;<i> +				csdev-&gt;io.NumPorts2	 = io-&gt;win[1].base;
</I>&gt;<i> +			}
</I>&gt;<i> +			/* reserve IO, but don't enable it. */
</I>&gt;<i> +			r = pcmcia_request_io(pcmcia, &amp;csdev-&gt;io);
</I>&gt;<i> +			if (CS_SUCCESS != r) {
</I>&gt;<i> +				mod_alert(&quot;pcmcia_request_io() mismatch\n&quot;);
</I>&gt;<i> +				goto do_next;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +		/* Memory window */
</I>&gt;<i> +		if ((cf-&gt;mem.nwin &gt; 0) || (def_cf.mem.nwin &gt; 0)) {
</I>&gt;<i> +			cistpl_mem_t *mem
</I>&gt;<i> +				= (cf-&gt;mem.nwin) ? &amp;cf-&gt;mem : &amp;def_cf.mem;
</I>&gt;<i> +			req.Attributes
</I>&gt;<i> +				= (is_16bit(sdev)
</I>&gt;<i> +					? WIN_DATA_WIDTH_16 : WIN_DATA_WIDTH_8)
</I>&gt;<i> +				| WIN_MEMORY_TYPE_CM
</I>&gt;<i> +				| WIN_ENABLE;
</I>&gt;<i> +			req.Base = mem-&gt;win[0].host_addr;
</I>&gt;<i> +			req.Size = mem-&gt;win[0].len;
</I>&gt;<i> +			if (req.Size &lt; 0x1000)
</I>&gt;<i> +				req.Size = 0x1000;
</I>&gt;<i> +			req.AccessSpeed = 0;
</I>&gt;<i> +			r = pcmcia_request_window(&amp;pcmcia, &amp;req, &amp;csdev-&gt;win);
</I>&gt;<i> +			if (CS_SUCCESS != r) {
</I>&gt;<i> +				mod_alert(&quot;pcmcia_request_window() mismatch\n&quot;);
</I>&gt;<i> +				goto do_next;
</I>&gt;<i> +			}
</I>&gt;<i> +			/*if (5 != (sdev-&gt;id.prod &amp; 0x7f)) {
</I>&gt;<i> +				csdev-&gt;win-&gt;ctl.flags
</I>&gt;<i> +					= MAP_ACTIVE | MAP_USE_WAIT;
</I>&gt;<i> +				csdev-&gt;win-&gt;ctl.speed = 3;
</I>&gt;<i> +			}*/
</I>Either the code is valid or it shall be deleted.


&gt;<i> +			map.Page = 0;
</I>&gt;<i> +			map.CardOffset = mem-&gt;win[0].card_addr;
</I>&gt;<i> +			if (0 != pcmcia_map_mem_page(csdev-&gt;win, &amp;map)) {
</I>&gt;<i> +				mod_alert(&quot;pcmcia_map_mem_page() mismatch\n&quot;);
</I>&gt;<i> +				goto do_next_win;
</I>&gt;<i> +			}
</I>&gt;<i> +		} else {
</I>&gt;<i> +			mod_info(&quot;no memory window in tuple %u&quot;, cf-&gt;index);
</I>&gt;<i> +			goto do_next;
</I>&gt;<i> +		}
</I>&gt;<i> +		break;
</I>&gt;<i> +do_next_win:
</I>&gt;<i> +		pcmcia_release_window(csdev-&gt;win);
</I>&gt;<i> +do_next:
</I>&gt;<i> +		pcmcia_disable_device(pcmcia);
</I>&gt;<i> +		CS_CHECK(GetNextTuple,
</I>&gt;<i> +			pcmcia_get_next_tuple(pcmcia, &amp;cfg.tuple));
</I>&gt;<i> +	} while (1);
</I>&gt;<i> +
</I>&gt;<i> +	if (csdev-&gt;conf.Attributes &amp; CONF_ENABLE_IRQ) {
</I>&gt;<i> +		/*csdev-&gt;irq.Handler  = dev_interrupt_nshared;
</I>&gt;<i> +		csdev-&gt;irq.Instance = card;
</I>&gt;<i> +		csdev-&gt;irq.Attributes |= IRQ_HANDLE_PRESENT;
</I>&gt;<i> +		*/
</I>&gt;<i> +		CS_CHECK(RequestIRQ, pcmcia_request_irq(pcmcia, &amp;csdev-&gt;irq));
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	CS_CHECK(RequestConfiguration,
</I>&gt;<i> +			pcmcia_request_configuration(pcmcia, &amp;csdev-&gt;conf));
</I>&gt;<i> +
</I>&gt;<i> +	/* Finally, report what we've done */
</I>&gt;<i> +	printk(KERN_INFO &quot;[%s] %s: index 0x%02x&quot;,
</I>&gt;<i> +			THIS_MODULE-&gt;name,
</I>&gt;<i> +			pcmcia-&gt;devname,
</I>&gt;<i> +			csdev-&gt;conf.ConfigIndex);
</I>&gt;<i> +	#if HANDLE_VCC
</I>&gt;<i> +	printk(&quot;, Vcc %d.%01d&quot;, config.Vcc/10, config.Vcc%10);
</I>&gt;<i> +	if (config.Vpp1)
</I>&gt;<i> +		printk(&quot;, Vpp %d.%d&quot;, config.Vpp1/10, config.Vpp1%10);
</I>&gt;<i> +	#endif
</I>&gt;<i> +	if (csdev-&gt;conf.Attributes &amp; CONF_ENABLE_IRQ) {
</I>&gt;<i> +		printk(&quot;, irq %d&quot;, csdev-&gt;irq.AssignedIRQ);
</I>&gt;<i> +		sdev-&gt;irq.nr = csdev-&gt;irq.AssignedIRQ;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (csdev-&gt;io.NumPorts1) {
</I>&gt;<i> +		int tmp;
</I>&gt;<i> +		const char *p;
</I>&gt;<i> +		printk(&quot;, io 0x%04x-0x%04x&quot;
</I>&gt;<i> +				, pcmcia-&gt;io.BasePort1
</I>&gt;<i> +				, csdev-&gt;io.BasePort1+csdev-&gt;io.NumPorts1-1);
</I>&gt;<i> +		tmp = csdev-&gt;io.Attributes1;
</I>&gt;<i> +		if (0 != tmp) {
</I>&gt;<i> +			do {
</I>&gt;<i> +				p = lookup_mask(pcmcia_io_attr, &amp;tmp);
</I>&gt;<i> +				if (p)
</I>&gt;<i> +					printk(&quot; %s&quot;, p);
</I>&gt;<i> +			} while (p);
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +	if (csdev-&gt;io.NumPorts2) {
</I>&gt;<i> +		int tmp;
</I>&gt;<i> +		const char *p;
</I>&gt;<i> +		printk(&quot; &amp; 0x%04x-0x%04x&quot;
</I>&gt;<i> +			, csdev-&gt;io.BasePort2
</I>&gt;<i> +			, csdev-&gt;io.BasePort2+csdev-&gt;io.NumPorts2-1);
</I>&gt;<i> +		tmp = csdev-&gt;io.Attributes2;
</I>&gt;<i> +		if (0 != tmp)
</I>&gt;<i> +			do {
</I>&gt;<i> +				p = lookup_mask(pcmcia_io_attr, &amp;tmp);
</I>&gt;<i> +				if (p)
</I>&gt;<i> +					printk(&quot; %s&quot;, p);
</I>&gt;<i> +			} while (p);
</I>&gt;<i> +	}
</I>&gt;<i> +	if (csdev-&gt;win) {
</I>&gt;<i> +		int tmp;
</I>&gt;<i> +		const char *p;
</I>&gt;<i> +		sdev-&gt;dpram.phys = req.Base;
</I>&gt;<i> +		sdev-&gt;dpram.size = req.Size;
</I>&gt;<i> +		printk(&quot;, mem 0x%08lx-0x%08lx&quot;
</I>&gt;<i> +				, sdev-&gt;dpram.phys
</I>&gt;<i> +				, sdev-&gt;dpram.phys + sdev-&gt;dpram.size-1);
</I>&gt;<i> +		tmp = req.Attributes;
</I>&gt;<i> +		if (0 != tmp)
</I>&gt;<i> +			do {
</I>&gt;<i> +				p = lookup_mask(pcmcia_mem_attr, &amp;tmp);
</I>&gt;<i> +				if (p)
</I>&gt;<i> +					printk(&quot; %s&quot;, p);
</I>&gt;<i> +			} while (p);
</I>&gt;<i> +	}
</I>&gt;<i> +	printk(&quot;\n&quot;);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +cs_failed:
</I>&gt;<i> +	cs_error(pcmcia, last_fn, last_ret);
</I>&gt;<i> +	pcmcia_release_window(csdev-&gt;win);
</I>&gt;<i> +	pcmcia_disable_device(pcmcia);
</I>&gt;<i> +	/*dev_release(sdev); */
</I>Use or delete..

&gt;<i> +	return EINVAL;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +#if softing_suspend
</I>&gt;<i> +static int driver_suspend(struct pcmcia_device *pcmcia)
</I>&gt;<i> +{
</I>&gt;<i> +	struct softing *card = (struct softing *)pcmcia-&gt;priv;
</I>&gt;<i> +	mod_trace(&quot;%s, device'%s'&quot;, card-&gt;id.name, pcmcia-&gt;devname);
</I>&gt;<i> +	softing_suspend(card);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +#endif
</I>CONFIG_PM_SUSPEND?
&gt;<i> +
</I>&gt;<i> +#if softing_resume
</I>&gt;<i> +static int driver_resume(struct pcmcia_device *pcmcia)
</I>&gt;<i> +{
</I>&gt;<i> +	struct softing *card = (struct softing *)pcmcia-&gt;priv;
</I>&gt;<i> +	mod_trace(&quot;%s, device'%s'&quot;, card-&gt;id.name, pcmcia-&gt;devname);
</I>&gt;<i> +	softing_resume(card);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +#endif
</I>CONFIG_PM_SUSPEND?
&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static void driver_remove(struct pcmcia_device *pcmcia)
</I>&gt;<i> +{
</I>&gt;<i> +	struct softing *card = (struct softing *)pcmcia-&gt;priv;
</I>&gt;<i> +	struct softing_cs *cs = softing2cs(card);
</I>&gt;<i> +	mod_trace(&quot;%s,device'%s'&quot;, card-&gt;id.name, pcmcia-&gt;devname);
</I>&gt;<i> +	/* Ensure any outstanding scheduled tasks are completed.
</I>&gt;<i> +	 * flush_scheduled_work();
</I>&gt;<i> +	 */
</I>&gt;<i> +	rm_softing(card);
</I>&gt;<i> +	/* release pcmcia stuff */
</I>&gt;<i> +	pcmcia_release_window(cs-&gt;win);
</I>&gt;<i> +	pcmcia_disable_device(pcmcia);
</I>&gt;<i> +	/* free bits */
</I>&gt;<i> +	kfree(cs);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int driver_probe(struct pcmcia_device *pcmcia)
</I>Annotate __devinit?

&gt;<i> +{
</I>&gt;<i> +	struct softing_cs *cs;
</I>&gt;<i> +	struct softing		*card;
</I>&gt;<i> +	int r = 0;
</I>&gt;<i> +
</I>&gt;<i> +	mod_trace(&quot;on %s&quot;, pcmcia-&gt;devname);
</I>&gt;<i> +
</I>&gt;<i> +	/* Create new softing device */
</I>&gt;<i> +	cs = kzalloc(sizeof(*cs), GFP_KERNEL);
</I>&gt;<i> +	if (0 == cs) {
</I>&gt;<i> +		r = ENOMEM;
</I>&gt;<i> +		goto no_mem;
</I>&gt;<i> +	}
</I>&gt;<i> +	card = &amp;cs-&gt;softing;
</I>&gt;<i> +	pcmcia-&gt;priv = card;
</I>&gt;<i> +	card-&gt;id.manf = pcmcia-&gt;manf_id;
</I>&gt;<i> +	card-&gt;id.prod = pcmcia-&gt;card_id;
</I>&gt;<i> +	card-&gt;dev = &amp;pcmcia-&gt;dev;
</I>&gt;<i> +	card-&gt;fn.reset
</I>&gt;<i> +		= is_16bit(card)
</I>&gt;<i> +		? card_reset_via_dpram : card_reset_via_pcmcia;
</I>Use if to increase readability.
&gt;<i> +	card-&gt;fn.enable_irq
</I>&gt;<i> +		= is_16bit(card) ? 0 : card_enable_irq_via_pcmcia;
</I>&gt;<i> +	card-&gt;nbus = 2;
</I>Use if to increase readability.
&gt;<i> +	if ((card-&gt;id.prod &amp; 0xf) &gt;= 5)
</I>&gt;<i> +		card-&gt;irq.shared = 1;
</I>I recall I saw this magic &quot;5&quot; before. You should define a propoer constant for it.

&gt;<i> +	/* presets */
</I>&gt;<i> +	cs-&gt;irq.Attributes
</I>&gt;<i> +		= card-&gt;irq.shared
</I>&gt;<i> +		? IRQ_TYPE_DYNAMIC_SHARING : IRQ_TYPE_EXCLUSIVE;
</I>&gt;<i> +	cs-&gt;irq.IRQInfo1	 = IRQ_LEVEL_ID;
</I>&gt;<i> +	cs-&gt;irq.Handler	 = 0;
</I>&gt;<i> +	cs-&gt;conf.Attributes = 0;
</I>&gt;<i> +	cs-&gt;conf.IntType	  = INT_MEMORY_AND_IO;
</I>&gt;<i> +
</I>&gt;<i> +	r = dev_config(pcmcia, cs);
</I>&gt;<i> +	if (0 != r)
</I>&gt;<i> +		goto config_failed;
</I>&gt;<i> +	if (0x1000 != card-&gt;dpram.size) {
</I>&gt;<i> +		mod_alert(&quot;dpram size 0x%lx mismatch\n&quot;, card-&gt;dpram.size);
</I>&gt;<i> +		goto wrong_dpram;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (0 == mk_softing(card))
</I>&gt;<i> +		return 0;
</I>&gt;<i> +	/* else */
</I>&gt;<i> +wrong_dpram:
</I>&gt;<i> +	pcmcia_release_window(cs-&gt;win);
</I>&gt;<i> +config_failed:
</I>&gt;<i> +	kfree(cs);
</I>&gt;<i> +no_mem:
</I>&gt;<i> +	pcmcia_disable_device(pcmcia);
</I>&gt;<i> +	return r ? r : EINVAL;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static struct pcmcia_device_id driver_ids[] = {
</I>&gt;<i> +	/* softing */
</I>&gt;<i> +	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0001),
</I>&gt;<i> +	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0002),
</I>&gt;<i> +	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0004),
</I>&gt;<i> +	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0005),
</I>&gt;<i> +	/* vector , manufacturer? */
</I>&gt;<i> +	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0081),
</I>&gt;<i> +	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0084),
</I>&gt;<i> +	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0085),
</I>&gt;<i> +	/* EDIC */
</I>&gt;<i> +	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0102),
</I>&gt;<i> +	PCMCIA_DEVICE_MANF_CARD(0x0168, 0x0105),
</I>&gt;<i> +	PCMCIA_DEVICE_NULL,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +MODULE_DEVICE_TABLE(pcmcia, driver_ids);
</I>&gt;<i> +
</I>&gt;<i> +static struct pcmcia_driver softing_cs_driver = {
</I>&gt;<i> +	.owner		= THIS_MODULE,
</I>&gt;<i> +	.drv			= {
</I>&gt;<i> +		.name		= &quot;softing_cs&quot;,
</I>&gt;<i> +	},
</I>&gt;<i> +	.probe		= driver_probe,
</I>&gt;<i> +	.remove		= driver_remove,
</I>&gt;<i> +	.id_table	= driver_ids,
</I>&gt;<i> +	#if softing_suspend &amp;&amp; softing_resume
</I>&gt;<i> +	.suspend		= driver_suspend,
</I>&gt;<i> +	.resume		= driver_resume,
</I>&gt;<i> +	#endif
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static int __init mod_start(void)
</I>&gt;<i> +{
</I>&gt;<i> +	int r;
</I>&gt;<i> +	mod_trace(&quot;&quot;);
</I>&gt;<i> +	r = pcmcia_register_driver(&amp;softing_cs_driver);
</I>&gt;<i> +	return r;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void __exit mod_stop(void)
</I>&gt;<i> +{
</I>&gt;<i> +	mod_trace(&quot;&quot;);
</I>&gt;<i> +	pcmcia_unregister_driver(&amp;softing_cs_driver);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +module_init(mod_start);
</I>&gt;<i> +module_exit(mod_stop);
</I>&gt;<i> +
</I>&gt;<i> +MODULE_DESCRIPTION(&quot;softing CANcard driver&quot;
</I>&gt;<i> +		&quot;, links PCMCIA card to softing driver&quot;);
</I>&gt;<i> +MODULE_LICENSE(&quot;GPL&quot;);
</I>&gt;<i> +MODULE_SUPPORTED_DEVICE(&quot;softing CANcard2&quot;);
</I>

	Sam

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001582.html">[3/3] softing CANcard
</A></li>
	<LI>Next message: <A HREF="001622.html">[3/3] softing CANcard
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1594">[ date ]</a>
              <a href="thread.html#1594">[ thread ]</a>
              <a href="subject.html#1594">[ subject ]</a>
              <a href="author.html#1594">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
