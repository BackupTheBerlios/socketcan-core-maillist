<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH net-next-2.6 v2] can: Topcliff: PCH_CAN driver: Fix build	warnings
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2010-November/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20net-next-2.6%20v2%5D%20can%3A%20Topcliff%3A%20PCH_CAN%20driver%3A%20Fix%20build%0A%09warnings&In-Reply-To=%3C4CCFEFE9.1020806%40pengutronix.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004910.html">
   <LINK REL="Next"  HREF="004947.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH net-next-2.6 v2] can: Topcliff: PCH_CAN driver: Fix build	warnings</H1>
    <B>Marc Kleine-Budde</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20net-next-2.6%20v2%5D%20can%3A%20Topcliff%3A%20PCH_CAN%20driver%3A%20Fix%20build%0A%09warnings&In-Reply-To=%3C4CCFEFE9.1020806%40pengutronix.de%3E"
       TITLE="[PATCH net-next-2.6 v2] can: Topcliff: PCH_CAN driver: Fix build	warnings">mkl at pengutronix.de
       </A><BR>
    <I>Tue Nov  2 12:03:05 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="004910.html">[PATCH net-next-2.6 v2] can: Topcliff: PCH_CAN driver: Fix build	warnings
</A></li>
        <LI>Next message: <A HREF="004947.html">[PATCH net-next-2.6 v2] can: Topcliff: PCH_CAN driver: Fix build	warnings
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4911">[ date ]</a>
              <a href="thread.html#4911">[ thread ]</a>
              <a href="subject.html#4911">[ subject ]</a>
              <a href="author.html#4911">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 11/02/2010 11:27 AM, Tomoya MORINAGA wrote:
&gt;<i> On Saturday, October 30, 2010 1:23 AM,  Marc Kleine-Budde wrote:
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> The driver has already been merged. Please send incremental patches
</I>&gt;&gt;&gt;<i> against david's net-2.6 branch.
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Here a review, find comments inline. Lets talk about my remarks, please
</I>&gt;&gt;<i> answer inline and don't delete the code.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Can you please explain me your locking sheme? If I understand the
</I>&gt;&gt;<i> documenation correctly the two message interfaces can be used mutual.
</I>&gt;&gt;<i> And you use one for rx the other one for tx.
</I>&gt;<i> 
</I>&gt;<i> I show our locking scheme.
</I>&gt;<i> When CPU accesses MessageRAM via IF1, CPU protect until read-modify-write
</I>&gt;<i> so that IF2 access not occurred, vice versa.
</I>
Why is that needed?

&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Please use netdev_&lt;level&gt; instead of dev_&lt;level&gt; for debug.
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> --- /dev/null
</I>&gt;&gt;&gt;<i> +++ b/drivers/net/can/pch_can.c
</I>&gt;&gt;&gt;<i> @@ -0,0 +1,1436 @@
</I>&gt;&gt;&gt;<i> +/*
</I>&gt;&gt;&gt;<i> + * Copyright (C) 1999 - 2010 Intel Corporation.
</I>&gt;&gt;&gt;<i> + * Copyright (C) 2010 OKI SEMICONDUCTOR CO., LTD.
</I>&gt;&gt;&gt;<i> + *
</I>&gt;&gt;&gt;<i> + * This program is free software; you can redistribute it and/or modify
</I>&gt;&gt;&gt;<i> + * it under the terms of the GNU General Public License as published by
</I>&gt;&gt;&gt;<i> + * the Free Software Foundation; version 2 of the License.
</I>&gt;&gt;&gt;<i> + *
</I>&gt;&gt;&gt;<i> + * This program is distributed in the hope that it will be useful,
</I>&gt;&gt;&gt;<i> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
</I>&gt;&gt;&gt;<i> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</I>&gt;&gt;&gt;<i> + * GNU General Public License for more details.
</I>&gt;&gt;&gt;<i> + *
</I>&gt;&gt;&gt;<i> + * You should have received a copy of the GNU General Public License
</I>&gt;&gt;&gt;<i> + * along with this program; if not, write to the Free Software
</I>&gt;&gt;&gt;<i> + * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
</I>&gt;&gt;&gt;<i> + */
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#include &lt;linux/interrupt.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/delay.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/io.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/module.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/sched.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/pci.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/init.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/kernel.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/types.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/errno.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/netdevice.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/skbuff.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/can.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/can/dev.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/can/error.h&gt;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define MAX_MSG_OBJ  32
</I>&gt;&gt;&gt;<i> +#define MSG_OBJ_RX  0 /* The receive message object flag. */
</I>&gt;&gt;&gt;<i> +#define MSG_OBJ_TX  1 /* The transmit message object flag. */
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define CAN_CTRL_INIT  0x0001 /* The INIT bit of CANCONT register. */
</I>&gt;&gt;&gt;<i> +#define CAN_CTRL_IE  0x0002 /* The IE bit of CAN control register */
</I>&gt;&gt;&gt;<i> +#define CAN_CTRL_IE_SIE_EIE 0x000e
</I>&gt;&gt;&gt;<i> +#define CAN_CTRL_CCE  0x0040
</I>&gt;&gt;&gt;<i> +#define CAN_CTRL_OPT  0x0080 /* The OPT bit of CANCONT register. */
</I>&gt;&gt;&gt;<i> +#define CAN_OPT_SILENT  0x0008 /* The Silent bit of CANOPT reg. */
</I>&gt;&gt;&gt;<i> +#define CAN_OPT_LBACK  0x0010 /* The LoopBack bit of CANOPT reg. */
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_RX_TX_SET 0x00f3
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_RX_TX_GET 0x0073
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_ALL  0xff
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_RDWR  0x80
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_ARB  0x20
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_CTRL  0x10
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_MASK  0x40
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_NEWDAT 0x04
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_CLRINTPND 0x08
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_NEWDAT 0x8000
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_INTPND 0x2000
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_UMASK 0x1000
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_TXIE 0x0800
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_RXIE 0x0400
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_RMTEN 0x0200
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_TXRQXT 0x0100
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_EOB 0x0080
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_DLC 0x000f
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_MSGLOST 0x4000
</I>&gt;&gt;&gt;<i> +#define CAN_MASK2_MDIR_MXTD 0xc000
</I>&gt;&gt;&gt;<i> +#define CAN_ID2_DIR  0x2000
</I>&gt;&gt;&gt;<i> +#define CAN_ID_MSGVAL  0x8000
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define CAN_STATUS_INT  0x8000
</I>&gt;&gt;&gt;<i> +#define CAN_IF_CREQ_BUSY 0x8000
</I>&gt;&gt;&gt;<i> +#define CAN_ID2_XTD  0x4000
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define CAN_REC   0x00007f00
</I>&gt;&gt;&gt;<i> +#define CAN_TEC   0x000000ff
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A prefix for like PCH_ instead of CAN_ for all those define above would
</I>&gt;&gt;<i> be fine to avoid namespace clashes and/or confusion with the defines from the socketcan framework.
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define PCH_RX_OK  0x00000010
</I>&gt;&gt;&gt;<i> +#define PCH_TX_OK  0x00000008
</I>&gt;&gt;&gt;<i> +#define PCH_BUS_OFF  0x00000080
</I>&gt;&gt;&gt;<i> +#define PCH_EWARN  0x00000040
</I>&gt;&gt;&gt;<i> +#define PCH_EPASSIV  0x00000020
</I>&gt;&gt;&gt;<i> +#define PCH_LEC0  0x00000001
</I>&gt;&gt;&gt;<i> +#define PCH_LEC1  0x00000002
</I>&gt;&gt;&gt;<i> +#define PCH_LEC2  0x00000004
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> These are just single set bit, please use BIT()
</I>&gt;&gt;<i> Consider adding the name of the corresponding register to the define's
</I>&gt;&gt;<i> name.
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +#define PCH_LEC_ALL  (PCH_LEC0 | PCH_LEC1 | PCH_LEC2)
</I>&gt;&gt;&gt;<i> +#define PCH_STUF_ERR  PCH_LEC0
</I>&gt;&gt;&gt;<i> +#define PCH_FORM_ERR  PCH_LEC1
</I>&gt;&gt;&gt;<i> +#define PCH_ACK_ERR  (PCH_LEC0 | PCH_LEC1)
</I>&gt;&gt;&gt;<i> +#define PCH_BIT1_ERR  PCH_LEC2
</I>&gt;&gt;&gt;<i> +#define PCH_BIT0_ERR  (PCH_LEC0 | PCH_LEC2)
</I>&gt;&gt;&gt;<i> +#define PCH_CRC_ERR  (PCH_LEC1 | PCH_LEC2)
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +/* bit position of certain controller bits. */
</I>&gt;&gt;&gt;<i> +#define BIT_BITT_BRP  0
</I>&gt;&gt;&gt;<i> +#define BIT_BITT_SJW  6
</I>&gt;&gt;&gt;<i> +#define BIT_BITT_TSEG1  8
</I>&gt;&gt;&gt;<i> +#define BIT_BITT_TSEG2  12
</I>&gt;&gt;&gt;<i> +#define BIT_IF1_MCONT_RXIE 10
</I>&gt;&gt;&gt;<i> +#define BIT_IF2_MCONT_TXIE 11
</I>&gt;&gt;&gt;<i> +#define BIT_BRPE_BRPE  6
</I>&gt;&gt;&gt;<i> +#define BIT_ES_TXERRCNT  0
</I>&gt;&gt;&gt;<i> +#define BIT_ES_RXERRCNT  8
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> these are usually called SHIFT
</I>&gt;<i> 
</I>&gt;<i> I agree.  Is the below TRUE ?
</I>&gt;<i> e.g.#define PCH_SHIFT_BITT_BRP 0
</I>
I would put the SHIFT at the end, YMMV

#define PCH_BIT_BRP_SHIFT

&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +#define MSK_BITT_BRP  0x3f
</I>&gt;&gt;&gt;<i> +#define MSK_BITT_SJW  0xc0
</I>&gt;&gt;&gt;<i> +#define MSK_BITT_TSEG1  0xf00
</I>&gt;&gt;&gt;<i> +#define MSK_BITT_TSEG2  0x7000
</I>&gt;&gt;&gt;<i> +#define MSK_BRPE_BRPE  0x3c0
</I>&gt;&gt;&gt;<i> +#define MSK_BRPE_GET  0x0f
</I>&gt;&gt;&gt;<i> +#define MSK_CTRL_IE_SIE_EIE 0x07
</I>&gt;&gt;&gt;<i> +#define MSK_MCONT_TXIE  0x08
</I>&gt;&gt;&gt;<i> +#define MSK_MCONT_RXIE  0x10
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> MSK or MASK is okay, however the last two are just single bits.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Please add a PCH_ prefix here, too.
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +#define PCH_CAN_NO_TX_BUFF 1
</I>&gt;&gt;&gt;<i> +#define COUNTER_LIMIT  10
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> dito
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define PCH_CAN_CLK  50000000 /* 50MHz */
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +/*
</I>&gt;&gt;&gt;<i> + * Define the number of message object.
</I>&gt;&gt;&gt;<i> + * PCH CAN communications are done via Message RAM.
</I>&gt;&gt;&gt;<i> + * The Message RAM consists of 32 message objects.
</I>&gt;&gt;&gt;<i> + */
</I>&gt;&gt;&gt;<i> +#define PCH_RX_OBJ_NUM  26  /* 1~ PCH_RX_OBJ_NUM is Rx*/
</I>&gt;&gt;&gt;<i> +#define PCH_TX_OBJ_NUM  6  /* PCH_RX_OBJ_NUM is RX ~ Tx*/
</I>&gt;&gt;&gt;<i> +#define PCH_OBJ_NUM  (PCH_TX_OBJ_NUM + PCH_RX_OBJ_NUM)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You define MAX_MSG_OBJ earlier, seems like two names for the same value.
</I>&gt;<i> 
</I>&gt;<i> In case, a use uses all message objects(=32), you are right.
</I>&gt;<i> But user does not alway use all message object.
</I>
No one will change these values if the driver isn't buggy. And it
doesn't make any sense to not use all objects.

&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define PCH_FIFO_THRESH  16
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +enum pch_can_mode {
</I>&gt;&gt;&gt;<i> + PCH_CAN_ENABLE,
</I>&gt;&gt;&gt;<i> + PCH_CAN_DISABLE,
</I>&gt;&gt;&gt;<i> + PCH_CAN_ALL,
</I>&gt;&gt;&gt;<i> + PCH_CAN_NONE,
</I>&gt;&gt;&gt;<i> + PCH_CAN_STOP,
</I>&gt;&gt;&gt;<i> + PCH_CAN_RUN,
</I>&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +struct pch_can_regs {
</I>&gt;&gt;&gt;<i> + u32 cont;
</I>&gt;&gt;&gt;<i> + u32 stat;
</I>&gt;&gt;&gt;<i> + u32 errc;
</I>&gt;&gt;&gt;<i> + u32 bitt;
</I>&gt;&gt;&gt;<i> + u32 intr;
</I>&gt;&gt;&gt;<i> + u32 opt;
</I>&gt;&gt;&gt;<i> + u32 brpe;
</I>&gt;&gt;&gt;<i> + u32 reserve1;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> VVVV
</I>&gt;&gt;&gt;<i> + u32 if1_creq;
</I>&gt;&gt;&gt;<i> + u32 if1_cmask;
</I>&gt;&gt;&gt;<i> + u32 if1_mask1;
</I>&gt;&gt;&gt;<i> + u32 if1_mask2;
</I>&gt;&gt;&gt;<i> + u32 if1_id1;
</I>&gt;&gt;&gt;<i> + u32 if1_id2;
</I>&gt;&gt;&gt;<i> + u32 if1_mcont;
</I>&gt;&gt;&gt;<i> + u32 if1_dataa1;
</I>&gt;&gt;&gt;<i> + u32 if1_dataa2;
</I>&gt;&gt;&gt;<i> + u32 if1_datab1;
</I>&gt;&gt;&gt;<i> + u32 if1_datab2;
</I>&gt;&gt;<i> ^^^^
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> these registers and....
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> + u32 reserve2;
</I>&gt;&gt;&gt;<i> + u32 reserve3[12];
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ...and these
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> VVVV
</I>&gt;&gt;&gt;<i> + u32 if2_creq;
</I>&gt;&gt;&gt;<i> + u32 if2_cmask;
</I>&gt;&gt;&gt;<i> + u32 if2_mask1;
</I>&gt;&gt;&gt;<i> + u32 if2_mask2;
</I>&gt;&gt;&gt;<i> + u32 if2_id1;
</I>&gt;&gt;&gt;<i> + u32 if2_id2;
</I>&gt;&gt;&gt;<i> + u32 if2_mcont;
</I>&gt;&gt;&gt;<i> + u32 if2_dataa1;
</I>&gt;&gt;&gt;<i> + u32 if2_dataa2;
</I>&gt;&gt;&gt;<i> + u32 if2_datab1;
</I>&gt;&gt;&gt;<i> + u32 if2_datab2;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ^^^^
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ...are identical. I suggest to make a struct defining a complete
</I>&gt;&gt;<i> &quot;Message Interface Register Set&quot;. If you include the correct number of
</I>&gt;&gt;<i> reserved bytes in the struct, you can have an array of two of these
</I>&gt;&gt;<i> structs in the struct pch_can_regs.
</I>&gt;<i> 
</I>&gt;<i> To me, IMHOHO, it looks insignificant point.
</I>&gt;<i> Please show the merit ?
</I>
See Wolfgangs comments. You can get rid of duplicated code....

&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> + u32 reserve4;
</I>&gt;&gt;&gt;<i> + u32 reserve5[20];
</I>&gt;&gt;&gt;<i> + u32 treq1;
</I>&gt;&gt;&gt;<i> + u32 treq2;
</I>&gt;&gt;&gt;<i> + u32 reserve6[2];
</I>&gt;&gt;&gt;<i> + u32 reserve7[56];
</I>&gt;&gt;&gt;<i> + u32 reserve8[3];
</I>&gt;&gt;&gt;<i> + u32 srst;
</I>&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +struct pch_can_priv {
</I>&gt;&gt;&gt;<i> + struct can_priv can;
</I>&gt;&gt;&gt;<i> + struct pci_dev *dev;
</I>&gt;&gt;&gt;<i> + unsigned int tx_enable[MAX_MSG_OBJ];
</I>&gt;&gt;&gt;<i> + unsigned int rx_enable[MAX_MSG_OBJ];
</I>&gt;&gt;&gt;<i> + unsigned int rx_link[MAX_MSG_OBJ];
</I>&gt;&gt;&gt;<i> + unsigned int int_enables;
</I>&gt;&gt;&gt;<i> + unsigned int int_stat;
</I>&gt;&gt;&gt;<i> + struct net_device *ndev;
</I>&gt;&gt;&gt;<i> + spinlock_t msgif_reg_lock; /* Message Interface Registers Access Lock*/
</I>&gt;&gt;<i>                                                                             ^^^
</I>&gt;&gt;<i> please add a whitespace
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> + unsigned int msg_obj[MAX_MSG_OBJ];
</I>&gt;&gt;&gt;<i> + struct pch_can_regs __iomem *regs;
</I>&gt;&gt;&gt;<i> + struct napi_struct napi;
</I>&gt;&gt;&gt;<i> + unsigned int tx_obj; /* Point next Tx Obj index */
</I>&gt;&gt;&gt;<i> + unsigned int use_msi;
</I>&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static struct can_bittiming_const pch_can_bittiming_const = {
</I>&gt;&gt;&gt;<i> + .name = &quot;pch_can&quot;,
</I>&gt;&gt;&gt;<i> + .tseg1_min = 1,
</I>&gt;&gt;&gt;<i> + .tseg1_max = 16,
</I>&gt;&gt;&gt;<i> + .tseg2_min = 1,
</I>&gt;&gt;&gt;<i> + .tseg2_max = 8,
</I>&gt;&gt;&gt;<i> + .sjw_max = 4,
</I>&gt;&gt;&gt;<i> + .brp_min = 1,
</I>&gt;&gt;&gt;<i> + .brp_max = 1024, /* 6bit + extended 4bit */
</I>&gt;&gt;&gt;<i> + .brp_inc = 1,
</I>&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static DEFINE_PCI_DEVICE_TABLE(pch_pci_tbl) = {
</I>&gt;&gt;&gt;<i> + {PCI_VENDOR_ID_INTEL, 0x8818, PCI_ANY_ID, PCI_ANY_ID,},
</I>&gt;&gt;&gt;<i> + {0,}
</I>&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;<i> +MODULE_DEVICE_TABLE(pci, pch_pci_tbl);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static inline void pch_can_bit_set(u32 *addr, u32 mask)
</I>&gt;&gt;<i>                                       ^^^^^
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> that should be an void __iomem *, see mail I've send the other day.
</I>&gt;&gt;<i> Please use sparse to check for this kinds of errors.
</I>&gt;&gt;<i> (Compile the driver with C=2, i.e.: make drivers/net/can/pch_can.ko C=2)
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + iowrite32(ioread32(addr) | mask, addr);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static inline void pch_can_bit_clear(u32 *addr, u32 mask)
</I>&gt;&gt;<i>                                         ^^^^^
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> dito
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + iowrite32(ioread32(addr) &amp; ~mask, addr);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_set_run_mode(struct pch_can_priv *priv,
</I>&gt;&gt;&gt;<i> +     enum pch_can_mode mode)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + switch (mode) {
</I>&gt;&gt;&gt;<i> + case PCH_CAN_RUN:
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_INIT);
</I>&gt;&gt;&gt;<i> +  break;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + case PCH_CAN_STOP:
</I>&gt;&gt;&gt;<i> +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_INIT);
</I>&gt;&gt;&gt;<i> +  break;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + default:
</I>&gt;&gt;&gt;<i> +  dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;%s -&gt; Invalid Mode.\n&quot;, __func__);
</I>&gt;&gt;&gt;<i> +  break;
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_set_optmode(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + u32 reg_val = ioread32(&amp;priv-&gt;regs-&gt;opt);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LISTENONLY)
</I>&gt;&gt;&gt;<i> +  reg_val |= CAN_OPT_SILENT;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LOOPBACK)
</I>&gt;&gt;&gt;<i> +  reg_val |= CAN_OPT_LBACK;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_OPT);
</I>&gt;&gt;&gt;<i> + iowrite32(reg_val, &amp;priv-&gt;regs-&gt;opt);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> IMHO the function name is missleading, if I understand the code
</I>&gt;&gt;<i> correctly, this functions triggers the transmission of the message.
</I>&gt;&gt;<i> After this it checks for busy, 
</I>&gt;<i> 
</I>&gt;<i> Yes, your understanding is TRUE.
</I>&gt;<i> 
</I>&gt;&gt;<i> but
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +static void pch_can_check_if_busy(u32 __iomem *creq_addr, u32 num)
</I>&gt;&gt;<i>                                      ^^^^
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Yes, me too.
</I>&gt;<i> I will rename the function name.
</I>&gt;<i> 
</I>&gt;<i> How about &quot;pch_can_rw_msg_obj&quot;
</I>&gt;<i> 
</I>&gt;&gt;<i> that should probaby be a void
</I>&gt;<i> What't the above mean ?
</I>&gt;<i> pch_can_check_if_busy is already &quot;void&quot; function.
</I>
&gt;&gt;&gt;<i> +static void pch_can_check_if_busy(u32 __iomem *creq_addr, u32 num)
</I>&gt;&gt;<i>                                     ^^^^
</I>
That u32 should be a void.

BTW: Does the Intel chip support x64? If so, have you tested the driver
on a 64 bit kernel.

&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + u32 counter = COUNTER_LIMIT;
</I>&gt;&gt;&gt;<i> + u32 ifx_creq;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + iowrite32(num, creq_addr);
</I>&gt;&gt;&gt;<i> + while (counter) {
</I>&gt;&gt;&gt;<i> +  ifx_creq = ioread32(creq_addr) &amp; CAN_IF_CREQ_BUSY;
</I>&gt;&gt;&gt;<i> +  if (!ifx_creq)
</I>&gt;&gt;&gt;<i> +   break;
</I>&gt;&gt;&gt;<i> +  counter--;
</I>&gt;&gt;&gt;<i> +  udelay(1);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> + if (!counter)
</I>&gt;&gt;&gt;<i> +  pr_err(&quot;%s:IF1 BUSY Flag is set forever.\n&quot;, __func__);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_set_int_enables(struct pch_can_priv *priv,
</I>&gt;&gt;&gt;<i> +        enum pch_can_mode interrupt_no)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + switch (interrupt_no) {
</I>&gt;&gt;&gt;<i> + case PCH_CAN_ENABLE:
</I>&gt;&gt;&gt;<i> +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_IE);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> noone uses this case.
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +  break;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + case PCH_CAN_DISABLE:
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_IE);
</I>&gt;&gt;&gt;<i> +  break;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + case PCH_CAN_ALL:
</I>&gt;&gt;&gt;<i> +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_IE_SIE_EIE);
</I>&gt;&gt;&gt;<i> +  break;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + case PCH_CAN_NONE:
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_IE_SIE_EIE);
</I>&gt;&gt;&gt;<i> +  break;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + default:
</I>&gt;&gt;&gt;<i> +  dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;Invalid interrupt number.\n&quot;);
</I>&gt;&gt;&gt;<i> +  break;
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_set_rx_enable(struct pch_can_priv *priv, u32 buff_num,
</I>&gt;&gt;&gt;<i> +      int set)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + unsigned long flags;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> + /* Reading the receive buffer data from RAM to Interface1 registers */
</I>&gt;&gt;&gt;<i> + iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buff_num);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Setting the IF1MASK1 register to access MsgVal and RxIE bits */
</I>&gt;&gt;&gt;<i> + iowrite32(CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL,
</I>&gt;&gt;&gt;<i> +    &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + if (set == 1) {
</I>&gt;&gt;&gt;<i> +  /* Setting the MsgVal and RxIE bits */
</I>&gt;&gt;&gt;<i> +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if1_mcont, CAN_IF_MCONT_RXIE);
</I>&gt;&gt;&gt;<i> +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if1_id2, CAN_ID_MSGVAL);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + } else if (set == 0) {
</I>&gt;&gt;&gt;<i> +  /* Resetting the MsgVal and RxIE bits */
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont, CAN_IF_MCONT_RXIE);
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_id2, CAN_ID_MSGVAL);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buff_num);
</I>&gt;&gt;&gt;<i> + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_rx_enable_all(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + int i;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Traversing to obtain the object configured as receivers. */
</I>&gt;&gt;&gt;<i> + for (i = 1; i &lt;= PCH_RX_OBJ_NUM; i++)
</I>&gt;&gt;&gt;<i> +  pch_can_set_rx_enable(priv, i, 1);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_rx_disable_all(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + int i;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Traversing to obtain the object configured as receivers. */
</I>&gt;&gt;&gt;<i> + for (i = 1; i &lt;= PCH_RX_OBJ_NUM; i++)
</I>&gt;&gt;&gt;<i> +  pch_can_set_rx_enable(priv, i, 0);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_set_tx_enable(struct pch_can_priv *priv, u32 buff_num,
</I>&gt;&gt;&gt;<i> +     u32 set)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + unsigned long flags;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> + /* Reading the Msg buffer from Message RAM to Interface2 registers. */
</I>&gt;&gt;&gt;<i> + iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, buff_num);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Setting the IF2CMASK register for accessing the
</I>&gt;&gt;&gt;<i> +  MsgVal and TxIE bits */
</I>&gt;&gt;&gt;<i> + iowrite32(CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL,
</I>&gt;&gt;&gt;<i> +   &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + if (set == 1) {
</I>&gt;&gt;&gt;<i> +  /* Setting the MsgVal and TxIE bits */
</I>&gt;&gt;&gt;<i> +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_mcont, CAN_IF_MCONT_TXIE);
</I>&gt;&gt;&gt;<i> +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id2, CAN_ID_MSGVAL);
</I>&gt;&gt;&gt;<i> + } else if (set == 0) {
</I>&gt;&gt;&gt;<i> +  /* Resetting the MsgVal and TxIE bits. */
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_mcont, CAN_IF_MCONT_TXIE);
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_id2, CAN_ID_MSGVAL);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, buff_num);
</I>&gt;&gt;&gt;<i> + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_tx_enable_all(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + int i;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Traversing to obtain the object configured as transmit object. */
</I>&gt;&gt;&gt;<i> + for (i = PCH_RX_OBJ_NUM + 1; i &lt;= PCH_OBJ_NUM; i++)
</I>&gt;&gt;&gt;<i> +  pch_can_set_tx_enable(priv, i, 1);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_tx_disable_all(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + int i;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Traversing to obtain the object configured as transmit object. */
</I>&gt;&gt;&gt;<i> + for (i = PCH_RX_OBJ_NUM + 1; i &lt;= PCH_OBJ_NUM; i++)
</I>&gt;&gt;&gt;<i> +  pch_can_set_tx_enable(priv, i, 0);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_can_int_pending(struct pch_can_priv *priv)
</I>&gt;&gt;<i>           ^^^
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> make it u32 as it returns a register value, or a u16 as you only use
</I>&gt;&gt;<i> the 16 lower bits.
</I>&gt;<i> 
</I>&gt;<i> I agree. I will modify to u32.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + return ioread32(&amp;priv-&gt;regs-&gt;intr) &amp; 0xffff;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_clear_buffers(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + int i; /* Msg Obj ID (1~32) */
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + for (i = 1; i &lt;= PCH_RX_OBJ_NUM; i++) {
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> IMHO the readability would be improved if you define something like
</I>&gt;&gt;<i> PCH_RX_OBJ_START and PCH_RX_OBJ_END.
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +  iowrite32(CAN_CMASK_RX_TX_SET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +  iowrite32(0xffff, &amp;priv-&gt;regs-&gt;if1_mask1);
</I>&gt;&gt;&gt;<i> +  iowrite32(0xffff, &amp;priv-&gt;regs-&gt;if1_mask2);
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_id1);
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_id2);
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_mcont);
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_dataa1);
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_dataa2);
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_datab1);
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_datab2);
</I>&gt;&gt;&gt;<i> +  iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK |
</I>&gt;&gt;&gt;<i> +     CAN_CMASK_ARB | CAN_CMASK_CTRL,
</I>&gt;&gt;&gt;<i> +     &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, i);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + for (i = PCH_RX_OBJ_NUM + 1; i &lt;= PCH_OBJ_NUM; i++) {
</I>&gt;&gt;<i>                  ^^^^^^^^^^^^^^^^^^
</I>&gt;&gt;<i> dito for TX objects
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +  iowrite32(CAN_CMASK_RX_TX_SET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +  iowrite32(0xffff, &amp;priv-&gt;regs-&gt;if2_mask1);
</I>&gt;&gt;&gt;<i> +  iowrite32(0xffff, &amp;priv-&gt;regs-&gt;if2_mask2);
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_id1);
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_id2);
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_mcont);
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_dataa1);
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_dataa2);
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_datab1);
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_datab2);
</I>&gt;&gt;&gt;<i> +  iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK | CAN_CMASK_ARB |
</I>&gt;&gt;&gt;<i> +     CAN_CMASK_CTRL, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, i);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + int i;
</I>&gt;&gt;&gt;<i> + unsigned long flags;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + for (i = 1; i &lt;= PCH_RX_OBJ_NUM; i++) {
</I>&gt;&gt;&gt;<i> +  iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, i);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If I understand the code correctly, the about function triggers a
</I>&gt;&gt;<i> transfer. Why do you first trigger a transfer, then set the message contents....
</I>&gt;<i> 
</I>&gt;<i> For doing Read-Modify-Write.
</I>&gt;<i> As to fixed parameter of message object, it doesn't be modified every access.
</I>
I see.

&gt;<i> We will modify to write only.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_id1);
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_id2);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if1_mcont, CAN_IF_MCONT_UMASK);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     Why do you set the &quot;Use acceptance mask&quot; bit? We want to receive
</I>&gt;&gt;<i>     all can messages.
</I>&gt;<i> 
</I>&gt;<i> Without &quot;Use acceptance mask&quot; means received packet matched ID[28:0] only.
</I>&gt;<i> As a result, filter is enabled.
</I>&gt;<i> 
</I>&gt;<i> With &quot;Use acceptance mask&quot; and setting Msk[0:28]=all 1, all packets can be received(=No filter state) 
</I>
Thanks for the explenation.

&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  /* Set FIFO mode set to 0 except last Rx Obj*/
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont, CAN_IF_MCONT_EOB);
</I>&gt;&gt;&gt;<i> +  /* In case FIFO mode, Last EoB of Rx Obj must be 1 */
</I>&gt;&gt;&gt;<i> +  if (i == (PCH_RX_OBJ_NUM - 1))
</I>&gt;&gt;&gt;<i> +   pch_can_bit_set(&amp;priv-&gt;regs-&gt;if1_mcont,
</I>&gt;&gt;&gt;<i> +     CAN_IF_MCONT_EOB);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     Make it if () { } else { }, please.
</I>&gt;<i> 
</I>&gt;<i> Sorry, I can't understand.
</I>&gt;<i> else {} is not necessary.
</I>
Please look at the code block above, again. You frist clean the bit
unconditionally, then you set the bit in the if. Please make it:

if (last)
	set_bit
else
	clear_bit

&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  iowrite32(0, &amp;priv-&gt;regs-&gt;if1_mask1);
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mask2,
</I>&gt;&gt;&gt;<i> +      0x1fff | CAN_MASK2_MDIR_MXTD);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  /* Setting CMASK for writing */
</I>&gt;&gt;&gt;<i> +  iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK | CAN_CMASK_ARB |
</I>&gt;&gt;&gt;<i> +     CAN_CMASK_CTRL, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, i);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ...and then trigger the transfer again?
</I>&gt;<i> 
</I>&gt;<i> This means Read-Modify-Write.
</I>
ic

&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + for (i = PCH_RX_OBJ_NUM + 1; i &lt;= PCH_OBJ_NUM; i++) {
</I>&gt;&gt;&gt;<i> +  iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, i);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> same question about triggering the transfer 2 times applied here, too
</I>&gt;<i> 
</I>&gt;<i> ditto.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  /* Resetting DIR bit for reception */
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_id1);
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_id2);
</I>&gt;&gt;&gt;<i> +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id2, CAN_ID2_DIR);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Can you combine the two accesses to &gt;if2_id2 into one?
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  /* Setting EOB bit for transmitter */
</I>&gt;&gt;&gt;<i> +  iowrite32(CAN_IF_MCONT_EOB, &amp;priv-&gt;regs-&gt;if2_mcont);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_mcont,
</I>&gt;&gt;&gt;<i> +    CAN_IF_MCONT_UMASK);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> dito for if2_mcont
</I>&gt;<i> 
</I>&gt;<i> ditto.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  iowrite32(0, &amp;priv-&gt;regs-&gt;if2_mask1);
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_mask2, 0x1fff);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  /* Setting CMASK for writing */
</I>&gt;&gt;&gt;<i> +  iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK | CAN_CMASK_ARB |
</I>&gt;&gt;&gt;<i> +     CAN_CMASK_CTRL, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, i);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_init(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + /* Stopping the Can device. */
</I>&gt;&gt;&gt;<i> + pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Clearing all the message object buffers. */
</I>&gt;&gt;&gt;<i> + pch_can_clear_buffers(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Configuring the respective message object as either rx/tx object. */
</I>&gt;&gt;&gt;<i> + pch_can_config_rx_tx_buffers(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Enabling the interrupts. */
</I>&gt;&gt;&gt;<i> + pch_can_set_int_enables(priv, PCH_CAN_ALL);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_release(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + /* Stooping the CAN device. */
</I>&gt;&gt;&gt;<i> + pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Disabling the interrupts. */
</I>&gt;&gt;&gt;<i> + pch_can_set_int_enables(priv, PCH_CAN_NONE);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Disabling all the receive object. */
</I>&gt;&gt;&gt;<i> + pch_can_rx_disable_all(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Disabling all the transmit object. */
</I>&gt;&gt;&gt;<i> + pch_can_tx_disable_all(priv);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +/* This function clears interrupt(s) from the CAN device. */
</I>&gt;&gt;&gt;<i> +static void pch_can_int_clr(struct pch_can_priv *priv, u32 mask)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + if (mask == CAN_STATUS_INT) {
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> is this a valid case?
</I>&gt;<i> 
</I>&gt;<i> This &quot;if&quot; is always false.
</I>&gt;<i> I will delete this condition.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +  ioread32(&amp;priv-&gt;regs-&gt;stat);
</I>&gt;&gt;&gt;<i> +  return;
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Clear interrupt for transmit object */
</I>&gt;&gt;&gt;<i> + if ((mask &gt;= 1) &amp;&amp; (mask &lt;= PCH_RX_OBJ_NUM)) {
</I>&gt;&gt;&gt;<i> +  /* Setting CMASK for clearing the reception interrupts. */
</I>&gt;&gt;&gt;<i> +  iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL | CAN_CMASK_ARB,
</I>&gt;&gt;&gt;<i> +     &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  /* Clearing the Dir bit. */
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_id2, CAN_ID2_DIR);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  /* Clearing NewDat &amp; IntPnd */
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont,
</I>&gt;&gt;&gt;<i> +      CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, mask);
</I>&gt;&gt;&gt;<i> + } else if ((mask &gt; PCH_RX_OBJ_NUM) &amp;&amp; (mask &lt;= PCH_OBJ_NUM)) {
</I>&gt;&gt;&gt;<i> +  /* Setting CMASK for clearing interrupts for
</I>&gt;&gt;&gt;<i> +     frame transmission. */
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> /*
</I>&gt;&gt;<i>  * this is the prefered style of multi line comments,
</I>&gt;&gt;<i>  * please adjust you comments
</I>&gt;&gt;<i>  */
</I>&gt;<i> 
</I>&gt;<i> I understand.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +  iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL | CAN_CMASK_ARB,
</I>&gt;&gt;&gt;<i> +     &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  /* Resetting the ID registers. */
</I>&gt;&gt;&gt;<i> +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id2,
</I>&gt;&gt;&gt;<i> +          CAN_ID2_DIR | (0x7ff &lt;&lt; 2));
</I>&gt;&gt;&gt;<i> +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_id1);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  /* Claring NewDat, TxRqst &amp; IntPnd */
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_mcont,
</I>&gt;&gt;&gt;<i> +      CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND |
</I>&gt;&gt;&gt;<i> +      CAN_IF_MCONT_TXRQXT);
</I>&gt;&gt;&gt;<i> +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, mask);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static u32 pch_can_get_buffer_status(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + return (ioread32(&amp;priv-&gt;regs-&gt;treq1) &amp; 0xffff) |
</I>&gt;&gt;&gt;<i> +        ((ioread32(&amp;priv-&gt;regs-&gt;treq2) &amp; 0xffff) &lt;&lt; 16);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> the second 0xffff is not needed, as the return value is u32 and you shift by 16.
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_reset(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + /* write to sw reset register */
</I>&gt;&gt;&gt;<i> + iowrite32(1, &amp;priv-&gt;regs-&gt;srst);
</I>&gt;&gt;&gt;<i> + iowrite32(0, &amp;priv-&gt;regs-&gt;srst);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_error(struct net_device *ndev, u32 status)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + struct sk_buff *skb;
</I>&gt;&gt;&gt;<i> + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> + struct can_frame *cf;
</I>&gt;&gt;&gt;<i> + u32 errc;
</I>&gt;&gt;&gt;<i> + struct net_device_stats *stats = &amp;(priv-&gt;ndev-&gt;stats);
</I>&gt;&gt;&gt;<i> + enum can_state state = priv-&gt;can.state;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + skb = alloc_can_err_skb(ndev, &amp;cf);
</I>&gt;&gt;&gt;<i> + if (!skb)
</I>&gt;&gt;&gt;<i> +  return;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + if (status &amp; PCH_BUS_OFF) {
</I>&gt;&gt;&gt;<i> +  pch_can_tx_disable_all(priv);
</I>&gt;&gt;&gt;<i> +  pch_can_rx_disable_all(priv);
</I>&gt;&gt;&gt;<i> +  state = CAN_STATE_BUS_OFF;
</I>&gt;&gt;&gt;<i> +  cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;&gt;&gt;<i> +  can_bus_off(ndev);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Warning interrupt. */
</I>&gt;&gt;&gt;<i> + if (status &amp; PCH_EWARN) {
</I>&gt;&gt;&gt;<i> +  state = CAN_STATE_ERROR_WARNING;
</I>&gt;&gt;&gt;<i> +  priv-&gt;can.can_stats.error_warning++;
</I>&gt;&gt;&gt;<i> +  cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;&gt;&gt;<i> +  errc = ioread32(&amp;priv-&gt;regs-&gt;errc);
</I>&gt;&gt;&gt;<i> +  if (((errc &amp; CAN_REC) &gt;&gt; 8) &gt; 96)
</I>&gt;&gt;&gt;<i> +   cf-&gt;data[1] |= CAN_ERR_CRTL_RX_WARNING;
</I>&gt;&gt;&gt;<i> +  if ((errc &amp; CAN_TEC) &gt; 96)
</I>&gt;&gt;&gt;<i> +   cf-&gt;data[1] |= CAN_ERR_CRTL_TX_WARNING;
</I>&gt;&gt;&gt;<i> +  dev_warn(&amp;ndev-&gt;dev,
</I>&gt;&gt;&gt;<i> +   &quot;%s -&gt; Error Counter is more than 96.\n&quot;, __func__);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Please use just &quot;debug&quot; level not warning here. Consider to use
</I>&gt;&gt;<i> netdev_dbg() instead. IMHO the __func__ can be dropped and the
</I>&gt;&gt;<i> &quot;official&quot; name for the error is &quot;Error Warning&quot;.
</I>&gt;<i> 
</I>&gt;<i> I want to know the reason.
</I>&gt;<i> Why is it not dev_warn but netdev_dbg ?
</I>
If you use warning level it would end up on the console or and in the
syslog. It's quite complicated (for programs) to get information from
there. This is why we send CAN error frames. They hold the same
information but int a binary form, thus it's easier to process.

&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> + /* Error passive interrupt. */
</I>&gt;&gt;&gt;<i> + if (status &amp; PCH_EPASSIV) {
</I>&gt;&gt;&gt;<i> +  priv-&gt;can.can_stats.error_passive++;
</I>&gt;&gt;&gt;<i> +  state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;&gt;&gt;<i> +  cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;&gt;&gt;<i> +  errc = ioread32(&amp;priv-&gt;regs-&gt;errc);
</I>&gt;&gt;&gt;<i> +  if (((errc &amp; CAN_REC) &gt;&gt; 8) &gt; 127)
</I>&gt;&gt;&gt;<i> +   cf-&gt;data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;&gt;&gt;<i> +  if ((errc &amp; CAN_TEC) &gt; 127)
</I>&gt;&gt;&gt;<i> +   cf-&gt;data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
</I>&gt;&gt;&gt;<i> +  dev_err(&amp;ndev-&gt;dev,
</I>&gt;&gt;&gt;<i> +   &quot;%s -&gt; CAN controller is ERROR PASSIVE .\n&quot;, __func__);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> dito
</I>&gt;<i> 
</I>&gt;<i> ditto
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + if (status &amp; PCH_LEC_ALL) {
</I>&gt;&gt;&gt;<i> +  priv-&gt;can.can_stats.bus_error++;
</I>&gt;&gt;&gt;<i> +  stats-&gt;rx_errors++;
</I>&gt;&gt;&gt;<i> +  switch (status &amp; PCH_LEC_ALL) {
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I suggest to convert to a if-bit-set because there might be more than
</I>&gt;&gt;<i> one bit set.
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +  case PCH_STUF_ERR:
</I>&gt;&gt;&gt;<i> +   cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;&gt;&gt;<i> +   break;
</I>&gt;&gt;&gt;<i> +  case PCH_FORM_ERR:
</I>&gt;&gt;&gt;<i> +   cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;&gt;&gt;<i> +   break;
</I>&gt;&gt;&gt;<i> +  case PCH_ACK_ERR:
</I>&gt;&gt;&gt;<i> +   cf-&gt;data[2] |= CAN_ERR_PROT_LOC_ACK |
</I>&gt;&gt;&gt;<i> +           CAN_ERR_PROT_LOC_ACK_DEL;
</I>&gt;&gt;&gt;<i> +   break;
</I>&gt;&gt;&gt;<i> +  case PCH_BIT1_ERR:
</I>&gt;&gt;&gt;<i> +  case PCH_BIT0_ERR:
</I>&gt;&gt;&gt;<i> +   cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
</I>&gt;&gt;&gt;<i> +   break;
</I>&gt;&gt;&gt;<i> +  case PCH_CRC_ERR:
</I>&gt;&gt;&gt;<i> +   cf-&gt;data[2] |= CAN_ERR_PROT_LOC_CRC_SEQ |
</I>&gt;&gt;&gt;<i> +           CAN_ERR_PROT_LOC_CRC_DEL;
</I>&gt;&gt;&gt;<i> +   break;
</I>&gt;&gt;&gt;<i> +  default:
</I>&gt;&gt;&gt;<i> +   iowrite32(status | PCH_LEC_ALL, &amp;priv-&gt;regs-&gt;stat);
</I>&gt;&gt;&gt;<i> +   break;
</I>&gt;&gt;&gt;<i> +  }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + priv-&gt;can.state = state;
</I>&gt;&gt;&gt;<i> + netif_receive_skb(skb);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + stats-&gt;rx_packets++;
</I>&gt;&gt;&gt;<i> + stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static irqreturn_t pch_can_interrupt(int irq, void *dev_id)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + struct net_device *ndev = (struct net_device *)dev_id;
</I>&gt;&gt;&gt;<i> + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + pch_can_set_int_enables(priv, PCH_CAN_NONE);
</I>&gt;&gt;&gt;<i> + napi_schedule(&amp;priv-&gt;napi);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + return IRQ_HANDLED;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_fifo_thresh(struct pch_can_priv *priv, int obj_id)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + if (obj_id &lt; PCH_FIFO_THRESH) {
</I>&gt;&gt;&gt;<i> +  iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL |
</I>&gt;&gt;&gt;<i> +     CAN_CMASK_ARB, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  /* Clearing the Dir bit. */
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_id2, CAN_ID2_DIR);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  /* Clearing NewDat &amp; IntPnd */
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont,
</I>&gt;&gt;&gt;<i> +      CAN_IF_MCONT_INTPND);
</I>&gt;&gt;&gt;<i> +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, obj_id);
</I>&gt;&gt;&gt;<i> + } else if (obj_id &gt; PCH_FIFO_THRESH) {
</I>&gt;&gt;&gt;<i> +  pch_can_int_clr(priv, obj_id);
</I>&gt;&gt;&gt;<i> + } else if (obj_id == PCH_FIFO_THRESH) {
</I>&gt;&gt;&gt;<i> +  int cnt;
</I>&gt;&gt;&gt;<i> +  for (cnt = 0; cnt &lt; PCH_FIFO_THRESH; cnt++)
</I>&gt;&gt;&gt;<i> +   pch_can_int_clr(priv, cnt+1);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_can_rx_msg_lost(struct net_device *ndev, int obj_id)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> + struct net_device_stats *stats = &amp;(priv-&gt;ndev-&gt;stats);
</I>&gt;&gt;&gt;<i> + struct sk_buff *skb;
</I>&gt;&gt;&gt;<i> + struct can_frame *cf;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;Msg Obj is overwritten.\n&quot;);
</I>&gt;&gt;&gt;<i> + pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont,
</I>&gt;&gt;&gt;<i> +     CAN_IF_MCONT_MSGLOST);
</I>&gt;&gt;&gt;<i> + iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL,
</I>&gt;&gt;&gt;<i> +    &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, obj_id);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + skb = alloc_can_err_skb(ndev, &amp;cf);
</I>&gt;&gt;&gt;<i> + if (!skb)
</I>&gt;&gt;&gt;<i> +  return -ENOMEM;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + priv-&gt;can.can_stats.error_passive++;
</I>&gt;&gt;&gt;<i> + priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;&gt;&gt;<i> + cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;&gt;&gt;<i> + cf-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
</I>&gt;&gt;&gt;<i> + stats-&gt;rx_over_errors++;
</I>&gt;&gt;&gt;<i> + stats-&gt;rx_errors++;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + netif_receive_skb(skb);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + return 0;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_can_rx_normal(struct net_device *ndev, u32 obj_num, int quota)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + u32 reg;
</I>&gt;&gt;&gt;<i> + canid_t id;
</I>&gt;&gt;&gt;<i> + u32 ide;
</I>&gt;&gt;&gt;<i> + u32 rtr;
</I>&gt;&gt;&gt;<i> + int rcv_pkts = 0;
</I>&gt;&gt;&gt;<i> + int rtn;
</I>&gt;&gt;&gt;<i> + int next_flag = 0;
</I>&gt;&gt;&gt;<i> + struct sk_buff *skb;
</I>&gt;&gt;&gt;<i> + struct can_frame *cf;
</I>&gt;&gt;&gt;<i> + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> + struct net_device_stats *stats = &amp;(priv-&gt;ndev-&gt;stats);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Reading the messsage object from the Message RAM */
</I>&gt;&gt;&gt;<i> + iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, obj_num);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Reading the MCONT register. */
</I>&gt;&gt;&gt;<i> + reg = ioread32(&amp;priv-&gt;regs-&gt;if1_mcont);
</I>&gt;&gt;&gt;<i> + reg &amp;= 0xffff;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + for (; (!(reg &amp; CAN_IF_MCONT_EOB)) &amp;&amp; (quota &gt; 0);
</I>&gt;&gt;&gt;<i> +      obj_num++, next_flag = 0) {
</I>&gt;&gt;&gt;<i> +  /* If MsgLost bit set. */
</I>&gt;&gt;&gt;<i> +  if (reg &amp; CAN_IF_MCONT_MSGLOST) {
</I>&gt;&gt;&gt;<i> +   rtn = pch_can_rx_msg_lost(ndev, obj_num);
</I>&gt;&gt;&gt;<i> +   if (!rtn)
</I>&gt;&gt;&gt;<i> +    return rtn;
</I>&gt;&gt;&gt;<i> +   rcv_pkts++;
</I>&gt;&gt;&gt;<i> +   quota--;
</I>&gt;&gt;&gt;<i> +   next_flag = 1;
</I>&gt;&gt;&gt;<i> +  } else if (!(reg &amp; CAN_IF_MCONT_NEWDAT))
</I>&gt;&gt;&gt;<i> +   next_flag = 1;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> after rearanging the code (see below..) you should be able to use a continue here.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +  if (!next_flag) {
</I>&gt;&gt;&gt;<i> +   skb = alloc_can_skb(priv-&gt;ndev, &amp;cf);
</I>&gt;&gt;&gt;<i> +   if (!skb)
</I>&gt;&gt;&gt;<i> +    return -ENOMEM;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +   /* Get Received data */
</I>&gt;&gt;&gt;<i> +   ide = ((ioread32(&amp;priv-&gt;regs-&gt;if1_id2)) &amp; CAN_ID2_XTD);
</I>&gt;&gt;&gt;<i> +   if (ide) {
</I>&gt;&gt;&gt;<i> +    id = (ioread32(&amp;priv-&gt;regs-&gt;if1_id1) &amp; 0xffff);
</I>&gt;&gt;&gt;<i> +    id |= (((ioread32(&amp;priv-&gt;regs-&gt;if1_id2)) &amp;
</I>&gt;&gt;&gt;<i> +          0x1fff) &lt;&lt; 16);
</I>&gt;&gt;&gt;<i> +    cf-&gt;can_id = (id &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
</I>&gt;&gt;<i>                                               ^^^^^^^^^^^^^^^^^
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> is the mask needed, you mask the if1_id{1,2} already
</I>&gt;<i> 
</I>&gt;<i> I will delete
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +   } else {
</I>&gt;&gt;&gt;<i> +    id = (((ioread32(&amp;priv-&gt;regs-&gt;if1_id2)) &amp;
</I>&gt;&gt;&gt;<i> +        (CAN_SFF_MASK &lt;&lt; 2)) &gt;&gt; 2);
</I>&gt;&gt;&gt;<i> +    cf-&gt;can_id = (id &amp; CAN_SFF_MASK);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> one mask can go away
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +   }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +   rtr = ioread32(&amp;priv-&gt;regs-&gt;if1_id2) &amp;  CAN_ID2_DIR;
</I>&gt;&gt;<i>                                                               ^^
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> remove one space
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +   if (rtr)
</I>&gt;&gt;&gt;<i> +    cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +   cf-&gt;can_dlc = get_can_dlc((ioread32(&amp;priv-&gt;regs-&gt;
</I>&gt;&gt;&gt;<i> +         if1_mcont)) &amp; 0xF);
</I>&gt;&gt;&gt;<i> +   *(u16 *)(cf-&gt;data + 0) = ioread16(&amp;priv-&gt;regs-&gt;
</I>&gt;&gt;&gt;<i> +         if1_dataa1);
</I>&gt;&gt;&gt;<i> +   *(u16 *)(cf-&gt;data + 2) = ioread16(&amp;priv-&gt;regs-&gt;
</I>&gt;&gt;&gt;<i> +         if1_dataa2);
</I>&gt;&gt;&gt;<i> +   *(u16 *)(cf-&gt;data + 4) = ioread16(&amp;priv-&gt;regs-&gt;
</I>&gt;&gt;&gt;<i> +         if1_datab1);
</I>&gt;&gt;&gt;<i> +   *(u16 *)(cf-&gt;data + 6) = ioread16(&amp;priv-&gt;regs-&gt;
</I>&gt;&gt;&gt;<i> +         if1_datab2);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> are you sure, the bytes in the can package a in the correct order.
</I>&gt;&gt;<i> Please test your pch_can against a non pch_can system.
</I>&gt;<i> 
</I>&gt;<i> Unfortunately, we don't have non pch_can system.
</I>
Have a look a the driver/net/can/usb subdir and buy one of those. It
really hard to find bugs if you test against your own driver.

&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +   netif_receive_skb(skb);
</I>&gt;&gt;&gt;<i> +   rcv_pkts++;
</I>&gt;&gt;&gt;<i> +   stats-&gt;rx_packets++;
</I>&gt;&gt;&gt;<i> +   quota--;
</I>&gt;&gt;&gt;<i> +   stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +   pch_fifo_thresh(priv, obj_num);
</I>&gt;&gt;&gt;<i> +  }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  /* Reading the messsage object from the Message RAM */
</I>&gt;&gt;&gt;<i> +  iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, obj_num + 1);
</I>&gt;&gt;&gt;<i> +  reg = ioread32(&amp;priv-&gt;regs-&gt;if1_mcont);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> this is almost the same code as before the the loop, can you rearange
</I>&gt;&gt;<i> the code to avoid duplication?
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + return rcv_pkts;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_tx_complete(struct net_device *ndev, u32 int_stat)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> + struct net_device_stats *stats = &amp;(priv-&gt;ndev-&gt;stats);
</I>&gt;&gt;&gt;<i> + unsigned long flags;
</I>&gt;&gt;&gt;<i> + u32 dlc;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + can_get_echo_skb(ndev, int_stat - PCH_RX_OBJ_NUM - 1);
</I>&gt;&gt;&gt;<i> + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> + iowrite32(CAN_CMASK_RX_TX_GET | CAN_CMASK_CLRINTPND,
</I>&gt;&gt;&gt;<i> +    &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> + dlc = ioread32(&amp;priv-&gt;regs-&gt;if2_mcont) &amp; CAN_IF_MCONT_DLC;
</I>&gt;&gt;&gt;<i> + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, int_stat);
</I>&gt;&gt;&gt;<i> + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> + if (dlc &gt; 8)
</I>&gt;&gt;&gt;<i> +  dlc = 8;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> use get_can_dlc
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> + stats-&gt;tx_bytes += dlc;
</I>&gt;&gt;&gt;<i> + stats-&gt;tx_packets++;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_can_rx_poll(struct napi_struct *napi, int quota)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + struct net_device *ndev = napi-&gt;dev;
</I>&gt;&gt;&gt;<i> + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> + u32 int_stat;
</I>&gt;&gt;&gt;<i> + int rcv_pkts = 0;
</I>&gt;&gt;&gt;<i> + u32 reg_stat;
</I>&gt;&gt;&gt;<i> + unsigned long flags;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + int_stat = pch_can_int_pending(priv);
</I>&gt;&gt;&gt;<i> + if (!int_stat)
</I>&gt;&gt;&gt;<i> +  goto END;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + if ((int_stat == CAN_STATUS_INT) &amp;&amp; (quota &gt; 0)) {
</I>&gt;&gt;&gt;<i> +  reg_stat = ioread32(&amp;priv-&gt;regs-&gt;stat);
</I>&gt;&gt;&gt;<i> +  if (reg_stat &amp; (PCH_BUS_OFF | PCH_LEC_ALL)) {
</I>&gt;&gt;&gt;<i> +   if ((reg_stat &amp; PCH_LEC_ALL) != PCH_LEC_ALL) {
</I>&gt;&gt;&gt;<i> +    pch_can_error(ndev, reg_stat);
</I>&gt;&gt;&gt;<i> +    quota--;
</I>&gt;&gt;&gt;<i> +   }
</I>&gt;&gt;&gt;<i> +  }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  if (reg_stat &amp; PCH_TX_OK) {
</I>&gt;&gt;&gt;<i> +   spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +   iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +   pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq,
</I>&gt;&gt;&gt;<i> +            ioread32(&amp;priv-&gt;regs-&gt;intr));
</I>&gt;&gt;<i>                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Isn't this &quot;int_stat&quot;. Might it be possilbe that regs-&gt;intr changes
</I>&gt;&gt;<i> between the pch_can_int_pending and here?
</I>&gt;<i> 
</I>&gt;<i> This code was mistake.
</I>&gt;<i> This condition, message object is not acccessed.
</I>&gt;<i> Thus, pch_can_check_if_busy can be deleted.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> What should this transfer do?
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +   spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +   pch_can_bit_clear(&amp;priv-&gt;regs-&gt;stat, PCH_TX_OK);
</I>&gt;&gt;&gt;<i> +  }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  if (reg_stat &amp; PCH_RX_OK)
</I>&gt;&gt;&gt;<i> +   pch_can_bit_clear(&amp;priv-&gt;regs-&gt;stat, PCH_RX_OK);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  int_stat = pch_can_int_pending(priv);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + if (quota == 0)
</I>&gt;&gt;&gt;<i> +  goto END;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + if ((int_stat &gt;= 1) &amp;&amp; (int_stat &lt;= PCH_RX_OBJ_NUM)) {
</I>&gt;&gt;&gt;<i> +  spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +  rcv_pkts += pch_can_rx_normal(ndev, int_stat, quota);
</I>&gt;&gt;&gt;<i> +  spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +  quota -= rcv_pkts;
</I>&gt;&gt;&gt;<i> +  if (rcv_pkts &lt; 0)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> how can this happen?
</I>&gt;<i> 
</I>&gt;<i> My mistake.
</I>&gt;<i> if (quota &lt; 0) is TRUE.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +   goto END;
</I>&gt;&gt;&gt;<i> + } else if ((int_stat &gt; PCH_RX_OBJ_NUM) &amp;&amp; (int_stat &lt;= PCH_OBJ_NUM)) {
</I>&gt;&gt;&gt;<i> +  /* Handle transmission interrupt */
</I>&gt;&gt;&gt;<i> +  pch_can_tx_complete(ndev, int_stat);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +END:
</I>&gt;&gt;&gt;<i> + napi_complete(napi);
</I>&gt;&gt;&gt;<i> + pch_can_set_int_enables(priv, PCH_CAN_ALL);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + return rcv_pkts;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_set_bittiming(struct net_device *ndev)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> + const struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
</I>&gt;&gt;&gt;<i> + u32 canbit;
</I>&gt;&gt;&gt;<i> + u32 bepe;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Setting the CCE bit for accessing the Can Timing register. */
</I>&gt;&gt;&gt;<i> + pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_CCE);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + canbit = (bt-&gt;brp - 1) &amp; MSK_BITT_BRP;
</I>&gt;&gt;&gt;<i> + canbit |= (bt-&gt;sjw - 1) &lt;&lt; BIT_BITT_SJW;
</I>&gt;&gt;&gt;<i> + canbit |= (bt-&gt;phase_seg1 + bt-&gt;prop_seg - 1) &lt;&lt; BIT_BITT_TSEG1;
</I>&gt;&gt;&gt;<i> + canbit |= (bt-&gt;phase_seg2 - 1) &lt;&lt; BIT_BITT_TSEG2;
</I>&gt;&gt;&gt;<i> + bepe = ((bt-&gt;brp - 1) &amp; MSK_BRPE_BRPE) &gt;&gt; BIT_BRPE_BRPE;
</I>&gt;&gt;&gt;<i> + iowrite32(canbit, &amp;priv-&gt;regs-&gt;bitt);
</I>&gt;&gt;&gt;<i> + iowrite32(bepe, &amp;priv-&gt;regs-&gt;brpe);
</I>&gt;&gt;&gt;<i> + pch_can_bit_clear(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_CCE);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + return 0;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_start(struct net_device *ndev)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + if (priv-&gt;can.state != CAN_STATE_STOPPED)
</I>&gt;&gt;&gt;<i> +  pch_can_reset(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + pch_set_bittiming(ndev);
</I>&gt;&gt;&gt;<i> + pch_can_set_optmode(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + pch_can_tx_enable_all(priv);
</I>&gt;&gt;&gt;<i> + pch_can_rx_enable_all(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Setting the CAN to run mode. */
</I>&gt;&gt;&gt;<i> + pch_can_set_run_mode(priv, PCH_CAN_RUN);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + return;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_can_do_set_mode(struct net_device *ndev, enum can_mode mode)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + int ret = 0;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + switch (mode) {
</I>&gt;&gt;&gt;<i> + case CAN_MODE_START:
</I>&gt;&gt;&gt;<i> +  pch_can_start(ndev);
</I>&gt;&gt;&gt;<i> +  netif_wake_queue(ndev);
</I>&gt;&gt;&gt;<i> +  break;
</I>&gt;&gt;&gt;<i> + default:
</I>&gt;&gt;&gt;<i> +  ret = -EOPNOTSUPP;
</I>&gt;&gt;&gt;<i> +  break;
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + return ret;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_can_open(struct net_device *ndev)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> + int retval;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Regsitering the interrupt. */
</I>&gt;&gt;&gt;<i> + retval = request_irq(priv-&gt;dev-&gt;irq, pch_can_interrupt, IRQF_SHARED,
</I>&gt;&gt;&gt;<i> +        ndev-&gt;name, ndev);
</I>&gt;&gt;&gt;<i> + if (retval) {
</I>&gt;&gt;&gt;<i> +  dev_err(&amp;ndev-&gt;dev, &quot;request_irq failed.\n&quot;);
</I>&gt;&gt;&gt;<i> +  goto req_irq_err;
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Open common can device */
</I>&gt;&gt;&gt;<i> + retval = open_candev(ndev);
</I>&gt;&gt;&gt;<i> + if (retval) {
</I>&gt;&gt;&gt;<i> +  dev_err(ndev-&gt;dev.parent, &quot;open_candev() failed %d\n&quot;, retval);
</I>&gt;&gt;&gt;<i> +  goto err_open_candev;
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + pch_can_init(priv);
</I>&gt;&gt;&gt;<i> + pch_can_start(ndev);
</I>&gt;&gt;&gt;<i> + napi_enable(&amp;priv-&gt;napi);
</I>&gt;&gt;&gt;<i> + netif_start_queue(ndev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + return 0;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +err_open_candev:
</I>&gt;&gt;&gt;<i> + free_irq(priv-&gt;dev-&gt;irq, ndev);
</I>&gt;&gt;&gt;<i> +req_irq_err:
</I>&gt;&gt;&gt;<i> + pch_can_release(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + return retval;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_close(struct net_device *ndev)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + netif_stop_queue(ndev);
</I>&gt;&gt;&gt;<i> + napi_disable(&amp;priv-&gt;napi);
</I>&gt;&gt;&gt;<i> + pch_can_release(priv);
</I>&gt;&gt;&gt;<i> + free_irq(priv-&gt;dev-&gt;irq, ndev);
</I>&gt;&gt;&gt;<i> + close_candev(ndev);
</I>&gt;&gt;&gt;<i> + priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;&gt;&gt;<i> + return 0;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + unsigned long flags;
</I>&gt;&gt;&gt;<i> + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> + struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;&gt;&gt;<i> + int tx_buffer_avail = 0;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> What I'm totally missing is the TX flow controll. Your driver has to
</I>&gt;&gt;<i> ensure that the package leave the controller in the order that come
</I>&gt;&gt;<i> into the xmit function. Further you have to stop your xmit queue if
</I>&gt;&gt;<i> you're out of tx objects and reenable if you have a object free.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Use netif_stop_queue() and netif_wake_queue() for this.
</I>&gt;<i> 
</I>&gt;<i> In this code, I think &quot;out of tx objects&quot; cannot be  occurred.
</I>
It's not a matter of code it's the hardware. You cannot put more than a
certain number of CAN frames into the hardware. If you have a CAN bus at
a certain speed, you can only send a certain number of CAN frames in a
second. So you cannot push more than this amount of frames/s into the
hardware.

&gt;<i> Nevertheless, are netif_stop_queue() and netif_wake_queue() is necessary ?
</I>
Yes.

&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + if (can_dropped_invalid_skb(ndev, skb))
</I>&gt;&gt;&gt;<i> +  return NETDEV_TX_OK;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + if (priv-&gt;tx_obj == (PCH_OBJ_NUM + 1)) { /* Point tail Obj + 1 */
</I>&gt;&gt;&gt;<i> +  while (ioread32(&amp;priv-&gt;regs-&gt;treq2) &amp; 0xfc00)
</I>&gt;&gt;&gt;<i> +   udelay(1);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> please no (possible) infinite delays!
</I>&gt;<i> 
</I>&gt;<i> I will add break processing.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +  priv-&gt;tx_obj = PCH_RX_OBJ_NUM + 1; /* Point head of Tx Obj ID */
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + tx_buffer_avail = priv-&gt;tx_obj;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> why has the &quot;object&quot; become a &quot;buffer&quot; now? :)
</I>&gt;<i> 
</I>&gt;<i> You are right.
</I>&gt;<i> I will modify the name.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> + priv-&gt;tx_obj++;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Attaining the lock. */
</I>&gt;&gt;&gt;<i> + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Setting the CMASK register to set value*/
</I>&gt;&gt;<i>                                                  ^^^
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> pleas add a whitespace
</I>&gt;<i> 
</I>&gt;<i> I agree.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> + iowrite32(CAN_CMASK_RX_TX_SET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* If ID extended is set. */
</I>&gt;&gt;&gt;<i> + if (cf-&gt;can_id &amp; CAN_EFF_FLAG) {
</I>&gt;&gt;&gt;<i> +  iowrite32(cf-&gt;can_id &amp; 0xffff, &amp;priv-&gt;regs-&gt;if2_id1);
</I>&gt;&gt;&gt;<i> +  iowrite32(((cf-&gt;can_id &gt;&gt; 16) &amp; 0x1fff) | CAN_ID2_XTD,
</I>&gt;&gt;&gt;<i> +       &amp;priv-&gt;regs-&gt;if2_id2);
</I>&gt;&gt;&gt;<i> + } else {
</I>&gt;&gt;&gt;<i> +  iowrite32(0, &amp;priv-&gt;regs-&gt;if2_id1);
</I>&gt;&gt;&gt;<i> +  iowrite32((cf-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; 2,
</I>&gt;&gt;&gt;<i> +      &amp;priv-&gt;regs-&gt;if2_id2);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id2, CAN_ID_MSGVAL);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Do you need to do a read-modify-write of the hardware register? Please
</I>&gt;&gt;<i> prepare the values you want to write to hardware, then do it.
</I>&gt;<i> 
</I>&gt;<i> Current design policy for read/write message object,
</I>&gt;<i> the driver is designed with Read-Modify-Write.
</I>&gt;<i> 
</I>&gt;<i> I will modify to Write only for reducing accessing Message RAM.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* If remote frame has to be transmitted.. */
</I>&gt;&gt;&gt;<i> + if (!(cf-&gt;can_id &amp; CAN_RTR_FLAG))
</I>&gt;&gt;&gt;<i> +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id2, CAN_ID2_DIR);
</I>&gt;&gt;<i> dito
</I>&gt;&gt;&gt;<i> + /* If remote frame has to be transmitted.. */
</I>&gt;&gt;&gt;<i> + if (cf-&gt;can_id &amp; CAN_RTR_FLAG)
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_id2, CAN_ID2_DIR);
</I>&gt;&gt;<i> dito
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Copy data to register */
</I>&gt;&gt;&gt;<i> + if (cf-&gt;can_dlc &gt; 0) {
</I>&gt;&gt;&gt;<i> +  u32 data1 = *((u16 *)&amp;cf-&gt;data[0]);
</I>&gt;&gt;&gt;<i> +  iowrite32(data1, &amp;priv-&gt;regs-&gt;if2_dataa1);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> do you think you send the bytes in correct order?
</I>&gt;<i> 
</I>&gt;<i> Let me study this endianess.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> + if (cf-&gt;can_dlc &gt; 2) {
</I>&gt;&gt;&gt;<i> +  u32 data1 = *((u16 *)&amp;cf-&gt;data[2]);
</I>&gt;&gt;&gt;<i> +  iowrite32(data1, &amp;priv-&gt;regs-&gt;if2_dataa2);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> + if (cf-&gt;can_dlc &gt; 4) {
</I>&gt;&gt;&gt;<i> +  u32 data1 = *((u16 *)&amp;cf-&gt;data[4]);
</I>&gt;&gt;&gt;<i> +  iowrite32(data1, &amp;priv-&gt;regs-&gt;if2_datab1);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> + if (cf-&gt;can_dlc &gt; 6) {
</I>&gt;&gt;&gt;<i> +  u32 data1 = *((u16 *)&amp;cf-&gt;data[6]);
</I>&gt;&gt;&gt;<i> +  iowrite32(data1, &amp;priv-&gt;regs-&gt;if2_datab2);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + can_put_echo_skb(skb, ndev, tx_buffer_avail - PCH_RX_OBJ_NUM - 1);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Set the size of the data. */
</I>&gt;&gt;&gt;<i> + iowrite32(cf-&gt;can_dlc, &amp;priv-&gt;regs-&gt;if2_mcont);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Update if2_mcont */
</I>&gt;&gt;&gt;<i> + pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_mcont,
</I>&gt;&gt;&gt;<i> +   CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_TXRQXT |
</I>&gt;&gt;&gt;<i> +   CAN_IF_MCONT_TXIE);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> pleae first perpare your value, then write to hardware.
</I>&gt;<i> 
</I>&gt;<i> ditto.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + if (tx_buffer_avail == PCH_RX_OBJ_NUM) /* If points tail of FIFO  */
</I>&gt;&gt;&gt;<i> +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_mcont, CAN_IF_MCONT_EOB);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> dito
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Is EOB relevant for TX objects?
</I>&gt;<i> 
</I>&gt;<i> This is mistake. No meaning for tx.
</I>&gt;<i> I will modify.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, tx_buffer_avail);
</I>&gt;&gt;&gt;<i> + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + return NETDEV_TX_OK;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static const struct net_device_ops pch_can_netdev_ops = {
</I>&gt;&gt;&gt;<i> + .ndo_open  = pch_can_open,
</I>&gt;&gt;&gt;<i> + .ndo_stop  = pch_close,
</I>&gt;&gt;&gt;<i> + .ndo_start_xmit  = pch_xmit,
</I>&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void __devexit pch_can_remove(struct pci_dev *pdev)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + struct net_device *ndev = pci_get_drvdata(pdev);
</I>&gt;&gt;&gt;<i> + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + unregister_candev(priv-&gt;ndev);
</I>&gt;&gt;&gt;<i> + pci_iounmap(pdev, priv-&gt;regs);
</I>&gt;&gt;&gt;<i> + if (priv-&gt;use_msi)
</I>&gt;&gt;&gt;<i> +  pci_disable_msi(priv-&gt;dev);
</I>&gt;&gt;&gt;<i> + pci_release_regions(pdev);
</I>&gt;&gt;&gt;<i> + pci_disable_device(pdev);
</I>&gt;&gt;&gt;<i> + pci_set_drvdata(pdev, NULL);
</I>&gt;&gt;&gt;<i> + free_candev(priv-&gt;ndev);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#ifdef CONFIG_PM
</I>&gt;&gt;&gt;<i> +static void pch_can_set_int_custom(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + /* Clearing the IE, SIE and EIE bits of Can control register. */
</I>&gt;&gt;&gt;<i> + pch_can_bit_clear(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_IE_SIE_EIE);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Appropriately setting them. */
</I>&gt;&gt;&gt;<i> + pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont,
</I>&gt;&gt;&gt;<i> +   ((priv-&gt;int_enables &amp; MSK_CTRL_IE_SIE_EIE) &lt;&lt; 1));
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +/* This function retrieves interrupt enabled for the CAN device. */
</I>&gt;&gt;&gt;<i> +static u32 pch_can_get_int_enables(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + /* Obtaining the status of IE, SIE and EIE interrupt bits. */
</I>&gt;&gt;&gt;<i> + return (ioread32(&amp;priv-&gt;regs-&gt;cont) &amp; CAN_CTRL_IE_SIE_EIE) &gt;&gt; 1;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static u32 pch_can_get_rx_enable(struct pch_can_priv *priv, u32 buff_num)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + unsigned long flags;
</I>&gt;&gt;&gt;<i> + u32 enable;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> + iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buff_num);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + if (((ioread32(&amp;priv-&gt;regs-&gt;if1_id2)) &amp; CAN_ID_MSGVAL) &amp;&amp;
</I>&gt;&gt;&gt;<i> +   ((ioread32(&amp;priv-&gt;regs-&gt;if1_mcont)) &amp;
</I>&gt;&gt;&gt;<i> +   CAN_IF_MCONT_RXIE))
</I>&gt;&gt;&gt;<i> +  enable = 1;
</I>&gt;&gt;&gt;<i> + else
</I>&gt;&gt;&gt;<i> +  enable = 0;
</I>&gt;&gt;&gt;<i> + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> + return enable;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static u32 pch_can_get_tx_enable(struct pch_can_priv *priv, u32 buff_num)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + unsigned long flags;
</I>&gt;&gt;&gt;<i> + u32 enable;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, buff_num);
</I>&gt;&gt;&gt;<i> + if (((ioread32(&amp;priv-&gt;regs-&gt;if2_id2)) &amp; CAN_ID_MSGVAL) &amp;&amp;
</I>&gt;&gt;&gt;<i> +   ((ioread32(&amp;priv-&gt;regs-&gt;if2_mcont)) &amp;
</I>&gt;&gt;&gt;<i> +   CAN_IF_MCONT_TXIE)) {
</I>&gt;&gt;&gt;<i> +  enable = 1;
</I>&gt;&gt;&gt;<i> + } else {
</I>&gt;&gt;&gt;<i> +  enable = 0;
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + return enable;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_set_rx_buffer_link(struct pch_can_priv *priv,
</I>&gt;&gt;&gt;<i> +           u32 buffer_num, u32 set)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + unsigned long flags;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> + iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buffer_num);
</I>&gt;&gt;&gt;<i> + iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> + if (set == 1)
</I>&gt;&gt;&gt;<i> +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont, CAN_IF_MCONT_EOB);
</I>&gt;&gt;&gt;<i> + else
</I>&gt;&gt;&gt;<i> +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if1_mcont, CAN_IF_MCONT_EOB);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buffer_num);
</I>&gt;&gt;&gt;<i> + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static u32 pch_can_get_rx_buffer_link(struct pch_can_priv *priv, u32 buffer_num)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + unsigned long flags;
</I>&gt;&gt;&gt;<i> + u32 link;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> + iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buffer_num);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + if (ioread32(&amp;priv-&gt;regs-&gt;if1_mcont) &amp; CAN_IF_MCONT_EOB)
</I>&gt;&gt;&gt;<i> +  link = 0;
</I>&gt;&gt;&gt;<i> + else
</I>&gt;&gt;&gt;<i> +  link = 1;
</I>&gt;&gt;&gt;<i> + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> + return link;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + int i;
</I>&gt;&gt;&gt;<i> + int retval;
</I>&gt;&gt;&gt;<i> + u32 buf_stat; /* Variable for reading the transmit buffer status. */
</I>&gt;&gt;&gt;<i> + u32 counter = COUNTER_LIMIT;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + struct net_device *dev = pci_get_drvdata(pdev);
</I>&gt;&gt;&gt;<i> + struct pch_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Stop the CAN controller */
</I>&gt;&gt;&gt;<i> + pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Indicate that we are aboutto/in suspend */
</I>&gt;&gt;&gt;<i> + priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Waiting for all transmission to complete. */
</I>&gt;&gt;&gt;<i> + while (counter) {
</I>&gt;&gt;&gt;<i> +  buf_stat = pch_can_get_buffer_status(priv);
</I>&gt;&gt;&gt;<i> +  if (!buf_stat)
</I>&gt;&gt;&gt;<i> +   break;
</I>&gt;&gt;&gt;<i> +  counter--;
</I>&gt;&gt;&gt;<i> +  udelay(1);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> + if (!counter)
</I>&gt;&gt;&gt;<i> +  dev_err(&amp;pdev-&gt;dev, &quot;%s -&gt; Transmission time out.\n&quot;, __func__);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Save interrupt configuration and then disable them */
</I>&gt;&gt;&gt;<i> + priv-&gt;int_enables = pch_can_get_int_enables(priv);
</I>&gt;&gt;&gt;<i> + pch_can_set_int_enables(priv, PCH_CAN_DISABLE);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Save Tx buffer enable state */
</I>&gt;&gt;&gt;<i> + for (i = PCH_RX_OBJ_NUM + 1; i &lt;= PCH_OBJ_NUM; i++)
</I>&gt;&gt;&gt;<i> +  priv-&gt;tx_enable[i] = pch_can_get_tx_enable(priv, i);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Disable all Transmit buffers */
</I>&gt;&gt;&gt;<i> + pch_can_tx_disable_all(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Save Rx buffer enable state */
</I>&gt;&gt;&gt;<i> + for (i = 1; i &lt;= PCH_RX_OBJ_NUM; i++) {
</I>&gt;&gt;&gt;<i> +  priv-&gt;rx_enable[i] = pch_can_get_rx_enable(priv, i);
</I>&gt;&gt;&gt;<i> +  priv-&gt;rx_link[i] = pch_can_get_rx_buffer_link(priv, i);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Disable all Receive buffers */
</I>&gt;&gt;&gt;<i> + pch_can_rx_disable_all(priv);
</I>&gt;&gt;&gt;<i> + retval = pci_save_state(pdev);
</I>&gt;&gt;&gt;<i> + if (retval) {
</I>&gt;&gt;&gt;<i> +  dev_err(&amp;pdev-&gt;dev, &quot;pci_save_state failed.\n&quot;);
</I>&gt;&gt;&gt;<i> + } else {
</I>&gt;&gt;&gt;<i> +  pci_enable_wake(pdev, PCI_D3hot, 0);
</I>&gt;&gt;&gt;<i> +  pci_disable_device(pdev);
</I>&gt;&gt;&gt;<i> +  pci_set_power_state(pdev, pci_choose_state(pdev, state));
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + return retval;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_can_resume(struct pci_dev *pdev)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + int i;
</I>&gt;&gt;&gt;<i> + int retval;
</I>&gt;&gt;&gt;<i> + struct net_device *dev = pci_get_drvdata(pdev);
</I>&gt;&gt;&gt;<i> + struct pch_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + pci_set_power_state(pdev, PCI_D0);
</I>&gt;&gt;&gt;<i> + pci_restore_state(pdev);
</I>&gt;&gt;&gt;<i> + retval = pci_enable_device(pdev);
</I>&gt;&gt;&gt;<i> + if (retval) {
</I>&gt;&gt;&gt;<i> +  dev_err(&amp;pdev-&gt;dev, &quot;pci_enable_device failed.\n&quot;);
</I>&gt;&gt;&gt;<i> +  return retval;
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + pci_enable_wake(pdev, PCI_D3hot, 0);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Disabling all interrupts. */
</I>&gt;&gt;&gt;<i> + pch_can_set_int_enables(priv, PCH_CAN_DISABLE);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Setting the CAN device in Stop Mode. */
</I>&gt;&gt;&gt;<i> + pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Configuring the transmit and receive buffers. */
</I>&gt;&gt;&gt;<i> + pch_can_config_rx_tx_buffers(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Restore the CAN state */
</I>&gt;&gt;&gt;<i> + pch_set_bittiming(dev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Listen/Active */
</I>&gt;&gt;&gt;<i> + pch_can_set_optmode(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Enabling the transmit buffer. */
</I>&gt;&gt;&gt;<i> + for (i = 1; i &lt;= PCH_RX_OBJ_NUM; i++)
</I>&gt;&gt;&gt;<i> +  pch_can_set_tx_enable(priv, i, priv-&gt;tx_enable[i]);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Configuring the receive buffer and enabling them. */
</I>&gt;&gt;&gt;<i> + for (i = PCH_RX_OBJ_NUM + 1; i &lt;= PCH_OBJ_NUM; i++) {
</I>&gt;&gt;&gt;<i> +  /* Restore buffer link */
</I>&gt;&gt;&gt;<i> +  pch_can_set_rx_buffer_link(priv, i, priv-&gt;rx_link[i]);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +  /* Restore buffer enables */
</I>&gt;&gt;&gt;<i> +  pch_can_set_rx_enable(priv, i, priv-&gt;rx_enable[i]);
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Enable CAN Interrupts */
</I>&gt;&gt;&gt;<i> + pch_can_set_int_custom(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + /* Restore Run Mode */
</I>&gt;&gt;&gt;<i> + pch_can_set_run_mode(priv, PCH_CAN_RUN);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + return retval;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +#else
</I>&gt;&gt;&gt;<i> +#define pch_can_suspend NULL
</I>&gt;&gt;&gt;<i> +#define pch_can_resume NULL
</I>&gt;&gt;&gt;<i> +#endif
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_can_get_berr_counter(const struct net_device *dev,
</I>&gt;&gt;&gt;<i> +        struct can_berr_counter *bec)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + struct pch_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + bec-&gt;txerr = ioread32(&amp;priv-&gt;regs-&gt;errc) &amp; CAN_TEC;
</I>&gt;&gt;&gt;<i> + bec-&gt;rxerr = (ioread32(&amp;priv-&gt;regs-&gt;errc) &amp; CAN_REC) &gt;&gt; 8;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + return 0;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int __devinit pch_can_probe(struct pci_dev *pdev,
</I>&gt;&gt;&gt;<i> +       const struct pci_device_id *id)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + struct net_device *ndev;
</I>&gt;&gt;&gt;<i> + struct pch_can_priv *priv;
</I>&gt;&gt;&gt;<i> + int rc;
</I>&gt;&gt;&gt;<i> + void __iomem *addr;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + rc = pci_enable_device(pdev);
</I>&gt;&gt;&gt;<i> + if (rc) {
</I>&gt;&gt;&gt;<i> +  dev_err(&amp;pdev-&gt;dev, &quot;Failed pci_enable_device %d\n&quot;, rc);
</I>&gt;&gt;&gt;<i> +  goto probe_exit_endev;
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + rc = pci_request_regions(pdev, KBUILD_MODNAME);
</I>&gt;&gt;&gt;<i> + if (rc) {
</I>&gt;&gt;&gt;<i> +  dev_err(&amp;pdev-&gt;dev, &quot;Failed pci_request_regions %d\n&quot;, rc);
</I>&gt;&gt;&gt;<i> +  goto probe_exit_pcireq;
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + addr = pci_iomap(pdev, 1, 0);
</I>&gt;&gt;&gt;<i> + if (!addr) {
</I>&gt;&gt;&gt;<i> +  rc = -EIO;
</I>&gt;&gt;&gt;<i> +  dev_err(&amp;pdev-&gt;dev, &quot;Failed pci_iomap\n&quot;);
</I>&gt;&gt;&gt;<i> +  goto probe_exit_ipmap;
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + ndev = alloc_candev(sizeof(struct pch_can_priv), PCH_TX_OBJ_NUM);
</I>&gt;&gt;&gt;<i> + if (!ndev) {
</I>&gt;&gt;&gt;<i> +  rc = -ENOMEM;
</I>&gt;&gt;&gt;<i> +  dev_err(&amp;pdev-&gt;dev, &quot;Failed alloc_candev\n&quot;);
</I>&gt;&gt;&gt;<i> +  goto probe_exit_alloc_candev;
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> + priv-&gt;ndev = ndev;
</I>&gt;&gt;&gt;<i> + priv-&gt;regs = addr;
</I>&gt;&gt;&gt;<i> + priv-&gt;dev = pdev;
</I>&gt;&gt;&gt;<i> + priv-&gt;can.bittiming_const = &amp;pch_can_bittiming_const;
</I>&gt;&gt;&gt;<i> + priv-&gt;can.do_set_mode = pch_can_do_set_mode;
</I>&gt;&gt;&gt;<i> + priv-&gt;can.do_get_berr_counter = pch_can_get_berr_counter;
</I>&gt;&gt;&gt;<i> + priv-&gt;can.ctrlmode_supported = CAN_CTRLMODE_LISTENONLY |
</I>&gt;&gt;&gt;<i> +           CAN_CTRLMODE_LOOPBACK;
</I>&gt;&gt;&gt;<i> + priv-&gt;tx_obj = PCH_RX_OBJ_NUM + 1; /* Point head of Tx Obj */
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + ndev-&gt;irq = pdev-&gt;irq;
</I>&gt;&gt;&gt;<i> + ndev-&gt;flags |= IFF_ECHO;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + pci_set_drvdata(pdev, ndev);
</I>&gt;&gt;&gt;<i> + SET_NETDEV_DEV(ndev, &amp;pdev-&gt;dev);
</I>&gt;&gt;&gt;<i> + ndev-&gt;netdev_ops = &amp;pch_can_netdev_ops;
</I>&gt;&gt;&gt;<i> + priv-&gt;can.clock.freq = PCH_CAN_CLK; /* Hz */
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + netif_napi_add(ndev, &amp;priv-&gt;napi, pch_can_rx_poll, PCH_RX_OBJ_NUM);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + rc = pci_enable_msi(priv-&gt;dev);
</I>&gt;&gt;&gt;<i> + if (rc) {
</I>&gt;&gt;&gt;<i> +  dev_info(&amp;ndev-&gt;dev, &quot;PCH CAN opened without MSI\n&quot;);
</I>&gt;&gt;&gt;<i> +  priv-&gt;use_msi = 0;
</I>&gt;&gt;&gt;<i> + } else {
</I>&gt;&gt;&gt;<i> +  dev_info(&amp;ndev-&gt;dev, &quot;PCH CAN opened with MSI\n&quot;);
</I>&gt;&gt;&gt;<i> +  priv-&gt;use_msi = 1;
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + rc = register_candev(ndev);
</I>&gt;&gt;&gt;<i> + if (rc) {
</I>&gt;&gt;&gt;<i> +  dev_err(&amp;pdev-&gt;dev, &quot;Failed register_candev %d\n&quot;, rc);
</I>&gt;&gt;&gt;<i> +  goto probe_exit_reg_candev;
</I>&gt;&gt;&gt;<i> + }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> + return 0;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +probe_exit_reg_candev:
</I>&gt;&gt;&gt;<i> + free_candev(ndev);
</I>&gt;&gt;&gt;<i> +probe_exit_alloc_candev:
</I>&gt;&gt;&gt;<i> + pci_iounmap(pdev, addr);
</I>&gt;&gt;&gt;<i> +probe_exit_ipmap:
</I>&gt;&gt;&gt;<i> + pci_release_regions(pdev);
</I>&gt;&gt;&gt;<i> +probe_exit_pcireq:
</I>&gt;&gt;&gt;<i> + pci_disable_device(pdev);
</I>&gt;&gt;&gt;<i> +probe_exit_endev:
</I>&gt;&gt;&gt;<i> + return rc;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static struct pci_driver pch_can_pcidev = {
</I>&gt;&gt;&gt;<i> + .name = &quot;pch_can&quot;,
</I>&gt;&gt;&gt;<i> + .id_table = pch_pci_tbl,
</I>&gt;&gt;&gt;<i> + .probe = pch_can_probe,
</I>&gt;&gt;&gt;<i> + .remove = __devexit_p(pch_can_remove),
</I>&gt;&gt;&gt;<i> + .suspend = pch_can_suspend,
</I>&gt;&gt;&gt;<i> + .resume = pch_can_resume,
</I>&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int __init pch_can_pci_init(void)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + return pci_register_driver(&amp;pch_can_pcidev);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +module_init(pch_can_pci_init);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void __exit pch_can_pci_exit(void)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> + pci_unregister_driver(&amp;pch_can_pcidev);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +module_exit(pch_can_pci_exit);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +MODULE_DESCRIPTION(&quot;Intel EG20T PCH CAN(Controller Area Network) Driver&quot;);
</I>&gt;&gt;&gt;<i> +MODULE_LICENSE(&quot;GPL v2&quot;);
</I>&gt;&gt;&gt;<i> +MODULE_VERSION(&quot;0.94&quot;);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> cheers, Marc
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> -- 
</I>&gt;&gt;<i> Pengutronix e.K.                  | Marc Kleine-Budde           |
</I>&gt;&gt;<i> Industrial Linux Solutions        | Phone: +49-231-2826-924     |
</I>&gt;&gt;<i> Vertretung West/Dortmund          | Fax:   +49-5121-206917-5555 |
</I>&gt;&gt;<i> Amtsgericht Hildesheim, HRA 2686  | <A HREF="http://www.pengutronix.de">http://www.pengutronix.de</A>   |
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Thanks, Tomoya(OKI SEMICONDUCTOR CO., LTD.)
</I>
cheers, Marc

-- 
Pengutronix e.K.                  | Marc Kleine-Budde           |
Industrial Linux Solutions        | Phone: +49-231-2826-924     |
Vertretung West/Dortmund          | Fax:   +49-5121-206917-5555 |
Amtsgericht Hildesheim, HRA 2686  | <A HREF="http://www.pengutronix.de">http://www.pengutronix.de</A>   |

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 262 bytes
Desc: OpenPGP digital signature
URL: &lt;<A HREF="https://lists.berlios.de/pipermail/socketcan-core/attachments/20101102/4d495d06/attachment.pgp">https://lists.berlios.de/pipermail/socketcan-core/attachments/20101102/4d495d06/attachment.pgp</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004910.html">[PATCH net-next-2.6 v2] can: Topcliff: PCH_CAN driver: Fix build	warnings
</A></li>
	<LI>Next message: <A HREF="004947.html">[PATCH net-next-2.6 v2] can: Topcliff: PCH_CAN driver: Fix build	warnings
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4911">[ date ]</a>
              <a href="thread.html#4911">[ thread ]</a>
              <a href="subject.html#4911">[ subject ]</a>
              <a href="author.html#4911">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
