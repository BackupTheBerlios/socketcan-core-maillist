<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [RFC PATCH 2/4 RESEND] Bosch CCAN driver
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2010-August/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BRFC%20PATCH%202/4%20RESEND%5D%20Bosch%20CCAN%20driver&In-Reply-To=%3CD5ECB3C7A6F99444980976A8C6D8963816A09367F3%40EAPEX1MAIL1.st.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004582.html">
   <LINK REL="Next"  HREF="004584.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[RFC PATCH 2/4 RESEND] Bosch CCAN driver</H1>
    <B>Bhupesh SHARMA</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BRFC%20PATCH%202/4%20RESEND%5D%20Bosch%20CCAN%20driver&In-Reply-To=%3CD5ECB3C7A6F99444980976A8C6D8963816A09367F3%40EAPEX1MAIL1.st.com%3E"
       TITLE="[RFC PATCH 2/4 RESEND] Bosch CCAN driver">bhupesh.sharma at st.com
       </A><BR>
    <I>Tue Aug 31 12:32:44 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="004582.html">[RFC PATCH 2/4 RESEND] Bosch CCAN driver
</A></li>
        <LI>Next message: <A HREF="004584.html">[RFC PATCH 2/4 RESEND] Bosch CCAN driver
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4583">[ date ]</a>
              <a href="thread.html#4583">[ thread ]</a>
              <a href="subject.html#4583">[ subject ]</a>
              <a href="author.html#4583">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Wolfgang,

Thanks for your inputs. Please see my comments below:

&gt;<i> &gt; Signed-off-by: Bhupesh Sharma &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">bhupesh.sharma at st.com</A>&gt;
</I>&gt;<i>
</I>&gt;<i> Please truncate to the usual &lt; 80 lines for readability.
</I>
I am myself not a big supporter of &lt; 80 lines being mandatory, especially if it is in a place like this.
Please see Linus' comments on the same here:
<A HREF="http://www.linux-archive.org/device-mapper-development/295901-drop-80-character-limit-checkpatch-pl.html">http://www.linux-archive.org/device-mapper-development/295901-drop-80-character-limit-checkpatch-pl.html</A>

&gt;<i> &gt;
</I>&gt;<i> &gt; Index: bosch_ccan.c
</I>&gt;<i> &gt; ===================================================================
</I>&gt;<i> &gt; --- bosch_ccan.c        (revision 0)
</I>&gt;<i> &gt; +++ bosch_ccan.c        (revision 0)
</I>&gt;<i> &gt; @@ -0,0 +1,858 @@
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * drivers/net/can/bosch_ccan.c
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * CAN bus driver for Bosch CCAN controller
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Copyright (C) 2010 ST Microelectronics
</I>&gt;<i> &gt; + * Bhupesh Sharma &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">bhupesh.sharma at st.com</A>&gt;
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Borrowed heavily from the CCAN driver originally written by:
</I>&gt;<i> &gt; + * - Sascha Hauer, Marc Kleine-Budde, Pengutronix
</I>&gt;<i> &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">s.hauer at pengutronix.de</A>&gt;
</I>&gt;<i> &gt; + * - Simon Kallweit, intefo AG &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">simon.kallweit at intefo.ch</A>&gt;
</I>&gt;<i> &gt; + * which can be viewed here:
</I>&gt;<i> &gt; + * <A HREF="http://svn.berlios.de/svnroot/repos/socketcan/trunk/kernel/2.6/">http://svn.berlios.de/svnroot/repos/socketcan/trunk/kernel/2.6/</A>
</I>&gt;<i> &gt; + * drivers/net/can/old/ccan/ccan.c
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Bosch CCAN controller is compliant to CAN protocol version 2.0
</I>&gt;<i> part A and B.
</I>&gt;<i> &gt; + * Bosch CCAN user manual can be obtained from:
</I>&gt;<i> &gt; + * <A HREF="http://www.semiconductors.bosch.de/pdf/Users_Manual_C_CAN.pdf">http://www.semiconductors.bosch.de/pdf/Users_Manual_C_CAN.pdf</A>
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * TODO:
</I>&gt;<i> &gt; + * - Add support for IF2 in Basic mode.
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * This file is licensed under the terms of the GNU General Public
</I>&gt;<i> &gt; + * License version 2. This program is licensed &quot;as is&quot; without any
</I>&gt;<i> &gt; + * warranty of any kind, whether express or implied.
</I>&gt;<i> &gt; + */
</I>&gt;<i>
</I>&gt;<i> See may comments on patch 1/4.
</I>
Ack to adding 'Original Copyright' message in V2 and removing the 'drivers/net/can/..' representation.
However, I have seen URL links in a number of kernel drivers at this place (for e.g., see 'ti_hecc.c' CAN driver).

&gt;<i> &gt; +#include &lt;linux/kernel.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/version.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/module.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/interrupt.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/delay.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/if_arp.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/if_ether.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/list.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/delay.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/workqueue.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/io.h&gt;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#include &lt;socketcan/can.h&gt;
</I>&gt;<i> &gt; +#include &lt;socketcan/can/dev.h&gt;
</I>&gt;<i> &gt; +#include &lt;socketcan/can/error.h&gt;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#include &quot;bosch_ccan.h&quot;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#define DRV_NAME &quot;bosch_ccan&quot;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static struct can_bittiming_const bosch_ccan_bittiming_const = {
</I>&gt;<i> &gt; +       .name = DRV_NAME,
</I>&gt;<i> &gt; +       .tseg1_min = 2,         /* Time segment 1 = prop_seg +
</I>&gt;<i> phase_seg1 */
</I>&gt;<i> &gt; +       .tseg1_max = 16,
</I>&gt;<i> &gt; +       .tseg2_min = 1,         /* Time segment 2 = phase_seg2 */
</I>&gt;<i> &gt; +       .tseg2_max = 8,
</I>&gt;<i> &gt; +       .sjw_max = 4,
</I>&gt;<i> &gt; +       .brp_min = 1,
</I>&gt;<i> &gt; +       .brp_max = 1024,        /* 6-bit BRP field + 4-bit BRPE
</I>&gt;<i> field*/
</I>&gt;<i> &gt; +       .brp_inc = 1,
</I>&gt;<i> &gt; +};
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static u32 bosch_ccan_read_reg32(struct net_device *dev, enum
</I>&gt;<i> ccan_regs reg)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       u32 val = priv-&gt;read_reg(priv, reg);
</I>&gt;<i> &gt; +       val |= ((u32) priv-&gt;read_reg(priv, reg + 2)) &lt;&lt; 16;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return val;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void bosch_ccan_write_reg32(struct net_device *dev, enum
</I>&gt;<i> ccan_regs reg,
</I>&gt;<i> &gt; +                                       u32 val)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       priv-&gt;write_reg(priv, reg, val &amp; 0xffff);
</I>&gt;<i> &gt; +       priv-&gt;write_reg(priv, reg + 2, val &gt;&gt; 16);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static inline void bosch_ccan_object_get(struct net_device *dev,
</I>&gt;<i> &gt; +                                       int iface, int objno, int
</I>&gt;<i> mask)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       priv-&gt;write_reg(priv, CAN_IF_COMM(iface), mask);
</I>&gt;<i> &gt; +       priv-&gt;write_reg(priv, CAN_IF_COMR(iface), objno + 1);
</I>&gt;<i> &gt; +       while (priv-&gt;read_reg(priv, CAN_IF_COMR(iface)) &amp;
</I>&gt;<i> IF_COMR_BUSY)
</I>&gt;<i> &gt; +               dev_info(dev-&gt;dev.parent, &quot;busy in object get\n&quot;);
</I>&gt;<i>
</I>&gt;<i> Hm, please use a proper timeout handling with a defined delay.
</I>
Ack. Suggested by Mark as well. Now adding 'wait_for_completion_timout' here.

&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static inline void bosch_ccan_object_put(struct net_device *dev,
</I>&gt;<i> &gt; +                                       int iface, int objno, int
</I>&gt;<i> mask)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       priv-&gt;write_reg(priv, CAN_IF_COMM(iface), IF_COMM_WR | mask);
</I>&gt;<i> &gt; +       priv-&gt;write_reg(priv, CAN_IF_COMR(iface), objno + 1);
</I>&gt;<i> &gt; +       while (priv-&gt;read_reg(priv, CAN_IF_COMR(iface)) &amp;
</I>&gt;<i> IF_COMR_BUSY)
</I>&gt;<i> &gt; +               dev_info(dev-&gt;dev.parent, &quot;busy in object put\n&quot;);
</I>&gt;<i>
</I>&gt;<i> ditto
</I>
Ditto

&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +int bosch_ccan_write_object(struct net_device *dev,
</I>&gt;<i> &gt; +                       int iface, struct can_frame *frame, int
</I>&gt;<i> objno)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       unsigned int val;
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       if (frame-&gt;can_id &amp; CAN_EFF_FLAG)
</I>&gt;<i> &gt; +               val = IF_ARB_MSGXTD | (frame-&gt;can_id &amp; CAN_EFF_MASK);
</I>&gt;<i> &gt; +       else
</I>&gt;<i> &gt; +               val = ((frame-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; 18);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       if (!(frame-&gt;can_id &amp; CAN_RTR_FLAG))
</I>&gt;<i> &gt; +               val |= IF_ARB_TRANSMIT;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       val |= IF_ARB_MSGVAL;
</I>&gt;<i> &gt; +       bosch_ccan_write_reg32(dev, CAN_IF_ARB(iface), val);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       memcpy(&amp;val, &amp;frame-&gt;data[0], 4);
</I>&gt;<i> &gt; +       bosch_ccan_write_reg32(dev, CAN_IF_DATAA(iface), val);
</I>&gt;<i> &gt; +       memcpy(&amp;val, &amp;frame-&gt;data[4], 4);
</I>&gt;<i> &gt; +       bosch_ccan_write_reg32(dev, CAN_IF_DATAB(iface), val);
</I>&gt;<i> &gt; +       priv-&gt;write_reg(priv, CAN_IF_MCONT(iface),
</I>&gt;<i> &gt; +                       IF_MCONT_TXIE | IF_MCONT_TXRQST |
</I>&gt;<i> IF_MCONT_EOB |
</I>&gt;<i> &gt; +                       (frame-&gt;can_dlc &amp; 0xf));
</I>&gt;<i>
</I>&gt;<i> This seems very inefficient. Also you only need to set can_dlc bytes.
</I>
Ack. Suggested by Mark as well.
Now removing 'memcpy' and will also checking that no endianess issues are caused by this.

&gt;<i> &gt; +       bosch_ccan_object_put(dev, 0, objno, IF_COMM_ALL);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +int bosch_ccan_read_object(struct net_device *dev, int iface, int
</I>&gt;<i> objno)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       unsigned int val, ctrl, data;
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
</I>&gt;<i> &gt; +       struct net_device_stats *stats = can_get_stats(dev);
</I>&gt;<i> &gt; +#else
</I>&gt;<i> &gt; +       struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> &gt; +#endif
</I>&gt;<i> &gt; +       struct sk_buff *skb;
</I>&gt;<i> &gt; +       struct can_frame *frame;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       skb = dev_alloc_skb(sizeof(struct can_frame));
</I>&gt;<i> &gt; +       if (skb == NULL) {
</I>&gt;<i> &gt; +               dev_err(dev-&gt;dev.parent,
</I>&gt;<i> &gt; +                               &quot;failed to allocate skb for read
</I>&gt;<i> object\n&quot;);
</I>&gt;<i> &gt; +               return -ENOMEM;
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       skb-&gt;dev = dev;
</I>&gt;<i> &gt; +       bosch_ccan_object_get(dev, 0, objno, IF_COMM_ALL &amp;
</I>&gt;<i> ~IF_COMM_TXRQST);
</I>&gt;<i> &gt; +       frame = (struct can_frame *)skb_put(skb, sizeof(struct
</I>&gt;<i> can_frame));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       ctrl = priv-&gt;read_reg(priv, CAN_IF_MCONT(iface));
</I>&gt;<i> &gt; +       if (ctrl &amp; IF_MCONT_MSGLST) {
</I>&gt;<i> &gt; +               stats-&gt;rx_errors++;
</I>&gt;<i> &gt; +               dev_info(dev-&gt;dev.parent, &quot;msg lost in buffer %d\n&quot;,
</I>&gt;<i> objno);
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       frame-&gt;can_dlc = ctrl &amp; 0xf;
</I>&gt;<i> &gt; +       val = bosch_ccan_read_reg32(dev, CAN_IF_ARB(iface));
</I>&gt;<i> &gt; +       data = bosch_ccan_read_reg32(dev, CAN_IF_DATAA(iface));
</I>&gt;<i> &gt; +       memcpy(&amp;frame-&gt;data[0], &amp;data, 4);
</I>&gt;<i> &gt; +       data = bosch_ccan_read_reg32(dev, CAN_IF_DATAB(iface));
</I>&gt;<i> &gt; +       memcpy(&amp;frame-&gt;data[4], &amp;data, 4);
</I>&gt;<i>
</I>&gt;<i> Dito. Also, I smell endianess issus.
</I>
Ditto

&gt;<i> &gt; +       if (val &amp; IF_ARB_MSGXTD)
</I>&gt;<i> &gt; +               frame-&gt;can_id = (val &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
</I>&gt;<i> &gt; +       else
</I>&gt;<i> &gt; +               frame-&gt;can_id = (val &gt;&gt; 18) &amp; CAN_SFF_MASK;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       if (val &amp; IF_ARB_TRANSMIT)
</I>&gt;<i> &gt; +               frame-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       priv-&gt;write_reg(priv, CAN_IF_MCONT(iface), ctrl &amp;
</I>&gt;<i> &gt; +                       ~(IF_MCONT_MSGLST | IF_MCONT_INTPND |
</I>&gt;<i> IF_MCONT_NEWDAT));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       bosch_ccan_object_put(dev, 0, objno, IF_COMM_CONTROL);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       skb-&gt;protocol = __constant_htons(ETH_P_CAN);
</I>&gt;<i> &gt; +       netif_rx(skb);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,32)
</I>&gt;<i> &gt; +       dev-&gt;last_rx = jiffies;
</I>&gt;<i> &gt; +#endif
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       stats-&gt;rx_packets++;
</I>&gt;<i> &gt; +       stats-&gt;rx_bytes += frame-&gt;can_dlc;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int bosch_ccan_setup_receive_object(struct net_device *dev,
</I>&gt;<i> int iface,
</I>&gt;<i> &gt; +                                       int objno, unsigned int mask,
</I>&gt;<i> &gt; +                                       unsigned int id, unsigned int
</I>&gt;<i> mcont)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       bosch_ccan_write_reg32(dev, CAN_IF_MASK(iface), mask);
</I>&gt;<i> &gt; +       bosch_ccan_write_reg32(dev, CAN_IF_ARB(iface), IF_ARB_MSGVAL
</I>&gt;<i> | id);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       priv-&gt;write_reg(priv, CAN_IF_MCONT(iface), mcont);
</I>&gt;<i> &gt; +       bosch_ccan_object_put(dev, 0, objno, IF_COMM_ALL &amp;
</I>&gt;<i> ~IF_COMM_TXRQST);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       dev_dbg(dev-&gt;dev.parent, &quot;obj no:%d, msgval:0x%08x\n&quot;, objno,
</I>&gt;<i> &gt; +                       bosch_ccan_read_reg32(dev, CAN_MSGVAL));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int bosch_ccan_inval_object(struct net_device *dev, int
</I>&gt;<i> iface, int objno)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       bosch_ccan_write_reg32(dev, CAN_IF_ARB(iface), 0);
</I>&gt;<i> &gt; +       priv-&gt;write_reg(priv, CAN_IF_MCONT(iface), 0);
</I>&gt;<i> &gt; +       bosch_ccan_object_put(dev, 0, objno, IF_COMM_ARB |
</I>&gt;<i> IF_COMM_CONTROL);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       dev_dbg(dev-&gt;dev.parent, &quot;obj no:%d, msgval:0x%08x\n&quot;, objno,
</I>&gt;<i> &gt; +                       bosch_ccan_read_reg32(dev, CAN_MSGVAL));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,32)
</I>&gt;<i> &gt; +static int bosch_ccan_start_xmit(struct sk_buff *skb,
</I>&gt;<i> &gt; +                                struct net_device *dev)
</I>&gt;<i> &gt; +#else
</I>&gt;<i> &gt; +static netdev_tx_t bosch_ccan_start_xmit(struct sk_buff *skb,
</I>&gt;<i> &gt; +                                       struct net_device *dev)
</I>&gt;<i> &gt; +#endif
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +       struct can_frame *frame = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> &gt; +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
</I>&gt;<i> &gt; +       struct net_device_stats *stats = can_get_stats(dev);
</I>&gt;<i> &gt; +#else
</I>&gt;<i> &gt; +       struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> &gt; +#endif
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       netif_stop_queue(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       bosch_ccan_write_object(dev, 0, frame, priv-&gt;tx_object);
</I>&gt;<i> &gt; +       priv-&gt;tx_object++;
</I>&gt;<i>
</I>&gt;<i> Is this variable really useful?
</I>
In my view it is helpful for debugging.

&gt;<i> &gt; +
</I>&gt;<i> &gt; +       stats-&gt;tx_bytes += frame-&gt;can_dlc;
</I>&gt;<i>
</I>&gt;<i> Should be set when TX is done.
</I>
Ack. Will be reflected in V2.

&gt;<i> &gt; +       dev-&gt;trans_start = jiffies;
</I>&gt;<i> &gt; +       can_put_echo_skb(skb, dev, 0);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return NETDEV_TX_OK;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int bosch_ccan_set_bittiming(struct net_device *dev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       unsigned int reg_btr, reg_brpe, ctrl_save;
</I>&gt;<i> &gt; +       u8 brp, brpe, sjw, tseg1, tseg2;
</I>&gt;<i> &gt; +       u32 ten_bit_brp;
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +       const struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* ccan provides a 6-bit brp and 4-bit brpe fields */
</I>&gt;<i> &gt; +       ten_bit_brp = bt-&gt;brp - 1;
</I>&gt;<i> &gt; +       brp = ten_bit_brp &amp; BTR_BRP_MASK;
</I>&gt;<i> &gt; +       brpe = ten_bit_brp &gt;&gt; 6;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       sjw = bt-&gt;sjw - 1;
</I>&gt;<i> &gt; +       tseg1 = bt-&gt;prop_seg + bt-&gt;phase_seg1 - 1;
</I>&gt;<i> &gt; +       tseg2 = bt-&gt;phase_seg2 - 1;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       reg_btr = (brp) |
</I>&gt;<i> &gt; +               ((sjw &lt;&lt; BTR_SJW_SHIFT) &amp; BTR_SJW_MASK) |
</I>&gt;<i> &gt; +               ((tseg1 &lt;&lt; BTR_TSEG1_SHIFT) &amp; BTR_TSEG1_MASK) |
</I>&gt;<i> &gt; +               ((tseg2 &lt;&lt; BTR_TSEG2_SHIFT) &amp; BTR_TSEG2_MASK);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       reg_brpe = brpe &amp; BRP_EXT_BRPE_MASK;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       dev_dbg(dev-&gt;dev.parent,
</I>&gt;<i> &gt; +                       &quot;brp = %d, brpe = %d, sjw = %d, seg1 = %d,
</I>&gt;<i> seg2 = %d\n&quot;,
</I>&gt;<i> &gt; +                       brp, brpe, sjw, tseg1, tseg2);
</I>&gt;<i> &gt; +       dev_dbg(dev-&gt;dev.parent, &quot;setting BTR to %04x\n&quot;, reg_btr);
</I>&gt;<i> &gt; +       dev_dbg(dev-&gt;dev.parent, &quot;setting BRPE to %04x\n&quot;, reg_brpe);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       ctrl_save = priv-&gt;read_reg(priv, CAN_CONTROL);
</I>&gt;<i> &gt; +       priv-&gt;write_reg(priv, CAN_CONTROL,
</I>&gt;<i> &gt; +                       ctrl_save | CONTROL_CCE | CONTROL_INIT);
</I>&gt;<i> &gt; +       priv-&gt;write_reg(priv, CAN_BTR, reg_btr);
</I>&gt;<i> &gt; +       priv-&gt;write_reg(priv, CAN_BRP_EXT, reg_brpe);
</I>&gt;<i> &gt; +       priv-&gt;write_reg(priv, CAN_CONTROL, ctrl_save);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * Configure CCAN auto-retransmission:
</I>&gt;<i> &gt; + * CCAN provides means to disable automatic retransmission of
</I>&gt;<i> &gt; + * frames to allow CCAN to work within a TTCAN environment.
</I>&gt;<i> &gt; + * One must be careful about the different bevaior of TxRqst and
</I>&gt;<i> &gt; + * NewDat in the case automatic retransmssion is disabled.
</I>&gt;<i> &gt; + * See user guide document for details.
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +static int bosch_ccan_auto_retransmission_config(struct net_device
</I>&gt;<i> *dev,
</I>&gt;<i> &gt; +                                       enum
</I>&gt;<i> bosch_ccan_auto_tx_config mode)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       switch (mode) {
</I>&gt;<i> &gt; +       case CCAN_ENABLE_AUTO_RE_TRANSMIT:
</I>&gt;<i> &gt; +               priv-&gt;write_reg(priv, CAN_CONTROL,
</I>&gt;<i> CONTROL_ENABLE_AR);
</I>&gt;<i> &gt; +               break;
</I>&gt;<i> &gt; +       case CCAN_DISABLE_AUTO_RE_TRANSMIT:
</I>&gt;<i> &gt; +               priv-&gt;write_reg(priv, CAN_CONTROL,
</I>&gt;<i> CONTROL_DISABLE_AR);
</I>&gt;<i> &gt; +               break;
</I>&gt;<i> &gt; +       default:
</I>&gt;<i> &gt; +               return -EOPNOTSUPP;
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * Configure CCAN operating mode
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +static int bosch_ccan_set_operating_mode(struct net_device *dev,
</I>&gt;<i> &gt; +                               enum bosch_ccan_operating_mode mode)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       unsigned int cntrl_reg = 0;
</I>&gt;<i> &gt; +       unsigned int test_reg = 0;
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       switch (mode) {
</I>&gt;<i> &gt; +       case CCAN_NORMAL_MODE:
</I>&gt;<i> &gt; +               cntrl_reg = (CONTROL_EIE | CONTROL_SIE | CONTROL_IE);
</I>&gt;<i> &gt; +               break;
</I>&gt;<i> &gt; +       case CCAN_BASIC_MODE:
</I>&gt;<i> &gt; +               /* basic mode : CCAN runs without the message RAM */
</I>&gt;<i> &gt; +               cntrl_reg = (CONTROL_EIE | CONTROL_SIE |
</I>&gt;<i> &gt; +                               CONTROL_IE | CONTROL_TEST);
</I>&gt;<i> &gt; +               test_reg = TEST_BASIC;
</I>&gt;<i> &gt; +               break;
</I>&gt;<i> &gt; +       case CCAN_LOOPBACK_MODE:
</I>&gt;<i> &gt; +               /* loopback mode : useful for self-test function */
</I>&gt;<i> &gt; +               cntrl_reg = (CONTROL_EIE | CONTROL_SIE |
</I>&gt;<i> &gt; +                               CONTROL_IE | CONTROL_TEST);
</I>&gt;<i> &gt; +               test_reg = TEST_LBACK;
</I>&gt;<i> &gt; +               break;
</I>&gt;<i> &gt; +       case CCAN_LOOPBACK_WITH_SILENT_MODE:
</I>&gt;<i> &gt; +               /* loopback + silent mode : useful for hot self-test
</I>&gt;<i> */
</I>&gt;<i> &gt; +               cntrl_reg = (CONTROL_EIE | CONTROL_SIE |
</I>&gt;<i> &gt; +                               CONTROL_IE | CONTROL_TEST);
</I>&gt;<i> &gt; +               test_reg = (TEST_LBACK | TEST_SILENT);
</I>&gt;<i> &gt; +               break;
</I>&gt;<i> &gt; +       case CCAN_SILENT_MODE:
</I>&gt;<i> &gt; +               /* silent mode : bus-monitoring mode */
</I>&gt;<i> &gt; +               cntrl_reg = (CONTROL_EIE | CONTROL_SIE |
</I>&gt;<i> &gt; +                               CONTROL_IE | CONTROL_TEST);
</I>&gt;<i> &gt; +               test_reg = TEST_SILENT;
</I>&gt;<i> &gt; +               break;
</I>&gt;<i>
</I>&gt;<i> Of these only CCAN_NORMAL_MODE is used. Please use priv-&gt;crtlmode to
</I>&gt;<i> handle more of them and remove the unused cases.
</I>
Please elaborate this. I have use CCAN_LOOPBACK_MODE as well during debugging the driver.
These modes are especially successful in debugging or testing the PCB's for non-functioning CAN interfaces.

&gt;<i> &gt; +       default:
</I>&gt;<i> &gt; +               return -EOPNOTSUPP;
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       priv-&gt;write_reg(priv, CAN_CONTROL, cntrl_reg);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* set test mode only when we do not want NORMAL mode */
</I>&gt;<i> &gt; +       if (test_reg)
</I>&gt;<i> &gt; +               priv-&gt;write_reg(priv, CAN_TEST, test_reg);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * Configure CCAN message objects for Tx and Rx purposes:
</I>&gt;<i> &gt; + * CCAN provides a total of 32 message objects that can be
</I>&gt;<i> configured
</I>&gt;<i> &gt; + * either for Tx or Rx purposes. This configuration may vary as per
</I>&gt;<i> the
</I>&gt;<i> &gt; + * system design. Here by default 16 message objects are kept aside
</I>&gt;<i> for
</I>&gt;<i> &gt; + * Tx purposes and 16 for Rx purposes. See user guide document for
</I>&gt;<i> details.
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +static int bosch_ccan_configure_msg_objects(struct net_device *dev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       int i;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* setup message objects */
</I>&gt;<i> &gt; +       for (i = 0; i &lt;= MAX_OBJECT; i++)
</I>&gt;<i> &gt; +               bosch_ccan_inval_object(dev, 0, i);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       for (i = MAX_TRANSMIT_OBJECT + 1; i &lt; MAX_OBJECT; i++)
</I>&gt;<i> &gt; +               bosch_ccan_setup_receive_object(dev, 0, i, 0, 0,
</I>&gt;<i> &gt; +                                               IF_MCONT_RXIE |
</I>&gt;<i> IF_MCONT_UMASK);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       bosch_ccan_setup_receive_object(dev, 0, MAX_OBJECT, 0, 0,
</I>&gt;<i> IF_MCONT_EOB |
</I>&gt;<i> &gt; +                                               IF_MCONT_RXIE |
</I>&gt;<i> IF_MCONT_UMASK);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * Configure CCAN chip:
</I>&gt;<i> &gt; + * - enable/disable auto-retransmission
</I>&gt;<i> &gt; + * - set operating mode
</I>&gt;<i> &gt; + * - configure message objects
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +static int bosch_ccan_chip_config(struct net_device *dev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       int err;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* enable automatic retransmission */
</I>&gt;<i> &gt; +       err = bosch_ccan_auto_retransmission_config(dev,
</I>&gt;<i> &gt; +
</I>&gt;<i> CCAN_ENABLE_AUTO_RE_TRANSMIT);
</I>&gt;<i> &gt; +       if (err)
</I>&gt;<i> &gt; +               return err;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* enable normal operating mode */
</I>&gt;<i> &gt; +       err = bosch_ccan_set_operating_mode(dev, CCAN_NORMAL_MODE);
</I>&gt;<i> &gt; +       if (err)
</I>&gt;<i> &gt; +               return err;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* configure message objects */
</I>&gt;<i> &gt; +       bosch_ccan_configure_msg_objects(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int bosch_ccan_start(struct net_device *dev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       int err;
</I>&gt;<i> &gt; +       unsigned int cntrl_save;
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* enable status change, error and module interrupts */
</I>&gt;<i> &gt; +       cntrl_save = priv-&gt;read_reg(priv, CAN_CONTROL);
</I>&gt;<i> &gt; +       cntrl_save = (cntrl_save | (CONTROL_SIE | CONTROL_EIE |
</I>&gt;<i> CONTROL_IE));
</I>&gt;<i>
</I>&gt;<i> &quot;|=&quot; ?
</I>
Ack. Will be reflected in V2.

&gt;<i> &gt; +       priv-&gt;write_reg(priv, CAN_CONTROL, cntrl_save);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* basic ccan configuration */
</I>&gt;<i> &gt; +       err = bosch_ccan_chip_config(dev);
</I>&gt;<i> &gt; +       if (err)
</I>&gt;<i> &gt; +               return err;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       priv-&gt;tx_object = 0;
</I>&gt;<i> &gt; +       priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int bosch_ccan_stop(struct net_device *dev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       unsigned int cntrl_save;
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* disable all interrupts */
</I>&gt;<i> &gt; +       cntrl_save = priv-&gt;read_reg(priv, CAN_CONTROL);
</I>&gt;<i> &gt; +       cntrl_save = ((((cntrl_save &amp; ~CONTROL_EIE) &amp; ~CONTROL_IE) &amp;
</I>&gt;<i> &gt; +                       ~CONTROL_SIE));
</I>&gt;<i>
</I>&gt;<i> &quot;&amp;=&quot; ?
</I>
Ack. Will be reflected in V2.

&gt;<i> &gt; +       priv-&gt;write_reg(priv, CAN_CONTROL, cntrl_save);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int bosch_ccan_set_mode(struct net_device *dev, enum can_mode
</I>&gt;<i> mode)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       switch (mode) {
</I>&gt;<i> &gt; +       case CAN_MODE_START:
</I>&gt;<i> &gt; +               bosch_ccan_start(dev);
</I>&gt;<i> &gt; +               if (netif_queue_stopped(dev))
</I>&gt;<i> &gt; +                       netif_wake_queue(dev);
</I>&gt;<i> &gt; +               dev_info(dev-&gt;dev.parent,
</I>&gt;<i> &gt; +                               &quot;bosch ccan CAN_MODE_START
</I>&gt;<i> requested\n&quot;);
</I>&gt;<i> &gt; +               break;
</I>&gt;<i>
</I>&gt;<i> How is bus-off recovery supposed to work?
</I>
Bus-Off recovery works by providing the command:
# ip link set canX type can restart

This causes 'bosch_ccan_start' to be called which enables the interrupts and allows a change of Bus Off bit in Status Register which is properly handled by ISR. Already checked the bus-off recovery on SPEAr320 platform.

&gt;<i> &gt; +       default:
</I>&gt;<i> &gt; +               return -EOPNOTSUPP;
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int bosch_ccan_get_state(const struct net_device *dev,
</I>&gt;<i> &gt; +                               enum can_state *state)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       *state = priv-&gt;can.state;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int bosch_ccan_err(struct net_device *dev,
</I>&gt;<i> &gt; +                               enum bosch_ccan_bus_error_types
</I>&gt;<i> error_type,
</I>&gt;<i> &gt; +                               int lec_type)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       unsigned int reg_err_counter = 0;
</I>&gt;<i> &gt; +       unsigned int rx_err_passive = 0;
</I>&gt;<i> &gt; +       unsigned int rx_err_counter = 0;
</I>&gt;<i> &gt; +       unsigned int tx_err_counter = 0;
</I>&gt;<i>
</I>&gt;<i> I do not see a need for pre-setting the values above.
</I>
Ack. V2 will implement do_get_berr_counter and use it as suggested by you and Mark.

&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
</I>&gt;<i> &gt; +       struct net_device_stats *stats = can_get_stats(dev);
</I>&gt;<i> &gt; +#else
</I>&gt;<i> &gt; +       struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> &gt; +#endif
</I>&gt;<i> &gt; +       struct can_frame *cf;
</I>&gt;<i> &gt; +       struct sk_buff *skb;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* propogate the error condition to the CAN stack */
</I>&gt;<i> &gt; +       skb = dev_alloc_skb(sizeof(struct can_frame));
</I>&gt;<i> &gt; +       if (skb == NULL)
</I>&gt;<i> &gt; +               return -ENOMEM;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       skb-&gt;dev = dev;
</I>&gt;<i> &gt; +       skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;<i> &gt; +       cf = (struct can_frame *)skb_put(skb, sizeof(struct
</I>&gt;<i> can_frame));
</I>&gt;<i> &gt; +       memset(cf, 0, sizeof(struct can_frame));
</I>&gt;<i> &gt; +       cf-&gt;can_id = CAN_ERR_FLAG;
</I>&gt;<i> &gt; +       cf-&gt;can_dlc = CAN_ERR_DLC;
</I>&gt;<i>
</I>&gt;<i> Please use alloc_can_skb(),
</I>
Ack. V2 will reflect this.

&gt;<i> &gt; +
</I>&gt;<i> &gt; +       reg_err_counter = priv-&gt;read_reg(priv, CAN_ERROR);
</I>&gt;<i> &gt; +       rx_err_counter = ((reg_err_counter &amp; ERR_COUNTER_REC_MASK) &gt;&gt;
</I>&gt;<i> &gt; +                               ERR_COUNTER_REC_SHIFT);
</I>&gt;<i> &gt; +       tx_err_counter = (reg_err_counter &amp; ERR_COUNTER_TEC_MASK);
</I>&gt;<i> &gt; +       rx_err_passive = ((reg_err_counter &amp; ERR_COUNTER_RP_MASK) &gt;&gt;
</I>&gt;<i> &gt; +                               ERR_COUNTER_RP_SHIFT);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       if (error_type &amp; CCAN_ERROR_WARNING) {
</I>&gt;<i> &gt; +               /* error warning state */
</I>&gt;<i> &gt; +               priv-&gt;can.can_stats.error_warning++;
</I>&gt;<i> &gt; +               priv-&gt;can.state = CAN_STATE_ERROR_WARNING;
</I>&gt;<i> &gt; +               cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> &gt; +               if (rx_err_counter &gt; 96)
</I>&gt;<i> &gt; +                       cf-&gt;data[1] = CAN_ERR_CRTL_RX_WARNING;
</I>&gt;<i> &gt; +               if (tx_err_counter &gt; 96)
</I>&gt;<i> &gt; +                       cf-&gt;data[1] = CAN_ERR_CRTL_TX_WARNING;
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +       if (error_type &amp; CCAN_ERROR_PASSIVE) {
</I>&gt;<i> &gt; +               /* error passive state */
</I>&gt;<i> &gt; +               priv-&gt;can.can_stats.error_passive++;
</I>&gt;<i> &gt; +               priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> &gt; +               cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> &gt; +               if (rx_err_passive)
</I>&gt;<i> &gt; +                       cf-&gt;data[1] = CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> &gt; +               if (tx_err_counter &gt; 127)
</I>&gt;<i> &gt; +                       cf-&gt;data[1] = CAN_ERR_CRTL_TX_PASSIVE;
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +       if (error_type &amp; CCAN_BUS_OFF) {
</I>&gt;<i> &gt; +               /* bus-off state */
</I>&gt;<i> &gt; +               priv-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> &gt; +               cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> &gt; +               /* disable all interrupts in bus-off mode to ensure
</I>&gt;<i> that
</I>&gt;<i> &gt; +                * the CPU is not hogged down
</I>&gt;<i> &gt; +                */
</I>&gt;<i> &gt; +               priv-&gt;write_reg(priv, CAN_CONTROL, 0);
</I>&gt;<i> &gt; +               can_bus_off(dev);
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* check for 'last error code' which tells us the
</I>&gt;<i> &gt; +        * type of the last error to occur on the CAN bus
</I>&gt;<i> &gt; +        */
</I>&gt;<i> &gt; +       if (lec_type) {
</I>&gt;<i> &gt; +               /* common for all type of bus errors */
</I>&gt;<i> &gt; +               priv-&gt;can.can_stats.bus_error++;
</I>&gt;<i> &gt; +               stats-&gt;rx_errors++;
</I>&gt;<i> &gt; +               cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
</I>&gt;<i> &gt; +               cf-&gt;data[2] |= CAN_ERR_PROT_UNSPEC;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +               if (lec_type &amp; LEC_STUFF_ERROR) {
</I>&gt;<i> &gt; +                       dev_info(dev-&gt;dev.parent, &quot;stuff error\n&quot;);
</I>&gt;<i> &gt; +                       cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;<i> &gt; +               }
</I>&gt;<i> &gt; +               if (lec_type &amp; LEC_FORM_ERROR) {
</I>&gt;<i> &gt; +                       dev_info(dev-&gt;dev.parent, &quot;form error\n&quot;);
</I>&gt;<i> &gt; +                       cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;<i> &gt; +               }
</I>&gt;<i> &gt; +               if (lec_type &amp; LEC_ACK_ERROR) {
</I>&gt;<i> &gt; +                       dev_info(dev-&gt;dev.parent, &quot;ack error\n&quot;);
</I>&gt;<i> &gt; +                       cf-&gt;data[2] |= (CAN_ERR_PROT_LOC_ACK |
</I>&gt;<i> &gt; +                                       CAN_ERR_PROT_LOC_ACK_DEL);
</I>&gt;<i> &gt; +               }
</I>&gt;<i> &gt; +               if (lec_type &amp; LEC_BIT1_ERROR) {
</I>&gt;<i> &gt; +                       dev_info(dev-&gt;dev.parent, &quot;bit1 error\n&quot;);
</I>&gt;<i> &gt; +                       cf-&gt;data[2] |= CAN_ERR_PROT_BIT1;
</I>&gt;<i> &gt; +               }
</I>&gt;<i> &gt; +               if (lec_type &amp; LEC_BIT0_ERROR) {
</I>&gt;<i> &gt; +                       dev_info(dev-&gt;dev.parent, &quot;bit0 error\n&quot;);
</I>&gt;<i> &gt; +                       cf-&gt;data[2] |= CAN_ERR_PROT_BIT0;
</I>&gt;<i> &gt; +               }
</I>&gt;<i> &gt; +               if (lec_type &amp; LEC_CRC_ERROR) {
</I>&gt;<i> &gt; +                       dev_info(dev-&gt;dev.parent, &quot;CRC error\n&quot;);
</I>&gt;<i> &gt; +                       cf-&gt;data[2] |= (CAN_ERR_PROT_LOC_CRC_SEQ |
</I>&gt;<i> &gt; +                                       CAN_ERR_PROT_LOC_CRC_DEL);
</I>&gt;<i> &gt; +               }
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       netif_rx(skb);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,32)
</I>&gt;<i> &gt; +       dev-&gt;last_rx = jiffies;
</I>&gt;<i> &gt; +#endif
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       stats-&gt;rx_packets++;
</I>&gt;<i> &gt; +       stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int bosch_ccan_do_status_irq(struct net_device *dev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       int ret, lec_type = 0;
</I>&gt;<i> &gt; +       enum bosch_ccan_bus_error_types error_type = CCAN_NO_ERROR;
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       priv-&gt;current_status = priv-&gt;read_reg(priv, CAN_STATUS);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* handle Tx/Rx events */
</I>&gt;<i> &gt; +       if (priv-&gt;current_status &amp; STATUS_TXOK) {
</I>&gt;<i> &gt; +               dev_dbg(dev-&gt;dev.parent,
</I>&gt;<i> &gt; +                               &quot;Trasmitted a msg successfully\n&quot;);
</I>&gt;<i> &gt; +               priv-&gt;write_reg(priv, CAN_STATUS,
</I>&gt;<i> &gt; +                               (priv-&gt;current_status &amp;
</I>&gt;<i> ~STATUS_TXOK));
</I>&gt;<i>
</I>&gt;<i> Please restrict dev_dbg() to the one useful for the real user. Printing
</I>&gt;<i> a message for every message sent is not really usefull.
</I>
Ack. V2 will reflect this.

&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +       if (priv-&gt;current_status &amp; STATUS_RXOK) {
</I>&gt;<i> &gt; +               dev_dbg(dev-&gt;dev.parent,
</I>&gt;<i> &gt; +                               &quot;Received a msg successfully\n&quot;);
</I>&gt;<i> &gt; +               priv-&gt;write_reg(priv, CAN_STATUS,
</I>&gt;<i> &gt; +                               (priv-&gt;current_status &amp;
</I>&gt;<i> ~STATUS_RXOK));
</I>&gt;<i> &gt; +       }
</I>&gt;<i>
</I>&gt;<i> Dito.
</I>
Ditto

&gt;<i> &gt; +       /* handle bus error events */
</I>&gt;<i> &gt; +       if (priv-&gt;current_status &amp; STATUS_EWARN) {
</I>&gt;<i> &gt; +               dev_info(dev-&gt;dev.parent,
</I>&gt;<i> &gt; +                               &quot;entered error warning state\n&quot;);
</I>&gt;<i> &gt; +               error_type = CCAN_ERROR_WARNING;
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +       if ((priv-&gt;current_status &amp; STATUS_EPASS) &amp;&amp;
</I>&gt;<i> &gt; +                       (!(priv-&gt;last_status &amp; STATUS_EPASS))) {
</I>&gt;<i> &gt; +               dev_info(dev-&gt;dev.parent,
</I>&gt;<i> &gt; +                               &quot;entered error passive state\n&quot;);
</I>&gt;<i> &gt; +               error_type = CCAN_ERROR_PASSIVE;
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +       if ((priv-&gt;current_status &amp; STATUS_BOFF) &amp;&amp;
</I>&gt;<i> &gt; +                       (!(priv-&gt;last_status &amp; STATUS_BOFF))) {
</I>&gt;<i> &gt; +               dev_info(dev-&gt;dev.parent,
</I>&gt;<i> &gt; +                               &quot;entered bus off state\n&quot;);
</I>&gt;<i> &gt; +               error_type = CCAN_BUS_OFF;
</I>&gt;<i> &gt; +       }
</I>&gt;<i>
</I>&gt;<i> But you can keep these.
</I>
Ok. :-)

&gt;<i> &gt; +       if (priv-&gt;current_status &amp; STATUS_LEC_MASK)
</I>&gt;<i> &gt; +               lec_type = (priv-&gt;current_status &amp; STATUS_LEC_MASK);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* handle bus recovery events */
</I>&gt;<i> &gt; +       if ((!(priv-&gt;current_status &amp; STATUS_EPASS)) &amp;&amp;
</I>&gt;<i> &gt; +                       (priv-&gt;last_status &amp; STATUS_EPASS)) {
</I>&gt;<i> &gt; +               dev_info(dev-&gt;dev.parent,
</I>&gt;<i> &gt; +                               &quot;left error passive state\n&quot;);
</I>&gt;<i> &gt; +               priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +       if ((!(priv-&gt;current_status &amp; STATUS_BOFF)) &amp;&amp;
</I>&gt;<i> &gt; +                       (priv-&gt;last_status &amp; STATUS_BOFF)) {
</I>&gt;<i> &gt; +               dev_info(dev-&gt;dev.parent,
</I>&gt;<i> &gt; +                               &quot;left bus off state\n&quot;);
</I>&gt;<i> &gt; +               priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       priv-&gt;last_status = priv-&gt;current_status;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* handle error on the bus */
</I>&gt;<i> &gt; +       if (error_type != CCAN_NO_ERROR) {
</I>&gt;<i> &gt; +               ret = bosch_ccan_err(dev, error_type, lec_type);
</I>&gt;<i> &gt; +               if (ret &lt; 0)
</I>&gt;<i> &gt; +                       return ret;
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void bosch_ccan_do_object_irq(struct net_device *dev, u16
</I>&gt;<i> irqstatus)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       int i;
</I>&gt;<i> &gt; +       u32 val;
</I>&gt;<i> &gt; +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
</I>&gt;<i> &gt; +       struct net_device_stats *stats = can_get_stats(dev);
</I>&gt;<i> &gt; +#else
</I>&gt;<i> &gt; +       struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> &gt; +#endif
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       if (irqstatus &gt; MAX_TRANSMIT_OBJECT) {
</I>&gt;<i> &gt; +               val = bosch_ccan_read_reg32(dev, CAN_NEWDAT);
</I>&gt;<i> &gt; +               while (val &amp; RECEIVE_OBJECT_BITS) {
</I>&gt;<i> &gt; +                       for (i = MAX_TRANSMIT_OBJECT + 1; i &lt;=
</I>&gt;<i> MAX_OBJECT; i++)
</I>&gt;<i> &gt; +                               if (val &amp; (1 &lt;&lt; i))
</I>&gt;<i> &gt; +                                       bosch_ccan_read_object(dev,
</I>&gt;<i> 0, i);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +                       val = bosch_ccan_read_reg32(dev, CAN_NEWDAT);
</I>&gt;<i> &gt; +               }
</I>&gt;<i> &gt; +       } else {
</I>&gt;<i> &gt; +               bosch_ccan_inval_object(dev, 0, irqstatus - 1);
</I>&gt;<i> &gt; +               val = bosch_ccan_read_reg32(dev, CAN_TXRQST);
</I>&gt;<i> &gt; +               if (!val) {
</I>&gt;<i> &gt; +                       can_get_echo_skb(dev, 0);
</I>&gt;<i> &gt; +                       priv-&gt;tx_object--;
</I>&gt;<i> &gt; +                       stats-&gt;tx_packets++;
</I>&gt;<i> &gt; +                       netif_wake_queue(dev);
</I>&gt;<i> &gt; +               }
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,19)
</I>&gt;<i> &gt; +static irqreturn_t bosch_ccan_isr(int irq, void *dev_id, struct
</I>&gt;<i> pt_regs *regs)
</I>&gt;<i> &gt; +#else
</I>&gt;<i> &gt; +static irqreturn_t bosch_ccan_isr(int irq, void *dev_id)
</I>&gt;<i> &gt; +#endif
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       u16 irqstatus;
</I>&gt;<i> &gt; +       int ret;
</I>&gt;<i> &gt; +       struct net_device *dev = (struct net_device *)dev_id;
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       irqstatus = priv-&gt;read_reg(priv, CAN_IR);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       if (!irqstatus)
</I>&gt;<i> &gt; +               return IRQ_NONE;
</I>&gt;<i> &gt; +       while (irqstatus) {
</I>&gt;<i> &gt; +               if (irqstatus == 0x8000) {
</I>&gt;<i>
</I>&gt;<i> Please use an appropriate macro definition.
</I>
Ack. V2 will reflect this.

&gt;<i> &gt; +                       ret = bosch_ccan_do_status_irq(dev);
</I>&gt;<i> &gt; +                       if (ret &lt; 0) {
</I>&gt;<i> &gt; +                               dev_err(dev-&gt;dev.parent,
</I>&gt;<i> &gt; +                                               &quot;do_status_irq
</I>&gt;<i> failed\n&quot;);
</I>&gt;<i> &gt; +                               goto exit;
</I>&gt;<i> &gt; +                       }
</I>&gt;<i> &gt; +               } else
</I>&gt;<i> &gt; +                       bosch_ccan_do_object_irq(dev, irqstatus);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +               irqstatus = priv-&gt;read_reg(priv, CAN_IR);
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +exit:
</I>&gt;<i> &gt; +       return IRQ_HANDLED;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int bosch_ccan_open(struct net_device *dev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       int err;
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* open the can device */
</I>&gt;<i> &gt; +       err = open_candev(dev);
</I>&gt;<i> &gt; +       if (err) {
</I>&gt;<i> &gt; +               dev_err(dev-&gt;dev.parent, &quot;failed to open can
</I>&gt;<i> device\n&quot;);
</I>&gt;<i> &gt; +               return err;
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* register interrupt handler */
</I>&gt;<i> &gt; +       err = request_irq(dev-&gt;irq, &amp;bosch_ccan_isr, priv-&gt;irq_flags,
</I>&gt;<i> dev-&gt;name,
</I>&gt;<i> &gt; +                               (void *)dev);
</I>&gt;<i> &gt; +       if (err &lt; 0) {
</I>&gt;<i> &gt; +               dev_err(dev-&gt;dev.parent, &quot;failed to attach
</I>&gt;<i> interrupt\n&quot;);
</I>&gt;<i> &gt; +               goto exit_irq_fail;
</I>&gt;<i> &gt; +       }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
</I>&gt;<i> &gt; +       /* clear statistics */
</I>&gt;<i> &gt; +       memset(&amp;priv-&gt;can.net_stats, 0, sizeof(priv-&gt;can.net_stats));
</I>&gt;<i> &gt; +#endif
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* start the ccan controller */
</I>&gt;<i> &gt; +       err = bosch_ccan_start(dev);
</I>&gt;<i> &gt; +       if (err)
</I>&gt;<i> &gt; +               goto exit_start_fail;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       netif_start_queue(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +exit_start_fail:
</I>&gt;<i> &gt; +       free_irq(dev-&gt;irq, dev);
</I>&gt;<i> &gt; +exit_irq_fail:
</I>&gt;<i> &gt; +       close_candev(dev);
</I>&gt;<i> &gt; +       return err;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int bosch_ccan_close(struct net_device *dev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       netif_stop_queue(dev);
</I>&gt;<i> &gt; +       bosch_ccan_stop(dev);
</I>&gt;<i> &gt; +       free_irq(dev-&gt;irq, dev);
</I>&gt;<i> &gt; +       close_candev(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +struct net_device *alloc_bosch_ccandev(int sizeof_priv)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       struct net_device *dev;
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#if ((LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,32))
</I>&gt;<i> ||(LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,32)))
</I>&gt;<i> &gt; +       dev = alloc_candev(sizeof(struct bosch_ccan_priv) +
</I>&gt;<i> sizeof_priv,
</I>&gt;<i> &gt; +                               BOSCH_CCAN_ECHO_SKB_MAX);
</I>&gt;<i> &gt; +#else
</I>&gt;<i> &gt; +       dev = alloc_candev(sizeof(struct bosch_ccan_priv) +
</I>&gt;<i> sizeof_priv);
</I>&gt;<i> &gt; +#endif
</I>&gt;<i> &gt; +       if (!dev)
</I>&gt;<i> &gt; +               return NULL;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       priv-&gt;dev = dev;
</I>&gt;<i> &gt; +       priv-&gt;can.bittiming_const = &amp;bosch_ccan_bittiming_const;
</I>&gt;<i> &gt; +       priv-&gt;can.do_set_bittiming = bosch_ccan_set_bittiming;
</I>&gt;<i> &gt; +       priv-&gt;can.do_get_state = bosch_ccan_get_state;
</I>&gt;<i> &gt; +       priv-&gt;can.do_set_mode = bosch_ccan_set_mode;
</I>&gt;<i>
</I>&gt;<i> Please also implement the &quot;get_berr_counter&quot; callback.
</I>
Please see above.

&gt;<i> &gt; +       return dev;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +EXPORT_SYMBOL(alloc_bosch_ccandev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +void free_bosch_ccandev(struct net_device *dev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       free_candev(dev);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +EXPORT_SYMBOL(free_bosch_ccandev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
</I>&gt;<i> &gt; +static const struct net_device_ops bosch_ccan_netdev_ops = {
</I>&gt;<i> &gt; +       .ndo_open = bosch_ccan_open,
</I>&gt;<i> &gt; +       .ndo_stop = bosch_ccan_close,
</I>&gt;<i> &gt; +       .ndo_start_xmit = bosch_ccan_start_xmit,
</I>&gt;<i> &gt; +};
</I>&gt;<i> &gt; +#endif
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +int register_bosch_ccandev(struct net_device *dev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       dev-&gt;flags |= IFF_ECHO; /* we support local echo */
</I>&gt;<i> &gt; +#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
</I>&gt;<i> &gt; +       dev-&gt;netdev_ops = &amp;bosch_ccan_netdev_ops;
</I>&gt;<i> &gt; +#else
</I>&gt;<i> &gt; +       dev-&gt;open = bosch_ccan_open;
</I>&gt;<i> &gt; +       dev-&gt;stop = bosch_ccan_close;
</I>&gt;<i> &gt; +       dev-&gt;hard_start_xmit = bosch_ccan_start_xmit;
</I>&gt;<i> &gt; +#endif
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       return register_candev(dev);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +EXPORT_SYMBOL(register_bosch_ccandev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +void unregister_bosch_ccandev(struct net_device *dev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +       struct bosch_ccan_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       /* disable all interrupts */
</I>&gt;<i> &gt; +       priv-&gt;write_reg(priv, CAN_CONTROL, 0);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +       unregister_candev(dev);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +EXPORT_SYMBOL(unregister_bosch_ccandev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +MODULE_AUTHOR(&quot;Bhupesh Sharma &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">bhupesh.sharma at st.com</A>&gt;&quot;);
</I>&gt;<i> &gt; +MODULE_LICENSE(&quot;GPL&quot;);
</I>&gt;<i> &gt; +MODULE_DESCRIPTION(&quot;CAN bus driver for Bosch CCAN controller&quot;);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Property changes on: bosch_ccan.c
</I>&gt;<i> &gt; ___________________________________________________________________
</I>&gt;<i> &gt; Name: svn:executable
</I>&gt;<i> &gt;    + *
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Index: bosch_ccan.h
</I>&gt;<i> &gt; ===================================================================
</I>&gt;<i> &gt; --- bosch_ccan.h        (revision 0)
</I>&gt;<i> &gt; +++ bosch_ccan.h        (revision 0)
</I>&gt;<i> &gt; @@ -0,0 +1,207 @@
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * drivers/net/can/bosch_ccan.h
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * CAN bus driver definitions for Bosch CCAN controller
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Copyright (C) 2010 ST Microelectronics
</I>&gt;<i> &gt; + * Bhupesh Sharma &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">bhupesh.sharma at st.com</A>&gt;
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Borrowed heavily from the CCAN driver originally written by:
</I>&gt;<i> &gt; + * - Sascha Hauer, Marc Kleine-Budde, Pengutronix
</I>&gt;<i> &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">s.hauer at pengutronix.de</A>&gt;
</I>&gt;<i> &gt; + * - Simon Kallweit, intefo AG &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">simon.kallweit at intefo.ch</A>&gt;
</I>&gt;<i> &gt; + * which can be viewed here:
</I>&gt;<i> &gt; + * <A HREF="http://svn.berlios.de/svnroot/repos/socketcan/trunk/kernel/2.6/">http://svn.berlios.de/svnroot/repos/socketcan/trunk/kernel/2.6/</A>
</I>&gt;<i> &gt; + * drivers/net/can/old/ccan/ccan.c
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Bosch CCAN controller is compliant to CAN protocol version 2.0
</I>&gt;<i> part A and B.
</I>&gt;<i> &gt; + * Bosch CCAN user manual can be obtained from:
</I>&gt;<i> &gt; + * <A HREF="http://www.semiconductors.bosch.de/pdf/Users_Manual_C_CAN.pdf">http://www.semiconductors.bosch.de/pdf/Users_Manual_C_CAN.pdf</A>
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * This file is licensed under the terms of the GNU General Public
</I>&gt;<i> &gt; + * License version 2. This program is licensed &quot;as is&quot; without any
</I>&gt;<i> &gt; + * warranty of any kind, whether express or implied.
</I>&gt;<i> &gt; + */
</I>&gt;<i>
</I>&gt;<i> See abocve.
</I>
Ditto as is bosch_ccan.c

&gt;<i> &gt; +#ifndef __CCAN_H__
</I>&gt;<i> &gt; +#define __CCAN_H__
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#include &lt;linux/can.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/clk.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/platform_device.h&gt;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#define BOSCH_CCAN_ECHO_SKB_MAX        1
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* ccan register offsets */
</I>&gt;<i> &gt; +enum ccan_regs {
</I>&gt;<i> &gt; +       CAN_CONTROL = 0x00,
</I>&gt;<i> &gt; +       CAN_STATUS = 0x02,
</I>&gt;<i> &gt; +       CAN_ERROR = 0x04,
</I>&gt;<i> &gt; +       CAN_BTR = 0x06,
</I>&gt;<i> &gt; +       CAN_IR = 0x08,
</I>&gt;<i> &gt; +       CAN_TEST = 0x0a,
</I>&gt;<i> &gt; +       CAN_BRP_EXT = 0x0c,
</I>&gt;<i> &gt; +       CAN_IF1 = 0x10,
</I>&gt;<i> &gt; +       CAN_IF2 = 0x40,
</I>&gt;<i> &gt; +       CAN_TXRQST = 0x80,      /* 32bit */
</I>&gt;<i> &gt; +       CAN_NEWDAT = 0x90,      /* 32bit */
</I>&gt;<i> &gt; +       CAN_INTPND = 0xa0,      /* 32bit */
</I>&gt;<i> &gt; +       CAN_MSGVAL = 0xb0,      /* 32bit */
</I>&gt;<i> &gt; +};
</I>&gt;<i>
</I>&gt;<i> It's unusual to define register offsets as enumeration.
</I>
Ok. I will check which can be a better way here and try to introduce the same in V2.

&gt;<i> &gt; +#define CAN_IF_COMR(x)         (CAN_IF1 + (x) * 0x30 + 0x00)
</I>&gt;<i> &gt; +#define CAN_IF_COMM(x)         (CAN_IF1 + (x) * 0x30 + 0x02)
</I>&gt;<i> &gt; +#define CAN_IF_MASK(x)         (CAN_IF1 + (x) * 0x30 + 0x04)   /*
</I>&gt;<i> 32bit */
</I>&gt;<i> &gt; +#define CAN_IF_ARB(x)          (CAN_IF1 + (x) * 0x30 + 0x08)   /*
</I>&gt;<i> 32bit */
</I>&gt;<i> &gt; +#define CAN_IF_MCONT(x)                (CAN_IF1 + (x) * 0x30 + 0x0c)
</I>&gt;<i> &gt; +#define CAN_IF_DATAA(x)                (CAN_IF1 + (x) * 0x30 + 0x0e)
</I>&gt;<i> /* 32bit */
</I>&gt;<i> &gt; +#define CAN_IF_DATAB(x)                (CAN_IF1 + (x) * 0x30 + 0x12)
</I>&gt;<i> /* 32bit */
</I>&gt;<i>
</I>&gt;<i> Hm, I don't like these macros. Is there a better way to handle message
</I>&gt;<i> offsets? Either with &quot;static inlines&quot; or even better by using a struct
</I>&gt;<i> to define the register layout.
</I>
Ok. I will check which can be a better way here and try to introduce the same in V2.

&gt;<i> &gt; +/* control register */
</I>&gt;<i> &gt; +#define CONTROL_TEST           (1&lt;&lt;7)
</I>&gt;<i> &gt; +#define CONTROL_CCE            (1&lt;&lt;6)
</I>&gt;<i> &gt; +#define CONTROL_DISABLE_AR     (1&lt;&lt;5)
</I>&gt;<i> &gt; +#define CONTROL_ENABLE_AR      (0&lt;&lt;5)
</I>&gt;<i> &gt; +#define CONTROL_EIE            (1&lt;&lt;3)
</I>&gt;<i> &gt; +#define CONTROL_SIE            (1&lt;&lt;2)
</I>&gt;<i> &gt; +#define CONTROL_IE             (1&lt;&lt;1)
</I>&gt;<i> &gt; +#define CONTROL_INIT           (1&lt;&lt;0)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* test register */
</I>&gt;<i> &gt; +#define TEST_RX                        (1&lt;&lt;7)
</I>&gt;<i> &gt; +#define TEST_TX1               (1&lt;&lt;6)
</I>&gt;<i> &gt; +#define TEST_TX2               (1&lt;&lt;5)
</I>&gt;<i> &gt; +#define TEST_LBACK             (1&lt;&lt;4)
</I>&gt;<i> &gt; +#define TEST_SILENT            (1&lt;&lt;3)
</I>&gt;<i> &gt; +#define TEST_BASIC             (1&lt;&lt;2)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* status register */
</I>&gt;<i> &gt; +#define STATUS_BOFF            (1&lt;&lt;7)
</I>&gt;<i> &gt; +#define STATUS_EWARN           (1&lt;&lt;6)
</I>&gt;<i> &gt; +#define STATUS_EPASS           (1&lt;&lt;5)
</I>&gt;<i> &gt; +#define STATUS_RXOK            (1&lt;&lt;4)
</I>&gt;<i> &gt; +#define STATUS_TXOK            (1&lt;&lt;3)
</I>&gt;<i> &gt; +#define STATUS_LEC_MASK                0x07
</I>&gt;<i> &gt; +#define LEC_STUFF_ERROR                1
</I>&gt;<i> &gt; +#define LEC_FORM_ERROR         2
</I>&gt;<i> &gt; +#define LEC_ACK_ERROR          3
</I>&gt;<i> &gt; +#define LEC_BIT1_ERROR         4
</I>&gt;<i> &gt; +#define LEC_BIT0_ERROR         5
</I>&gt;<i> &gt; +#define LEC_CRC_ERROR          6
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* error counter register */
</I>&gt;<i> &gt; +#define ERR_COUNTER_TEC_MASK   0xff
</I>&gt;<i> &gt; +#define ERR_COUNTER_TEC_SHIFT  0x0
</I>&gt;<i> &gt; +#define ERR_COUNTER_REC_SHIFT  8
</I>&gt;<i> &gt; +#define ERR_COUNTER_REC_MASK   (0x7f&lt;&lt;ERR_COUNTER_REC_SHIFT)
</I>&gt;<i> &gt; +#define ERR_COUNTER_RP_SHIFT   15
</I>&gt;<i> &gt; +#define ERR_COUNTER_RP_MASK    (0x1&lt;&lt;ERR_COUNTER_RP_SHIFT)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* bit-timing register */
</I>&gt;<i> &gt; +#define BTR_BRP_MASK           0x3f
</I>&gt;<i> &gt; +#define BTR_BRP_SHIFT          0
</I>&gt;<i> &gt; +#define BTR_SJW_SHIFT          6
</I>&gt;<i> &gt; +#define BTR_SJW_MASK           (0x3&lt;&lt;BTR_SJW_SHIFT)
</I>&gt;<i> &gt; +#define BTR_TSEG1_SHIFT                8
</I>&gt;<i> &gt; +#define BTR_TSEG1_MASK         (0xf&lt;&lt;BTR_TSEG1_SHIFT)
</I>&gt;<i> &gt; +#define BTR_TSEG2_SHIFT                12
</I>&gt;<i> &gt; +#define BTR_TSEG2_MASK         (0x7&lt;&lt;BTR_TSEG2_SHIFT)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* brp extension register */
</I>&gt;<i> &gt; +#define BRP_EXT_BRPE_MASK      0x0f
</I>&gt;<i> &gt; +#define BRP_EXT_BRPE_SHIFT     0
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* IFx command request */
</I>&gt;<i> &gt; +#define IF_COMR_BUSY           (1&lt;&lt;15)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* IFx command mask */
</I>&gt;<i> &gt; +#define IF_COMM_WR             (1&lt;&lt;7)
</I>&gt;<i> &gt; +#define IF_COMM_MASK           (1&lt;&lt;6)
</I>&gt;<i> &gt; +#define IF_COMM_ARB            (1&lt;&lt;5)
</I>&gt;<i> &gt; +#define IF_COMM_CONTROL                (1&lt;&lt;4)
</I>&gt;<i> &gt; +#define IF_COMM_CLR_INT_PND    (1&lt;&lt;3)
</I>&gt;<i> &gt; +#define IF_COMM_TXRQST         (1&lt;&lt;2)
</I>&gt;<i> &gt; +#define IF_COMM_DATAA          (1&lt;&lt;1)
</I>&gt;<i> &gt; +#define IF_COMM_DATAB          (1&lt;&lt;0)
</I>&gt;<i> &gt; +#define IF_COMM_ALL            (IF_COMM_MASK | IF_COMM_ARB | \
</I>&gt;<i> &gt; +                               IF_COMM_CONTROL | IF_COMM_TXRQST | \
</I>&gt;<i> &gt; +                               IF_COMM_DATAA | IF_COMM_DATAB)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* IFx arbitration */
</I>&gt;<i> &gt; +#define IF_ARB_MSGVAL          (1&lt;&lt;31)
</I>&gt;<i> &gt; +#define IF_ARB_MSGXTD          (1&lt;&lt;30)
</I>&gt;<i> &gt; +#define IF_ARB_TRANSMIT                (1&lt;&lt;29)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* IFx message control */
</I>&gt;<i> &gt; +#define IF_MCONT_NEWDAT                (1&lt;&lt;15)
</I>&gt;<i> &gt; +#define IF_MCONT_MSGLST                (1&lt;&lt;14)
</I>&gt;<i> &gt; +#define IF_MCONT_INTPND                (1&lt;&lt;13)
</I>&gt;<i> &gt; +#define IF_MCONT_UMASK         (1&lt;&lt;12)
</I>&gt;<i> &gt; +#define IF_MCONT_TXIE          (1&lt;&lt;11)
</I>&gt;<i> &gt; +#define IF_MCONT_RXIE          (1&lt;&lt;10)
</I>&gt;<i> &gt; +#define IF_MCONT_RMTEN         (1&lt;&lt;9)
</I>&gt;<i> &gt; +#define IF_MCONT_TXRQST                (1&lt;&lt;8)
</I>&gt;<i> &gt; +#define IF_MCONT_EOB           (1&lt;&lt;7)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* message object */
</I>&gt;<i> &gt; +#define MAX_OBJECT             31
</I>&gt;<i> &gt; +#define MAX_TRANSMIT_OBJECT    15
</I>&gt;<i> &gt; +#define RECEIVE_OBJECT_BITS    0xffff0000
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * CCAN operating modes:
</I>&gt;<i> &gt; + * Support is available for default as well as test operating modes.
</I>&gt;<i> &gt; + * Normal mode will generally be used as a default mode in most
</I>&gt;<i> cases,
</I>&gt;<i> &gt; + * however, various test modes may be useful in specific use-cases.
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +enum bosch_ccan_operating_mode {
</I>&gt;<i> &gt; +       CCAN_NORMAL_MODE = 0,
</I>&gt;<i> &gt; +       CCAN_BASIC_MODE,
</I>&gt;<i> &gt; +       CCAN_LOOPBACK_MODE,
</I>&gt;<i> &gt; +       CCAN_LOOPBACK_WITH_SILENT_MODE,
</I>&gt;<i> &gt; +       CCAN_SILENT_MODE
</I>&gt;<i> &gt; +};
</I>&gt;<i>
</I>&gt;<i> I do not see a need for another enumeration o the type. We already have
</I>&gt;<i> the CAN_CTRLMODE_*.
</I>
Yes. But I don't see CAN_CTRLMODE_* capturing all the operating mode types supported by Bosch CCAN.

&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * Automatic Retransmssion compliance with ISO11898, 6.3.3 Recovery
</I>&gt;<i> Management:
</I>&gt;<i> &gt; + * Support is available for enabling automatic retransmission of
</I>&gt;<i> frames
</I>&gt;<i> &gt; + * (default behavior) as well as disabling the same for TTCAN
</I>&gt;<i> &gt; + * environments.
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +enum bosch_ccan_auto_tx_config {
</I>&gt;<i> &gt; +       CCAN_ENABLE_AUTO_RE_TRANSMIT = 0,
</I>&gt;<i> &gt; +       CCAN_DISABLE_AUTO_RE_TRANSMIT
</I>&gt;<i> &gt; +};
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * CCAN error types:
</I>&gt;<i> &gt; + * Bus errors (BUS_OFF, ERROR_WARNING, ERROR_PASSIVE) are supported
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +enum bosch_ccan_bus_error_types {
</I>&gt;<i> &gt; +       CCAN_NO_ERROR = 0,
</I>&gt;<i> &gt; +       CCAN_BUS_OFF,
</I>&gt;<i> &gt; +       CCAN_ERROR_WARNING,
</I>&gt;<i> &gt; +       CCAN_ERROR_PASSIVE
</I>&gt;<i> &gt; +};
</I>&gt;<i>
</I>&gt;<i> Ditto. Also CCAN_ERROR_PASSIVE=3 and you use &quot;error_type &amp;
</I>&gt;<i> CCAN_ERROR_PASSIVE&quot; in your code.
</I>
Ditto.

&gt;<i> &gt; +/* CCAN private data structure */
</I>&gt;<i> &gt; +struct bosch_ccan_priv {
</I>&gt;<i> &gt; +       struct can_priv can;    /* must be the first member */
</I>&gt;<i> &gt; +       struct net_device *dev;
</I>&gt;<i> &gt; +       int tx_object;
</I>&gt;<i> &gt; +       int current_status;
</I>&gt;<i> &gt; +       int last_status;
</I>&gt;<i> &gt; +       u16 (*read_reg) (const struct bosch_ccan_priv *priv,
</I>&gt;<i> &gt; +                               enum ccan_regs reg);
</I>&gt;<i> &gt; +       void (*write_reg) (const struct bosch_ccan_priv *priv,
</I>&gt;<i> &gt; +                               enum ccan_regs reg, u16 val);
</I>&gt;<i> &gt; +       void __iomem *reg_base;  /* ioremap'ed address to registers
</I>&gt;<i> */
</I>&gt;<i> &gt; +       unsigned long irq_flags; /* for request_irq() */
</I>&gt;<i> &gt; +       struct clk *clk;
</I>&gt;<i> &gt; +};
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +struct net_device *alloc_bosch_ccandev(int sizeof_priv);
</I>&gt;<i> &gt; +void free_bosch_ccandev(struct net_device *dev);
</I>&gt;<i> &gt; +int register_bosch_ccandev(struct net_device *dev);
</I>&gt;<i> &gt; +void unregister_bosch_ccandev(struct net_device *dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#endif /* __CCAN_H__ */
</I>&gt;<i>
</I>&gt;<i> Wolfgang.
</I>
Regards,
Bhupesh

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004582.html">[RFC PATCH 2/4 RESEND] Bosch CCAN driver
</A></li>
	<LI>Next message: <A HREF="004584.html">[RFC PATCH 2/4 RESEND] Bosch CCAN driver
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4583">[ date ]</a>
              <a href="thread.html#4583">[ thread ]</a>
              <a href="subject.html#4583">[ subject ]</a>
              <a href="author.html#4583">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
