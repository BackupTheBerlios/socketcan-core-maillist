<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH net-next-2.6 v1] can: Topcliff: Update PCH_CAN driver	to 2.6.35
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2010-October/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20net-next-2.6%20v1%5D%20can%3A%20Topcliff%3A%20Update%20PCH_CAN%20driver%0A%09to%202.6.35&In-Reply-To=%3C4CBD5053.1060901%40grandegger.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004787.html">
   <LINK REL="Next"  HREF="004871.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH net-next-2.6 v1] can: Topcliff: Update PCH_CAN driver	to 2.6.35</H1>
    <B>Wolfgang Grandegger</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20net-next-2.6%20v1%5D%20can%3A%20Topcliff%3A%20Update%20PCH_CAN%20driver%0A%09to%202.6.35&In-Reply-To=%3C4CBD5053.1060901%40grandegger.com%3E"
       TITLE="[PATCH net-next-2.6 v1] can: Topcliff: Update PCH_CAN driver	to 2.6.35">wg at grandegger.com
       </A><BR>
    <I>Tue Oct 19 10:01:23 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="004787.html">[PATCH net-next-2.6 v1] can: Topcliff: Update PCH_CAN driver	to 2.6.35
</A></li>
        <LI>Next message: <A HREF="004871.html">[PATCH net-next-2.6 v1] can: Topcliff: Update PCH_CAN driver	to 2.6.35
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4789">[ date ]</a>
              <a href="thread.html#4789">[ thread ]</a>
              <a href="subject.html#4789">[ subject ]</a>
              <a href="author.html#4789">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>CoOn 10/19/2010 09:30 AM, Wolfgang Grandegger wrote:
&gt;<i> Hallo,
</I>&gt;<i> 
</I>&gt;<i> I will add some more comments here:
</I>&gt;<i> 
</I>&gt;<i> On 10/15/2010 09:07 PM, Marc Kleine-Budde wrote:
</I>&gt;&gt;<i> Hello Masayuki,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On 10/15/2010 03:00 PM, Masayuki Ohtak wrote:
</I>&gt;&gt;&gt;<i> Hi Wolfgang,
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> We have modified for your indications.
</I>&gt;&gt;&gt;<i> Please check below.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The driver looks better each time, some comments inline.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> cheers, Marc
</I>&gt;&gt;&gt;<i> ---
</I>&gt;&gt;&gt;<i> CAN driver of Topcliff PCH
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Topcliff PCH is the platform controller hub that is going to be used in
</I>&gt;&gt;&gt;<i> Intel's upcoming general embedded platform. All IO peripherals in
</I>&gt;&gt;&gt;<i> Topcliff PCH are actually devices sitting on AMBA bus. 
</I>&gt;&gt;&gt;<i> Topcliff PCH has CAN I/F. This driver enables CAN function.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Signed-off-by: Masayuki Ohtake &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">masa-korg at dsn.okisemi.com</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> The patch does not apply to the net-next-2.6 try. This is required for
</I>&gt;<i> kernel sooner than later.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> ---
</I>&gt;&gt;&gt;<i>  drivers/net/can/Kconfig   |    8 +
</I>&gt;&gt;&gt;<i>  drivers/net/can/Makefile  |    1 +
</I>&gt;&gt;&gt;<i>  drivers/net/can/pch_can.c | 1463 +++++++++++++++++++++++++++++++++++++++++++++
</I>&gt;&gt;&gt;<i>  3 files changed, 1472 insertions(+), 0 deletions(-)
</I>&gt;&gt;&gt;<i>  create mode 100644 drivers/net/can/pch_can.c
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
</I>&gt;&gt;&gt;<i> index 2c5227c..5c98a20 100644
</I>&gt;&gt;&gt;<i> --- a/drivers/net/can/Kconfig
</I>&gt;&gt;&gt;<i> +++ b/drivers/net/can/Kconfig
</I>&gt;&gt;&gt;<i> @@ -73,6 +73,14 @@ config CAN_JANZ_ICAN3
</I>&gt;&gt;&gt;<i>  	  This driver can also be built as a module. If so, the module will be
</I>&gt;&gt;&gt;<i>  	  called janz-ican3.ko.
</I>&gt;&gt;&gt;<i>  
</I>&gt;&gt;&gt;<i> +config PCH_CAN
</I>&gt;&gt;&gt;<i> +	tristate &quot;PCH CAN&quot;
</I>&gt;&gt;&gt;<i> +	depends on  CAN_DEV
</I>&gt;&gt;&gt;<i> +	---help---
</I>&gt;&gt;&gt;<i> +	  This driver is for PCH CAN of Topcliff which is an IOH for x86
</I>&gt;&gt;&gt;<i> +	  embedded processor.
</I>&gt;&gt;&gt;<i> +	  This driver can access CAN bus.
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i>  source &quot;drivers/net/can/mscan/Kconfig&quot;
</I>&gt;&gt;&gt;<i>  
</I>&gt;&gt;&gt;<i>  source &quot;drivers/net/can/sja1000/Kconfig&quot;
</I>&gt;&gt;&gt;<i> diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
</I>&gt;&gt;&gt;<i> index 9047cd0..3ddc6a7 100644
</I>&gt;&gt;&gt;<i> --- a/drivers/net/can/Makefile
</I>&gt;&gt;&gt;<i> +++ b/drivers/net/can/Makefile
</I>&gt;&gt;&gt;<i> @@ -16,5 +16,6 @@ obj-$(CONFIG_CAN_TI_HECC)	+= ti_hecc.o
</I>&gt;&gt;&gt;<i>  obj-$(CONFIG_CAN_MCP251X)	+= mcp251x.o
</I>&gt;&gt;&gt;<i>  obj-$(CONFIG_CAN_BFIN)		+= bfin_can.o
</I>&gt;&gt;&gt;<i>  obj-$(CONFIG_CAN_JANZ_ICAN3)	+= janz-ican3.o
</I>&gt;&gt;&gt;<i> +obj-$(CONFIG_PCH_CAN)		+= pch_can.o
</I>&gt;&gt;&gt;<i>  
</I>&gt;&gt;&gt;<i>  ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
</I>&gt;&gt;&gt;<i> diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
</I>&gt;&gt;&gt;<i> new file mode 100644
</I>&gt;&gt;&gt;<i> index 0000000..55ec324
</I>&gt;&gt;&gt;<i> --- /dev/null
</I>&gt;&gt;&gt;<i> +++ b/drivers/net/can/pch_can.c
</I>&gt;&gt;&gt;<i> @@ -0,0 +1,1463 @@
</I>&gt;&gt;&gt;<i> +/*
</I>&gt;&gt;&gt;<i> + * Copyright (C) 1999 - 2010 Intel Corporation.
</I>&gt;&gt;&gt;<i> + * Copyright (C) 2010 OKI SEMICONDUCTOR Co., LTD.
</I>&gt;&gt;&gt;<i> + *
</I>&gt;&gt;&gt;<i> + * This program is free software; you can redistribute it and/or modify
</I>&gt;&gt;&gt;<i> + * it under the terms of the GNU General Public License as published by
</I>&gt;&gt;&gt;<i> + * the Free Software Foundation; version 2 of the License.
</I>&gt;&gt;&gt;<i> + *
</I>&gt;&gt;&gt;<i> + * This program is distributed in the hope that it will be useful,
</I>&gt;&gt;&gt;<i> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
</I>&gt;&gt;&gt;<i> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</I>&gt;&gt;&gt;<i> + * GNU General Public License for more details.
</I>&gt;&gt;&gt;<i> + *
</I>&gt;&gt;&gt;<i> + * You should have received a copy of the GNU General Public License
</I>&gt;&gt;&gt;<i> + * along with this program; if not, write to the Free Software
</I>&gt;&gt;&gt;<i> + * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
</I>&gt;&gt;&gt;<i> + */
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#include &lt;linux/interrupt.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/delay.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/io.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/module.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/sched.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/pci.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/init.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/kernel.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/types.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/errno.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/netdevice.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/skbuff.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/can.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/can/dev.h&gt;
</I>&gt;&gt;&gt;<i> +#include &lt;linux/can/error.h&gt;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define MAX_MSG_OBJ		32
</I>&gt;&gt;&gt;<i> +#define MSG_OBJ_RX		0 /* The receive message object flag. */
</I>&gt;&gt;&gt;<i> +#define MSG_OBJ_TX		1 /* The transmit message object flag. */
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define ENABLE			1 /* The enable flag */
</I>&gt;&gt;&gt;<i> +#define DISABLE			0 /* The disable flag */
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I prefer just plain 0 and 1, YMMV.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +#define CAN_CTRL_INIT		0x0001 /* The INIT bit of CANCONT register. */
</I>&gt;&gt;&gt;<i> +#define CAN_CTRL_IE		0x0002 /* The IE bit of CAN control register */
</I>&gt;&gt;&gt;<i> +#define CAN_CTRL_IE_SIE_EIE	0x000e
</I>&gt;&gt;&gt;<i> +#define CAN_CTRL_CCE		0x0040
</I>&gt;&gt;&gt;<i> +#define CAN_CTRL_OPT		0x0080 /* The OPT bit of CANCONT register. */
</I>&gt;&gt;&gt;<i> +#define CAN_OPT_SILENT		0x0008 /* The Silent bit of CANOPT reg. */
</I>&gt;&gt;&gt;<i> +#define CAN_OPT_LBACK		0x0010 /* The LoopBack bit of CANOPT reg. */
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_RX_TX_SET	0x00f3
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_RX_TX_GET	0x0073
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_ALL		0xff
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_RDWR		0x80
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_ARB		0x20
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_CTRL		0x10
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_MASK		0x40
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_NEWDAT	0x04
</I>&gt;&gt;&gt;<i> +#define CAN_CMASK_CLRINTPND	0x08
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_NEWDAT	0x8000
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_INTPND	0x2000
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_UMASK	0x1000
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_TXIE	0x0800
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_RXIE	0x0400
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_RMTEN	0x0200
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_TXRQXT	0x0100
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_EOB	0x0080
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_DLC	0x000f
</I>&gt;&gt;&gt;<i> +#define CAN_IF_MCONT_MSGLOST	0x4000
</I>&gt;&gt;&gt;<i> +#define CAN_MASK2_MDIR_MXTD	0xc000
</I>&gt;&gt;&gt;<i> +#define CAN_ID2_DIR		0x2000
</I>&gt;&gt;&gt;<i> +#define CAN_ID_MSGVAL		0x8000
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define CAN_STATUS_INT		0x8000
</I>&gt;&gt;&gt;<i> +#define CAN_IF_CREQ_BUSY	0x8000
</I>&gt;&gt;&gt;<i> +#define CAN_ID2_XTD		0x4000
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define CAN_REC			0x00007f00
</I>&gt;&gt;&gt;<i> +#define CAN_TEC			0x000000ff
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define PCH_RX_OK		0x00000010
</I>&gt;&gt;&gt;<i> +#define PCH_TX_OK		0x00000008
</I>&gt;&gt;&gt;<i> +#define PCH_BUS_OFF		0x00000080
</I>&gt;&gt;&gt;<i> +#define PCH_EWARN		0x00000040
</I>&gt;&gt;&gt;<i> +#define PCH_EPASSIV		0x00000020
</I>&gt;&gt;&gt;<i> +#define PCH_LEC0		0x00000001
</I>&gt;&gt;&gt;<i> +#define PCH_LEC1		0x00000002
</I>&gt;&gt;&gt;<i> +#define PCH_LEC2		0x00000004
</I>&gt;&gt;&gt;<i> +#define PCH_LEC_ALL		(PCH_LEC0 | PCH_LEC1 | PCH_LEC2)
</I>&gt;&gt;&gt;<i> +#define PCH_STUF_ERR		PCH_LEC0
</I>&gt;&gt;&gt;<i> +#define PCH_FORM_ERR		PCH_LEC1
</I>&gt;&gt;&gt;<i> +#define PCH_ACK_ERR		(PCH_LEC0 | PCH_LEC1)
</I>&gt;&gt;&gt;<i> +#define PCH_BIT1_ERR		PCH_LEC2
</I>&gt;&gt;&gt;<i> +#define PCH_BIT0_ERR		(PCH_LEC0 | PCH_LEC2)
</I>&gt;&gt;&gt;<i> +#define PCH_CRC_ERR		(PCH_LEC1 | PCH_LEC2)
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +/* bit position of certain controller bits. */
</I>&gt;&gt;&gt;<i> +#define BIT_BITT_BRP		0
</I>&gt;&gt;&gt;<i> +#define BIT_BITT_SJW		6
</I>&gt;&gt;&gt;<i> +#define BIT_BITT_TSEG1		8
</I>&gt;&gt;&gt;<i> +#define BIT_BITT_TSEG2		12
</I>&gt;&gt;&gt;<i> +#define BIT_IF1_MCONT_RXIE	10
</I>&gt;&gt;&gt;<i> +#define BIT_IF2_MCONT_TXIE	11
</I>&gt;&gt;&gt;<i> +#define BIT_BRPE_BRPE		6
</I>&gt;&gt;&gt;<i> +#define BIT_ES_TXERRCNT		0
</I>&gt;&gt;&gt;<i> +#define BIT_ES_RXERRCNT		8
</I>&gt;&gt;&gt;<i> +#define MSK_BITT_BRP		0x3f
</I>&gt;&gt;&gt;<i> +#define MSK_BITT_SJW		0xc0
</I>&gt;&gt;&gt;<i> +#define MSK_BITT_TSEG1		0xf00
</I>&gt;&gt;&gt;<i> +#define MSK_BITT_TSEG2		0x7000
</I>&gt;&gt;&gt;<i> +#define MSK_BRPE_BRPE		0x3c0
</I>&gt;&gt;&gt;<i> +#define MSK_BRPE_GET		0x0f
</I>&gt;&gt;&gt;<i> +#define MSK_CTRL_IE_SIE_EIE	0x07
</I>&gt;&gt;&gt;<i> +#define MSK_MCONT_TXIE		0x08
</I>&gt;&gt;&gt;<i> +#define MSK_MCONT_RXIE		0x10
</I>&gt;&gt;&gt;<i> +#define PCH_CAN_NO_TX_BUFF	1
</I>&gt;&gt;&gt;<i> +#define COUNTER_LIMIT		10
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define PCH_CAN_CLK		50000000	/* 50MHz */
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +/* Define the number of message object.
</I>&gt;&gt;&gt;<i> + * PCH CAN communications are done via Message RAM.
</I>&gt;&gt;&gt;<i> + * The Message RAM consists of 32 message objects. */
</I>&gt;&gt;<i> /*
</I>&gt;&gt;<i>  * this is the preferred multi line comment style,
</I>&gt;&gt;<i>  * please change
</I>&gt;&gt;<i>  */
</I>&gt;&gt;&gt;<i> +#define PCH_RX_OBJ_NUM		26  /* 1~ PCH_RX_OBJ_NUM is Rx*/
</I>&gt;&gt;&gt;<i> +#define PCH_TX_OBJ_NUM		6  /* PCH_RX_OBJ_NUM is RX ~ Tx*/
</I>&gt;&gt;&gt;<i> +#define PCH_OBJ_NUM		(PCH_TX_OBJ_NUM + PCH_RX_OBJ_NUM)
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define PCH_FIFO_THRESH		16
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +enum pch_can_mode {
</I>&gt;&gt;&gt;<i> +	PCH_CAN_ENABLE,
</I>&gt;&gt;&gt;<i> +	PCH_CAN_DISABLE,
</I>&gt;&gt;&gt;<i> +	PCH_CAN_ALL,
</I>&gt;&gt;&gt;<i> +	PCH_CAN_NONE,
</I>&gt;&gt;&gt;<i> +	PCH_CAN_STOP,
</I>&gt;&gt;&gt;<i> +	PCH_CAN_RUN
</I>&gt;&gt;<i> please add a &quot;,&quot; at the end
</I>&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +struct pch_can_regs {
</I>&gt;&gt;&gt;<i> +	u32 cont;
</I>&gt;&gt;&gt;<i> +	u32 stat;
</I>&gt;&gt;&gt;<i> +	u32 errc;
</I>&gt;&gt;&gt;<i> +	u32 bitt;
</I>&gt;&gt;&gt;<i> +	u32 intr;
</I>&gt;&gt;&gt;<i> +	u32 opt;
</I>&gt;&gt;&gt;<i> +	u32 brpe;
</I>&gt;&gt;&gt;<i> +	u32 reserve1;
</I>&gt;&gt;&gt;<i> +	u32 if1_creq;
</I>&gt;&gt;&gt;<i> +	u32 if1_cmask;
</I>&gt;&gt;&gt;<i> +	u32 if1_mask1;
</I>&gt;&gt;&gt;<i> +	u32 if1_mask2;
</I>&gt;&gt;&gt;<i> +	u32 if1_id1;
</I>&gt;&gt;&gt;<i> +	u32 if1_id2;
</I>&gt;&gt;&gt;<i> +	u32 if1_mcont;
</I>&gt;&gt;&gt;<i> +	u32 if1_dataa1;
</I>&gt;&gt;&gt;<i> +	u32 if1_dataa2;
</I>&gt;&gt;&gt;<i> +	u32 if1_datab1;
</I>&gt;&gt;&gt;<i> +	u32 if1_datab2;
</I>&gt;&gt;&gt;<i> +	u32 reserve2;
</I>&gt;&gt;&gt;<i> +	u32 reserve3[12];
</I>&gt;&gt;&gt;<i> +	u32 if2_creq;
</I>&gt;&gt;&gt;<i> +	u32 if2_cmask;
</I>&gt;&gt;&gt;<i> +	u32 if2_mask1;
</I>&gt;&gt;&gt;<i> +	u32 if2_mask2;
</I>&gt;&gt;&gt;<i> +	u32 if2_id1;
</I>&gt;&gt;&gt;<i> +	u32 if2_id2;
</I>&gt;&gt;&gt;<i> +	u32 if2_mcont;
</I>&gt;&gt;&gt;<i> +	u32 if2_dataa1;
</I>&gt;&gt;&gt;<i> +	u32 if2_dataa2;
</I>&gt;&gt;&gt;<i> +	u32 if2_datab1;
</I>&gt;&gt;&gt;<i> +	u32 if2_datab2;
</I>&gt;&gt;&gt;<i> +	u32 reserve4;
</I>&gt;&gt;&gt;<i> +	u32 reserve5[20];
</I>&gt;&gt;&gt;<i> +	u32 treq1;
</I>&gt;&gt;&gt;<i> +	u32 treq2;
</I>&gt;&gt;&gt;<i> +	u32 reserve6[2];
</I>&gt;&gt;&gt;<i> +	u32 reserve7[56];
</I>&gt;&gt;&gt;<i> +	u32 reserve8[3];
</I>&gt;&gt;&gt;<i> +	u32 srst;
</I>&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +struct pch_can_priv {
</I>&gt;&gt;&gt;<i> +	struct can_priv can;
</I>&gt;&gt;&gt;<i> +	unsigned int can_num;
</I>&gt;&gt;<i> seems unused, pelase remove
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +	struct pci_dev *dev;
</I>&gt;&gt;&gt;<i> +	unsigned int tx_enable[MAX_MSG_OBJ];
</I>&gt;&gt;&gt;<i> +	unsigned int rx_enable[MAX_MSG_OBJ];
</I>&gt;&gt;&gt;<i> +	unsigned int rx_link[MAX_MSG_OBJ];
</I>&gt;&gt;&gt;<i> +	unsigned int int_enables;
</I>&gt;&gt;&gt;<i> +	unsigned int int_stat;
</I>&gt;&gt;&gt;<i> +	struct net_device *ndev;
</I>&gt;&gt;&gt;<i> +	spinlock_t msgif_reg_lock; /* Message Interface Registers Access Lock*/
</I>&gt;&gt;&gt;<i> +	unsigned int msg_obj[MAX_MSG_OBJ];
</I>&gt;&gt;&gt;<i> +	struct pch_can_regs __iomem *regs;
</I>&gt;&gt;&gt;<i> +	struct napi_struct napi;
</I>&gt;&gt;&gt;<i> +	unsigned int tx_obj;	/* Point next Tx Obj index */
</I>&gt;&gt;&gt;<i> +	unsigned int use_msi;
</I>&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static struct can_bittiming_const pch_can_bittiming_const = {
</I>&gt;&gt;&gt;<i> +	.name = KBUILD_MODNAME,
</I>&gt;&gt;&gt;<i> +	.tseg1_min = 1,
</I>&gt;&gt;&gt;<i> +	.tseg1_max = 16,
</I>&gt;&gt;&gt;<i> +	.tseg2_min = 1,
</I>&gt;&gt;&gt;<i> +	.tseg2_max = 8,
</I>&gt;&gt;&gt;<i> +	.sjw_max = 4,
</I>&gt;&gt;&gt;<i> +	.brp_min = 1,
</I>&gt;&gt;&gt;<i> +	.brp_max = 1024, /* 6bit + extended 4bit */
</I>&gt;&gt;&gt;<i> +	.brp_inc = 1,
</I>&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static DEFINE_PCI_DEVICE_TABLE(pch_pci_tbl) = {
</I>&gt;&gt;&gt;<i> +	{PCI_VENDOR_ID_INTEL, 0x8818, PCI_ANY_ID, PCI_ANY_ID,},
</I>&gt;&gt;&gt;<i> +	{0,}
</I>&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;<i> +MODULE_DEVICE_TABLE(pci, pch_pci_tbl);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static inline void pch_can_bit_set(u32 *addr, u32 mask)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	iowrite32(ioread32(addr) | mask, addr);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static inline void pch_can_bit_clear(u32 *addr, u32 mask)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	iowrite32(ioread32(addr) &amp; ~mask, addr);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_set_run_mode(struct pch_can_priv *priv,
</I>&gt;&gt;&gt;<i> +				 enum pch_can_mode mode)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	switch (mode) {
</I>&gt;&gt;&gt;<i> +	case PCH_CAN_RUN:
</I>&gt;&gt;&gt;<i> +		pch_can_bit_clear(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_INIT);
</I>&gt;&gt;&gt;<i> +		break;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	case PCH_CAN_STOP:
</I>&gt;&gt;&gt;<i> +		pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_INIT);
</I>&gt;&gt;&gt;<i> +		break;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	default:
</I>&gt;&gt;&gt;<i> +		dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;%s -&gt; Invalid Mode.\n&quot;, __func__);
</I>&gt;&gt;&gt;<i> +		break;
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_set_optmode(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	u32 reg_val = ioread32(&amp;priv-&gt;regs-&gt;opt);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LISTENONLY)
</I>&gt;&gt;&gt;<i> +		reg_val |= CAN_OPT_SILENT;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LOOPBACK)
</I>&gt;&gt;&gt;<i> +		reg_val |= CAN_OPT_LBACK;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_OPT);
</I>&gt;&gt;&gt;<i> +	iowrite32(reg_val, &amp;priv-&gt;regs-&gt;opt);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_set_int_custom(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	/* Clearing the IE, SIE and EIE bits of Can control register. */
</I>&gt;&gt;&gt;<i> +	pch_can_bit_clear(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_IE_SIE_EIE);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Appropriately setting them. */
</I>&gt;&gt;&gt;<i> +	pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont,
</I>&gt;&gt;&gt;<i> +			((priv-&gt;int_enables &amp; MSK_CTRL_IE_SIE_EIE) &lt;&lt; 1));
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +/* This function retrieves interrupt enabled for the CAN device. */
</I>&gt;&gt;&gt;<i> +static void pch_can_get_int_enables(struct pch_can_priv *priv, u32 *enables)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	/* Obtaining the status of IE, SIE and EIE interrupt bits. */
</I>&gt;&gt;&gt;<i> +	*enables = ((ioread32(&amp;priv-&gt;regs-&gt;cont) &amp; CAN_CTRL_IE_SIE_EIE) &gt;&gt; 1);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I suggest to change these functions to simply return the value, not
</I>&gt;&gt;<i> using a pointer.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_set_int_enables(struct pch_can_priv *priv,
</I>&gt;&gt;&gt;<i> +				    enum pch_can_mode interrupt_no)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	switch (interrupt_no) {
</I>&gt;&gt;&gt;<i> +	case PCH_CAN_ENABLE:
</I>&gt;&gt;&gt;<i> +		pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_IE);
</I>&gt;&gt;&gt;<i> +		break;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	case PCH_CAN_DISABLE:
</I>&gt;&gt;&gt;<i> +		pch_can_bit_clear(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_IE);
</I>&gt;&gt;&gt;<i> +		break;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	case PCH_CAN_ALL:
</I>&gt;&gt;&gt;<i> +		pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_IE_SIE_EIE);
</I>&gt;&gt;&gt;<i> +		break;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	case PCH_CAN_NONE:
</I>&gt;&gt;&gt;<i> +		pch_can_bit_clear(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_IE_SIE_EIE);
</I>&gt;&gt;&gt;<i> +		break;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	default:
</I>&gt;&gt;&gt;<i> +		dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;Invalid interrupt number.\n&quot;);
</I>&gt;&gt;&gt;<i> +		break;
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_check_if_busy(u32 __iomem *creq_addr, u32 num)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	u32 counter = COUNTER_LIMIT;
</I>&gt;&gt;&gt;<i> +	u32 ifx_creq;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	iowrite32(num, creq_addr);
</I>&gt;&gt;&gt;<i> +	while (counter) {
</I>&gt;&gt;&gt;<i> +		ifx_creq = ioread32(creq_addr) &amp; CAN_IF_CREQ_BUSY;
</I>&gt;&gt;&gt;<i> +		if (!ifx_creq)
</I>&gt;&gt;&gt;<i> +			break;
</I>&gt;&gt;&gt;<i> +		counter--;
</I>&gt;&gt;&gt;<i> +		udelay(1);
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +	if (!counter)
</I>&gt;&gt;&gt;<i> +		pr_err(&quot;%s:IF1 BUSY Flag is set forever.\n&quot;, __func__);
</I>&gt;&gt;&gt;<i> +}
</I>
OK, COUNTER_LIMIT=10 means a timeout of 10 us, at leasst.

&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_set_rx_enable(struct pch_can_priv *priv, u32 buff_num,
</I>&gt;&gt;&gt;<i> +				  u32 set)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> a u32 is a bit uncommen here, as it is not a HW register, just use an
</I>&gt;&gt;<i> &quot;int&quot; (or a bool).
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	unsigned long flags;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +	/* Reading the receive buffer data from RAM to Interface1 registers */
</I>&gt;&gt;&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +	pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buff_num);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Setting the IF1MASK1 register to access MsgVal and RxIE bits */
</I>&gt;&gt;&gt;<i> +	iowrite32(CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL,
</I>&gt;&gt;&gt;<i> +		  &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	if (set == ENABLE) {
</I>&gt;&gt;&gt;<i> +		/* Setting the MsgVal and RxIE bits */
</I>&gt;&gt;&gt;<i> +		pch_can_bit_set(&amp;priv-&gt;regs-&gt;if1_mcont, CAN_IF_MCONT_RXIE);
</I>&gt;&gt;&gt;<i> +		pch_can_bit_set(&amp;priv-&gt;regs-&gt;if1_id2, CAN_ID_MSGVAL);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	} else if (set == DISABLE) {
</I>&gt;&gt;&gt;<i> +		/* Resetting the MsgVal and RxIE bits */
</I>&gt;&gt;&gt;<i> +		pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont, CAN_IF_MCONT_RXIE);
</I>&gt;&gt;&gt;<i> +		pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_id2, CAN_ID_MSGVAL);
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buff_num);
</I>&gt;&gt;&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_rx_enable_all(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	int i;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Traversing to obtain the object configured as receivers. */
</I>&gt;&gt;&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;&gt;&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_RX)
</I>&gt;&gt;&gt;<i> +			pch_can_set_rx_enable(priv, i + 1, ENABLE);
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_rx_disable_all(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	int i;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Traversing to obtain the object configured as receivers. */
</I>&gt;&gt;&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;&gt;&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_RX)
</I>&gt;&gt;&gt;<i> +			pch_can_set_rx_enable(priv, i + 1, DISABLE);
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_set_tx_enable(struct pch_can_priv *priv, u32 buff_num,
</I>&gt;&gt;&gt;<i> +				 u32 set)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	unsigned long flags;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +	/* Reading the Msg buffer from Message RAM to Interface2 registers. */
</I>&gt;&gt;&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +	pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, buff_num);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Setting the IF2CMASK register for accessing the
</I>&gt;&gt;&gt;<i> +		MsgVal and TxIE bits */
</I>&gt;&gt;&gt;<i> +	iowrite32(CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL,
</I>&gt;&gt;&gt;<i> +		 &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	if (set == ENABLE) {
</I>&gt;&gt;&gt;<i> +		/* Setting the MsgVal and TxIE bits */
</I>&gt;&gt;&gt;<i> +		pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_mcont, CAN_IF_MCONT_TXIE);
</I>&gt;&gt;&gt;<i> +		pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id2, CAN_ID_MSGVAL);
</I>&gt;&gt;&gt;<i> +	} else if (set == DISABLE) {
</I>&gt;&gt;&gt;<i> +		/* Resetting the MsgVal and TxIE bits. */
</I>&gt;&gt;&gt;<i> +		pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_mcont, CAN_IF_MCONT_TXIE);
</I>&gt;&gt;&gt;<i> +		pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_id2, CAN_ID_MSGVAL);
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, buff_num);
</I>&gt;&gt;&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_tx_enable_all(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	int i;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Traversing to obtain the object configured as transmit object. */
</I>&gt;&gt;&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;&gt;&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_TX)
</I>&gt;&gt;&gt;<i> +			pch_can_set_tx_enable(priv, i + 1, ENABLE);
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_tx_disable_all(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	int i;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Traversing to obtain the object configured as transmit object. */
</I>&gt;&gt;&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;&gt;&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_TX)
</I>&gt;&gt;&gt;<i> +			pch_can_set_tx_enable(priv, i + 1, DISABLE);
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_get_rx_enable(struct pch_can_priv *priv, u32 buff_num,
</I>&gt;&gt;&gt;<i> +				 u32 *enable)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	unsigned long flags;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +	pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buff_num);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	if (((ioread32(&amp;priv-&gt;regs-&gt;if1_id2)) &amp; CAN_ID_MSGVAL) &amp;&amp;
</I>&gt;&gt;&gt;<i> +			((ioread32(&amp;priv-&gt;regs-&gt;if1_mcont)) &amp;
</I>&gt;&gt;&gt;<i> +			CAN_IF_MCONT_RXIE))
</I>&gt;&gt;&gt;<i> +		*enable = ENABLE;
</I>&gt;&gt;&gt;<i> +	else
</I>&gt;&gt;&gt;<i> +		*enable = DISABLE;
</I>&gt;&gt;&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_get_tx_enable(struct pch_can_priv *priv, u32 buff_num,
</I>&gt;&gt;&gt;<i> +				 u32 *enable)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	unsigned long flags;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +	pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, buff_num);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	if (((ioread32(&amp;priv-&gt;regs-&gt;if2_id2)) &amp; CAN_ID_MSGVAL) &amp;&amp;
</I>&gt;&gt;&gt;<i> +			((ioread32(&amp;priv-&gt;regs-&gt;if2_mcont)) &amp;
</I>&gt;&gt;&gt;<i> +			CAN_IF_MCONT_TXIE)) {
</I>&gt;&gt;&gt;<i> +		*enable = ENABLE;
</I>&gt;&gt;&gt;<i> +	} else {
</I>&gt;&gt;&gt;<i> +		*enable = DISABLE;
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_can_int_pending(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	return ioread32(&amp;priv-&gt;regs-&gt;intr) &amp; 0xffff;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_set_rx_buffer_link(struct pch_can_priv *priv,
</I>&gt;&gt;&gt;<i> +				       u32 buffer_num, u32 set)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	unsigned long flags;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +	pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buffer_num);
</I>&gt;&gt;&gt;<i> +	iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +	if (set == ENABLE)
</I>&gt;&gt;&gt;<i> +		pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont, CAN_IF_MCONT_EOB);
</I>&gt;&gt;&gt;<i> +	else
</I>&gt;&gt;&gt;<i> +		pch_can_bit_set(&amp;priv-&gt;regs-&gt;if1_mcont, CAN_IF_MCONT_EOB);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buffer_num);
</I>&gt;&gt;&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_get_rx_buffer_link(struct pch_can_priv *priv,
</I>&gt;&gt;&gt;<i> +				       u32 buffer_num, u32 *link)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	unsigned long flags;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +	pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buffer_num);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	if (ioread32(&amp;priv-&gt;regs-&gt;if1_mcont) &amp; CAN_IF_MCONT_EOB)
</I>&gt;&gt;&gt;<i> +		*link = DISABLE;
</I>&gt;&gt;&gt;<i> +	else
</I>&gt;&gt;&gt;<i> +		*link = ENABLE;
</I>&gt;&gt;&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_clear_buffers(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	int i;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	for (i = 0; i &lt; PCH_RX_OBJ_NUM; i++) {
</I>&gt;&gt;&gt;<i> +		iowrite32(CAN_CMASK_RX_TX_SET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +		iowrite32(0xffff, &amp;priv-&gt;regs-&gt;if1_mask1);
</I>&gt;&gt;&gt;<i> +		iowrite32(0xffff, &amp;priv-&gt;regs-&gt;if1_mask2);
</I>&gt;&gt;&gt;<i> +		iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_id1);
</I>&gt;&gt;&gt;<i> +		iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_id2);
</I>&gt;&gt;&gt;<i> +		iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_mcont);
</I>&gt;&gt;&gt;<i> +		iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_dataa1);
</I>&gt;&gt;&gt;<i> +		iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_dataa2);
</I>&gt;&gt;&gt;<i> +		iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_datab1);
</I>&gt;&gt;&gt;<i> +		iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_datab2);
</I>&gt;&gt;&gt;<i> +		iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK |
</I>&gt;&gt;&gt;<i> +			  CAN_CMASK_ARB | CAN_CMASK_CTRL,
</I>&gt;&gt;&gt;<i> +			  &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +		pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, i+1);
</I>&gt;&gt;<i>                                                              ^^^
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Is it correct that the loop variable &quot;i&quot; is only used here?
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	for (i = i;  i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;&gt;<i>              ^^^^^
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> this _looks_ strange, make it more clean, i.e. by removing it, adding a
</I>&gt;&gt;<i> comment, defining a macro for the staring value...
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +		iowrite32(CAN_CMASK_RX_TX_SET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +		iowrite32(0xffff, &amp;priv-&gt;regs-&gt;if2_mask1);
</I>&gt;&gt;&gt;<i> +		iowrite32(0xffff, &amp;priv-&gt;regs-&gt;if2_mask2);
</I>&gt;&gt;&gt;<i> +		iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_id1);
</I>&gt;&gt;&gt;<i> +		iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_id2);
</I>&gt;&gt;&gt;<i> +		iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_mcont);
</I>&gt;&gt;&gt;<i> +		iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_dataa1);
</I>&gt;&gt;&gt;<i> +		iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_dataa2);
</I>&gt;&gt;&gt;<i> +		iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_datab1);
</I>&gt;&gt;&gt;<i> +		iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_datab2);
</I>&gt;&gt;&gt;<i> +		iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK |
</I>&gt;&gt;&gt;<i> +			  CAN_CMASK_ARB | CAN_CMASK_CTRL,
</I>&gt;&gt;&gt;<i> +			  &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +		pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, i+1);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> dito
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	int i;
</I>&gt;&gt;&gt;<i> +	unsigned long flags;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;&gt;&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_RX) {
</I>&gt;&gt;<i>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</I>&gt;&gt;&gt;<i> +			iowrite32(CAN_CMASK_RX_TX_GET,
</I>&gt;&gt;&gt;<i> +				&amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +			pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, i+1);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_id1);
</I>&gt;&gt;&gt;<i> +			iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_id2);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			pch_can_bit_set(&amp;priv-&gt;regs-&gt;if1_mcont,
</I>&gt;&gt;&gt;<i> +					CAN_IF_MCONT_UMASK);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			/* Set FIFO mode set to 0 except last Rx Obj*/
</I>&gt;&gt;&gt;<i> +			pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont,
</I>&gt;&gt;&gt;<i> +					  CAN_IF_MCONT_EOB);
</I>&gt;&gt;&gt;<i> +			/* In case FIFO mode, Last EoB of Rx Obj must be 1 */
</I>&gt;&gt;&gt;<i> +			if (i == (PCH_RX_OBJ_NUM - 1))
</I>&gt;&gt;&gt;<i> +				pch_can_bit_set(&amp;priv-&gt;regs-&gt;if1_mcont,
</I>&gt;&gt;&gt;<i> +						  CAN_IF_MCONT_EOB);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			iowrite32(0, &amp;priv-&gt;regs-&gt;if1_mask1);
</I>&gt;&gt;&gt;<i> +			pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mask2,
</I>&gt;&gt;&gt;<i> +					  0x1fff | CAN_MASK2_MDIR_MXTD);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			/* Setting CMASK for writing */
</I>&gt;&gt;&gt;<i> +			iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK |
</I>&gt;&gt;&gt;<i> +				  CAN_CMASK_ARB | CAN_CMASK_CTRL,
</I>&gt;&gt;&gt;<i> +				  &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, i+1);
</I>&gt;&gt;&gt;<i> +		} else if (priv-&gt;msg_obj[i] == MSG_OBJ_TX) {
</I>&gt;&gt;<i>                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Do I understand your code correctly? You have a big loop, but only do
</I>&gt;&gt;<i> two different things at certain values of the loop? Smells fishy.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +			iowrite32(CAN_CMASK_RX_TX_GET,
</I>&gt;&gt;&gt;<i> +				&amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +			pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, i+1);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			/* Resetting DIR bit for reception */
</I>&gt;&gt;&gt;<i> +			iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_id1);
</I>&gt;&gt;&gt;<i> +			iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_id2);
</I>&gt;&gt;&gt;<i> +			pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id2, CAN_ID2_DIR);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			/* Setting EOB bit for transmitter */
</I>&gt;&gt;&gt;<i> +			iowrite32(CAN_IF_MCONT_EOB, &amp;priv-&gt;regs-&gt;if2_mcont);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_mcont,
</I>&gt;&gt;&gt;<i> +					CAN_IF_MCONT_UMASK);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			iowrite32(0, &amp;priv-&gt;regs-&gt;if2_mask1);
</I>&gt;&gt;&gt;<i> +			pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_mask2, 0x1fff);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			/* Setting CMASK for writing */
</I>&gt;&gt;&gt;<i> +			iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK |
</I>&gt;&gt;&gt;<i> +				  CAN_CMASK_ARB | CAN_CMASK_CTRL,
</I>&gt;&gt;&gt;<i> +				  &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, i+1);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_init(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	/* Stopping the Can device. */
</I>&gt;&gt;&gt;<i> +	pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Clearing all the message object buffers. */
</I>&gt;&gt;&gt;<i> +	pch_can_clear_buffers(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Configuring the respective message object as either rx/tx object. */
</I>&gt;&gt;&gt;<i> +	pch_can_config_rx_tx_buffers(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Enabling the interrupts. */
</I>&gt;&gt;&gt;<i> +	pch_can_set_int_enables(priv, PCH_CAN_ALL);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_release(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	/* Stooping the CAN device. */
</I>&gt;&gt;&gt;<i> +	pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Disabling the interrupts. */
</I>&gt;&gt;&gt;<i> +	pch_can_set_int_enables(priv, PCH_CAN_NONE);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Disabling all the receive object. */
</I>&gt;&gt;&gt;<i> +	pch_can_rx_disable_all(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Disabling all the transmit object. */
</I>&gt;&gt;&gt;<i> +	pch_can_tx_disable_all(priv);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +/* This function clears interrupt(s) from the CAN device. */
</I>&gt;&gt;&gt;<i> +static void pch_can_int_clr(struct pch_can_priv *priv, u32 mask)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	if (mask == CAN_STATUS_INT) {
</I>&gt;&gt;&gt;<i> +		ioread32(&amp;priv-&gt;regs-&gt;stat);
</I>&gt;&gt;&gt;<i> +		return;
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Clear interrupt for transmit object */
</I>&gt;&gt;&gt;<i> +	if (priv-&gt;msg_obj[mask - 1] == MSG_OBJ_TX) {
</I>&gt;&gt;&gt;<i> +		/* Setting CMASK for clearing interrupts for
</I>&gt;&gt;&gt;<i> +					 frame transmission. */
</I>&gt;&gt;&gt;<i> +		iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL | CAN_CMASK_ARB,
</I>&gt;&gt;&gt;<i> +			  &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/* Resetting the ID registers. */
</I>&gt;&gt;&gt;<i> +		pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id2,
</I>&gt;&gt;&gt;<i> +			       CAN_ID2_DIR | (0x7ff &lt;&lt; 2));
</I>&gt;&gt;&gt;<i> +		iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_id1);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/* Claring NewDat, TxRqst &amp; IntPnd */
</I>&gt;&gt;&gt;<i> +		pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_mcont,
</I>&gt;&gt;&gt;<i> +				  CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND |
</I>&gt;&gt;&gt;<i> +				  CAN_IF_MCONT_TXRQXT);
</I>&gt;&gt;&gt;<i> +		pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, mask);
</I>&gt;&gt;&gt;<i> +	} else if (priv-&gt;msg_obj[mask - 1] == MSG_OBJ_RX) {
</I>&gt;&gt;&gt;<i> +		/* Setting CMASK for clearing the reception interrupts. */
</I>&gt;&gt;&gt;<i> +		iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL | CAN_CMASK_ARB,
</I>&gt;&gt;&gt;<i> +			  &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/* Clearing the Dir bit. */
</I>&gt;&gt;&gt;<i> +		pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_id2, CAN_ID2_DIR);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/* Clearing NewDat &amp; IntPnd */
</I>&gt;&gt;&gt;<i> +		pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont,
</I>&gt;&gt;&gt;<i> +				  CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, mask);
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_can_get_buffer_status(struct pch_can_priv *priv)
</I>&gt;&gt;<i>           ^^^
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'd use a u32, as it's a register value....
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	return (ioread32(&amp;priv-&gt;regs-&gt;treq1) &amp; 0xffff) |
</I>&gt;&gt;&gt;<i> +	       ((ioread32(&amp;priv-&gt;regs-&gt;treq2) &amp; 0xffff) &lt;&lt; 16);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_reset(struct pch_can_priv *priv)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	/* write to sw reset register */
</I>&gt;&gt;&gt;<i> +	iowrite32(1, &amp;priv-&gt;regs-&gt;srst);
</I>&gt;&gt;&gt;<i> +	iowrite32(0, &amp;priv-&gt;regs-&gt;srst);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_error(struct net_device *ndev, u32 status)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	struct sk_buff *skb;
</I>&gt;&gt;&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> +	struct can_frame *cf;
</I>&gt;&gt;&gt;<i> +	u32 errc;
</I>&gt;&gt;&gt;<i> +	struct net_device_stats *stats = &amp;(priv-&gt;ndev-&gt;stats);
</I>&gt;&gt;&gt;<i> +	enum can_state state = priv-&gt;can.state;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	skb = alloc_can_err_skb(ndev, &amp;cf);
</I>&gt;&gt;&gt;<i> +	if (!skb)
</I>&gt;&gt;&gt;<i> +		return;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	if (status &amp; PCH_BUS_OFF) {
</I>&gt;&gt;&gt;<i> +		pch_can_tx_disable_all(priv);
</I>&gt;&gt;&gt;<i> +		pch_can_rx_disable_all(priv);
</I>&gt;&gt;&gt;<i> +		state = CAN_STATE_BUS_OFF;
</I>&gt;&gt;&gt;<i> +		cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;&gt;&gt;<i> +		can_bus_off(ndev);
</I>&gt;&gt;&gt;<i> +		pch_can_set_run_mode(priv, PCH_CAN_RUN);
</I>&gt;&gt;&gt;<i> +		dev_err(&amp;ndev-&gt;dev, &quot;%s -&gt; Bus Off occurres.\n&quot;, __func__);
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;<i> 
</I>&gt;<i> You bus-off handling is still bogus. Please check my comments on the
</I>&gt;<i> previous patch version. Also remove dev_err above (it's already reported
</I>&gt;<i> in can_bus_off) and use dev_dbg's below.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Warning interrupt. */
</I>&gt;&gt;&gt;<i> +	if (status &amp; PCH_EWARN) {
</I>&gt;&gt;&gt;<i> +		state = CAN_STATE_ERROR_WARNING;
</I>&gt;&gt;&gt;<i> +		priv-&gt;can.can_stats.error_warning++;
</I>&gt;&gt;&gt;<i> +		cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;&gt;&gt;<i> +		errc = ioread32(&amp;priv-&gt;regs-&gt;errc);
</I>&gt;&gt;&gt;<i> +		if (((errc &amp; CAN_REC) &gt;&gt; 8) &gt; 96)
</I>&gt;&gt;&gt;<i> +			cf-&gt;data[1] |= CAN_ERR_CRTL_RX_WARNING;
</I>&gt;&gt;&gt;<i> +		if ((errc &amp; CAN_TEC) &gt; 96)
</I>&gt;&gt;&gt;<i> +			cf-&gt;data[1] |= CAN_ERR_CRTL_TX_WARNING;
</I>&gt;&gt;&gt;<i> +		dev_warn(&amp;ndev-&gt;dev,
</I>&gt;&gt;&gt;<i> +			&quot;%s -&gt; Error Counter is more than 96.\n&quot;, __func__);
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +	/* Error passive interrupt. */
</I>&gt;&gt;&gt;<i> +	if (status &amp; PCH_EPASSIV) {
</I>&gt;&gt;&gt;<i> +		priv-&gt;can.can_stats.error_passive++;
</I>&gt;&gt;&gt;<i> +		state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;&gt;&gt;<i> +		cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;&gt;&gt;<i> +		errc = ioread32(&amp;priv-&gt;regs-&gt;errc);
</I>&gt;&gt;&gt;<i> +		if (((errc &amp; CAN_REC) &gt;&gt; 8) &gt; 127)
</I>&gt;&gt;&gt;<i> +			cf-&gt;data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;&gt;&gt;<i> +		if ((errc &amp; CAN_TEC) &gt; 127)
</I>&gt;&gt;&gt;<i> +			cf-&gt;data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
</I>&gt;&gt;&gt;<i> +		dev_err(&amp;ndev-&gt;dev,
</I>&gt;&gt;&gt;<i> +			&quot;%s -&gt; CAN controller is ERROR PASSIVE .\n&quot;, __func__);
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	if (status &amp; PCH_LEC_ALL) {
</I>&gt;&gt;&gt;<i> +		priv-&gt;can.can_stats.bus_error++;
</I>&gt;&gt;&gt;<i> +		stats-&gt;rx_errors++;
</I>&gt;&gt;&gt;<i> +		switch (status &amp; PCH_LEC_ALL) {
</I>&gt;&gt;&gt;<i> +		case PCH_STUF_ERR:
</I>&gt;&gt;&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;&gt;&gt;<i> +			break;
</I>&gt;&gt;&gt;<i> +		case PCH_FORM_ERR:
</I>&gt;&gt;&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;&gt;&gt;<i> +			break;
</I>&gt;&gt;&gt;<i> +		case PCH_ACK_ERR:
</I>&gt;&gt;&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_LOC_ACK |
</I>&gt;&gt;&gt;<i> +				       CAN_ERR_PROT_LOC_ACK_DEL;
</I>&gt;&gt;&gt;<i> +			break;
</I>&gt;&gt;&gt;<i> +		case PCH_BIT1_ERR:
</I>&gt;&gt;&gt;<i> +		case PCH_BIT0_ERR:
</I>&gt;&gt;&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
</I>&gt;&gt;&gt;<i> +			break;
</I>&gt;&gt;&gt;<i> +		case PCH_CRC_ERR:
</I>&gt;&gt;&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_LOC_CRC_SEQ |
</I>&gt;&gt;&gt;<i> +				       CAN_ERR_PROT_LOC_CRC_DEL;
</I>&gt;&gt;&gt;<i> +			break;
</I>&gt;&gt;&gt;<i> +		default:
</I>&gt;&gt;&gt;<i> +			iowrite32(status | PCH_LEC_ALL, &amp;priv-&gt;regs-&gt;stat);
</I>&gt;&gt;&gt;<i> +			break;
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	priv-&gt;can.state = state;
</I>&gt;&gt;&gt;<i> +	netif_rx(skb);
</I>&gt;<i> 
</I>&gt;<i> netif_receive_skb(skb) should be used here.
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;&gt;&gt;<i> +	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static irqreturn_t pch_can_interrupt(int irq, void *dev_id)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	struct net_device *ndev = (struct net_device *)dev_id;
</I>&gt;&gt;&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	pch_can_set_int_enables(priv, PCH_CAN_NONE);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	napi_schedule(&amp;priv-&gt;napi);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	return IRQ_HANDLED;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	u32 reg;
</I>&gt;&gt;&gt;<i> +	canid_t id;
</I>&gt;&gt;&gt;<i> +	u32 ide;
</I>&gt;&gt;&gt;<i> +	u32 rtr;
</I>&gt;&gt;&gt;<i> +	int i, j, k;
</I>&gt;&gt;&gt;<i> +	int rcv_pkts = 0;
</I>&gt;&gt;&gt;<i> +	struct sk_buff *skb;
</I>&gt;&gt;&gt;<i> +	struct can_frame *cf;
</I>&gt;&gt;&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> +	struct net_device_stats *stats = &amp;(priv-&gt;ndev-&gt;stats);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Reading the messsage object from the Message RAM */
</I>&gt;&gt;&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +	pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, int_stat);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Reading the MCONT register. */
</I>&gt;&gt;&gt;<i> +	reg = ioread32(&amp;priv-&gt;regs-&gt;if1_mcont);
</I>&gt;&gt;&gt;<i> +	reg &amp;= 0xffff;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	for (k = int_stat; !(reg &amp; CAN_IF_MCONT_EOB); k++) {
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> IMHO the loop is too long, please put make two or three functions from
</I>&gt;&gt;<i> this. (MsgLost bit handling, normal RX and threshold stuff)
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +		/* If MsgLost bit set. */
</I>&gt;&gt;&gt;<i> +		if (reg &amp; CAN_IF_MCONT_MSGLOST) {
</I>&gt;&gt;&gt;<i> +			dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;Msg Obj is overwritten.\n&quot;);
</I>&gt;&gt;&gt;<i> +			pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont,
</I>&gt;&gt;&gt;<i> +					  CAN_IF_MCONT_MSGLOST);
</I>&gt;&gt;&gt;<i> +			iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL,
</I>&gt;&gt;&gt;<i> +				  &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +			pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, k);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			skb = alloc_can_err_skb(ndev, &amp;cf);
</I>&gt;&gt;&gt;<i> +			if (!skb)
</I>&gt;&gt;&gt;<i> +				return -ENOMEM;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			priv-&gt;can.can_stats.error_passive++;
</I>&gt;&gt;&gt;<i> +			priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;&gt;&gt;<i> +			cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;&gt;&gt;<i> +			cf-&gt;data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;
</I>&gt;&gt;&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_OVERLOAD;
</I>&gt;&gt;&gt;<i> +			stats-&gt;rx_packets++;
</I>&gt;&gt;&gt;<i> +			stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> 
</I>&gt;<i> Hm, that looks bogus! Should be just:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>                 cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i>                 cf-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
</I>&gt;<i>                 stats-&gt;rx_over_errors++;
</I>&gt;<i>                 stats-&gt;rx_errors++;
</I>&gt;<i> 
</I>&gt;&gt;&gt;<i> +			netif_receive_skb(skb);
</I>&gt;&gt;&gt;<i> +			rcv_pkts++;
</I>&gt;&gt;&gt;<i> +			goto RX_NEXT;
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +		if (!(reg &amp; CAN_IF_MCONT_NEWDAT))
</I>&gt;&gt;&gt;<i> +			goto RX_NEXT;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		skb = alloc_can_skb(priv-&gt;ndev, &amp;cf);
</I>&gt;&gt;&gt;<i> +		if (!skb)
</I>&gt;&gt;&gt;<i> +			return -ENOMEM;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/* Get Received data */
</I>&gt;&gt;&gt;<i> +		ide = ((ioread32(&amp;priv-&gt;regs-&gt;if1_id2)) &amp; CAN_ID2_XTD) &gt;&gt; 14;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> the shift is not needed
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +		if (ide) {
</I>&gt;&gt;&gt;<i> +			id = (ioread32(&amp;priv-&gt;regs-&gt;if1_id1) &amp; 0xffff);
</I>&gt;&gt;&gt;<i> +			id |= (((ioread32(&amp;priv-&gt;regs-&gt;if1_id2)) &amp;
</I>&gt;&gt;&gt;<i> +					    0x1fff) &lt;&lt; 16);
</I>&gt;&gt;&gt;<i> +			cf-&gt;can_id = (id &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
</I>&gt;&gt;&gt;<i> +		} else {
</I>&gt;&gt;&gt;<i> +			id = (((ioread32(&amp;priv-&gt;regs-&gt;if1_id2)) &amp;
</I>&gt;&gt;&gt;<i> +					  (CAN_SFF_MASK &lt;&lt; 2)) &gt;&gt; 2);
</I>&gt;&gt;&gt;<i> +			cf-&gt;can_id = (id &amp; CAN_SFF_MASK);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		rtr = (ioread32(&amp;priv-&gt;regs-&gt;if1_id2) &amp;  CAN_ID2_DIR);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> please remove the braces
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +		if (rtr) {
</I>&gt;&gt;&gt;<i> +			cf-&gt;can_dlc = 0;
</I>&gt;&gt;<i>                                       ^
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> use the supplied dlc value
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +			cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;&gt;&gt;<i> +		} else {
</I>&gt;&gt;&gt;<i> +			cf-&gt;can_dlc = ((ioread32(&amp;priv-&gt;regs-&gt;if1_mcont)) &amp;
</I>&gt;&gt;&gt;<i> +						   0x0f);
</I>&gt;&gt;<i> use get_can_dlc()
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		for (i = 0, j = 0; i &lt; cf-&gt;can_dlc; j++) {
</I>&gt;&gt;&gt;<i> +			reg = ioread32(&amp;priv-&gt;regs-&gt;if1_dataa1 + j*4);
</I>&gt;&gt;&gt;<i> +			cf-&gt;data[i++] = cpu_to_le32(reg &amp; 0xff);
</I>&gt;&gt;&gt;<i> +			if (i == cf-&gt;can_dlc)
</I>&gt;&gt;&gt;<i> +				break;
</I>&gt;&gt;&gt;<i> +			cf-&gt;data[i++] = cpu_to_le32((reg &gt;&gt; 8) &amp; 0xff);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> the idea behind the cpu_to_le32 and friends is that they do the needed
</I>&gt;&gt;<i> endianess conversion for you. This way you get rid of the second
</I>&gt;&gt;<i> variable in this loop (j).
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		netif_receive_skb(skb);
</I>&gt;&gt;&gt;<i> +		rcv_pkts++;
</I>&gt;&gt;&gt;<i> +		stats-&gt;rx_packets++;
</I>&gt;&gt;&gt;<i> +		stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		if (k &lt; PCH_FIFO_THRESH) {
</I>&gt;&gt;&gt;<i> +			iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL |
</I>&gt;&gt;&gt;<i> +				  CAN_CMASK_ARB, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			/* Clearing the Dir bit. */
</I>&gt;&gt;&gt;<i> +			pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_id2, CAN_ID2_DIR);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			/* Clearing NewDat &amp; IntPnd */
</I>&gt;&gt;&gt;<i> +			pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont,
</I>&gt;&gt;&gt;<i> +					  CAN_IF_MCONT_INTPND);
</I>&gt;&gt;&gt;<i> +			pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, k);
</I>&gt;&gt;&gt;<i> +		} else if (k &gt; PCH_FIFO_THRESH) {
</I>&gt;&gt;&gt;<i> +			pch_can_int_clr(priv, k);
</I>&gt;&gt;&gt;<i> +		} else if (k == PCH_FIFO_THRESH) {
</I>&gt;&gt;&gt;<i> +			int cnt;
</I>&gt;&gt;&gt;<i> +			for (cnt = 0; cnt &lt; PCH_FIFO_THRESH; cnt++)
</I>&gt;&gt;&gt;<i> +				pch_can_int_clr(priv, cnt+1);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +RX_NEXT:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> please use low case names for the labes
</I>&gt;<i> 
</I>&gt;<i> please use labels just for the usual cleanup.
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +		/* Reading the messsage object from the Message RAM */
</I>&gt;&gt;&gt;<i> +		iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;&gt;&gt;<i> +		pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, k + 1);
</I>&gt;&gt;&gt;<i> +		reg = ioread32(&amp;priv-&gt;regs-&gt;if1_mcont);
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	return rcv_pkts;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +static int pch_can_rx_poll(struct napi_struct *napi, int quota)
</I>&gt;&gt;<i>                                                         ^^^^^^^^^^
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You should take care about the quota.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	struct net_device *ndev = napi-&gt;dev;
</I>&gt;&gt;&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> +	struct net_device_stats *stats = &amp;(priv-&gt;ndev-&gt;stats);
</I>&gt;&gt;&gt;<i> +	u32 dlc;
</I>&gt;&gt;&gt;<i> +	u32 int_stat;
</I>&gt;&gt;&gt;<i> +	int rcv_pkts = 0;
</I>&gt;&gt;&gt;<i> +	u32 reg_stat;
</I>&gt;&gt;&gt;<i> +	unsigned long flags;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	int_stat = pch_can_int_pending(priv);
</I>&gt;&gt;&gt;<i> +	if (!int_stat)
</I>&gt;&gt;&gt;<i> +		return 0;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +INT_STAT:
</I>&gt;&gt;&gt;<i> +	if (int_stat == CAN_STATUS_INT) {
</I>&gt;&gt;&gt;<i> +		reg_stat = ioread32(&amp;priv-&gt;regs-&gt;stat);
</I>&gt;&gt;&gt;<i> +		if (reg_stat &amp; (PCH_BUS_OFF | PCH_LEC_ALL)) {
</I>&gt;&gt;&gt;<i> +			if ((reg_stat &amp; PCH_LEC_ALL) != PCH_LEC_ALL)
</I>&gt;&gt;&gt;<i> +				pch_can_error(ndev, reg_stat);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		if (reg_stat &amp; PCH_TX_OK) {
</I>&gt;&gt;&gt;<i> +			spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +			iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +			pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq,
</I>&gt;&gt;&gt;<i> +					       ioread32(&amp;priv-&gt;regs-&gt;intr));
</I>&gt;&gt;&gt;<i> +			spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +			pch_can_bit_clear(&amp;priv-&gt;regs-&gt;stat, PCH_TX_OK);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		if (reg_stat &amp; PCH_RX_OK)
</I>&gt;&gt;&gt;<i> +			pch_can_bit_clear(&amp;priv-&gt;regs-&gt;stat, PCH_RX_OK);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		int_stat = pch_can_int_pending(priv);
</I>&gt;&gt;&gt;<i> +		if (int_stat == CAN_STATUS_INT)
</I>&gt;&gt;&gt;<i> +			goto INT_STAT;
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +MSG_OBJ:
</I>&gt;&gt;&gt;<i> +	if ((int_stat &gt;= 1) &amp;&amp; (int_stat &lt;= PCH_RX_OBJ_NUM)) {
</I>&gt;&gt;&gt;<i> +		spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +		rcv_pkts = pch_can_rx_normal(ndev, int_stat);
</I>&gt;&gt;&gt;<i> +		spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +		if (rcv_pkts &lt; 0)
</I>&gt;&gt;&gt;<i> +			return 0;
</I>&gt;&gt;&gt;<i> +	} else if ((int_stat &gt; PCH_RX_OBJ_NUM) &amp;&amp; (int_stat &lt;= PCH_OBJ_NUM)) {
</I>&gt;&gt;&gt;<i> +		if (priv-&gt;msg_obj[int_stat - 1] == MSG_OBJ_TX) {
</I>&gt;&gt;&gt;<i> +			/* Handle transmission interrupt */
</I>&gt;&gt;<i> IMHO, make this a function, too
</I>&gt;&gt;&gt;<i> +			can_get_echo_skb(ndev, int_stat - PCH_RX_OBJ_NUM - 1);
</I>&gt;&gt;&gt;<i> +			spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +			iowrite32(CAN_CMASK_RX_TX_GET | CAN_CMASK_CLRINTPND,
</I>&gt;&gt;&gt;<i> +				  &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +			dlc = ioread32(&amp;priv-&gt;regs-&gt;if2_mcont) &amp;
</I>&gt;&gt;&gt;<i> +				       CAN_IF_MCONT_DLC;
</I>&gt;&gt;&gt;<i> +			pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, int_stat);
</I>&gt;&gt;&gt;<i> +			spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +			if (dlc &gt; 8)
</I>&gt;&gt;&gt;<i> +				dlc = 8;
</I>&gt;&gt;&gt;<i> +			stats-&gt;tx_bytes += dlc;
</I>&gt;&gt;&gt;<i> +			stats-&gt;tx_packets++;
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	int_stat = pch_can_int_pending(priv);
</I>&gt;&gt;&gt;<i> +	if (int_stat == CAN_STATUS_INT)
</I>&gt;&gt;&gt;<i> +		goto INT_STAT;
</I>&gt;&gt;&gt;<i> +	else if (int_stat &gt;= 1 &amp;&amp; int_stat &lt;= 32)
</I>&gt;&gt;&gt;<i> +		goto MSG_OBJ;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	napi_complete(napi);
</I>&gt;&gt;&gt;<i> +	pch_can_set_int_enables(priv, PCH_CAN_ALL);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	return rcv_pkts;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_set_bittiming(struct net_device *ndev)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> +	const struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
</I>&gt;&gt;&gt;<i> +	u32 canbit;
</I>&gt;&gt;&gt;<i> +	u32 bepe;
</I>&gt;&gt;&gt;<i> +	u32 brp;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Setting the CCE bit for accessing the Can Timing register. */
</I>&gt;&gt;&gt;<i> +	pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_CCE);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	brp = (bt-&gt;tq) / (1000000000/PCH_CAN_CLK) - 1;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You already set &quot;priv-&gt;can.clock.freq = PCH_CAN_CLK;&quot; why do you need to
</I>&gt;&gt;<i> calculate the brp by yourself?
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +	canbit = brp &amp; MSK_BITT_BRP;
</I>&gt;&gt;&gt;<i> +	canbit |= (bt-&gt;sjw - 1) &lt;&lt; BIT_BITT_SJW;
</I>&gt;&gt;&gt;<i> +	canbit |= (bt-&gt;phase_seg1 + bt-&gt;prop_seg - 1) &lt;&lt; BIT_BITT_TSEG1;
</I>&gt;&gt;&gt;<i> +	canbit |= (bt-&gt;phase_seg2 - 1) &lt;&lt; BIT_BITT_TSEG2;
</I>&gt;&gt;&gt;<i> +	bepe = (brp &amp; MSK_BRPE_BRPE) &gt;&gt; BIT_BRPE_BRPE;
</I>&gt;&gt;&gt;<i> +	iowrite32(canbit, &amp;priv-&gt;regs-&gt;bitt);
</I>&gt;&gt;&gt;<i> +	iowrite32(bepe, &amp;priv-&gt;regs-&gt;brpe);
</I>&gt;&gt;&gt;<i> +	pch_can_bit_clear(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_CCE);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	return 0;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void pch_can_start(struct net_device *ndev)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	if (priv-&gt;can.state != CAN_STATE_STOPPED)
</I>&gt;&gt;&gt;<i> +		pch_can_reset(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	pch_set_bittiming(ndev);
</I>&gt;&gt;&gt;<i> +	pch_can_set_optmode(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	pch_can_tx_enable_all(priv);
</I>&gt;&gt;&gt;<i> +	pch_can_rx_enable_all(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Setting the CAN to run mode. */
</I>&gt;&gt;&gt;<i> +	pch_can_set_run_mode(priv, PCH_CAN_RUN);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	return;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_can_do_set_mode(struct net_device *ndev, enum can_mode mode)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	int ret = 0;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	switch (mode) {
</I>&gt;&gt;&gt;<i> +	case CAN_MODE_START:
</I>&gt;&gt;&gt;<i> +		pch_can_start(ndev);
</I>&gt;&gt;&gt;<i> +		netif_wake_queue(ndev);
</I>&gt;&gt;&gt;<i> +		break;
</I>&gt;&gt;&gt;<i> +	default:
</I>&gt;&gt;&gt;<i> +		ret = -EOPNOTSUPP;
</I>&gt;&gt;&gt;<i> +		break;
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	return ret;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_can_open(struct net_device *ndev)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> +	int retval;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	retval = pci_enable_msi(priv-&gt;dev);
</I>&gt;&gt;&gt;<i> +	if (retval) {
</I>&gt;&gt;&gt;<i> +		dev_info(&amp;ndev-&gt;dev, &quot;PCH CAN opened without MSI\n&quot;);
</I>&gt;&gt;&gt;<i> +		priv-&gt;use_msi = 0;
</I>&gt;&gt;&gt;<i> +	} else {
</I>&gt;&gt;&gt;<i> +		dev_info(&amp;ndev-&gt;dev, &quot;PCH CAN opened with MSI\n&quot;);
</I>&gt;&gt;&gt;<i> +		priv-&gt;use_msi = 1;
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Regsitering the interrupt. */
</I>&gt;&gt;&gt;<i> +	retval = request_irq(priv-&gt;dev-&gt;irq, pch_can_interrupt, IRQF_SHARED,
</I>&gt;&gt;&gt;<i> +			     ndev-&gt;name, ndev);
</I>&gt;&gt;&gt;<i> +	if (retval) {
</I>&gt;&gt;&gt;<i> +		dev_err(&amp;ndev-&gt;dev, &quot;request_irq failed.\n&quot;);
</I>&gt;&gt;&gt;<i> +		goto req_irq_err;
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Open common can device */
</I>&gt;&gt;&gt;<i> +	retval = open_candev(ndev);
</I>&gt;&gt;&gt;<i> +	if (retval) {
</I>&gt;&gt;&gt;<i> +		dev_err(ndev-&gt;dev.parent, &quot;open_candev() failed %d\n&quot;, retval);
</I>&gt;&gt;&gt;<i> +		goto err_open_candev;
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	pch_can_init(priv);
</I>&gt;&gt;&gt;<i> +	pch_can_start(ndev);
</I>&gt;&gt;&gt;<i> +	napi_enable(&amp;priv-&gt;napi);
</I>&gt;&gt;&gt;<i> +	netif_start_queue(ndev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	return 0;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +err_open_candev:
</I>&gt;&gt;&gt;<i> +	free_irq(priv-&gt;dev-&gt;irq, ndev);
</I>&gt;&gt;&gt;<i> +req_irq_err:
</I>&gt;&gt;&gt;<i> +	if (priv-&gt;use_msi)
</I>&gt;&gt;&gt;<i> +		pci_disable_msi(priv-&gt;dev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	pch_can_release(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	return retval;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_close(struct net_device *ndev)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	netif_stop_queue(ndev);
</I>&gt;&gt;&gt;<i> +	napi_disable(&amp;priv-&gt;napi);
</I>&gt;&gt;&gt;<i> +	pch_can_release(priv);
</I>&gt;&gt;&gt;<i> +	free_irq(priv-&gt;dev-&gt;irq, ndev);
</I>&gt;&gt;&gt;<i> +	if (priv-&gt;use_msi)
</I>&gt;&gt;&gt;<i> +		pci_disable_msi(priv-&gt;dev);
</I>&gt;&gt;&gt;<i> +	close_candev(ndev);
</I>&gt;&gt;&gt;<i> +	priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;&gt;&gt;<i> +	return 0;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_get_msg_obj_sts(struct net_device *ndev, u32 obj_id)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	u32 buffer_status = 0;
</I>&gt;&gt;&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Getting the message object status. */
</I>&gt;&gt;&gt;<i> +	buffer_status = (u32) pch_can_get_buffer_status(priv);
</I>
With Marc suggestion above, you can drop the cast.

&gt;&gt;&gt;<i> +	return buffer_status &amp; obj_id;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	int i, j;
</I>&gt;&gt;&gt;<i> +	unsigned long flags;
</I>&gt;&gt;&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> +	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;&gt;&gt;<i> +	int tx_buffer_avail = 0;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	if (can_dropped_invalid_skb(ndev, skb))
</I>&gt;&gt;&gt;<i> +		return NETDEV_TX_OK;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	if (priv-&gt;tx_obj == (PCH_OBJ_NUM + 1)) { /* Point tail Obj */
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> what does this loop do? why is it nessecarry? I don't like delay loops
</I>&gt;&gt;<i> in the hot path of a driver.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +		while (pch_get_msg_obj_sts(ndev, (((1 &lt;&lt; PCH_TX_OBJ_NUM)-1) &lt;&lt;
</I>&gt;&gt;&gt;<i> +					   PCH_RX_OBJ_NUM)))
</I>&gt;&gt;&gt;<i> +			udelay(500);
</I>
That might take long as well. Even 500us in the hot path is too much.

&gt;&gt;&gt;<i> +		priv-&gt;tx_obj = PCH_RX_OBJ_NUM + 1; /* Point head of Tx Obj ID */
</I>&gt;&gt;&gt;<i> +		tx_buffer_avail = priv-&gt;tx_obj; /* Point Tail of Tx Obj */
</I>&gt;&gt;&gt;<i> +	} else {
</I>&gt;&gt;&gt;<i> +		tx_buffer_avail = priv-&gt;tx_obj;
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +	priv-&gt;tx_obj++;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Attaining the lock. */
</I>&gt;&gt;&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Reading the Msg Obj from the Msg RAM to the Interface register. */
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You mean write? We're sending can frames here :)
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;&gt;&gt;<i> +	pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, tx_buffer_avail);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Setting the CMASK register. */
</I>&gt;&gt;&gt;<i> +	pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_cmask, CAN_CMASK_ALL);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* If ID extended is set. */
</I>&gt;&gt;&gt;<i> +	pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_id1, 0xffff);
</I>&gt;&gt;&gt;<i> +	pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_id2, 0x1fff | CAN_ID2_XTD);
</I>&gt;&gt;&gt;<i> +	if (cf-&gt;can_id &amp; CAN_EFF_FLAG) {
</I>&gt;&gt;&gt;<i> +		pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id1, cf-&gt;can_id &amp; 0xffff);
</I>&gt;&gt;&gt;<i> +		pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id2,
</I>&gt;&gt;&gt;<i> +				((cf-&gt;can_id &gt;&gt; 16) &amp; 0x1fff) | CAN_ID2_XTD);
</I>&gt;&gt;&gt;<i> +	} else {
</I>&gt;&gt;&gt;<i> +		pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id1, 0);
</I>&gt;&gt;&gt;<i> +		pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id2,
</I>&gt;&gt;&gt;<i> +				(cf-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; 2);
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Taking about speed, you do 2 read-modify-write cycles on if2_id{1,2}.
</I>&gt;&gt;<i> Yhe usual way is to prepare the values that should go into the hardware,
</I>&gt;&gt;<i> then writen them.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* If remote frame has to be transmitted.. */
</I>&gt;&gt;&gt;<i> +	if (cf-&gt;can_id &amp; CAN_RTR_FLAG)
</I>&gt;&gt;&gt;<i> +		pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_id2, CAN_ID2_DIR);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> dito
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	for (i = 0, j = 0; i &lt; cf-&gt;can_dlc; j++) {
</I>&gt;&gt;&gt;<i> +		iowrite32(le32_to_cpu(cf-&gt;data[i++]),
</I>&gt;&gt;&gt;<i> +			 (&amp;priv-&gt;regs-&gt;if2_dataa1) + j*4);
</I>&gt;&gt;&gt;<i> +		if (i == cf-&gt;can_dlc)
</I>&gt;&gt;&gt;<i> +			break;
</I>&gt;&gt;&gt;<i> +		iowrite32(le32_to_cpu(cf-&gt;data[i++] &lt;&lt; 8),
</I>&gt;&gt;&gt;<i> +			 (&amp;priv-&gt;regs-&gt;if2_dataa1) + j*4);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you figured out how to use the endianess conversion functions from
</I>&gt;&gt;<i> the cpu_to_{le,be}-{le,to}_to_cpup family use them here, too.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	can_put_echo_skb(skb, ndev, tx_buffer_avail - PCH_RX_OBJ_NUM - 1);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Updating the size of the data. */
</I>&gt;&gt;&gt;<i> +	pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_mcont, 0x0f);
</I>&gt;&gt;&gt;<i> +	pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_mcont, cf-&gt;can_dlc);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> the comment about read-modify-write applies here, too
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Clearing IntPend, NewDat &amp; TxRqst */
</I>&gt;&gt;&gt;<i> +	pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_mcont,
</I>&gt;&gt;&gt;<i> +			  CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND |
</I>&gt;&gt;&gt;<i> +			  CAN_IF_MCONT_TXRQXT);
</I>&gt;&gt;<i> dito
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Setting NewDat, TxRqst bits */
</I>&gt;&gt;&gt;<i> +	pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_mcont,
</I>&gt;&gt;&gt;<i> +			CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_TXRQXT);
</I>&gt;&gt;<i> dito
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, tx_buffer_avail);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> All these check if busy in the code make me a bit nervous, can you
</I>&gt;&gt;<i> please explain why they are needed. A pointer to the manual is okay, too.
</I>
Me too. I already ask in my previous mail how long that functions
usually blocks.

&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	return NETDEV_TX_OK;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static const struct net_device_ops pch_can_netdev_ops = {
</I>&gt;&gt;&gt;<i> +	.ndo_open		= pch_can_open,
</I>&gt;&gt;&gt;<i> +	.ndo_stop		= pch_close,
</I>&gt;&gt;&gt;<i> +	.ndo_start_xmit		= pch_xmit,
</I>&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void __devexit pch_can_remove(struct pci_dev *pdev)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	struct net_device *ndev = pci_get_drvdata(pdev);
</I>&gt;&gt;&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	unregister_candev(priv-&gt;ndev);
</I>&gt;&gt;&gt;<i> +	free_candev(priv-&gt;ndev);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Is priv still valid after this? It's in several other drivers, too...but
</I>&gt;&gt;<i> this smells like a bug.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Any has a &quot;spatch&quot; handy?
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +	pci_iounmap(pdev, priv-&gt;regs);
</I>&gt;&gt;&gt;<i> +	pci_release_regions(pdev);
</I>&gt;&gt;&gt;<i> +	pci_disable_device(pdev);
</I>&gt;&gt;&gt;<i> +	pci_set_drvdata(pdev, NULL);
</I>&gt;&gt;&gt;<i> +	pch_can_reset(priv);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#ifdef CONFIG_PM
</I>&gt;&gt;&gt;<i> +static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	int i;			/* Counter variable. */
</I>&gt;&gt;&gt;<i> +	int retval;		/* Return value. */
</I>&gt;&gt;&gt;<i> +	u32 buf_stat;	/* Variable for reading the transmit buffer status. */
</I>&gt;&gt;&gt;<i> +	u32 counter = 0xFFFFFF;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	struct net_device *dev = pci_get_drvdata(pdev);
</I>&gt;&gt;&gt;<i> +	struct pch_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Stop the CAN controller */
</I>&gt;&gt;&gt;<i> +	pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Indicate that we are aboutto/in suspend */
</I>&gt;&gt;&gt;<i> +	priv-&gt;can.state = CAN_STATE_SLEEPING;
</I>
You already stopped the device! Therefore the proper state is
CAN_STATE_STOPPED. Anyway, CAN_STATE_SLEEPING is not supported yet by
any driver,.

&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Waiting for all transmission to complete. */
</I>&gt;&gt;&gt;<i> +	while (counter) {
</I>&gt;&gt;&gt;<i> +		buf_stat = pch_can_get_buffer_status(priv);
</I>&gt;&gt;&gt;<i> +		if (!buf_stat)
</I>&gt;&gt;&gt;<i> +			break;
</I>&gt;&gt;&gt;<i> +		counter--;
</I>&gt;&gt;&gt;<i> +		udelay(1);
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +	if (!counter)
</I>&gt;&gt;&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;%s -&gt; Transmission time out.\n&quot;, __func__);
</I>
Might loop for up to *16.7* seconds, right? That does not seem to be a
proper timeout value.

&gt;&gt;&gt;<i> +	/* Save interrupt configuration and then disable them */
</I>&gt;&gt;&gt;<i> +	pch_can_get_int_enables(priv, &amp;(priv-&gt;int_enables));
</I>
s/&amp;(priv-&gt;int_enables)/&amp;priv-&gt;int_enables/

&gt;&gt;&gt;<i> +	pch_can_set_int_enables(priv, PCH_CAN_DISABLE);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Save Tx buffer enable state */
</I>&gt;&gt;&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;&gt;&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_TX)
</I>&gt;&gt;&gt;<i> +			pch_can_get_tx_enable(priv, i + 1,
</I>&gt;&gt;&gt;<i> +					      &amp;(priv-&gt;tx_enable[i]));
</I>
Ditto.

&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Disable all Transmit buffers */
</I>&gt;&gt;&gt;<i> +	pch_can_tx_disable_all(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Save Rx buffer enable state */
</I>&gt;&gt;&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;&gt;&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_RX) {
</I>&gt;&gt;&gt;<i> +			pch_can_get_rx_enable(priv, i + 1,
</I>&gt;&gt;&gt;<i> +						&amp;(priv-&gt;rx_enable[i]));
</I>&gt;&gt;&gt;<i> +			pch_can_get_rx_buffer_link(priv, i + 1,
</I>&gt;&gt;&gt;<i> +						&amp;(priv-&gt;rx_link[i]));
</I>
Ditto.

&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Disable all Receive buffers */
</I>&gt;&gt;&gt;<i> +	pch_can_rx_disable_all(priv);
</I>&gt;&gt;&gt;<i> +	retval = pci_save_state(pdev);
</I>&gt;&gt;&gt;<i> +	if (retval) {
</I>&gt;&gt;&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;pci_save_state failed.\n&quot;);
</I>&gt;&gt;&gt;<i> +	} else {
</I>&gt;&gt;&gt;<i> +		pci_enable_wake(pdev, PCI_D3hot, 0);
</I>&gt;&gt;&gt;<i> +		pci_disable_device(pdev);
</I>&gt;&gt;&gt;<i> +		pci_set_power_state(pdev, pci_choose_state(pdev, state));
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	return retval;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_can_resume(struct pci_dev *pdev)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	int i;			/* Counter variable. */
</I>&gt;&gt;&gt;<i> +	int retval;		/* Return variable. */
</I>
The comments describe the obvious.

&gt;&gt;&gt;<i> +	struct net_device *dev = pci_get_drvdata(pdev);
</I>&gt;&gt;&gt;<i> +	struct pch_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	pci_set_power_state(pdev, PCI_D0);
</I>&gt;&gt;&gt;<i> +	pci_restore_state(pdev);
</I>&gt;&gt;&gt;<i> +	retval = pci_enable_device(pdev);
</I>&gt;&gt;&gt;<i> +	if (retval) {
</I>&gt;&gt;&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;pci_enable_device failed.\n&quot;);
</I>&gt;&gt;&gt;<i> +		return retval;
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	pci_enable_wake(pdev, PCI_D3hot, 0);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Disabling all interrupts. */
</I>&gt;&gt;&gt;<i> +	pch_can_set_int_enables(priv, PCH_CAN_DISABLE);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Setting the CAN device in Stop Mode. */
</I>&gt;&gt;&gt;<i> +	pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Configuring the transmit and receive buffers. */
</I>&gt;&gt;&gt;<i> +	pch_can_config_rx_tx_buffers(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Restore the CAN state */
</I>&gt;&gt;&gt;<i> +	pch_set_bittiming(dev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Listen/Active */
</I>&gt;&gt;&gt;<i> +	pch_can_set_optmode(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Enabling the transmit buffer. */
</I>&gt;&gt;&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;&gt;&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_TX) {
</I>&gt;&gt;&gt;<i> +			pch_can_set_tx_enable(priv, i + 1,
</I>&gt;&gt;&gt;<i> +					      priv-&gt;tx_enable[i]);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Configuring the receive buffer and enabling them. */
</I>&gt;&gt;&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;&gt;&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_RX) {
</I>&gt;&gt;&gt;<i> +			/* Restore buffer link */
</I>&gt;&gt;&gt;<i> +			pch_can_set_rx_buffer_link(priv, i + 1,
</I>&gt;&gt;&gt;<i> +						   priv-&gt;rx_link[i]);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			/* Restore buffer enables */
</I>&gt;&gt;&gt;<i> +			pch_can_set_rx_enable(priv, i + 1, priv-&gt;rx_enable[i]);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Enable CAN Interrupts */
</I>&gt;&gt;&gt;<i> +	pch_can_set_int_custom(priv);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	/* Restore Run Mode */
</I>&gt;&gt;&gt;<i> +	pch_can_set_run_mode(priv, PCH_CAN_RUN);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	return retval;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +#else
</I>&gt;&gt;&gt;<i> +#define pch_can_suspend NULL
</I>&gt;&gt;&gt;<i> +#define pch_can_resume NULL
</I>&gt;&gt;&gt;<i> +#endif
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int pch_can_get_berr_counter(const struct net_device *dev,
</I>&gt;&gt;&gt;<i> +				    struct can_berr_counter *bec)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	struct pch_can_priv *priv = netdev_priv(dev);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	bec-&gt;txerr = ioread32(&amp;priv-&gt;regs-&gt;errc) &amp; CAN_TEC;
</I>&gt;&gt;&gt;<i> +	bec-&gt;rxerr = (ioread32(&amp;priv-&gt;regs-&gt;errc) &amp; CAN_REC) &gt;&gt; 8;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	return 0;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int __devinit pch_can_probe(struct pci_dev *pdev,
</I>&gt;&gt;&gt;<i> +				   const struct pci_device_id *id)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	struct net_device *ndev;
</I>&gt;&gt;&gt;<i> +	struct pch_can_priv *priv;
</I>&gt;&gt;&gt;<i> +	int rc;
</I>&gt;&gt;&gt;<i> +	int index;
</I>&gt;&gt;&gt;<i> +	void __iomem *addr;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	rc = pci_enable_device(pdev);
</I>&gt;&gt;&gt;<i> +	if (rc) {
</I>&gt;&gt;&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;Failed pci_enable_device %d\n&quot;, rc);
</I>&gt;&gt;&gt;<i> +		goto probe_exit_endev;
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	rc = pci_request_regions(pdev, KBUILD_MODNAME);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> is there some pdev-&gt;name instead of KBUILD_MODNAME that can be used?
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +	if (rc) {
</I>&gt;&gt;&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;Failed pci_request_regions %d\n&quot;, rc);
</I>&gt;&gt;&gt;<i> +		goto probe_exit_pcireq;
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	addr = pci_iomap(pdev, 1, 0);
</I>&gt;&gt;&gt;<i> +	if (!addr) {
</I>&gt;&gt;&gt;<i> +		rc = -EIO;
</I>&gt;&gt;&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;Failed pci_iomap\n&quot;);
</I>&gt;&gt;&gt;<i> +		goto probe_exit_ipmap;
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	ndev = alloc_candev(sizeof(struct pch_can_priv), PCH_TX_OBJ_NUM);
</I>&gt;&gt;&gt;<i> +	if (!ndev) {
</I>&gt;&gt;&gt;<i> +		rc = -ENOMEM;
</I>&gt;&gt;&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;Failed alloc_candev\n&quot;);
</I>&gt;&gt;&gt;<i> +		goto probe_exit_alloc_candev;
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	priv = netdev_priv(ndev);
</I>&gt;&gt;&gt;<i> +	priv-&gt;ndev = ndev;
</I>&gt;&gt;&gt;<i> +	priv-&gt;regs = addr;
</I>&gt;&gt;&gt;<i> +	priv-&gt;dev = pdev;
</I>&gt;&gt;&gt;<i> +	priv-&gt;can.bittiming_const = &amp;pch_can_bittiming_const;
</I>&gt;&gt;&gt;<i> +	priv-&gt;can.do_set_mode = pch_can_do_set_mode;
</I>&gt;&gt;&gt;<i> +	priv-&gt;can.do_get_berr_counter = pch_can_get_berr_counter;
</I>&gt;&gt;&gt;<i> +	priv-&gt;can.ctrlmode_supported = CAN_CTRLMODE_LISTENONLY |
</I>&gt;&gt;&gt;<i> +				       CAN_CTRLMODE_LOOPBACK;
</I>&gt;&gt;&gt;<i> +	priv-&gt;tx_obj = PCH_RX_OBJ_NUM + 1; /* Point head of Tx Obj */
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	ndev-&gt;irq = pdev-&gt;irq;
</I>&gt;&gt;&gt;<i> +	ndev-&gt;flags |= IFF_ECHO;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	pci_set_drvdata(pdev, ndev);
</I>&gt;&gt;&gt;<i> +	SET_NETDEV_DEV(ndev, &amp;pdev-&gt;dev);
</I>&gt;&gt;&gt;<i> +	ndev-&gt;netdev_ops = &amp;pch_can_netdev_ops;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	priv-&gt;can.clock.freq = PCH_CAN_CLK; /* Hz */
</I>&gt;&gt;&gt;<i> +	for (index = 0; index &lt; PCH_RX_OBJ_NUM;)
</I>&gt;&gt;&gt;<i> +		priv-&gt;msg_obj[index++] = MSG_OBJ_RX;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	for (index = index;  index &lt; PCH_OBJ_NUM;)
</I>&gt;&gt;&gt;<i> +		priv-&gt;msg_obj[index++] = MSG_OBJ_TX;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	netif_napi_add(ndev, &amp;priv-&gt;napi, pch_can_rx_poll, PCH_RX_OBJ_NUM);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	rc = register_candev(ndev);
</I>&gt;&gt;&gt;<i> +	if (rc) {
</I>&gt;&gt;&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;Failed register_candev %d\n&quot;, rc);
</I>&gt;&gt;&gt;<i> +		goto probe_exit_reg_candev;
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	return 0;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +probe_exit_reg_candev:
</I>&gt;&gt;&gt;<i> +	free_candev(ndev);
</I>&gt;&gt;&gt;<i> +probe_exit_alloc_candev:
</I>&gt;&gt;&gt;<i> +	pci_iounmap(pdev, addr);
</I>&gt;&gt;&gt;<i> +probe_exit_ipmap:
</I>&gt;&gt;&gt;<i> +	pci_release_regions(pdev);
</I>&gt;&gt;&gt;<i> +probe_exit_pcireq:
</I>&gt;&gt;&gt;<i> +	pci_disable_device(pdev);
</I>&gt;&gt;&gt;<i> +probe_exit_endev:
</I>&gt;&gt;&gt;<i> +	return rc;
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static struct pci_driver pch_can_pcidev = {
</I>&gt;&gt;&gt;<i> +	.name = &quot;pch_can&quot;,
</I>&gt;&gt;&gt;<i> +	.id_table = pch_pci_tbl,
</I>&gt;&gt;&gt;<i> +	.probe = pch_can_probe,
</I>&gt;&gt;&gt;<i> +	.remove = __devexit_p(pch_can_remove),
</I>&gt;&gt;&gt;<i> +	.suspend = pch_can_suspend,
</I>&gt;&gt;&gt;<i> +	.resume = pch_can_resume,
</I>&gt;&gt;&gt;<i> +};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static int __init pch_can_pci_init(void)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	return pci_register_driver(&amp;pch_can_pcidev);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +module_init(pch_can_pci_init);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +static void __exit pch_can_pci_exit(void)
</I>&gt;&gt;&gt;<i> +{
</I>&gt;&gt;&gt;<i> +	pci_unregister_driver(&amp;pch_can_pcidev);
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +module_exit(pch_can_pci_exit);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +MODULE_DESCRIPTION(&quot;Controller Area Network Driver&quot;);
</I>&gt;&gt;<i> the driver name should apper here
</I>&gt;&gt;&gt;<i> +MODULE_LICENSE(&quot;GPL v2&quot;);
</I>&gt;&gt;&gt;<i> +MODULE_VERSION(&quot;0.94&quot;);
</I>
Wolfgang.

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004787.html">[PATCH net-next-2.6 v1] can: Topcliff: Update PCH_CAN driver	to 2.6.35
</A></li>
	<LI>Next message: <A HREF="004871.html">[PATCH net-next-2.6 v1] can: Topcliff: Update PCH_CAN driver	to 2.6.35
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4789">[ date ]</a>
              <a href="thread.html#4789">[ thread ]</a>
              <a href="subject.html#4789">[ subject ]</a>
              <a href="author.html#4789">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
