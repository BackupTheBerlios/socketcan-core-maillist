<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH net-next-2.6 v3 1/2] can: add driver for Softing card
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2011-January/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20net-next-2.6%20v3%201/2%5D%20can%3A%20add%20driver%20for%20Softing%20card&In-Reply-To=%3C20110111143231.GC387%40e-circ.dyndns.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005350.html">
   <LINK REL="Next"  HREF="005352.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH net-next-2.6 v3 1/2] can: add driver for Softing card</H1>
    <B>Kurt Van Dijck</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20net-next-2.6%20v3%201/2%5D%20can%3A%20add%20driver%20for%20Softing%20card&In-Reply-To=%3C20110111143231.GC387%40e-circ.dyndns.org%3E"
       TITLE="[PATCH net-next-2.6 v3 1/2] can: add driver for Softing card">kurt.van.dijck at eia.be
       </A><BR>
    <I>Tue Jan 11 15:32:31 CET 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="005350.html">[PATCH net-next-2.6 v3 0/2] can: add driver for Softing card
</A></li>
        <LI>Next message: <A HREF="005352.html">[PATCH net-next-2.6 v3 2/2] can: add driver for Softing card
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5351">[ date ]</a>
              <a href="thread.html#5351">[ thread ]</a>
              <a href="subject.html#5351">[ subject ]</a>
              <a href="author.html#5351">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This patch adds a driver for the platform:softing device.
This will create (up to) 2 CAN network devices from 1
platform:softing device

Signed-off-by: Kurt Van Dijck &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kurt.van.dijck at eia.be</A>&gt;
Acked-by: Wolfgang Grandegger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">wg at grandegger.com</A>&gt;
---
 drivers/net/can/Kconfig                    |    2 +
 drivers/net/can/Makefile                   |    1 +
 drivers/net/can/softing/Kconfig            |   16 +
 drivers/net/can/softing/Makefile           |    5 +
 drivers/net/can/softing/softing.h          |  168 ++++++
 drivers/net/can/softing/softing_fw.c       |  692 +++++++++++++++++++++
 drivers/net/can/softing/softing_main.c     |  893 ++++++++++++++++++++++++++++
 drivers/net/can/softing/softing_platform.h |   41 ++
 8 files changed, 1818 insertions(+), 0 deletions(-)

diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
index d5a9db6..986195e 100644
--- a/drivers/net/can/Kconfig
+++ b/drivers/net/can/Kconfig
@@ -117,6 +117,8 @@ source &quot;drivers/net/can/sja1000/Kconfig&quot;
 
 source &quot;drivers/net/can/usb/Kconfig&quot;
 
+source &quot;drivers/net/can/softing/Kconfig&quot;
+
 config CAN_DEBUG_DEVICES
 	bool &quot;CAN devices debugging messages&quot;
 	depends on CAN
diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
index 07ca159..53c82a7 100644
--- a/drivers/net/can/Makefile
+++ b/drivers/net/can/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_CAN_DEV)		+= can-dev.o
 can-dev-y			:= dev.o
 
 obj-y				+= usb/
+obj-y				+= softing/
 
 obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
 obj-$(CONFIG_CAN_MSCAN)		+= mscan/
diff --git a/drivers/net/can/softing/Kconfig b/drivers/net/can/softing/Kconfig
new file mode 100644
index 0000000..072f337
--- /dev/null
+++ b/drivers/net/can/softing/Kconfig
@@ -0,0 +1,16 @@
+config CAN_SOFTING
+	tristate &quot;Softing Gmbh CAN generic support&quot;
+	depends on CAN_DEV
+	---help---
+	  Support for CAN cards from Softing Gmbh &amp; some cards
+	  from Vector Gmbh.
+	  Softing Gmbh CAN cards come with 1 or 2 physical busses.
+	  Those cards typically use Dual Port RAM to communicate
+	  with the host CPU. The interface is then identical for PCI
+	  and PCMCIA cards. This driver operates on a platform device,
+	  which has been created by softing_cs or softing_pci driver.
+	  Warning:
+	  The API of the card does not allow fine control per bus, but
+	  controls the 2 busses on the card together.
+	  As such, some actions (start/stop/busoff recovery) on 1 bus
+	  must bring down the other bus too temporarily.
diff --git a/drivers/net/can/softing/Makefile b/drivers/net/can/softing/Makefile
new file mode 100644
index 0000000..7db0445
--- /dev/null
+++ b/drivers/net/can/softing/Makefile
@@ -0,0 +1,5 @@
+
+softing-y := softing_main.o softing_fw.o
+obj-$(CONFIG_CAN_SOFTING) += softing.o
+
+ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
diff --git a/drivers/net/can/softing/softing.h b/drivers/net/can/softing/softing.h
new file mode 100644
index 0000000..7479ee1
--- /dev/null
+++ b/drivers/net/can/softing/softing.h
@@ -0,0 +1,168 @@
+/*
+ * softing common interfaces
+ *
+ * by Kurt Van Dijck, 2008-2010
+ */
+
+#include &lt;linux/atomic.h&gt;
+#include &lt;linux/netdevice.h&gt;
+#include &lt;linux/ktime.h&gt;
+#include &lt;linux/mutex.h&gt;
+#include &lt;linux/spinlock.h&gt;
+#include &lt;linux/can.h&gt;
+#include &lt;linux/can/dev.h&gt;
+
+#include &quot;softing_platform.h&quot;
+
+struct softing;
+
+struct softing_priv {
+	struct can_priv can; /* must be the first member! */
+	struct net_device *netdev;
+	struct softing *card;
+	struct {
+		int pending;
+		/* variables wich hold the circular buffer */
+		int echo_put;
+		int echo_get;
+	} tx;
+	struct can_bittiming_const btr_const;
+	int index;
+	uint8_t output;
+	uint16_t chip;
+};
+#define netdev2softing(netdev)	((struct softing_priv *)netdev_priv(netdev))
+
+struct softing {
+	const struct softing_platform_data *pdat;
+	struct platform_device *pdev;
+	struct net_device *net[2];
+	spinlock_t spin; /* protect this structure &amp; DPRAM access */
+	ktime_t ts_ref;
+	ktime_t ts_overflow; /* timestamp overflow value, in ktime */
+
+	struct {
+		/* indication of firmware status */
+		int up;
+		/* protection of the 'up' variable */
+		struct mutex lock;
+	} fw;
+	struct {
+		int nr;
+		int requested;
+		int svc_count;
+		unsigned int dpram_position;
+	} irq;
+	struct {
+		int pending;
+		int last_bus;
+		/*
+		 * keep the bus that last tx'd a message,
+		 * in order to let every netdev queue resume
+		 */
+	} tx;
+	__iomem uint8_t *dpram;
+	unsigned long dpram_phys;
+	unsigned long dpram_size;
+	struct {
+		uint16_t fw_version, hw_version, license, serial;
+		uint16_t chip[2];
+		unsigned int freq; /* remote cpu's operating frequency */
+	} id;
+};
+
+extern int softing_default_output(struct net_device *netdev);
+
+extern ktime_t softing_raw2ktime(struct softing *card, u32 raw);
+
+extern int softing_chip_poweron(struct softing *card);
+
+extern int softing_bootloader_command(struct softing *card, int16_t cmd,
+		const char *msg);
+
+/* Load firmware after reset */
+extern int softing_load_fw(const char *file, struct softing *card,
+			__iomem uint8_t *virt, unsigned int size, int offset);
+
+/* Load final application firmware after bootloader */
+extern int softing_load_app_fw(const char *file, struct softing *card);
+
+/*
+ * enable or disable irq
+ * only called with fw.lock locked
+ */
+extern int softing_enable_irq(struct softing *card, int enable);
+
+/* start/stop 1 bus on card */
+extern int softing_startstop(struct net_device *netdev, int up);
+
+/* netif_rx() */
+extern int softing_netdev_rx(struct net_device *netdev,
+		const struct can_frame *msg, ktime_t ktime);
+
+/* SOFTING DPRAM mappings */
+#define DPRAM_RX		0x0000
+	#define DPRAM_RX_SIZE	32
+	#define DPRAM_RX_CNT	16
+#define DPRAM_RX_RD		0x0201	/* uint8_t */
+#define DPRAM_RX_WR		0x0205	/* uint8_t */
+#define DPRAM_RX_LOST		0x0207	/* uint8_t */
+
+#define DPRAM_FCT_PARAM		0x0300	/* int16_t [20] */
+#define DPRAM_FCT_RESULT	0x0328	/* int16_t */
+#define DPRAM_FCT_HOST		0x032b	/* uint16_t */
+
+#define DPRAM_INFO_BUSSTATE	0x0331	/* uint16_t */
+#define DPRAM_INFO_BUSSTATE2	0x0335	/* uint16_t */
+#define DPRAM_INFO_ERRSTATE	0x0339	/* uint16_t */
+#define DPRAM_INFO_ERRSTATE2	0x033d	/* uint16_t */
+#define DPRAM_RESET		0x0341	/* uint16_t */
+#define DPRAM_CLR_RECV_FIFO	0x0345	/* uint16_t */
+#define DPRAM_RESET_TIME	0x034d	/* uint16_t */
+#define DPRAM_TIME		0x0350	/* uint64_t */
+#define DPRAM_WR_START		0x0358	/* uint8_t */
+#define DPRAM_WR_END		0x0359	/* uint8_t */
+#define DPRAM_RESET_RX_FIFO	0x0361	/* uint16_t */
+#define DPRAM_RESET_TX_FIFO	0x0364	/* uint8_t */
+#define DPRAM_READ_FIFO_LEVEL	0x0365	/* uint8_t */
+#define DPRAM_RX_FIFO_LEVEL	0x0366	/* uint16_t */
+#define DPRAM_TX_FIFO_LEVEL	0x0366	/* uint16_t */
+
+#define DPRAM_TX		0x0400	/* uint16_t */
+	#define DPRAM_TX_SIZE	16
+	#define DPRAM_TX_CNT	32
+#define DPRAM_TX_RD		0x0601	/* uint8_t */
+#define DPRAM_TX_WR		0x0605	/* uint8_t */
+
+#define DPRAM_COMMAND		0x07e0	/* uint16_t */
+#define DPRAM_RECEIPT		0x07f0	/* uint16_t */
+#define DPRAM_IRQ_TOHOST	0x07fe	/* uint8_t */
+#define DPRAM_IRQ_TOCARD	0x07ff	/* uint8_t */
+
+#define DPRAM_V2_RESET		0x0e00	/* uint8_t */
+#define DPRAM_V2_IRQ_TOHOST	0x0e02	/* uint8_t */
+
+#define TXMAX	(DPRAM_TX_CNT - 1)
+
+/* DPRAM return codes */
+#define RES_NONE	0
+#define RES_OK		1
+#define RES_NOK		2
+#define RES_UNKNOWN	3
+/* DPRAM flags */
+#define CMD_TX		0x01
+#define CMD_ACK		0x02
+#define CMD_XTD		0x04
+#define CMD_RTR		0x08
+#define CMD_ERR		0x10
+#define CMD_BUS2	0x80
+
+/* returned fifo entry bus state masks */
+#define SF_MASK_BUSOFF		0x80
+#define SF_MASK_EPASSIVE	0x60
+
+/* bus states */
+#define STATE_BUSOFF	2
+#define STATE_EPASSIVE	1
+#define STATE_EACTIVE	0
+
diff --git a/drivers/net/can/softing/softing_fw.c b/drivers/net/can/softing/softing_fw.c
new file mode 100644
index 0000000..ec42a87
--- /dev/null
+++ b/drivers/net/can/softing/softing_fw.c
@@ -0,0 +1,692 @@
+/*
+ * Copyright (C) 2008-2010
+ *
+ * - Kurt Van Dijck, EIA Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include &lt;linux/firmware.h&gt;
+#include &lt;linux/sched.h&gt;
+#include &lt;asm/div64.h&gt;
+
+#include &quot;softing.h&quot;
+
+/*
+ * low level DPRAM command.
+ * Make sure that card-&gt;dpram[DPRAM_FCT_HOST] is preset
+ */
+static int _softing_fct_cmd(struct softing *card, int16_t cmd, uint16_t vector,
+		const char *msg)
+{
+	int ret;
+	unsigned long stamp;
+
+	iowrite16(cmd, &amp;card-&gt;dpram[DPRAM_FCT_PARAM]);
+	iowrite8(vector &gt;&gt; 8, &amp;card-&gt;dpram[DPRAM_FCT_HOST + 1]);
+	iowrite8(vector, &amp;card-&gt;dpram[DPRAM_FCT_HOST]);
+	/* be sure to flush this to the card */
+	wmb();
+	stamp = jiffies + 1 * HZ;
+	/* wait for card */
+	do {
+		/* DPRAM_FCT_HOST is _not_ aligned */
+		ret = ioread8(&amp;card-&gt;dpram[DPRAM_FCT_HOST]) +
+			(ioread8(&amp;card-&gt;dpram[DPRAM_FCT_HOST + 1]) &lt;&lt; 8);
+		/* don't have any cached variables */
+		rmb();
+		if (ret == RES_OK)
+			/* read return-value now */
+			return ioread16(&amp;card-&gt;dpram[DPRAM_FCT_RESULT]);
+
+		if ((ret != vector) || time_after(jiffies, stamp))
+			break;
+		/* process context =&gt; relax */
+		usleep_range(500, 10000);
+	} while (1);
+
+	ret = (ret == RES_NONE) ? -ETIMEDOUT : -ECANCELED;
+	dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;firmware %s failed (%i)\n&quot;, msg, ret);
+	return ret;
+}
+
+static int softing_fct_cmd(struct softing *card, int16_t cmd, const char *msg)
+{
+	int ret;
+
+	ret = _softing_fct_cmd(card, cmd, 0, msg);
+	if (ret &gt; 0) {
+		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;%s returned %u\n&quot;, msg, ret);
+		ret = -EIO;
+	}
+	return ret;
+}
+
+int softing_bootloader_command(struct softing *card, int16_t cmd,
+		const char *msg)
+{
+	int ret;
+	unsigned long stamp;
+
+	iowrite16(RES_NONE, &amp;card-&gt;dpram[DPRAM_RECEIPT]);
+	iowrite16(cmd, &amp;card-&gt;dpram[DPRAM_COMMAND]);
+	/* be sure to flush this to the card */
+	wmb();
+	stamp = jiffies + 3 * HZ;
+	/* wait for card */
+	do {
+		ret = ioread16(&amp;card-&gt;dpram[DPRAM_RECEIPT]);
+		/* don't have any cached variables */
+		rmb();
+		if (ret == RES_OK)
+			return 0;
+		if (time_after(jiffies, stamp))
+			break;
+		/* process context =&gt; relax */
+		usleep_range(500, 10000);
+	} while (!signal_pending(current));
+
+	ret = (ret == RES_NONE) ? -ETIMEDOUT : -ECANCELED;
+	dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;bootloader %s failed (%i)\n&quot;, msg, ret);
+	return ret;
+}
+
+static int fw_parse(const uint8_t **pmem, uint16_t *ptype, uint32_t *paddr,
+		uint16_t *plen, const uint8_t **pdat)
+{
+	uint16_t checksum[2];
+	const uint8_t *mem;
+	const uint8_t *end;
+
+	/*
+	 * firmware records are a binary, unaligned stream composed of:
+	 * uint16_t type;
+	 * uint32_t addr;
+	 * uint16_t len;
+	 * uint8_t dat[len];
+	 * uint16_t checksum;
+	 * all values in little endian.
+	 * We could define a struct for this, with __attribute__((packed)),
+	 * but would that solve the alignment in _all_ cases (cfr. the
+	 * struct itself may be an odd address)?
+	 *
+	 * I chose to use leXX_to_cpup() since this solves both
+	 * endianness &amp; alignment.
+	 */
+	mem = *pmem;
+	*ptype = le16_to_cpup((void *)&amp;mem[0]);
+	*paddr = le32_to_cpup((void *)&amp;mem[2]);
+	*plen = le16_to_cpup((void *)&amp;mem[6]);
+	*pdat = &amp;mem[8];
+	/* verify checksum */
+	end = &amp;mem[8 + *plen];
+	checksum[0] = le16_to_cpup((void *)end);
+	for (checksum[1] = 0; mem &lt; end; ++mem)
+		checksum[1] += *mem;
+	if (checksum[0] != checksum[1])
+		return -EINVAL;
+	/* increment */
+	*pmem += 10 + *plen;
+	return 0;
+}
+
+int softing_load_fw(const char *file, struct softing *card,
+		__iomem uint8_t *dpram, unsigned int size, int offset)
+{
+	const struct firmware *fw;
+	int ret;
+	const uint8_t *mem, *end, *dat;
+	uint16_t type, len;
+	uint32_t addr;
+	uint8_t *buf = NULL;
+	int buflen = 0;
+	int8_t type_end = 0;
+
+	ret = request_firmware(&amp;fw, file, &amp;card-&gt;pdev-&gt;dev);
+	if (ret &lt; 0)
+		return ret;
+	dev_dbg(&amp;card-&gt;pdev-&gt;dev, &quot;%s, firmware(%s) got %u bytes&quot;
+		&quot;, offset %c0x%04x\n&quot;,
+		card-&gt;pdat-&gt;name, file, (unsigned int)fw-&gt;size,
+		(offset &gt;= 0) ? '+' : '-', (unsigned int)abs(offset));
+	/* parse the firmware */
+	mem = fw-&gt;data;
+	end = &amp;mem[fw-&gt;size];
+	/* look for header record */
+	ret = fw_parse(&amp;mem, &amp;type, &amp;addr, &amp;len, &amp;dat);
+	if (ret &lt; 0)
+		goto failed;
+	if (type != 0xffff)
+		goto failed;
+	if (strncmp(&quot;Structured Binary Format, Softing GmbH&quot; , dat, len)) {
+		ret = -EINVAL;
+		goto failed;
+	}
+	/* ok, we had a header */
+	while (mem &lt; end) {
+		ret = fw_parse(&amp;mem, &amp;type, &amp;addr, &amp;len, &amp;dat);
+		if (ret &lt; 0)
+			goto failed;
+		if (type == 3) {
+			/* start address, not used here */
+			continue;
+		} else if (type == 1) {
+			/* eof */
+			type_end = 1;
+			break;
+		} else if (type != 0) {
+			ret = -EINVAL;
+			goto failed;
+		}
+
+		if ((addr + len + offset) &gt; size)
+			goto failed;
+		memcpy_toio(&amp;dpram[addr + offset], dat, len);
+		/* be sure to flush caches from IO space */
+		mb();
+		if (len &gt; buflen) {
+			/* align buflen */
+			buflen = (len + (1024-1)) &amp; ~(1024-1);
+			buf = krealloc(buf, buflen, GFP_KERNEL);
+			if (!buf) {
+				ret = -ENOMEM;
+				goto failed;
+			}
+		}
+		/* verify record data */
+		memcpy_fromio(buf, &amp;dpram[addr + offset], len);
+		if (memcmp(buf, dat, len)) {
+			/* is not ok */
+			dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;DPRAM readback failed\n&quot;);
+			ret = -EIO;
+			goto failed;
+		}
+	}
+	if (!type_end)
+		/* no end record seen */
+		goto failed;
+	ret = 0;
+failed:
+	kfree(buf);
+	release_firmware(fw);
+	if (ret &lt; 0)
+		dev_info(&amp;card-&gt;pdev-&gt;dev, &quot;firmware %s failed\n&quot;, file);
+	return ret;
+}
+
+int softing_load_app_fw(const char *file, struct softing *card)
+{
+	const struct firmware *fw;
+	const uint8_t *mem, *end, *dat;
+	int ret, j;
+	uint16_t type, len;
+	uint32_t addr, start_addr = 0;
+	unsigned int sum, rx_sum;
+	int8_t type_end = 0, type_entrypoint = 0;
+
+	ret = request_firmware(&amp;fw, file, &amp;card-&gt;pdev-&gt;dev);
+	if (ret) {
+		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;request_firmware(%s) got %i\n&quot;,
+			file, ret);
+		return ret;
+	}
+	dev_dbg(&amp;card-&gt;pdev-&gt;dev, &quot;firmware(%s) got %lu bytes\n&quot;,
+		file, (unsigned long)fw-&gt;size);
+	/* parse the firmware */
+	mem = fw-&gt;data;
+	end = &amp;mem[fw-&gt;size];
+	/* look for header record */
+	ret = fw_parse(&amp;mem, &amp;type, &amp;addr, &amp;len, &amp;dat);
+	if (ret)
+		goto failed;
+	ret = -EINVAL;
+	if (type != 0xffff) {
+		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;firmware starts with type 0x%x\n&quot;,
+			type);
+		goto failed;
+	}
+	if (strncmp(&quot;Structured Binary Format, Softing GmbH&quot;, dat, len)) {
+		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;firmware string '%.*s' fault\n&quot;,
+				len, dat);
+		goto failed;
+	}
+	/* ok, we had a header */
+	while (mem &lt; end) {
+		ret = fw_parse(&amp;mem, &amp;type, &amp;addr, &amp;len, &amp;dat);
+		if (ret)
+			goto failed;
+
+		if (type == 3) {
+			/* start address */
+			start_addr = addr;
+			type_entrypoint = 1;
+			continue;
+		} else if (type == 1) {
+			/* eof */
+			type_end = 1;
+			break;
+		} else if (type != 0) {
+			dev_alert(&amp;card-&gt;pdev-&gt;dev,
+					&quot;unknown record type 0x%04x\n&quot;, type);
+			ret = -EINVAL;
+			goto failed;
+		}
+
+		/* regualar data */
+		for (sum = 0, j = 0; j &lt; len; ++j)
+			sum += dat[j];
+		/* work in 16bit (target) */
+		sum &amp;= 0xffff;
+
+		memcpy_toio(&amp;card-&gt;dpram[card-&gt;pdat-&gt;app.offs], dat, len);
+		iowrite32(card-&gt;pdat-&gt;app.offs + card-&gt;pdat-&gt;app.addr,
+				&amp;card-&gt;dpram[DPRAM_COMMAND + 2]);
+		iowrite32(addr, &amp;card-&gt;dpram[DPRAM_COMMAND + 6]);
+		iowrite16(len, &amp;card-&gt;dpram[DPRAM_COMMAND + 10]);
+		iowrite8(1, &amp;card-&gt;dpram[DPRAM_COMMAND + 12]);
+		ret = softing_bootloader_command(card, 1, &quot;loading app.&quot;);
+		if (ret &lt; 0)
+			goto failed;
+		/* verify checksum */
+		rx_sum = ioread16(&amp;card-&gt;dpram[DPRAM_RECEIPT + 2]);
+		if (rx_sum != sum) {
+			dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;SRAM seems to be damaged&quot;
+				&quot;, wanted 0x%04x, got 0x%04x\n&quot;, sum, rx_sum);
+			ret = -EIO;
+			goto failed;
+		}
+	}
+	if (!type_end || !type_entrypoint)
+		goto failed;
+	/* start application in card */
+	iowrite32(start_addr, &amp;card-&gt;dpram[DPRAM_COMMAND + 2]);
+	iowrite8(1, &amp;card-&gt;dpram[DPRAM_COMMAND + 6]);
+	ret = softing_bootloader_command(card, 3, &quot;start app.&quot;);
+	if (ret &lt; 0)
+		goto failed;
+	ret = 0;
+failed:
+	release_firmware(fw);
+	if (ret &lt; 0)
+		dev_info(&amp;card-&gt;pdev-&gt;dev, &quot;firmware %s failed\n&quot;, file);
+	return ret;
+}
+
+static int softing_reset_chip(struct softing *card)
+{
+	int ret;
+
+	do {
+		/* reset chip */
+		iowrite8(0, &amp;card-&gt;dpram[DPRAM_RESET_RX_FIFO]);
+		iowrite8(0, &amp;card-&gt;dpram[DPRAM_RESET_RX_FIFO+1]);
+		iowrite8(1, &amp;card-&gt;dpram[DPRAM_RESET]);
+		iowrite8(0, &amp;card-&gt;dpram[DPRAM_RESET+1]);
+
+		ret = softing_fct_cmd(card, 0, &quot;reset_can&quot;);
+		if (!ret)
+			break;
+		if (signal_pending(current))
+			/* don't wait any longer */
+			break;
+	} while (1);
+	card-&gt;tx.pending = 0;
+	return ret;
+}
+
+int softing_chip_poweron(struct softing *card)
+{
+	int ret;
+	/* sync */
+	ret = _softing_fct_cmd(card, 99, 0x55, &quot;sync-a&quot;);
+	if (ret &lt; 0)
+		goto failed;
+
+	ret = _softing_fct_cmd(card, 99, 0xaa, &quot;sync-b&quot;);
+	if (ret &lt; 0)
+		goto failed;
+
+	ret = softing_reset_chip(card);
+	if (ret &lt; 0)
+		goto failed;
+	/* get_serial */
+	ret = softing_fct_cmd(card, 43, &quot;get_serial_number&quot;);
+	if (ret &lt; 0)
+		goto failed;
+	card-&gt;id.serial = ioread32(&amp;card-&gt;dpram[DPRAM_FCT_PARAM]);
+	/* get_version */
+	ret = softing_fct_cmd(card, 12, &quot;get_version&quot;);
+	if (ret &lt; 0)
+		goto failed;
+	card-&gt;id.fw_version = ioread16(&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
+	card-&gt;id.hw_version = ioread16(&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 4]);
+	card-&gt;id.license = ioread16(&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 6]);
+	card-&gt;id.chip[0] = ioread16(&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 8]);
+	card-&gt;id.chip[1] = ioread16(&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 10]);
+	return 0;
+failed:
+	return ret;
+}
+
+static void softing_initialize_timestamp(struct softing *card)
+{
+	uint64_t ovf;
+
+	card-&gt;ts_ref = ktime_get();
+
+	/* 16MHz is the reference */
+	ovf = 0x100000000ULL * 16;
+	do_div(ovf, card-&gt;pdat-&gt;freq ?: 16);
+
+	card-&gt;ts_overflow = ktime_add_us(ktime_set(0, 0), ovf);
+}
+
+ktime_t softing_raw2ktime(struct softing *card, u32 raw)
+{
+	uint64_t rawl;
+	ktime_t now, real_offset;
+	ktime_t target;
+	ktime_t tmp;
+
+	now = ktime_get();
+	real_offset = ktime_sub(ktime_get_real(), now);
+
+	/* find nsec from card */
+	rawl = raw * 16;
+	do_div(rawl, card-&gt;pdat-&gt;freq ?: 16);
+	target = ktime_add_us(card-&gt;ts_ref, rawl);
+	/* test for overflows */
+	tmp = ktime_add(target, card-&gt;ts_overflow);
+	while (unlikely(ktime_to_ns(tmp) &gt; ktime_to_ns(now))) {
+		card-&gt;ts_ref = ktime_add(card-&gt;ts_ref, card-&gt;ts_overflow);
+		target = tmp;
+		tmp = ktime_add(target, card-&gt;ts_overflow);
+	}
+	return ktime_add(target, real_offset);
+}
+
+static inline int softing_error_reporting(struct net_device *netdev)
+{
+	struct softing_priv *priv = netdev_priv(netdev);
+
+	return (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_BERR_REPORTING)
+		? 1 : 0;
+}
+
+int softing_startstop(struct net_device *dev, int up)
+{
+	int ret;
+	struct softing *card;
+	struct softing_priv *priv;
+	struct net_device *netdev;
+	int bus_bitmask_start;
+	int j, error_reporting;
+	struct can_frame msg;
+	const struct can_bittiming *bt;
+
+	priv = netdev_priv(dev);
+	card = priv-&gt;card;
+
+	if (!card-&gt;fw.up)
+		return -EIO;
+
+	ret = mutex_lock_interruptible(&amp;card-&gt;fw.lock);
+	if (ret)
+		return ret;
+
+	bus_bitmask_start = 0;
+	if (dev &amp;&amp; up)
+		/* prepare to start this bus as well */
+		bus_bitmask_start |= (1 &lt;&lt; priv-&gt;index);
+	/* bring netdevs down */
+	for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
+		netdev = card-&gt;net[j];
+		if (!netdev)
+			continue;
+		priv = netdev_priv(netdev);
+
+		if (dev != netdev)
+			netif_stop_queue(netdev);
+
+		if (netif_running(netdev)) {
+			if (dev != netdev)
+				bus_bitmask_start |= (1 &lt;&lt; j);
+			priv-&gt;tx.pending = 0;
+			priv-&gt;tx.echo_put = 0;
+			priv-&gt;tx.echo_get = 0;
+			/*
+			 * this bus' may just have called open_candev()
+			 * which is rather stupid to call close_candev()
+			 * already
+			 * but we may come here from busoff recovery too
+			 * in which case the echo_skb _needs_ flushing too.
+			 * just be sure to call open_candev() again
+			 */
+			close_candev(netdev);
+		}
+		priv-&gt;can.state = CAN_STATE_STOPPED;
+	}
+	card-&gt;tx.pending = 0;
+
+	softing_enable_irq(card, 0);
+	ret = softing_reset_chip(card);
+	if (ret)
+		goto failed;
+	if (!bus_bitmask_start)
+		/* no busses to be brought up */
+		goto card_done;
+
+	if ((bus_bitmask_start &amp; 1) &amp;&amp; (bus_bitmask_start &amp; 2)
+			&amp;&amp; (softing_error_reporting(card-&gt;net[0])
+				!= softing_error_reporting(card-&gt;net[1]))) {
+		dev_alert(&amp;card-&gt;pdev-&gt;dev,
+				&quot;err_reporting flag differs for busses\n&quot;);
+		goto invalid;
+	}
+	error_reporting = 0;
+	if (bus_bitmask_start &amp; 1) {
+		netdev = card-&gt;net[0];
+		priv = netdev_priv(netdev);
+		error_reporting += softing_error_reporting(netdev);
+		/* init chip 1 */
+		bt = &amp;priv-&gt;can.bittiming;
+		iowrite16(bt-&gt;brp, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
+		iowrite16(bt-&gt;sjw, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 4]);
+		iowrite16(bt-&gt;phase_seg1 + bt-&gt;prop_seg,
+				&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 6]);
+		iowrite16(bt-&gt;phase_seg2, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 8]);
+		iowrite16((priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES) ? 1 : 0,
+				&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 10]);
+		ret = softing_fct_cmd(card, 1, &quot;initialize_chip[0]&quot;);
+		if (ret &lt; 0)
+			goto failed;
+		/* set mode */
+		iowrite16(0, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
+		iowrite16(0, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 4]);
+		ret = softing_fct_cmd(card, 3, &quot;set_mode[0]&quot;);
+		if (ret &lt; 0)
+			goto failed;
+		/* set filter */
+		/* 11bit id &amp; mask */
+		iowrite16(0x0000, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
+		iowrite16(0x07ff, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 4]);
+		/* 29bit id.lo &amp; mask.lo &amp; id.hi &amp; mask.hi */
+		iowrite16(0x0000, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 6]);
+		iowrite16(0xffff, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 8]);
+		iowrite16(0x0000, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 10]);
+		iowrite16(0x1fff, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 12]);
+		ret = softing_fct_cmd(card, 7, &quot;set_filter[0]&quot;);
+		if (ret &lt; 0)
+			goto failed;
+		/* set output control */
+		iowrite16(priv-&gt;output, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
+		ret = softing_fct_cmd(card, 5, &quot;set_output[0]&quot;);
+		if (ret &lt; 0)
+			goto failed;
+	}
+	if (bus_bitmask_start &amp; 2) {
+		netdev = card-&gt;net[1];
+		priv = netdev_priv(netdev);
+		error_reporting += softing_error_reporting(netdev);
+		/* init chip2 */
+		bt = &amp;priv-&gt;can.bittiming;
+		iowrite16(bt-&gt;brp, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
+		iowrite16(bt-&gt;sjw, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 4]);
+		iowrite16(bt-&gt;phase_seg1 + bt-&gt;prop_seg,
+				&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 6]);
+		iowrite16(bt-&gt;phase_seg2, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 8]);
+		iowrite16((priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES) ? 1 : 0,
+				&amp;card-&gt;dpram[DPRAM_FCT_PARAM + 10]);
+		ret = softing_fct_cmd(card, 2, &quot;initialize_chip[1]&quot;);
+		if (ret &lt; 0)
+			goto failed;
+		/* set mode2 */
+		iowrite16(0, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
+		iowrite16(0, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 4]);
+		ret = softing_fct_cmd(card, 4, &quot;set_mode[1]&quot;);
+		if (ret &lt; 0)
+			goto failed;
+		/* set filter2 */
+		/* 11bit id &amp; mask */
+		iowrite16(0x0000, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
+		iowrite16(0x07ff, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 4]);
+		/* 29bit id.lo &amp; mask.lo &amp; id.hi &amp; mask.hi */
+		iowrite16(0x0000, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 6]);
+		iowrite16(0xffff, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 8]);
+		iowrite16(0x0000, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 10]);
+		iowrite16(0x1fff, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 12]);
+		ret = softing_fct_cmd(card, 8, &quot;set_filter[1]&quot;);
+		if (ret &lt; 0)
+			goto failed;
+		/* set output control2 */
+		iowrite16(priv-&gt;output, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
+		ret = softing_fct_cmd(card, 6, &quot;set_output[1]&quot;);
+		if (ret &lt; 0)
+			goto failed;
+	}
+	/* enable_error_frame */
+	/*
+	 * Error reporting is switched off at the moment since
+	 * the receiving of them is not yet 100% verified
+	 * This should be enabled sooner or later
+	 *
+	if (error_reporting) {
+		ret = softing_fct_cmd(card, 51, &quot;enable_error_frame&quot;);
+		if (ret &lt; 0)
+			goto failed;
+	}
+	*/
+	/* initialize interface */
+	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 2]);
+	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 4]);
+	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 6]);
+	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 8]);
+	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 10]);
+	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 12]);
+	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 14]);
+	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 16]);
+	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 18]);
+	iowrite16(1, &amp;card-&gt;dpram[DPRAM_FCT_PARAM + 20]);
+	ret = softing_fct_cmd(card, 17, &quot;initialize_interface&quot;);
+	if (ret &lt; 0)
+		goto failed;
+	/* enable_fifo */
+	ret = softing_fct_cmd(card, 36, &quot;enable_fifo&quot;);
+	if (ret &lt; 0)
+		goto failed;
+	/* enable fifo tx ack */
+	ret = softing_fct_cmd(card, 13, &quot;fifo_tx_ack[0]&quot;);
+	if (ret &lt; 0)
+		goto failed;
+	/* enable fifo tx ack2 */
+	ret = softing_fct_cmd(card, 14, &quot;fifo_tx_ack[1]&quot;);
+	if (ret &lt; 0)
+		goto failed;
+	/* start_chip */
+	ret = softing_fct_cmd(card, 11, &quot;start_chip&quot;);
+	if (ret &lt; 0)
+		goto failed;
+	iowrite8(0, &amp;card-&gt;dpram[DPRAM_INFO_BUSSTATE]);
+	iowrite8(0, &amp;card-&gt;dpram[DPRAM_INFO_BUSSTATE2]);
+	if (card-&gt;pdat-&gt;generation &lt; 2) {
+		iowrite8(0, &amp;card-&gt;dpram[DPRAM_V2_IRQ_TOHOST]);
+		/* flush the DPRAM caches */
+		wmb();
+	}
+
+	softing_initialize_timestamp(card);
+
+	/*
+	 * do socketcan notifications/status changes
+	 * from here, no errors should occur, or the failed: part
+	 * must be reviewed
+	 */
+	memset(&amp;msg, 0, sizeof(msg));
+	msg.can_id = CAN_ERR_FLAG | CAN_ERR_RESTARTED;
+	msg.can_dlc = CAN_ERR_DLC;
+	for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
+		if (!(bus_bitmask_start &amp; (1 &lt;&lt; j)))
+			continue;
+		netdev = card-&gt;net[j];
+		if (!netdev)
+			continue;
+		priv = netdev_priv(netdev);
+		priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
+		open_candev(netdev);
+		if (dev != netdev) {
+			/* notify other busses on the restart */
+			softing_netdev_rx(netdev, &amp;msg, ktime_set(0, 0));
+			++priv-&gt;can.can_stats.restarts;
+		}
+		netif_wake_queue(netdev);
+	}
+
+	/* enable interrupts */
+	ret = softing_enable_irq(card, 1);
+	if (ret)
+		goto failed;
+card_done:
+	mutex_unlock(&amp;card-&gt;fw.lock);
+	return 0;
+invalid:
+	ret = -EINVAL;
+failed:
+	softing_enable_irq(card, 0);
+	softing_reset_chip(card);
+	mutex_unlock(&amp;card-&gt;fw.lock);
+	/* bring all other interfaces down */
+	for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
+		netdev = card-&gt;net[j];
+		if (!netdev)
+			continue;
+		dev_close(netdev);
+	}
+	return ret;
+}
+
+int softing_default_output(struct net_device *netdev)
+{
+	struct softing_priv *priv = netdev_priv(netdev);
+	struct softing *card = priv-&gt;card;
+
+	switch (priv-&gt;chip) {
+	case 1000:
+		return (card-&gt;pdat-&gt;generation &lt; 2) ? 0xfb : 0xfa;
+	case 5:
+		return 0x60;
+	default:
+		return 0x40;
+	}
+}
+
diff --git a/drivers/net/can/softing/softing_main.c b/drivers/net/can/softing/softing_main.c
new file mode 100644
index 0000000..5157e15
--- /dev/null
+++ b/drivers/net/can/softing/softing_main.c
@@ -0,0 +1,893 @@
+/*
+ * Copyright (C) 2008-2010
+ *
+ * - Kurt Van Dijck, EIA Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include &lt;linux/version.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/interrupt.h&gt;
+
+#include &quot;softing.h&quot;
+
+#define TX_ECHO_SKB_MAX (((TXMAX+1)/2)-1)
+
+/*
+ * test is a specific CAN netdev
+ * is online (ie. up 'n running, not sleeping, not busoff
+ */
+static inline int canif_is_active(struct net_device *netdev)
+{
+	struct can_priv *can = netdev_priv(netdev);
+
+	if (!netif_running(netdev))
+		return 0;
+	return (can-&gt;state &lt;= CAN_STATE_ERROR_PASSIVE);
+}
+
+/* reset DPRAM */
+static inline void softing_set_reset_dpram(struct softing *card)
+{
+	if (card-&gt;pdat-&gt;generation &gt;= 2) {
+		spin_lock_bh(&amp;card-&gt;spin);
+		iowrite8(ioread8(&amp;card-&gt;dpram[DPRAM_V2_RESET]) &amp; ~1,
+				&amp;card-&gt;dpram[DPRAM_V2_RESET]);
+		spin_unlock_bh(&amp;card-&gt;spin);
+	}
+}
+
+static inline void softing_clr_reset_dpram(struct softing *card)
+{
+	if (card-&gt;pdat-&gt;generation &gt;= 2) {
+		spin_lock_bh(&amp;card-&gt;spin);
+		iowrite8(ioread8(&amp;card-&gt;dpram[DPRAM_V2_RESET]) | 1,
+				&amp;card-&gt;dpram[DPRAM_V2_RESET]);
+		spin_unlock_bh(&amp;card-&gt;spin);
+	}
+}
+
+/* trigger the tx queue-ing */
+static netdev_tx_t softing_netdev_start_xmit(struct sk_buff *skb,
+		struct net_device *dev)
+{
+	struct softing_priv *priv = netdev_priv(dev);
+	struct softing *card = priv-&gt;card;
+	int ret;
+	uint8_t *ptr;
+	uint8_t fifo_wr, fifo_rd;
+	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
+	uint8_t buf[DPRAM_TX_SIZE];
+
+	if (can_dropped_invalid_skb(dev, skb))
+		return NETDEV_TX_OK;
+
+	spin_lock(&amp;card-&gt;spin);
+
+	ret = NETDEV_TX_BUSY;
+	if (!card-&gt;fw.up ||
+			(card-&gt;tx.pending &gt;= TXMAX) ||
+			(priv-&gt;tx.pending &gt;= TX_ECHO_SKB_MAX))
+		goto xmit_done;
+	fifo_wr = ioread8(&amp;card-&gt;dpram[DPRAM_TX_WR]);
+	fifo_rd = ioread8(&amp;card-&gt;dpram[DPRAM_TX_RD]);
+	if (fifo_wr == fifo_rd)
+		/* fifo full */
+		goto xmit_done;
+	memset(buf, 0, sizeof(buf));
+	ptr = buf;
+	*ptr = CMD_TX;
+	if (cf-&gt;can_id &amp; CAN_RTR_FLAG)
+		*ptr |= CMD_RTR;
+	if (cf-&gt;can_id &amp; CAN_EFF_FLAG)
+		*ptr |= CMD_XTD;
+	if (priv-&gt;index)
+		*ptr |= CMD_BUS2;
+	++ptr;
+	*ptr++ = cf-&gt;can_dlc;
+	*ptr++ = (cf-&gt;can_id &gt;&gt; 0);
+	*ptr++ = (cf-&gt;can_id &gt;&gt; 8);
+	if (cf-&gt;can_id &amp; CAN_EFF_FLAG) {
+		*ptr++ = (cf-&gt;can_id &gt;&gt; 16);
+		*ptr++ = (cf-&gt;can_id &gt;&gt; 24);
+	} else {
+		/* increment 1, not 2 as you might think */
+		ptr += 1;
+	}
+	if (!(cf-&gt;can_id &amp; CAN_RTR_FLAG))
+		memcpy(ptr, &amp;cf-&gt;data[0], cf-&gt;can_dlc);
+	memcpy_toio(&amp;card-&gt;dpram[DPRAM_TX + DPRAM_TX_SIZE * fifo_wr],
+			buf, DPRAM_TX_SIZE);
+	if (++fifo_wr &gt;= DPRAM_TX_CNT)
+		fifo_wr = 0;
+	iowrite8(fifo_wr, &amp;card-&gt;dpram[DPRAM_TX_WR]);
+	card-&gt;tx.last_bus = priv-&gt;index;
+	++card-&gt;tx.pending;
+	++priv-&gt;tx.pending;
+	can_put_echo_skb(skb, dev, priv-&gt;tx.echo_put);
+	++priv-&gt;tx.echo_put;
+	if (priv-&gt;tx.echo_put &gt;= TX_ECHO_SKB_MAX)
+		priv-&gt;tx.echo_put = 0;
+	/* can_put_echo_skb() saves the skb, safe to return TX_OK */
+	ret = NETDEV_TX_OK;
+xmit_done:
+	spin_unlock(&amp;card-&gt;spin);
+	if (card-&gt;tx.pending &gt;= TXMAX) {
+		int j;
+		for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
+			if (card-&gt;net[j])
+				netif_stop_queue(card-&gt;net[j]);
+		}
+	}
+	if (ret != NETDEV_TX_OK)
+		netif_stop_queue(dev);
+
+	return ret;
+}
+
+/*
+ * shortcut for skb delivery
+ */
+int softing_netdev_rx(struct net_device *netdev, const struct can_frame *msg,
+		ktime_t ktime)
+{
+	struct sk_buff *skb;
+	struct can_frame *cf;
+
+	skb = alloc_can_skb(netdev, &amp;cf);
+	if (!skb)
+		return -ENOMEM;
+	memcpy(cf, msg, sizeof(*msg));
+	skb-&gt;tstamp = ktime;
+	return netif_rx(skb);
+}
+
+/*
+ * softing_handle_1
+ * pop 1 entry from the DPRAM queue, and process
+ */
+static int softing_handle_1(struct softing *card)
+{
+	struct net_device *netdev;
+	struct softing_priv *priv;
+	ktime_t ktime;
+	struct can_frame msg;
+	int cnt = 0, lost_msg;
+	uint8_t fifo_rd, fifo_wr, cmd;
+	uint8_t *ptr;
+	uint32_t tmp_u32;
+	uint8_t buf[DPRAM_RX_SIZE];
+
+	memset(&amp;msg, 0, sizeof(msg));
+	/* test for lost msgs */
+	lost_msg = ioread8(&amp;card-&gt;dpram[DPRAM_RX_LOST]);
+	if (lost_msg) {
+		int j;
+		/* reset condition */
+		iowrite8(0, &amp;card-&gt;dpram[DPRAM_RX_LOST]);
+		/* prepare msg */
+		msg.can_id = CAN_ERR_FLAG | CAN_ERR_CRTL;
+		msg.can_dlc = CAN_ERR_DLC;
+		msg.data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+		/*
+		 * service to all busses, we don't know which it was applicable
+		 * but only service busses that are online
+		 */
+		for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
+			netdev = card-&gt;net[j];
+			if (!netdev)
+				continue;
+			if (!canif_is_active(netdev))
+				/* a dead bus has no overflows */
+				continue;
+			++netdev-&gt;stats.rx_over_errors;
+			softing_netdev_rx(netdev, &amp;msg, ktime_set(0, 0));
+		}
+		/* prepare for other use */
+		memset(&amp;msg, 0, sizeof(msg));
+		++cnt;
+	}
+
+	fifo_rd = ioread8(&amp;card-&gt;dpram[DPRAM_RX_RD]);
+	fifo_wr = ioread8(&amp;card-&gt;dpram[DPRAM_RX_WR]);
+
+	if (++fifo_rd &gt;= DPRAM_RX_CNT)
+		fifo_rd = 0;
+	if (fifo_wr == fifo_rd)
+		return cnt;
+
+	memcpy_fromio(buf, &amp;card-&gt;dpram[DPRAM_RX + DPRAM_RX_SIZE*fifo_rd],
+			DPRAM_RX_SIZE);
+	mb();
+	/* trigger dual port RAM */
+	iowrite8(fifo_rd, &amp;card-&gt;dpram[DPRAM_RX_RD]);
+
+	ptr = buf;
+	cmd = *ptr++;
+	if (cmd == 0xff)
+		/* not quite usefull, probably the card has got out */
+		return 0;
+	netdev = card-&gt;net[0];
+	if (cmd &amp; CMD_BUS2)
+		netdev = card-&gt;net[1];
+	priv = netdev_priv(netdev);
+
+	if (cmd &amp; CMD_ERR) {
+		uint8_t can_state, state;
+
+		state = *ptr++;
+
+		msg.can_id = CAN_ERR_FLAG;
+		msg.can_dlc = CAN_ERR_DLC;
+
+		if (state &amp; SF_MASK_BUSOFF) {
+			can_state = CAN_STATE_BUS_OFF;
+			msg.can_id |= CAN_ERR_BUSOFF;
+			state = STATE_BUSOFF;
+		} else if (state &amp; SF_MASK_EPASSIVE) {
+			can_state = CAN_STATE_ERROR_PASSIVE;
+			msg.can_id |= CAN_ERR_CRTL;
+			msg.data[1] = CAN_ERR_CRTL_TX_PASSIVE;
+			state = STATE_EPASSIVE;
+		} else {
+			can_state = CAN_STATE_ERROR_ACTIVE;
+			msg.can_id |= CAN_ERR_CRTL;
+			state = STATE_EACTIVE;
+		}
+		/* update DPRAM */
+		iowrite8(state, &amp;card-&gt;dpram[priv-&gt;index ?
+				DPRAM_INFO_BUSSTATE2 : DPRAM_INFO_BUSSTATE]);
+		/* timestamp */
+		tmp_u32 = le32_to_cpup((void *)ptr);
+		ptr += 4;
+		ktime = softing_raw2ktime(card, tmp_u32);
+
+		++netdev-&gt;stats.rx_errors;
+		/* update internal status */
+		if (can_state != priv-&gt;can.state) {
+			priv-&gt;can.state = can_state;
+			if (can_state == CAN_STATE_ERROR_PASSIVE)
+				++priv-&gt;can.can_stats.error_passive;
+			else if (can_state == CAN_STATE_BUS_OFF) {
+				/* this calls can_close_cleanup() */
+				can_bus_off(netdev);
+				netif_stop_queue(netdev);
+			}
+			/* trigger socketcan */
+			softing_netdev_rx(netdev, &amp;msg, ktime);
+		}
+
+	} else {
+		if (cmd &amp; CMD_RTR)
+			msg.can_id |= CAN_RTR_FLAG;
+		msg.can_dlc = get_can_dlc(*ptr++);
+		if (cmd &amp; CMD_XTD) {
+			msg.can_id |= CAN_EFF_FLAG;
+			msg.can_id |= le32_to_cpup((void *)ptr);
+			ptr += 4;
+		} else {
+			msg.can_id |= le16_to_cpup((void *)ptr);
+			ptr += 2;
+		}
+		/* timestamp */
+		tmp_u32 = le32_to_cpup((void *)ptr);
+		ptr += 4;
+		ktime = softing_raw2ktime(card, tmp_u32);
+		if (!(msg.can_id &amp; CAN_RTR_FLAG))
+			memcpy(&amp;msg.data[0], ptr, 8);
+		ptr += 8;
+		/* update socket */
+		if (cmd &amp; CMD_ACK) {
+			/* acknowledge, was tx msg */
+			struct sk_buff *skb;
+			skb = priv-&gt;can.echo_skb[priv-&gt;tx.echo_get];
+			if (skb)
+				skb-&gt;tstamp = ktime;
+			can_get_echo_skb(netdev, priv-&gt;tx.echo_get);
+			++priv-&gt;tx.echo_get;
+			if (priv-&gt;tx.echo_get &gt;= TX_ECHO_SKB_MAX)
+				priv-&gt;tx.echo_get = 0;
+			if (priv-&gt;tx.pending)
+				--priv-&gt;tx.pending;
+			if (card-&gt;tx.pending)
+				--card-&gt;tx.pending;
+			++netdev-&gt;stats.tx_packets;
+			if (!(msg.can_id &amp; CAN_RTR_FLAG))
+				netdev-&gt;stats.tx_bytes += msg.can_dlc;
+		} else {
+			int ret;
+
+			ret = softing_netdev_rx(netdev, &amp;msg, ktime);
+			if (ret == NET_RX_SUCCESS) {
+				++netdev-&gt;stats.rx_packets;
+				if (!(msg.can_id &amp; CAN_RTR_FLAG))
+					netdev-&gt;stats.rx_bytes += msg.can_dlc;
+			} else {
+				++netdev-&gt;stats.rx_dropped;
+			}
+		}
+	}
+	++cnt;
+	return cnt;
+}
+
+/*
+ * real interrupt handler
+ */
+static irqreturn_t softing_irq_thread(int irq, void *dev_id)
+{
+	struct softing *card = (struct softing *)dev_id;
+	struct net_device *netdev;
+	struct softing_priv *priv;
+	int j, offset, work_done;
+
+	work_done = 0;
+	spin_lock_bh(&amp;card-&gt;spin);
+	while (softing_handle_1(card) &gt; 0) {
+		++card-&gt;irq.svc_count;
+		++work_done;
+	}
+	spin_unlock_bh(&amp;card-&gt;spin);
+	/* resume tx queue's */
+	offset = card-&gt;tx.last_bus;
+	for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
+		if (card-&gt;tx.pending &gt;= TXMAX)
+			break;
+		netdev = card-&gt;net[(j + offset + 1) % card-&gt;pdat-&gt;nbus];
+		if (!netdev)
+			continue;
+		priv = netdev_priv(netdev);
+		if (!canif_is_active(netdev))
+			/* it makes no sense to wake dead busses */
+			continue;
+		if (priv-&gt;tx.pending &gt;= TX_ECHO_SKB_MAX)
+			continue;
+		++work_done;
+		netif_wake_queue(netdev);
+	}
+	return work_done ? IRQ_HANDLED : IRQ_NONE;
+}
+
+/*
+ * interrupt routines:
+ * schedule the 'real interrupt handler'
+ */
+static irqreturn_t softing_irq_v2(int irq, void *dev_id)
+{
+	struct softing *card = (struct softing *)dev_id;
+	uint8_t ir;
+
+	ir = ioread8(&amp;card-&gt;dpram[DPRAM_V2_IRQ_TOHOST]);
+	iowrite8(0, &amp;card-&gt;dpram[DPRAM_V2_IRQ_TOHOST]);
+	return (1 == ir) ? IRQ_WAKE_THREAD : IRQ_NONE;
+}
+
+static irqreturn_t softing_irq_v1(int irq, void *dev_id)
+{
+	struct softing *card = (struct softing *)dev_id;
+	uint8_t ir;
+
+	ir = ioread8(&amp;card-&gt;dpram[DPRAM_IRQ_TOHOST]);
+	iowrite8(0, &amp;card-&gt;dpram[DPRAM_IRQ_TOHOST]);
+	return ir ? IRQ_WAKE_THREAD : IRQ_NONE;
+}
+
+/*
+ * netdev/candev inter-operability
+ */
+static int softing_netdev_open(struct net_device *ndev)
+{
+	int ret;
+
+	/* check or determine and set bittime */
+	ret = open_candev(ndev);
+	if (!ret)
+		ret = softing_startstop(ndev, 1);
+	return ret;
+}
+
+static int softing_netdev_stop(struct net_device *ndev)
+{
+	int ret;
+
+	netif_stop_queue(ndev);
+
+	/* softing cycle does close_candev() */
+	ret = softing_startstop(ndev, 0);
+	return ret;
+}
+
+static int softing_candev_set_mode(struct net_device *ndev, enum can_mode mode)
+{
+	int ret;
+
+	switch (mode) {
+	case CAN_MODE_START:
+		/* softing_startstop does close_candev() */
+		ret = softing_startstop(ndev, 1);
+		return ret;
+	case CAN_MODE_STOP:
+	case CAN_MODE_SLEEP:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+/*
+ * Softing device management helpers
+ */
+int softing_enable_irq(struct softing *card, int enable)
+{
+	int ret;
+
+	if (!card-&gt;irq.nr) {
+		return 0;
+	} else if (card-&gt;irq.requested &amp;&amp; !enable) {
+		free_irq(card-&gt;irq.nr, card);
+		card-&gt;irq.requested = 0;
+	} else if (!card-&gt;irq.requested &amp;&amp; enable) {
+		ret = request_threaded_irq(card-&gt;irq.nr,
+				(card-&gt;pdat-&gt;generation &gt;= 2) ?
+					softing_irq_v2 : softing_irq_v1,
+				softing_irq_thread, IRQF_SHARED,
+				dev_name(&amp;card-&gt;pdev-&gt;dev), card);
+		if (ret) {
+			dev_alert(&amp;card-&gt;pdev-&gt;dev,
+					&quot;request_threaded_irq(%u) failed\n&quot;,
+					card-&gt;irq.nr);
+			return ret;
+		}
+		card-&gt;irq.requested = 1;
+	}
+	return 0;
+}
+
+static void softing_card_shutdown(struct softing *card)
+{
+	int fw_up = 0;
+
+	if (mutex_lock_interruptible(&amp;card-&gt;fw.lock))
+		/* return -ERESTARTSYS */;
+	fw_up = card-&gt;fw.up;
+	card-&gt;fw.up = 0;
+
+	if (card-&gt;irq.requested &amp;&amp; card-&gt;irq.nr) {
+		free_irq(card-&gt;irq.nr, card);
+		card-&gt;irq.requested = 0;
+	}
+	if (fw_up) {
+		if (card-&gt;pdat-&gt;enable_irq)
+			card-&gt;pdat-&gt;enable_irq(card-&gt;pdev, 0);
+		softing_set_reset_dpram(card);
+		if (card-&gt;pdat-&gt;reset)
+			card-&gt;pdat-&gt;reset(card-&gt;pdev, 1);
+	}
+	mutex_unlock(&amp;card-&gt;fw.lock);
+}
+
+static __devinit int softing_card_boot(struct softing *card)
+{
+	int ret, j;
+	static const uint8_t stream[] = {
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, };
+	unsigned char back[sizeof(stream)];
+
+	if (mutex_lock_interruptible(&amp;card-&gt;fw.lock))
+		return -ERESTARTSYS;
+	if (card-&gt;fw.up) {
+		mutex_unlock(&amp;card-&gt;fw.lock);
+		return 0;
+	}
+	/* reset board */
+	if (card-&gt;pdat-&gt;enable_irq)
+		card-&gt;pdat-&gt;enable_irq(card-&gt;pdev, 1);
+	/* boot card */
+	softing_set_reset_dpram(card);
+	if (card-&gt;pdat-&gt;reset)
+		card-&gt;pdat-&gt;reset(card-&gt;pdev, 1);
+	for (j = 0; (j + sizeof(stream)) &lt; card-&gt;dpram_size;
+			j += sizeof(stream)) {
+
+		memcpy_toio(&amp;card-&gt;dpram[j], stream, sizeof(stream));
+		/* flush IO cache */
+		mb();
+		memcpy_fromio(back, &amp;card-&gt;dpram[j], sizeof(stream));
+
+		if (!memcmp(back, stream, sizeof(stream)))
+			continue;
+		/* memory is not equal */
+		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;dpram failed at 0x%04x\n&quot;, j);
+		ret = -EIO;
+		goto failed;
+	}
+	wmb();
+	/* load boot firmware */
+	ret = softing_load_fw(card-&gt;pdat-&gt;boot.fw, card, card-&gt;dpram,
+				card-&gt;dpram_size,
+				card-&gt;pdat-&gt;boot.offs - card-&gt;pdat-&gt;boot.addr);
+	if (ret &lt; 0)
+		goto failed;
+	/* load loader firmware */
+	ret = softing_load_fw(card-&gt;pdat-&gt;load.fw, card, card-&gt;dpram,
+				card-&gt;dpram_size,
+				card-&gt;pdat-&gt;load.offs - card-&gt;pdat-&gt;load.addr);
+	if (ret &lt; 0)
+		goto failed;
+
+	if (card-&gt;pdat-&gt;reset)
+		card-&gt;pdat-&gt;reset(card-&gt;pdev, 0);
+	softing_clr_reset_dpram(card);
+	ret = softing_bootloader_command(card, 0, &quot;card boot&quot;);
+	if (ret &lt; 0)
+		goto failed;
+	ret = softing_load_app_fw(card-&gt;pdat-&gt;app.fw, card);
+	if (ret &lt; 0)
+		goto failed;
+
+	ret = softing_chip_poweron(card);
+	if (ret &lt; 0)
+		goto failed;
+
+	card-&gt;fw.up = 1;
+	mutex_unlock(&amp;card-&gt;fw.lock);
+	return 0;
+failed:
+	card-&gt;fw.up = 0;
+	if (card-&gt;pdat-&gt;enable_irq)
+		card-&gt;pdat-&gt;enable_irq(card-&gt;pdev, 0);
+	softing_set_reset_dpram(card);
+	if (card-&gt;pdat-&gt;reset)
+		card-&gt;pdat-&gt;reset(card-&gt;pdev, 1);
+	mutex_unlock(&amp;card-&gt;fw.lock);
+	return ret;
+}
+
+/*
+ * netdev sysfs
+ */
+static ssize_t show_channel(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct net_device *ndev = to_net_dev(dev);
+	struct softing_priv *priv = netdev2softing(ndev);
+
+	return sprintf(buf, &quot;%i\n&quot;, priv-&gt;index);
+}
+
+static ssize_t show_chip(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct net_device *ndev = to_net_dev(dev);
+	struct softing_priv *priv = netdev2softing(ndev);
+
+	return sprintf(buf, &quot;%i\n&quot;, priv-&gt;chip);
+}
+
+static ssize_t show_output(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct net_device *ndev = to_net_dev(dev);
+	struct softing_priv *priv = netdev2softing(ndev);
+
+	return sprintf(buf, &quot;0x%02x\n&quot;, priv-&gt;output);
+}
+
+static ssize_t store_output(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct net_device *ndev = to_net_dev(dev);
+	struct softing_priv *priv = netdev2softing(ndev);
+	struct softing *card = priv-&gt;card;
+	unsigned long val;
+	int ret;
+
+	ret = strict_strtoul(buf, 0, &amp;val);
+	if (ret &lt; 0)
+		return ret;
+	val &amp;= 0xFF;
+
+	ret = mutex_lock_interruptible(&amp;card-&gt;fw.lock);
+	if (ret)
+		return -ERESTARTSYS;
+	if (netif_running(ndev)) {
+		mutex_unlock(&amp;card-&gt;fw.lock);
+		return -EBUSY;
+	}
+	priv-&gt;output = val;
+	mutex_unlock(&amp;card-&gt;fw.lock);
+	return count;
+}
+
+static const DEVICE_ATTR(channel, S_IRUGO, show_channel, NULL);
+static const DEVICE_ATTR(chip, S_IRUGO, show_chip, NULL);
+static const DEVICE_ATTR(output, S_IRUGO | S_IWUSR, show_output, store_output);
+
+static const struct attribute *const netdev_sysfs_attrs[] = {
+	&amp;dev_attr_channel.attr,
+	&amp;dev_attr_chip.attr,
+	&amp;dev_attr_output.attr,
+	NULL,
+};
+static const struct attribute_group netdev_sysfs_group = {
+	.name = NULL,
+	.attrs = (struct attribute **)netdev_sysfs_attrs,
+};
+
+static const struct net_device_ops softing_netdev_ops = {
+	.ndo_open = softing_netdev_open,
+	.ndo_stop = softing_netdev_stop,
+	.ndo_start_xmit	= softing_netdev_start_xmit,
+};
+
+static const struct can_bittiming_const softing_btr_const = {
+	.tseg1_min = 1,
+	.tseg1_max = 16,
+	.tseg2_min = 1,
+	.tseg2_max = 8,
+	.sjw_max = 4, /* overruled */
+	.brp_min = 1,
+	.brp_max = 32, /* overruled */
+	.brp_inc = 1,
+};
+
+
+static __devinit struct net_device *softing_netdev_create(struct softing *card,
+		uint16_t chip_id)
+{
+	struct net_device *netdev;
+	struct softing_priv *priv;
+
+	netdev = alloc_candev(sizeof(*priv), TX_ECHO_SKB_MAX);
+	if (!netdev) {
+		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;alloc_candev failed\n&quot;);
+		return NULL;
+	}
+	priv = netdev_priv(netdev);
+	priv-&gt;netdev = netdev;
+	priv-&gt;card = card;
+	memcpy(&amp;priv-&gt;btr_const, &amp;softing_btr_const, sizeof(priv-&gt;btr_const));
+	priv-&gt;btr_const.brp_max = card-&gt;pdat-&gt;max_brp;
+	priv-&gt;btr_const.sjw_max = card-&gt;pdat-&gt;max_sjw;
+	priv-&gt;can.bittiming_const = &amp;priv-&gt;btr_const;
+	priv-&gt;can.clock.freq = 8000000;
+	priv-&gt;chip = chip_id;
+	priv-&gt;output = softing_default_output(netdev);
+	SET_NETDEV_DEV(netdev, &amp;card-&gt;pdev-&gt;dev);
+
+	netdev-&gt;flags |= IFF_ECHO;
+	netdev-&gt;netdev_ops = &amp;softing_netdev_ops;
+	priv-&gt;can.do_set_mode = softing_candev_set_mode;
+	priv-&gt;can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;
+
+	return netdev;
+}
+
+static __devinit int softing_netdev_register(struct net_device *netdev)
+{
+	int ret;
+
+	netdev-&gt;sysfs_groups[0] = &amp;netdev_sysfs_group;
+	ret = register_candev(netdev);
+	if (ret) {
+		dev_alert(&amp;netdev-&gt;dev, &quot;register failed\n&quot;);
+		return ret;
+	}
+	return 0;
+}
+
+static void softing_netdev_cleanup(struct net_device *netdev)
+{
+	unregister_candev(netdev);
+	free_candev(netdev);
+}
+
+/*
+ * sysfs for Platform device
+ */
+#define DEV_ATTR_RO(name, member) \
+static ssize_t show_##name(struct device *dev, \
+		struct device_attribute *attr, char *buf) \
+{ \
+	struct softing *card = platform_get_drvdata(to_platform_device(dev)); \
+	return sprintf(buf, &quot;%u\n&quot;, card-&gt;member); \
+} \
+static DEVICE_ATTR(name, 0444, show_##name, NULL)
+
+#define DEV_ATTR_RO_STR(name, member) \
+static ssize_t show_##name(struct device *dev, \
+		struct device_attribute *attr, char *buf) \
+{ \
+	struct softing *card = platform_get_drvdata(to_platform_device(dev)); \
+	return sprintf(buf, &quot;%s\n&quot;, card-&gt;member); \
+} \
+static DEVICE_ATTR(name, 0444, show_##name, NULL)
+
+DEV_ATTR_RO(serial, id.serial);
+DEV_ATTR_RO_STR(firmware, pdat-&gt;app.fw);
+DEV_ATTR_RO(firmware_version, id.fw_version);
+DEV_ATTR_RO_STR(hardware, pdat-&gt;name);
+DEV_ATTR_RO(hardware_version, id.hw_version);
+DEV_ATTR_RO(license, id.license);
+DEV_ATTR_RO(frequency, id.freq);
+DEV_ATTR_RO(txpending, tx.pending);
+
+static struct attribute *softing_pdev_attrs[] = {
+	&amp;dev_attr_serial.attr,
+	&amp;dev_attr_firmware.attr,
+	&amp;dev_attr_firmware_version.attr,
+	&amp;dev_attr_hardware.attr,
+	&amp;dev_attr_hardware_version.attr,
+	&amp;dev_attr_license.attr,
+	&amp;dev_attr_frequency.attr,
+	&amp;dev_attr_txpending.attr,
+	NULL,
+};
+
+static const struct attribute_group softing_pdev_group = {
+	.name = NULL,
+	.attrs = softing_pdev_attrs,
+};
+
+/*
+ * platform driver
+ */
+static __devexit int softing_pdev_remove(struct platform_device *pdev)
+{
+	struct softing *card = platform_get_drvdata(pdev);
+	int j;
+
+	/* first, disable card*/
+	softing_card_shutdown(card);
+
+	for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
+		if (!card-&gt;net[j])
+			continue;
+		softing_netdev_cleanup(card-&gt;net[j]);
+		card-&gt;net[j] = NULL;
+	}
+	sysfs_remove_group(&amp;pdev-&gt;dev.kobj, &amp;softing_pdev_group);
+
+	iounmap(card-&gt;dpram);
+	kfree(card);
+	return 0;
+}
+
+static __devinit int softing_pdev_probe(struct platform_device *pdev)
+{
+	const struct softing_platform_data *pdat = pdev-&gt;dev.platform_data;
+	struct softing *card;
+	struct net_device *netdev;
+	struct softing_priv *priv;
+	struct resource *pres;
+	int ret;
+	int j;
+
+	if (!pdat) {
+		dev_warn(&amp;pdev-&gt;dev, &quot;no platform data\n&quot;);
+		return -EINVAL;
+	}
+	if (pdat-&gt;nbus &gt; ARRAY_SIZE(card-&gt;net)) {
+		dev_warn(&amp;pdev-&gt;dev, &quot;%u nets??\n&quot;, pdat-&gt;nbus);
+		return -EINVAL;
+	}
+
+	card = kzalloc(sizeof(*card), GFP_KERNEL);
+	if (!card)
+		return -ENOMEM;
+	card-&gt;pdat = pdat;
+	card-&gt;pdev = pdev;
+	platform_set_drvdata(pdev, card);
+	mutex_init(&amp;card-&gt;fw.lock);
+	spin_lock_init(&amp;card-&gt;spin);
+
+	ret = -EINVAL;
+	pres = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!pres)
+		goto platform_resource_failed;;
+	card-&gt;dpram_phys = pres-&gt;start;
+	card-&gt;dpram_size = pres-&gt;end - pres-&gt;start + 1;
+	card-&gt;dpram = ioremap_nocache(card-&gt;dpram_phys, card-&gt;dpram_size);
+	if (!card-&gt;dpram) {
+		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;dpram ioremap failed\n&quot;);
+		goto ioremap_failed;
+	}
+
+	pres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (pres)
+		card-&gt;irq.nr = pres-&gt;start;
+
+	/* reset card */
+	ret = softing_card_boot(card);
+	if (ret &lt; 0) {
+		dev_alert(&amp;pdev-&gt;dev, &quot;failed to boot\n&quot;);
+		goto boot_failed;
+	}
+
+	/* only now, the chip's are known */
+	card-&gt;id.freq = card-&gt;pdat-&gt;freq;
+
+	ret = sysfs_create_group(&amp;pdev-&gt;dev.kobj, &amp;softing_pdev_group);
+	if (ret &lt; 0) {
+		dev_alert(&amp;card-&gt;pdev-&gt;dev, &quot;sysfs failed\n&quot;);
+		goto sysfs_failed;
+	}
+
+	ret = -ENOMEM;
+	for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
+		card-&gt;net[j] = netdev =
+			softing_netdev_create(card, card-&gt;id.chip[j]);
+		if (!netdev) {
+			dev_alert(&amp;pdev-&gt;dev, &quot;failed to make can[%i]&quot;, j);
+			goto netdev_failed;
+		}
+		priv = netdev_priv(card-&gt;net[j]);
+		priv-&gt;index = j;
+		ret = softing_netdev_register(netdev);
+		if (ret) {
+			free_candev(netdev);
+			card-&gt;net[j] = NULL;
+			dev_alert(&amp;card-&gt;pdev-&gt;dev,
+					&quot;failed to register can[%i]\n&quot;, j);
+			goto netdev_failed;
+		}
+	}
+	dev_info(&amp;card-&gt;pdev-&gt;dev, &quot;%s ready.\n&quot;, card-&gt;pdat-&gt;name);
+	return 0;
+
+netdev_failed:
+	for (j = 0; j &lt; ARRAY_SIZE(card-&gt;net); ++j) {
+		if (!card-&gt;net[j])
+			continue;
+		softing_netdev_cleanup(card-&gt;net[j]);
+	}
+	sysfs_remove_group(&amp;pdev-&gt;dev.kobj, &amp;softing_pdev_group);
+sysfs_failed:
+	softing_card_shutdown(card);
+boot_failed:
+	iounmap(card-&gt;dpram);
+ioremap_failed:
+platform_resource_failed:
+	kfree(card);
+	return ret;
+}
+
+static struct platform_driver softing_driver = {
+	.driver = {
+		.name = &quot;softing&quot;,
+		.owner = THIS_MODULE,
+	},
+	.probe = softing_pdev_probe,
+	.remove = __devexit_p(softing_pdev_remove),
+};
+
+MODULE_ALIAS(&quot;platform:softing&quot;);
+
+static int __init softing_start(void)
+{
+	return platform_driver_register(&amp;softing_driver);
+}
+
+static void __exit softing_stop(void)
+{
+	platform_driver_unregister(&amp;softing_driver);
+}
+
+module_init(softing_start);
+module_exit(softing_stop);
+
+MODULE_DESCRIPTION(&quot;Softing DPRAM CAN driver&quot;);
+MODULE_AUTHOR(&quot;Kurt Van Dijck &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kurt.van.dijck at eia.be</A>&gt;&quot;);
+MODULE_LICENSE(&quot;GPL v2&quot;);
diff --git a/drivers/net/can/softing/softing_platform.h b/drivers/net/can/softing/softing_platform.h
new file mode 100644
index 0000000..d2471cd
--- /dev/null
+++ b/drivers/net/can/softing/softing_platform.h
@@ -0,0 +1,41 @@
+
+#include &lt;linux/platform_device.h&gt;
+
+#ifndef _SOFTING_DEVICE_H_
+#define _SOFTING_DEVICE_H_
+
+/* softing firmware directory prefix */
+#define fw_dir &quot;softing-4.6/&quot;
+
+struct softing_platform_data {
+	unsigned int manf;
+	unsigned int prod;
+	/*
+	 * generation
+	 * 1st with NEC or SJA1000
+	 * 8bit, exclusive interrupt, ...
+	 * 2nd only SJA1000
+	 * 16bit, shared interrupt
+	 */
+	int generation;
+	int nbus; /* # busses on device */
+	unsigned int freq; /* operating frequency in Hz */
+	unsigned int max_brp;
+	unsigned int max_sjw;
+	unsigned long dpram_size;
+	const char *name;
+	struct {
+		unsigned long offs;
+		unsigned long addr;
+		const char *fw;
+	} boot, load, app;
+	/*
+	 * reset() function
+	 * bring pdev in or out of reset, depending on value
+	 */
+	int (*reset)(struct platform_device *pdev, int value);
+	int (*enable_irq)(struct platform_device *pdev, int value);
+};
+
+#endif
+

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005350.html">[PATCH net-next-2.6 v3 0/2] can: add driver for Softing card
</A></li>
	<LI>Next message: <A HREF="005352.html">[PATCH net-next-2.6 v3 2/2] can: add driver for Softing card
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5351">[ date ]</a>
              <a href="thread.html#5351">[ thread ]</a>
              <a href="subject.html#5351">[ subject ]</a>
              <a href="author.html#5351">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
