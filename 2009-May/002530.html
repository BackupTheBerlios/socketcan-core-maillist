<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH] Driver for esd CAN cards
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20Driver%20for%20esd%20CAN%20cards&In-Reply-To=%3C4A113B5A.2060608%40grandegger.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002529.html">
   <LINK REL="Next"  HREF="002533.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH] Driver for esd CAN cards</H1>
    <B>Wolfgang Grandegger</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20Driver%20for%20esd%20CAN%20cards&In-Reply-To=%3C4A113B5A.2060608%40grandegger.com%3E"
       TITLE="[PATCH] Driver for esd CAN cards">wg at grandegger.com
       </A><BR>
    <I>Mon May 18 12:41:30 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002529.html">[PATCH] Driver for esd CAN cards
</A></li>
        <LI>Next message: <A HREF="002533.html">[PATCH] Driver for esd CAN cards
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2530">[ date ]</a>
              <a href="thread.html#2530">[ thread ]</a>
              <a href="subject.html#2530">[ subject ]</a>
              <a href="author.html#2530">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Thomas,

unfortunately, your patch does not apply properly to the current SVN
trunk revision 975. Makefile and Kconfig fails and it also does not
compile for my test system (MPC5200) with Linux 2.6.30-rc3:

  CC [M]  /temp/socketcan/trunk/kernel/2.6/drivers/net/can/esd_pci331.o
/temp/socketcan/trunk/kernel/2.6/drivers/net/can/esd_pci331.c:133:
error: 'esd331_open' undeclared here (not in a function)
/temp/socketcan/trunk/kernel/2.6/drivers/net/can/esd_pci331.c:134:
error: 'esd331_close' undeclared here (not in a function)
/temp/socketcan/trunk/kernel/2.6/drivers/net/can/esd_pci331.c:135:
error: 'esd331_start_xmit' undeclared here (not in a function)
/temp/socketcan/trunk/kernel/2.6/drivers/net/can/esd_pci331.c: In
function 'esd331_read_feat':
/temp/socketcan/trunk/kernel/2.6/drivers/net/can/esd_pci331.c:359:
warning: comparison is always true due to limited range of data type
/temp/socketcan/trunk/kernel/2.6/drivers/net/can/esd_pci331.c:373:
warning: comparison is always true due to limited range of data type

More inline:

Thomas K&#246;rper wrote:
&gt;<i> This patch adds support for the PCI/331, CPCI/331 and PMC/331 CAN
</I>&gt;<i> interface cards from electronic system design gmbh.
</I>&gt;<i> 
</I>&gt;<i> To set the baudrate by sysfs file, recently posted patch by Wolfgang
</I>&gt;<i> is needed. See thread &quot;New PCI driver: preferred way to set baudrate?&quot;
</I>
I will apply it a.s.a.p.

&gt;<i> 
</I>&gt;<i> 	Thomas
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Signed-off-by: thomas.koerper &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">thomas.koerper at esd.eu</A>&gt;
</I>&gt;<i> ---
</I>&gt;<i> Index: kernel/2.6/Makefile
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- kernel/2.6/Makefile	(revision 973)
</I>&gt;<i> +++ kernel/2.6/Makefile	(working copy)
</I>&gt;<i> @@ -11,6 +11,8 @@
</I>&gt;<i>   export CONFIG_CAN_SJA1000=m
</I>&gt;<i>   export CONFIG_CAN_SJA1000_PLATFORM=m
</I>&gt;<i>   export CONFIG_CAN_EMS_PCI=m
</I>&gt;<i> +export CONFIG_CAN_ESD_PCI=m
</I>&gt;<i> +export CONFIG_CAN_ESD_331=m
</I>&gt;<i>   export CONFIG_CAN_EMS_PCMCIA=m
</I>
Why you put your definitions between the one for the EMS cards?

&gt;<i>   export CONFIG_CAN_PIPCAN=m
</I>&gt;<i>   export CONFIG_CAN_SOFTING=m
</I>&gt;<i> Index: kernel/2.6/drivers/net/can/Kconfig
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- kernel/2.6/drivers/net/can/Kconfig	(revision 973)
</I>&gt;<i> +++ kernel/2.6/drivers/net/can/Kconfig	(working copy)
</I>&gt;<i> @@ -115,6 +115,13 @@
</I>&gt;<i>   	  CAN-PCIe2000 (PCI Express) and CAN-PCI104/200 (PCI104)
</I>&gt;<i>   	  from the esd electronic system design gmbh (<A HREF="http://www.esd.eu">http://www.esd.eu</A>).
</I>&gt;<i> 
</I>&gt;<i> +config CAN_ESD_PCI331
</I>&gt;<i> +	tristate &quot;ESD CAN 331 Cards&quot;
</I>&gt;<i> +	depends on PCI &amp;&amp; CAN_SJA1000
</I>
Why does it depend on CAN_SJA1000?

&gt;<i> +	---help---
</I>&gt;<i> +	  This driver supports the PCI/331, CPCI/331 and PMC/331 CAN cards
</I>&gt;<i> +	  from the esd system design gmbh (<A HREF="http://www.esd.eu">http://www.esd.eu</A>).
</I>&gt;<i> +
</I>&gt;<i>   config CAN_IXXAT_PCI
</I>&gt;<i>   	tristate &quot;IXXAT PCI Card&quot;
</I>&gt;<i>   	depends on PCI &amp;&amp; CAN_SJA1000
</I>&gt;<i> Index: kernel/2.6/drivers/net/can/Makefile
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- kernel/2.6/drivers/net/can/Makefile	(revision 973)
</I>&gt;<i> +++ kernel/2.6/drivers/net/can/Makefile	(working copy)
</I>&gt;<i> @@ -16,6 +16,7 @@
</I>&gt;<i>   export CONFIG_CAN_SJA1000=m
</I>&gt;<i>   export CONFIG_CAN_SJA1000_PLATFORM=m
</I>&gt;<i>   export CONFIG_CAN_EMS_PCI=m
</I>&gt;<i> +export CONFIG_CAN_ESD_PCI331=m
</I>&gt;<i>   export CONFIG_CAN_EMS_PCMCIA=m
</I>&gt;<i>   export CONFIG_CAN_PIPCAN=m
</I>&gt;<i>   export CONFIG_CAN_SOFTING=m
</I>&gt;<i> @@ -39,6 +40,7 @@
</I>&gt;<i>   obj-$(CONFIG_CAN_SOFTING)	+= softing/
</I>&gt;<i>   obj-$(CONFIG_CAN_MSCAN)		+= mscan/
</I>&gt;<i>   obj-$(CONFIG_CAN_AT91)		+= at91_can.o
</I>&gt;<i> +obj-$(CONFIG_CAN_ESD_PCI331)	+= esd_pci331.o
</I>&gt;<i>   obj-$(CONFIG_CAN_SJA1000_OLD)	+= old/sja1000/
</I>&gt;<i>   obj-$(CONFIG_CAN_I82527_OLD)	+= old/i82527/
</I>&gt;<i>   obj-$(CONFIG_CAN_MSCAN_OLD)	+= old/mscan/
</I>&gt;<i> Index: kernel/2.6/drivers/net/can/esd_pci331.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- kernel/2.6/drivers/net/can/esd_pci331.c	(revision 0)
</I>&gt;<i> +++ kernel/2.6/drivers/net/can/esd_pci331.c	(revision 0)
</I>&gt;<i> @@ -0,0 +1,949 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * Copyright (C) 2009 Thomas K&#246;rper &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">thomas.koerper at esd.eu</A>&gt;, esd gmbhk&#246;r
</I>&gt;<i> + * derived from kernel/2.6/drivers/net/can/sja1000/esd_pci.c,
</I>&gt;<i> + * * Copyright (C) 2007 Wolfgang Grandegger &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">wg at grandegger.com</A>&gt;
</I>&gt;<i> + * * Copyright (C) 2008 Sascha Hauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">s.hauer at pengutronix.de</A>&gt;, Pengutronix
</I>&gt;<i> + * * Copyright (C) 2009 Matthias Fuchs &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">matthias.fuchs at esd.eu</A>&gt;, esd gmbh
</I>&gt;<i> + * and kernel/2.6/drivers/net/can/at91_can.c,
</I>&gt;<i> + * * Copyright (C) 2007 by Hans J. Koch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">hjk at linutronix.de</A>&gt;
</I>&gt;<i> + * * Copyright (C) 2008 by Marc Kleine-Budde &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kernel at pengutronix.de</A>
</I>&gt;<i> + *
</I>&gt;<i> + * This program is free software; you can redistribute it and/or modify
</I>&gt;<i> + * it under the terms of the version 2 of the GNU General Public License
</I>&gt;<i> + * as published by the Free Software Foundation
</I>&gt;<i> + *
</I>&gt;<i> + * This program is distributed in the hope that it will be useful,
</I>&gt;<i> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
</I>&gt;<i> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
</I>&gt;<i> + * GNU General Public License for more details.
</I>&gt;<i> + *
</I>&gt;<i> + * You should have received a copy of the GNU General Public License
</I>&gt;<i> + * along with this program; if not, write to the Free Software Foundation,
</I>&gt;<i> + * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/interrupt.h&gt;
</I>&gt;<i> +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> +#include &lt;linux/module.h&gt;
</I>&gt;<i> +#include &lt;linux/kernel.h&gt;
</I>&gt;<i> +#include &lt;linux/if_arp.h&gt;
</I>&gt;<i> +#include &lt;linux/skbuff.h&gt;
</I>&gt;<i> +#include &lt;linux/types.h&gt;
</I>&gt;<i> +#include &lt;linux/errno.h&gt;
</I>&gt;<i> +#include &lt;linux/init.h&gt;
</I>&gt;<i> +#include &lt;linux/io.h&gt;
</I>&gt;<i> +#include &lt;linux/byteorder/generic.h&gt;
</I>&gt;<i> +#include &lt;linux/pci.h&gt;
</I>&gt;<i> +#include &lt;linux/pci_ids.h&gt;
</I>&gt;<i> +#include &lt;linux/can.h&gt;
</I>&gt;<i> +#include &lt;linux/can/error.h&gt;
</I>&gt;<i> +#include &lt;linux/can/dev.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#define DRV_NAME &quot;esd_pci331&quot;
</I>&gt;<i> +
</I>&gt;<i> +MODULE_AUTHOR(&quot;Thomas K&#246;rper &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">thomas.koerper at esd.eu</A>&gt;&quot;);
</I>
Please avoid german &quot;Umlaute&quot;.

&gt;<i> +MODULE_LICENSE(&quot;GPL v2&quot;);
</I>&gt;<i> +MODULE_DESCRIPTION(&quot;LLCF/socketcan '&quot; DRV_NAME &quot;' network device driver&quot;);
</I>
The name LLCF is not used any more. I would prefer something like:

  MODULE_DESCRIPTION(&quot;Driver for the ESD PCI33&quot;);

&gt;<i> +MODULE_DEVICE_TABLE(pci, esd331_pci_tbl);
</I>&gt;<i> +MODULE_SUPPORTED_DEVICE(&quot;esd CAN-PCI/331, CAN-CPCI/331, CAN-PMC/331&quot;);
</I>&gt;<i> +
</I>&gt;<i> +#ifndef PCI_DEVICE_ID_PLX_9050
</I>&gt;<i> +# define PCI_DEVICE_ID_PLX_9050 0x9050
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +#define ESD_PCI_SUB_SYS_ID_PCI331 0x0001
</I>&gt;<i> +#define ESD_PCI_SUB_SYS_ID_PMC331 0x000C
</I>&gt;<i> +
</I>&gt;<i> +#define ESD331_MAX_CAN 2 /* Maximum number of interfaces supported per card */
</I>&gt;<i> +#define ESD331_DPRSIZE 1024 /* 331's fifo size. Don't change! */
</I>&gt;<i> +#define ESD331_MAX_INTERRUPT_WORK 8 /* Max. messages to handle per interrupt */
</I>&gt;<i> +
</I>&gt;<i> +#define ESD331_I20_BCAN		0
</I>&gt;<i> +#define ESD331_I20_ENABLE	1
</I>&gt;<i> +#define ESD331_I20_BAUD		4
</I>&gt;<i> +#define ESD331_I20_TXDONE	5
</I>&gt;<i> +#define ESD331_I20_TXTOUT	12
</I>&gt;<i> +#define ESD331_I20_ERROR	13
</I>&gt;<i> +#define ESD331_I20_BOARD	14
</I>&gt;<i> +#define ESD331_I20_EX_BCAN	15
</I>&gt;<i> +#define ESD331_I20_EX_TXDONE	16
</I>&gt;<i> +#define ESD331_I20_EX_TXTOUT	17
</I>&gt;<i> +#define ESD331_I20_BOARD2	20
</I>&gt;<i> +#define ESD331_I20_FAST		21
</I>&gt;<i> +
</I>&gt;<i> +static struct pci_device_id esd331_pci_tbl[] = {
</I>&gt;<i> +		{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9050,
</I>&gt;<i> +		PCI_VENDOR_ID_ESDGMBH, ESD_PCI_SUB_SYS_ID_PCI331},
</I>&gt;<i> +		{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030,
</I>&gt;<i> +		PCI_VENDOR_ID_ESDGMBH, ESD_PCI_SUB_SYS_ID_PMC331},
</I>&gt;<i> +		{0, }
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct esd331_can_msg {
</I>&gt;<i> +	u8 cmmd;
</I>&gt;<i> +	u8 net;
</I>&gt;<i> +	s16 id;
</I>&gt;<i> +	s16 len;
</I>&gt;<i> +	u8 data[8];
</I>&gt;<i> +	u16 x1;
</I>&gt;<i> +	u16 x2;
</I>&gt;<i> +	u16 x3;
</I>&gt;<i> +} __attribute__((packed));
</I>&gt;<i> +#define ESD331_CM_SSIZE (sizeof(struct esd331_can_msg) / sizeof(u16))
</I>&gt;<i> +
</I>&gt;<i> +struct esd331_idp {
</I>&gt;<i> +	u8 dummy[16];
</I>&gt;<i> +	u8 buffer[4];
</I>&gt;<i> +} __attribute__((packed));
</I>&gt;<i> +
</I>&gt;<i> +struct esd331_dpr {
</I>&gt;<i> +	char magic[16];
</I>&gt;<i> +	u16 rx_in;
</I>&gt;<i> +	u16 dummy1;
</I>&gt;<i> +	u16 rx_ou;
</I>&gt;<i> +	u16 dummy2;
</I>&gt;<i> +	struct esd331_can_msg rx_buff[ESD331_DPRSIZE];
</I>&gt;<i> +	u16 tx_in;
</I>&gt;<i> +	u16 dummy3;
</I>&gt;<i> +	u16 tx_ou;
</I>&gt;<i> +	u16 dummy4;
</I>&gt;<i> +	struct esd331_can_msg tx_buff[ESD331_DPRSIZE];
</I>&gt;<i> +} __attribute__((packed));
</I>&gt;<i> +
</I>&gt;<i> +struct esd331_pci {
</I>&gt;<i> +	struct pci_dev *pci_dev;
</I>&gt;<i> +	struct net_device *dev[ESD331_MAX_CAN];
</I>&gt;<i> +	void __iomem *conf_addr;
</I>&gt;<i> +	void __iomem *base_addr1;
</I>&gt;<i> +	void __iomem *base_addr2;
</I>&gt;<i> +	spinlock_t irq_lock; /* locks access to card's fifo */
</I>&gt;<i> +	struct esd331_dpr *dpr;
</I>&gt;<i> +	int eff_supp;
</I>&gt;<i> +	int net_count;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct esd331_priv {
</I>&gt;<i> +	struct can_priv can; /* must be the first member! */
</I>&gt;<i> +	struct esd331_pci *board;
</I>&gt;<i> +	u8 boardsNet;
</I>
Using upper-case letters is unusual. Please use lower-case letters and
the &quot;_&quot; as word separator.

&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
</I>&gt;<i> +static const struct net_device_ops esd331_netdev_ops = {
</I>&gt;<i> +	.ndo_open = esd331_open,
</I>&gt;<i> +	.ndo_stop = esd331_close,
</I>&gt;<i> +	.ndo_start_xmit = esd331_start_xmit,
</I>&gt;<i> +};
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +static void esd331_reset(void *pci331_confspace)
</I>&gt;<i> +{
</I>&gt;<i> +	unsigned long data;
</I>&gt;<i> +
</I>&gt;<i> +	data = readl((u8 *)pci331_confspace + 0x50);
</I>&gt;<i> +	data |= 0x40000010;
</I>&gt;<i> +	writel(data, (u8 *)pci331_confspace + 0x50);
</I>&gt;<i> +	msleep(10);
</I>
That's long...

&gt;<i> +
</I>&gt;<i> +	data = readl((u8 *)pci331_confspace + 0x50);
</I>&gt;<i> +	data &amp;= ~0x40000028;
</I>&gt;<i> +	writel(data, (u8 *)pci331_confspace + 0x50);
</I>&gt;<i> +
</I>&gt;<i> +	msleep(3500);
</I>
... and that takes ages ;-). Is this a typo or is the hardware/firmware
really that slow ;-(. Anyhow, msleep() does not busy sleep but calls
schedule_timeout_uninterruptible(),

&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static struct esd331_dpr *esd331_initPointer(void *pci331_space2)
</I>&gt;<i> +{
</I>&gt;<i> +	unsigned long data;
</I>&gt;<i> +	u8 *ptr;
</I>&gt;<i> +	struct esd331_idp *idp;
</I>&gt;<i> +
</I>&gt;<i> +	ptr = (u8 *)pci331_space2 + 0x846;
</I>&gt;<i> +	data = readb(ptr++);
</I>&gt;<i> +	data = (data &lt;&lt; 8) + readb(ptr++);
</I>&gt;<i> +	data = (data &lt;&lt; 8) + readb(ptr++);
</I>&gt;<i> +	data = (data &lt;&lt; 8) + readb(ptr++);
</I>&gt;<i> +
</I>&gt;<i> +	idp = (struct esd331_idp *)((u8 *)pci331_space2 + data);
</I>&gt;<i> +	data = idp-&gt;buffer[0];
</I>&gt;<i> +	data = (data &lt;&lt; 8) + idp-&gt;buffer[1];
</I>&gt;<i> +	data = (data &lt;&lt; 8) + idp-&gt;buffer[2];
</I>&gt;<i> +	data = (data &lt;&lt; 8) + idp-&gt;buffer[3];
</I>&gt;<i> +
</I>&gt;<i> +	return (struct esd331_dpr *)((u8 *)pci331_space2 + data);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void esd331_enableIRQ(void *pci331_confspace)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 data;
</I>&gt;<i> +
</I>&gt;<i> +	data = readl((u8 *)pci331_confspace + 0x4c);
</I>&gt;<i> +	data |= 0x00000041;
</I>&gt;<i> +	writel(data, (u8 *)pci331_confspace + 0x4c);
</I>
In general, the correct type for read[lwb} and write[lwb] is
&quot;void __iomem *&quot;:

        void __iomem *addr = pci331_confspace + 0x4c;

And it would also be nice to define meaningful macros for the various
offsets.

&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void esd331_disableIRQ(void *pci331_confspace)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 data;
</I>&gt;<i> +
</I>&gt;<i> +	data = readl((u8 *)pci331_confspace + 0x4c);
</I>&gt;<i> +	data &amp;= ~0x00000041;
</I>&gt;<i> +	writel(data, (u8 *)pci331_confspace + 0x4c);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd331_write(struct esd331_can_msg *mesg, struct esd331_pci *board)
</I>&gt;<i> +{
</I>&gt;<i> +	u16 in;
</I>&gt;<i> +	u16 in_new;
</I>&gt;<i> +	u16 out;
</I>&gt;<i> +	unsigned long irq_flags;
</I>&gt;<i> +	int err = -1;
</I>
Please use an appropriate error code, e.g. -EIO. And what does it mean
when the write fails? Isn't it a fatal error?

&gt;<i> +	int i;
</I>&gt;<i> +
</I>&gt;<i> +	spin_lock_irqsave(&amp;board-&gt;irq_lock, irq_flags);
</I>&gt;<i> +
</I>&gt;<i> +	out = be16_to_cpu(readw(&amp;board-&gt;dpr-&gt;rx_ou));
</I>&gt;<i> +	in = be16_to_cpu(readw(&amp;board-&gt;dpr-&gt;rx_in));
</I>&gt;<i> +	in_new = (in + 1) % ESD331_DPRSIZE;
</I>&gt;<i> +
</I>&gt;<i> +	if (in_new != out) {
</I>&gt;<i> +		u16 *ptr1;
</I>&gt;<i> +		u16 *ptr2;
</I>&gt;<i> +		ptr1 = (u16 *)mesg;
</I>&gt;<i> +		ptr2 = (u16 *)&amp;board-&gt;dpr-&gt;rx_buff[in];
</I>&gt;<i> +		for (i = 0; i &lt; ESD331_CM_SSIZE; i++)
</I>&gt;<i> +			writew(*ptr1++, ptr2++);
</I>&gt;<i> +
</I>&gt;<i> +		in_new = cpu_to_be16(in_new);
</I>&gt;<i> +		wmb();
</I>&gt;<i> +		writew(in_new, &amp;board-&gt;dpr-&gt;rx_in);
</I>&gt;<i> +
</I>&gt;<i> +		err = 0;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	spin_unlock_irqrestore(&amp;board-&gt;irq_lock, irq_flags);
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd331_read(struct esd331_can_msg *mesg, struct esd331_pci *board)
</I>&gt;<i> +{
</I>&gt;<i> +	u16 in;
</I>&gt;<i> +	u16 out;
</I>&gt;<i> +	unsigned long irq_flags;
</I>&gt;<i> +	int err = -1;
</I>
The same here.

&gt;<i> +
</I>&gt;<i> +	spin_lock_irqsave(&amp;board-&gt;irq_lock, irq_flags);
</I>&gt;<i> +
</I>&gt;<i> +	out = be16_to_cpu(readw(&amp;board-&gt;dpr-&gt;tx_ou));
</I>&gt;<i> +	in = be16_to_cpu(readw(&amp;board-&gt;dpr-&gt;tx_in));
</I>&gt;<i> +
</I>&gt;<i> +	if (in != out) {
</I>&gt;<i> +		u16 *ptr1;
</I>&gt;<i> +		u16 *ptr2;
</I>&gt;<i> +		int ll;
</I>&gt;<i> +		ptr1 = (u16 *)mesg;
</I>&gt;<i> +		ptr2 = (u16 *)&amp;board-&gt;dpr-&gt;tx_buff[out];
</I>&gt;<i> +		for (ll = 0; ll &lt; ESD331_CM_SSIZE; ll++)
</I>&gt;<i> +			*ptr1++ = readw(ptr2++);
</I>&gt;<i> +
</I>&gt;<i> +		out++;
</I>&gt;<i> +		out %= ESD331_DPRSIZE;
</I>&gt;<i> +
</I>&gt;<i> +		wmb();
</I>&gt;<i> +		writew(cpu_to_be16(out), &amp;board-&gt;dpr-&gt;tx_ou);
</I>&gt;<i> +
</I>&gt;<i> +		mesg-&gt;id = be16_to_cpu(mesg-&gt;id);
</I>&gt;<i> +		mesg-&gt;len = be16_to_cpu(mesg-&gt;len);
</I>&gt;<i> +		mesg-&gt;x1 = be16_to_cpu(mesg-&gt;x1);
</I>&gt;<i> +		mesg-&gt;x2 = be16_to_cpu(mesg-&gt;x2);
</I>&gt;<i> +		mesg-&gt;x3 = be16_to_cpu(mesg-&gt;x3);
</I>&gt;<i> +
</I>&gt;<i> +		err = 0;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	spin_unlock_irqrestore(&amp;board-&gt;irq_lock, irq_flags);
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd331_send(struct esd331_pci *board, u8 pci331net, unsigned long id,
</I>&gt;<i> +					int eff, int rtr, u16 dlc, u8 *data)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd331_can_msg msg;
</I>&gt;<i> +	int l;
</I>
A single &quot;l&quot; looks like a &quot;1&quot; and can be very confusing, e.g.:

  data[l]
  data[1]

Did you realize the difference? &quot;len&quot; is much better readable and less
error-prone.

&gt;<i> +	int res;
</I>&gt;<i> +
</I>&gt;<i> +	memset(&amp;msg, 0, sizeof(msg));
</I>&gt;<i> +
</I>&gt;<i> +	if (eff) {
</I>&gt;<i> +		msg.cmmd = ESD331_I20_EX_BCAN;
</I>&gt;<i> +		msg.id = cpu_to_be16((id &gt;&gt; 16) &amp; 0x1fff);
</I>&gt;<i> +		msg.x2 = cpu_to_be16(id);
</I>&gt;<i> +	} else {
</I>&gt;<i> +		msg.cmmd = ESD331_I20_BCAN;
</I>&gt;<i> +		msg.id = cpu_to_be16(id);
</I>&gt;<i> +	}
</I>&gt;<i> +	msg.net = pci331net;
</I>&gt;<i> +	msg.len = cpu_to_be16(rtr ? dlc | 0x10 : dlc);
</I>&gt;<i> +
</I>&gt;<i> +	l = (dlc &lt; 8) ? dlc : 8;
</I>&gt;<i> +	while (l--)
</I>&gt;<i> +		msg.data[l] = data[l];
</I>&gt;<i> +
</I>&gt;<i> +	res = esd331_write(&amp;msg, board);
</I>&gt;<i> +
</I>&gt;<i> +	return res;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd331_write_allid(u8 net, struct esd331_pci *board)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd331_can_msg mesg;
</I>&gt;<i> +	u16 id;
</I>&gt;<i> +
</I>&gt;<i> +	memset(&amp;mesg, 0, sizeof(mesg));
</I>&gt;<i> +
</I>&gt;<i> +	mesg.cmmd = ESD331_I20_ENABLE;
</I>&gt;<i> +	mesg.net = net;
</I>&gt;<i> +
</I>&gt;<i> +	for (id = 0; id &lt; 2048; id++) {
</I>&gt;<i> +		int retryCount = 5;
</I>&gt;<i> +		mesg.id = cpu_to_be16(id);
</I>&gt;<i> +
</I>&gt;<i> +		while (esd331_write(&amp;mesg, board) &amp;&amp; (retryCount--))
</I>&gt;<i> +			msleep(1);
</I>&gt;<i> +
</I>&gt;<i> +		if (retryCount == 0)
</I>&gt;<i> +			return -1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd331_write_fast(struct esd331_pci *board)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd331_can_msg mesg;
</I>&gt;<i> +
</I>&gt;<i> +	memset(&amp;mesg, 0, sizeof(mesg));
</I>&gt;<i> +	mesg.cmmd = ESD331_I20_FAST;
</I>&gt;<i> +
</I>&gt;<i> +	return esd331_write(&amp;mesg, board);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd331_write_baud(u8 pci331net, int index, struct esd331_pci *board)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd331_can_msg mesg;
</I>&gt;<i> +
</I>&gt;<i> +	memset(&amp;mesg, 0, sizeof(mesg));
</I>&gt;<i> +	mesg.cmmd = ESD331_I20_BAUD;
</I>&gt;<i> +	mesg.net = pci331net;
</I>&gt;<i> +	mesg.data[0] = (u8)(index &gt;&gt; 8);
</I>&gt;<i> +	mesg.data[1] = (u8)0x100;
</I>
Hm, (u8)0x100 == 0!

&gt;<i> +
</I>&gt;<i> +	return esd331_write(&amp;mesg, board);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd331_read_feat(struct esd331_pci *board)
</I>
esd331_read_feature?

&gt;<i> +{
</I>&gt;<i> +	struct esd331_can_msg msg;
</I>&gt;<i> +	int max_msg = 5;
</I>&gt;<i> +
</I>&gt;<i> +	board-&gt;net_count = 0;
</I>&gt;<i> +	board-&gt;eff_supp = 0;
</I>&gt;<i> +
</I>&gt;<i> +	while ((esd331_read(&amp;msg, board) == 0) &amp;&amp; (max_msg--)) {
</I>&gt;<i> +		if (msg.cmmd == ESD331_I20_BOARD) {
</I>&gt;<i> +			u8 magic = (msg.x1 &gt;&gt; 8);
</I>&gt;<i> +			if (magic == 0) {
</I>&gt;<i> +				u8 features = (u8)msg.x1;
</I>&gt;<i> +				u8 nets = (features &amp; 0x07);
</I>&gt;<i> +				if ((nets &gt;= 0) &amp;&amp; (nets &lt;= ESD331_MAX_CAN))
</I>&gt;<i> +					board-&gt;net_count = nets;
</I>&gt;<i> +
</I>&gt;<i> +				if (features &amp; 0x80)
</I>&gt;<i> +					board-&gt;eff_supp = 1;
</I>&gt;<i> +			}
</I>&gt;<i> +		} else if (msg.cmmd == ESD331_I20_BOARD2) {
</I>&gt;<i> +			u8 features = msg.net;
</I>&gt;<i> +
</I>&gt;<i> +			if (features &amp; 0x80)
</I>&gt;<i> +				board-&gt;eff_supp = 1;
</I>&gt;<i> +
</I>&gt;<i> +			if (board-&gt;net_count == 0) {
</I>&gt;<i> +				u8 nets = (features &amp; 0x07);
</I>&gt;<i> +				if ((nets &gt;= 0) &amp;&amp; (nets &lt;= ESD331_MAX_CAN))
</I>&gt;<i> +					board-&gt;net_count = nets;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return board-&gt;net_count &lt; 1;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd331_create_err_frame(struct net_device *dev, canid_t idflags,
</I>&gt;<i> +									u8 d1)
</I>
This indention is unusual. Please either align on the opening bracket
above or the first tab position after it.

&gt;<i> +{
</I>&gt;<i> +	struct net_device_stats *stats;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +
</I>&gt;<i> +	skb = dev_alloc_skb(sizeof(*cf));
</I>&gt;<i> +	if (unlikely(skb == NULL))
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +
</I>&gt;<i> +	stats = &amp;dev-&gt;stats;
</I>&gt;<i> +
</I>&gt;<i> +	skb-&gt;dev = dev;
</I>&gt;<i> +	skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;<i> +	cf = (struct can_frame *)skb_put(skb, sizeof(*cf));
</I>&gt;<i> +	memset(cf, 0, sizeof(*cf));
</I>&gt;<i> +
</I>&gt;<i> +	cf-&gt;can_id = CAN_ERR_FLAG | idflags;
</I>&gt;<i> +	cf-&gt;can_dlc = CAN_ERR_DLC;
</I>&gt;<i> +	cf-&gt;data[1] = d1;
</I>&gt;<i> +
</I>&gt;<i> +	netif_rx(skb);
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;last_rx = jiffies;
</I>&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;<i> +	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void esd331_irq_rx(struct net_device *dev, struct esd331_can_msg *msg,
</I>&gt;<i> +									int eff)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cfrm;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	int i;
</I>&gt;<i> +
</I>&gt;<i> +	skb = netdev_alloc_skb(dev, sizeof(*cfrm));
</I>&gt;<i> +	if (unlikely(skb == NULL)) {
</I>&gt;<i> +		stats-&gt;rx_dropped++;
</I>&gt;<i> +		return;
</I>&gt;<i> +	}
</I>&gt;<i> +	skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;<i> +
</I>&gt;<i> +	cfrm = (struct can_frame *)skb_put(skb, sizeof(*cfrm));
</I>&gt;<i> +	memset(cfrm, 0, sizeof(*cfrm));
</I>&gt;<i> +
</I>&gt;<i> +	if (eff) {
</I>&gt;<i> +		cfrm-&gt;can_id = (msg-&gt;id &lt;&lt; 16);
</I>&gt;<i> +		cfrm-&gt;can_id |= (msg-&gt;x2);
</I>&gt;<i> +	} else {
</I>&gt;<i> +		cfrm-&gt;can_id = msg-&gt;id;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (msg-&gt;len &amp; 0x10)
</I>&gt;<i> +		cfrm-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> +
</I>&gt;<i> +	if (eff)
</I>&gt;<i> +		cfrm-&gt;can_id |= CAN_EFF_FLAG;
</I>&gt;<i> +
</I>&gt;<i> +	cfrm-&gt;can_dlc = msg-&gt;len &amp; 0x0F;
</I>&gt;<i> +
</I>&gt;<i> +	if (cfrm-&gt;can_dlc &gt; 8)
</I>&gt;<i> +		cfrm-&gt;can_dlc = 8;
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; cfrm-&gt;can_dlc; ++i)
</I>&gt;<i> +		cfrm-&gt;data[i] = msg-&gt;data[i];
</I>&gt;<i> +
</I>&gt;<i> +	netif_rx(skb);
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;last_rx = jiffies;
</I>&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;<i> +	stats-&gt;rx_bytes += cfrm-&gt;can_dlc;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void esd331_handle_errmsg(struct net_device *dev,
</I>&gt;<i> +						struct esd331_can_msg *msg)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd331_priv *priv = netdev_priv(dev);
</I>&gt;<i> +
</I>&gt;<i> +	if (msg-&gt;id &amp; 0x7F)
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	switch (msg-&gt;data[1]) {
</I>&gt;<i> +	case 0x00:
</I>&gt;<i> +		if (priv-&gt;can.state != CAN_STATE_STOPPED)
</I>&gt;<i> +			priv-&gt;can.state = CAN_STATE_ACTIVE;
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	case 0x40:
</I>&gt;<i> +		if ((priv-&gt;can.state != CAN_STATE_BUS_WARNING)
</I>&gt;<i> +				&amp;&amp; (priv-&gt;can.state != CAN_STATE_STOPPED)) {
</I>&gt;<i> +			priv-&gt;can.can_stats.error_warning++;
</I>&gt;<i> +			priv-&gt;can.state = CAN_STATE_BUS_WARNING;
</I>&gt;<i> +
</I>&gt;<i> +			/* might be RX warning, too... */
</I>&gt;<i> +			esd331_create_err_frame(dev, CAN_ERR_CRTL,
</I>&gt;<i> +					CAN_ERR_CRTL_TX_WARNING);
</I>&gt;<i> +		}
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	case 0x80:
</I>&gt;<i> +	case 0xC0:
</I>&gt;<i> +		if ((priv-&gt;can.state != CAN_STATE_BUS_OFF)
</I>&gt;<i> +				&amp;&amp; (priv-&gt;can.state != CAN_STATE_STOPPED)) {
</I>&gt;<i> +			priv-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +			esd331_create_err_frame(dev, CAN_ERR_BUSOFF, 0);
</I>&gt;<i> +			can_bus_off(dev);
</I>&gt;<i> +		}
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	default:
</I>&gt;<i> +		break;
</I>&gt;<i> +	}
</I>
Using macro definitons for the switch cases would be nice here as well.

&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void esd331_handle_messages(struct esd331_pci *board)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd331_priv *priv;
</I>&gt;<i> +	struct net_device_stats *stats;
</I>&gt;<i> +	struct esd331_can_msg msg;
</I>&gt;<i> +	int msg_count = ESD331_MAX_INTERRUPT_WORK;
</I>&gt;<i> +
</I>&gt;<i> +	while ((esd331_read(&amp;msg, board) == 0) &amp;&amp; (msg_count--)) {
</I>&gt;<i> +		if (unlikely((msg.net &gt;= ESD331_MAX_CAN)
</I>&gt;<i> +				|| (board-&gt;dev[msg.net] == NULL)))
</I>&gt;<i> +			continue;
</I>&gt;<i> +
</I>&gt;<i> +		priv = netdev_priv(board-&gt;dev[msg.net]);
</I>&gt;<i> +		if (priv-&gt;can.state == CAN_STATE_STOPPED)
</I>&gt;<i> +			continue;
</I>&gt;<i> +
</I>&gt;<i> +		stats = &amp;board-&gt;dev[msg.net]-&gt;stats;
</I>&gt;<i> +
</I>&gt;<i> +		switch (msg.cmmd) {
</I>&gt;<i> +
</I>&gt;<i> +		case ESD331_I20_BCAN:
</I>&gt;<i> +		case ESD331_I20_EX_BCAN:
</I>&gt;<i> +			esd331_irq_rx(board-&gt;dev[msg.net], &amp;msg,
</I>&gt;<i> +					(msg.cmmd == ESD331_I20_EX_BCAN));
</I>&gt;<i> +			break;
</I>&gt;<i> +
</I>&gt;<i> +		case ESD331_I20_TXDONE:
</I>&gt;<i> +		case ESD331_I20_EX_TXDONE:
</I>&gt;<i> +			stats-&gt;tx_packets++;
</I>&gt;<i> +			can_get_echo_skb(board-&gt;dev[msg.net], 0);
</I>&gt;<i> +			netif_wake_queue(board-&gt;dev[msg.net]);
</I>&gt;<i> +			break;
</I>&gt;<i> +
</I>&gt;<i> +		case ESD331_I20_TXTOUT:
</I>&gt;<i> +		case ESD331_I20_EX_TXTOUT:
</I>&gt;<i> +			stats-&gt;tx_errors++;
</I>&gt;<i> +			can_get_echo_skb(board-&gt;dev[msg.net], 0);
</I>&gt;<i> +			netif_wake_queue(board-&gt;dev[msg.net]);
</I>&gt;<i> +			break;
</I>
Hm, this will loopback the message even if it did not go out. And if the
message get's dropped, stats-&gt;tx_dropped should be increments. Why might
the hardware signal such an error.

&gt;<i> +
</I>&gt;<i> +		case ESD331_I20_ERROR:
</I>&gt;<i> +			esd331_handle_errmsg(board-&gt;dev[msg.net], &amp;msg);
</I>&gt;<i> +			break;
</I>&gt;<i> +
</I>&gt;<i> +		default:
</I>&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,19)
</I>&gt;<i> +irqreturn_t esd331_interrupt(int irq, void *dev_id, struct pt_regs *regs)
</I>&gt;<i> +#else
</I>&gt;<i> +irqreturn_t esd331_interrupt(int irq, void *dev_id)
</I>&gt;<i> +#endif
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd331_pci *board = (struct esd331_pci *)dev_id;
</I>&gt;<i> +
</I>&gt;<i> +	if (!(readl((u8 *)(board-&gt;conf_addr) + 0x4c) &amp; 0x04))
</I>&gt;<i> +		return IRQ_NONE;
</I>&gt;<i> +
</I>&gt;<i> +	writew(0xffff, (u8 *)board-&gt;base_addr2 + 0xc0100);
</I>&gt;<i> +
</I>&gt;<i> +	esd331_handle_messages(board);
</I>&gt;<i> +
</I>&gt;<i> +	return IRQ_HANDLED;
</I>&gt;<i> +}
</I>&gt;<i> +EXPORT_SYMBOL_GPL(esd331_interrupt);
</I>&gt;<i> +
</I>&gt;<i> +/* also enables interrupt when no other net on card is openened yet */
</I>&gt;<i> +static int esd331_open(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd331_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	int i;
</I>&gt;<i> +	int enable_int = 1;
</I>&gt;<i> +	int err;
</I>&gt;<i> +
</I>&gt;<i> +	err = can_set_bittiming(dev);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		return err;
</I>&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,23)
</I>&gt;<i> +	memset(&amp;priv-&gt;can.net_stats, 0, sizeof(priv-&gt;can.net_stats));
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; ESD331_MAX_CAN; i++) {
</I>&gt;<i> +		if (priv-&gt;board-&gt;dev[i] == NULL) {
</I>&gt;<i> +			break;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			struct esd331_priv *otherPriv;
</I>&gt;<i> +			otherPriv = netdev_priv(priv-&gt;board-&gt;dev[i]);
</I>&gt;<i> +			if (otherPriv-&gt;can.state != CAN_STATE_STOPPED) {
</I>&gt;<i> +				enable_int = 0;
</I>&gt;<i> +				break;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (enable_int)
</I>&gt;<i> +		esd331_enableIRQ(priv-&gt;board-&gt;conf_addr);
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_ACTIVE;
</I>&gt;<i> +	priv-&gt;can.restart_ms = 500;
</I>
It should be *off* by default!

&gt;<i> +	netif_start_queue(dev);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/* also disables interrupt when all other nets on card are closed already*/
</I>&gt;<i> +static int esd331_close(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd331_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	int disable_int = 1;
</I>&gt;<i> +	int i;
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> +	netif_stop_queue(dev);
</I>&gt;<i> +	can_close_cleanup(dev);
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; ESD331_MAX_CAN; i++) {
</I>&gt;<i> +		if (priv-&gt;board-&gt;dev[i] == NULL) {
</I>&gt;<i> +			break;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			struct esd331_priv *otherPriv;
</I>&gt;<i> +			otherPriv = netdev_priv(priv-&gt;board-&gt;dev[i]);
</I>&gt;<i> +			if (otherPriv-&gt;can.state != CAN_STATE_STOPPED) {
</I>&gt;<i> +				disable_int = 0;
</I>&gt;<i> +				break;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (disable_int)
</I>&gt;<i> +		esd331_disableIRQ(priv-&gt;board-&gt;conf_addr);
</I>
Please disable the interrupts earlier, especially before calling
can_close_cleanup().

&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd331_start_xmit(struct sk_buff *skb, struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd331_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> +
</I>&gt;<i> +	if ((cf-&gt;can_id &amp; CAN_EFF_FLAG) &amp;&amp; (priv-&gt;board-&gt;eff_supp == 0)) {
</I>&gt;<i> +		stats-&gt;tx_errors++;
</I>&gt;<i> +		return 0;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	netif_stop_queue(dev);
</I>&gt;<i> +
</I>&gt;<i> +	if (esd331_send(priv-&gt;board, priv-&gt;boardsNet, cf-&gt;can_id &amp; 0x1FFFFFFF,
</I>&gt;<i> +						cf-&gt;can_id &amp; CAN_EFF_FLAG,
</I>&gt;<i> +						cf-&gt;can_id &amp; CAN_RTR_FLAG,
</I>&gt;<i> +						cf-&gt;can_dlc, cf-&gt;data)) {
</I>&gt;<i> +		stats-&gt;tx_fifo_errors++;
</I>&gt;<i> +		return 0;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	stats-&gt;tx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +	dev-&gt;trans_start = jiffies;
</I>&gt;<i> +
</I>&gt;<i> +	can_put_echo_skb(skb, dev, 0);
</I>
This should be called before sending the message. And in case of errors
you need to free the skb and increment stats-&gt;tx_errors *and*
stats-&gt;tx_dropped.

&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd331_set_bittiming(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd331_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	int idx;
</I>&gt;<i> +
</I>&gt;<i> +	if (priv-&gt;can.bittiming.bitrate &gt;= 1600000) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 1600000;
</I>&gt;<i> +		idx = 15;
</I>&gt;<i> +	} else if (priv-&gt;can.bittiming.bitrate &gt;= 1000000) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 1000000;
</I>&gt;<i> +		idx = 0;
</I>&gt;<i> +	} else if (priv-&gt;can.bittiming.bitrate &gt;= 800000) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 800000;
</I>&gt;<i> +		idx = 14;
</I>&gt;<i> +	} else if (priv-&gt;can.bittiming.bitrate &gt;= 666000) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 666000;
</I>&gt;<i> +		idx = 1;
</I>&gt;<i> +	} else if (priv-&gt;can.bittiming.bitrate &gt;= 500000) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 500000;
</I>&gt;<i> +		idx = 2;
</I>&gt;<i> +	} else if (priv-&gt;can.bittiming.bitrate &gt;= 333000) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 333000;
</I>&gt;<i> +		idx = 3;
</I>&gt;<i> +	} else if (priv-&gt;can.bittiming.bitrate &gt;= 250000) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 250000;
</I>&gt;<i> +		idx = 4;
</I>&gt;<i> +	} else if (priv-&gt;can.bittiming.bitrate &gt;= 166000) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 166000;
</I>&gt;<i> +		idx = 5;
</I>&gt;<i> +	} else if (priv-&gt;can.bittiming.bitrate &gt;= 125000) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 125000;
</I>&gt;<i> +		idx = 6;
</I>&gt;<i> +	} else if (priv-&gt;can.bittiming.bitrate &gt;= 100000) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 100000;
</I>&gt;<i> +		idx = 7;
</I>&gt;<i> +	} else if (priv-&gt;can.bittiming.bitrate &gt;= 83000) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 83000;
</I>&gt;<i> +		idx = 16;
</I>&gt;<i> +	} else if (priv-&gt;can.bittiming.bitrate &gt;= 66000) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 66000;
</I>&gt;<i> +		idx = 8;
</I>&gt;<i> +	} else if (priv-&gt;can.bittiming.bitrate &gt;= 50000) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 50000;
</I>&gt;<i> +		idx = 9;
</I>&gt;<i> +	} else if (priv-&gt;can.bittiming.bitrate &gt;= 33000) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 33000;
</I>&gt;<i> +		idx = 10;
</I>&gt;<i> +	} else if (priv-&gt;can.bittiming.bitrate &gt;= 20000) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 20000;
</I>&gt;<i> +		idx = 11;
</I>&gt;<i> +	} else if (priv-&gt;can.bittiming.bitrate &gt;= 12500) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 12500;
</I>&gt;<i> +		idx = 12;
</I>&gt;<i> +	} else if (priv-&gt;can.bittiming.bitrate &gt;= 10000) {
</I>&gt;<i> +		priv-&gt;can.bittiming.bitrate = 10000;
</I>&gt;<i> +		idx = 13;
</I>&gt;<i> +	} else
</I>&gt;<i> +		return -EINVAL;
</I>
Please use a table and scan it.

&gt;<i> +
</I>&gt;<i> +	if (esd331_write_baud(priv-&gt;boardsNet, idx, priv-&gt;board))
</I>&gt;<i> +		return -EAGAIN;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int esd331_get_state(struct net_device *dev, enum can_state *state)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd331_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	*state = priv-&gt;can.state;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>
This function can be removed as the upper layer already does it that way.

&gt;<i> +static int esd331_set_mode(struct net_device *dev, enum can_mode mode)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd331_priv *priv = netdev_priv(dev);
</I>&gt;<i> +
</I>&gt;<i> +	switch (mode) {
</I>&gt;<i> +	case CAN_MODE_START:
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_ACTIVE;
</I>&gt;<i> +		if (netif_queue_stopped(dev))
</I>&gt;<i> +			netif_wake_queue(dev);
</I>&gt;<i> +
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	default:
</I>&gt;<i> +		return -EOPNOTSUPP;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static struct net_device *__devinit esd331_pci_add_chan(struct pci_dev *pdev,
</I>&gt;<i> +					struct esd331_pci *board,
</I>&gt;<i> +					u8 boardsNet)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *dev;
</I>&gt;<i> +	struct esd331_priv *priv;
</I>&gt;<i> +	int err;
</I>&gt;<i> +
</I>&gt;<i> +	dev = alloc_candev(sizeof(*priv));
</I>&gt;<i> +	if (dev == NULL)
</I>&gt;<i> +		return ERR_PTR(-ENOMEM);
</I>&gt;<i> +
</I>&gt;<i> +	priv = netdev_priv(dev);
</I>&gt;<i> +	priv-&gt;boardsNet = boardsNet;
</I>&gt;<i> +	priv-&gt;board = board;
</I>&gt;<i> +
</I>&gt;<i> +	SET_NETDEV_DEV(dev, &amp;pdev-&gt;dev);
</I>&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
</I>&gt;<i> +	dev-&gt;netdev_ops = &amp;esd331_netdev_ops;
</I>&gt;<i> +#else
</I>&gt;<i> +	dev-&gt;open = esd331_open;
</I>&gt;<i> +	dev-&gt;stop = esd331_close;
</I>&gt;<i> +	dev-&gt;hard_start_xmit = esd331_start_xmit;
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;irq = pdev-&gt;irq;
</I>&gt;<i> +	dev-&gt;flags |= IFF_ECHO;
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.do_set_bittiming = esd331_set_bittiming;
</I>&gt;<i> +	priv-&gt;can.do_get_state = esd331_get_state;
</I>&gt;<i> +	priv-&gt;can.do_set_mode = esd331_set_mode;
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> +
</I>&gt;<i> +	err = register_candev(dev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;registering candev failed\n&quot;);
</I>&gt;<i> +		free_netdev(dev);
</I>&gt;<i> +		return ERR_PTR(err);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	dev_info(&amp;pdev-&gt;dev, &quot;device %s registered\n&quot;, dev-&gt;name);
</I>&gt;<i> +
</I>&gt;<i> +	return dev;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int __devinit esd331_pci_init_one(struct pci_dev *pdev,
</I>&gt;<i> +						const struct pci_device_id *ent)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd331_pci *board;
</I>&gt;<i> +	int err;
</I>&gt;<i> +	int i;
</I>&gt;<i> +
</I>&gt;<i> +	dev_info(&amp;pdev-&gt;dev,
</I>&gt;<i> +			&quot;Initializing device %04x:%04x %04x:%04x\n&quot;,
</I>&gt;<i> +			pdev-&gt;vendor, pdev-&gt;device,
</I>&gt;<i> +			pdev-&gt;subsystem_vendor, pdev-&gt;subsystem_device);
</I>&gt;<i> +
</I>&gt;<i> +	board = kzalloc(sizeof(*board), GFP_KERNEL);
</I>&gt;<i> +	if (board == NULL)
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +
</I>&gt;<i> +	err = pci_enable_device(pdev);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		goto failure;
</I>&gt;<i> +
</I>&gt;<i> +	err = pci_request_regions(pdev, DRV_NAME);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		goto failure;
</I>&gt;<i> +
</I>&gt;<i> +	board-&gt;conf_addr = pci_iomap(pdev, 0, 0x00001000);
</I>&gt;<i> +	if (board-&gt;conf_addr == NULL) {
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto failure_release_pci;
</I>&gt;<i> +	}
</I>&gt;<i> +	board-&gt;base_addr1 = pci_iomap(pdev, 2, 0x00100000);
</I>&gt;<i> +	if (board-&gt;base_addr1 == NULL) {
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto failure_iounmap_conf;
</I>&gt;<i> +	}
</I>&gt;<i> +	board-&gt;base_addr2 = pci_iomap(pdev, 3, 0x00100000);
</I>&gt;<i> +	if (board-&gt;base_addr2 == NULL) {
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto failure_iounmap_base1;
</I>&gt;<i> +	}
</I>
Please use macro definitons for the size arguments above, if really
required. A value of &quot;0&quot; will map the whole space.

&gt;<i> +	board-&gt;dpr = esd331_initPointer(board-&gt;base_addr1);
</I>&gt;<i> +
</I>&gt;<i> +	spin_lock_init(&amp;board-&gt;irq_lock);
</I>&gt;<i> +
</I>&gt;<i> +	/* Features are read from board's messages after reset. Avoid */
</I>&gt;<i> +	/* that long reset time and set features by other means? */
</I>&gt;<i> +	esd331_reset(board-&gt;conf_addr);
</I>&gt;<i> +
</I>&gt;<i> +	if (esd331_read_feat(board)) {
</I>&gt;<i> +		err = -EIO;
</I>&gt;<i> +		goto failure_iounmap_base2;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; board-&gt;net_count; ++i) {
</I>&gt;<i> +		board-&gt;dev[i] = esd331_pci_add_chan(pdev, board, i);
</I>&gt;<i> +		if (IS_ERR(board-&gt;dev[i])) {
</I>&gt;<i> +			err = (int)board-&gt;dev[i];
</I>&gt;<i> +			goto failure_iounmap_base2;
</I>&gt;<i> +		}
</I>&gt;<i> +		if (esd331_write_allid(i, board)) {
</I>&gt;<i> +			dev_err(&amp;pdev-&gt;dev, &quot;device %s failed to enable &quot;
</I>&gt;<i> +					&quot;all IDs\n&quot;, board-&gt;dev[i]-&gt;name);
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (esd331_write_fast(board))
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;failed to enable fast mode\n&quot;);
</I>&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,18)
</I>&gt;<i> +	err = request_irq(pdev-&gt;irq, &amp;esd331_interrupt, SA_SHIRQ, &quot;pci331&quot;,
</I>&gt;<i> +								(void *)board);
</I>&gt;<i> +#else
</I>&gt;<i> +	err = request_irq(pdev-&gt;irq, &amp;esd331_interrupt, IRQF_SHARED, &quot;pci331&quot;,
</I>&gt;<i> +								(void *)board);
</I>&gt;<i> +#endif
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		err = -EAGAIN;
</I>&gt;<i> +		goto failure_iounmap_base2;
</I>&gt;<i> +	}
</I>&gt;<i> +	pci_set_drvdata(pdev, board);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +failure_iounmap_base2:
</I>&gt;<i> +	pci_iounmap(pdev, board-&gt;base_addr2);
</I>&gt;<i> +
</I>&gt;<i> +failure_iounmap_base1:
</I>&gt;<i> +	pci_iounmap(pdev, board-&gt;base_addr1);
</I>&gt;<i> +
</I>&gt;<i> +failure_iounmap_conf:
</I>&gt;<i> +	pci_iounmap(pdev, board-&gt;conf_addr);
</I>&gt;<i> +
</I>&gt;<i> +failure_release_pci:
</I>&gt;<i> +	pci_release_regions(pdev);
</I>&gt;<i> +
</I>&gt;<i> +failure:
</I>&gt;<i> +	kfree(board);
</I>&gt;<i> +
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void __devexit esd331_pci_remove_one(struct pci_dev *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct esd331_pci *board = pci_get_drvdata(pdev);
</I>&gt;<i> +	int i;
</I>&gt;<i> +
</I>&gt;<i> +	esd331_disableIRQ(board-&gt;conf_addr);
</I>&gt;<i> +	free_irq(pdev-&gt;irq, (void *)board);
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; ESD331_MAX_CAN; i++) {
</I>&gt;<i> +		if (board-&gt;dev[i] == NULL)
</I>&gt;<i> +			break;
</I>&gt;<i> +
</I>&gt;<i> +		unregister_candev(board-&gt;dev[i]);
</I>&gt;<i> +		free_netdev(board-&gt;dev[i]);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	pci_iounmap(pdev, board-&gt;base_addr2);
</I>&gt;<i> +	pci_iounmap(pdev, board-&gt;base_addr1);
</I>&gt;<i> +	pci_iounmap(pdev, board-&gt;conf_addr);
</I>&gt;<i> +	pci_release_regions(pdev);
</I>&gt;<i> +
</I>&gt;<i> +	pci_disable_device(pdev);
</I>&gt;<i> +	pci_set_drvdata(pdev, NULL);
</I>&gt;<i> +
</I>&gt;<i> +	kfree(board);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static struct pci_driver esd331_pci_driver = {
</I>&gt;<i> +				.name = DRV_NAME,
</I>&gt;<i> +				.id_table = esd331_pci_tbl,
</I>&gt;<i> +				.probe = esd331_pci_init_one,
</I>&gt;<i> +				.remove = __devexit_p(esd331_pci_remove_one), };
</I>
One tab only, as usual.

&gt;<i> +static int __init esd331_pci_init(void)
</I>&gt;<i> +{
</I>&gt;<i> +	printk(KERN_INFO &quot;%s CAN netdevice driver\n&quot;, DRV_NAME);
</I>&gt;<i> +	return pci_register_driver(&amp;esd331_pci_driver);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void __exit esd331_pci_exit(void)
</I>&gt;<i> +{
</I>&gt;<i> +	pci_unregister_driver(&amp;esd331_pci_driver);
</I>&gt;<i> +	printk(KERN_INFO &quot;%s driver removed\n&quot;, DRV_NAME);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +module_init(esd331_pci_init);
</I>&gt;<i> +module_exit(esd331_pci_exit);
</I>
Thanks for yur contribution.

Wolfgang.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002529.html">[PATCH] Driver for esd CAN cards
</A></li>
	<LI>Next message: <A HREF="002533.html">[PATCH] Driver for esd CAN cards
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2530">[ date ]</a>
              <a href="thread.html#2530">[ thread ]</a>
              <a href="subject.html#2530">[ subject ]</a>
              <a href="author.html#2530">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
