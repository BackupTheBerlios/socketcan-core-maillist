<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [MeeGo-Dev][PATCH v3] Topcliff: Update PCH_CAN driver to 2.6.35
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2010-September/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BMeeGo-Dev%5D%5BPATCH%20v3%5D%20Topcliff%3A%20Update%20PCH_CAN%20driver%20to%202.6.35&In-Reply-To=%3C4CA4541F.5040804%40grandegger.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004682.html">
   <LINK REL="Next"  HREF="004685.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[MeeGo-Dev][PATCH v3] Topcliff: Update PCH_CAN driver to 2.6.35</H1>
    <B>Wolfgang Grandegger</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BMeeGo-Dev%5D%5BPATCH%20v3%5D%20Topcliff%3A%20Update%20PCH_CAN%20driver%20to%202.6.35&In-Reply-To=%3C4CA4541F.5040804%40grandegger.com%3E"
       TITLE="[MeeGo-Dev][PATCH v3] Topcliff: Update PCH_CAN driver to 2.6.35">wg at grandegger.com
       </A><BR>
    <I>Thu Sep 30 11:10:55 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="004682.html">[MeeGo-Dev][PATCH v3] Topcliff: Update PCH_CAN driver to 2.6.35
</A></li>
        <LI>Next message: <A HREF="004685.html">[MeeGo-Dev][PATCH v3] Topcliff: Update PCH_CAN driver to 2.6.35
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4684">[ date ]</a>
              <a href="thread.html#4684">[ thread ]</a>
              <a href="subject.html#4684">[ subject ]</a>
              <a href="author.html#4684">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Ohtake,

here comes my review, sorry for delay.

On 09/24/2010 12:24 PM, Masayuki Ohtak wrote:
&gt;<i> Hi Wolfgang and Marc,
</I>&gt;<i> 
</I>&gt;<i> We have modified a pretty amount of our driver based on other accepted Socket CAN driver.
</I>&gt;<i> Additionally, We have reduced the number of lines 3601 to 1444.
</I>
Much better, but I believe it could be reduced even further.

&gt;<i> Please check below.
</I>&gt;<i> 
</I>&gt;<i> Thanks, Ohtake(OKISemi)
</I>&gt;<i> 
</I>&gt;<i> ---
</I>&gt;<i> CAN driver of Topcliff PCH
</I>&gt;<i> 
</I>&gt;<i> Topcliff PCH is the platform controller hub that is going to be used in
</I>&gt;<i> Intel's upcoming general embedded platform. All IO peripherals in
</I>&gt;<i> Topcliff PCH are actually devices sitting on AMBA bus. 
</I>&gt;<i> Topcliff PCH has CAN I/F. This driver enables CAN function.
</I>&gt;<i> 
</I>&gt;<i> Signed-off-by: Masayuki Ohtake &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">masa-korg at dsn.okisemi.com</A>&gt;
</I>&gt;<i> ---
</I>&gt;<i>  drivers/net/can/Kconfig   |    8 +
</I>&gt;<i>  drivers/net/can/Makefile  |    1 +
</I>&gt;<i>  drivers/net/can/pch_can.c | 1444 +++++++++++++++++++++++++++++++++++++++++++++
</I>&gt;<i>  3 files changed, 1453 insertions(+), 0 deletions(-)
</I>&gt;<i>  create mode 100644 drivers/net/can/pch_can.c
</I>&gt;<i> 
</I>&gt;<i> diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
</I>&gt;<i> index 2c5227c..5c98a20 100644
</I>&gt;<i> --- a/drivers/net/can/Kconfig
</I>&gt;<i> +++ b/drivers/net/can/Kconfig
</I>&gt;<i> @@ -73,6 +73,14 @@ config CAN_JANZ_ICAN3
</I>&gt;<i>  	  This driver can also be built as a module. If so, the module will be
</I>&gt;<i>  	  called janz-ican3.ko.
</I>&gt;<i>  
</I>&gt;<i> +config PCH_CAN
</I>&gt;<i> +	tristate &quot;PCH CAN&quot;
</I>&gt;<i> +	depends on  CAN_DEV
</I>&gt;<i> +	---help---
</I>&gt;<i> +	  This driver is for PCH CAN of Topcliff which is an IOH for x86
</I>&gt;<i> +	  embedded processor.
</I>&gt;<i> +	  This driver can access CAN bus.
</I>&gt;<i> +
</I>&gt;<i>  source &quot;drivers/net/can/mscan/Kconfig&quot;
</I>&gt;<i>  
</I>&gt;<i>  source &quot;drivers/net/can/sja1000/Kconfig&quot;
</I>&gt;<i> diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
</I>&gt;<i> index 9047cd0..3ddc6a7 100644
</I>&gt;<i> --- a/drivers/net/can/Makefile
</I>&gt;<i> +++ b/drivers/net/can/Makefile
</I>&gt;<i> @@ -16,5 +16,6 @@ obj-$(CONFIG_CAN_TI_HECC)	+= ti_hecc.o
</I>&gt;<i>  obj-$(CONFIG_CAN_MCP251X)	+= mcp251x.o
</I>&gt;<i>  obj-$(CONFIG_CAN_BFIN)		+= bfin_can.o
</I>&gt;<i>  obj-$(CONFIG_CAN_JANZ_ICAN3)	+= janz-ican3.o
</I>&gt;<i> +obj-$(CONFIG_PCH_CAN)		+= pch_can.o
</I>
Please provide patches against David Millers &quot;net-next-2.6&quot; GIT tree and
use the prefix &quot;can: &quot; in your subject next time. See
<A HREF="http://svn.berlios.de/wsvn/socketcan/trunk/README.submitting-patches">http://svn.berlios.de/wsvn/socketcan/trunk/README.submitting-patches</A>
for further information.

&gt;<i>  ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
</I>&gt;<i> diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..8c1731b
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/pch_can.c
</I>&gt;<i> @@ -0,0 +1,1444 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * Copyright (C) 1999 - 2010 Intel Corporation.
</I>&gt;<i> + * Copyright (C) 2010 OKI SEMICONDUCTOR Co., LTD.
</I>&gt;<i> + *
</I>&gt;<i> + * This program is free software; you can redistribute it and/or modify
</I>&gt;<i> + * it under the terms of the GNU General Public License as published by
</I>&gt;<i> + * the Free Software Foundation; version 2 of the License.
</I>&gt;<i> + *
</I>&gt;<i> + * This program is distributed in the hope that it will be useful,
</I>&gt;<i> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
</I>&gt;<i> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</I>&gt;<i> + * GNU General Public License for more details.
</I>&gt;<i> + *
</I>&gt;<i> + * You should have received a copy of the GNU General Public License
</I>&gt;<i> + * along with this program; if not, write to the Free Software
</I>&gt;<i> + * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/interrupt.h&gt;
</I>&gt;<i> +#include &lt;linux/delay.h&gt;
</I>&gt;<i> +#include &lt;linux/io.h&gt;
</I>&gt;<i> +#include &lt;linux/module.h&gt;
</I>&gt;<i> +#include &lt;linux/sched.h&gt;
</I>&gt;<i> +#include &lt;linux/pci.h&gt;
</I>&gt;<i> +#include &lt;linux/init.h&gt;
</I>&gt;<i> +#include &lt;linux/kernel.h&gt;
</I>&gt;<i> +#include &lt;linux/types.h&gt;
</I>&gt;<i> +#include &lt;linux/errno.h&gt;
</I>&gt;<i> +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> +#include &lt;linux/skbuff.h&gt;
</I>&gt;<i> +#include &lt;linux/can.h&gt;
</I>&gt;<i> +#include &lt;linux/can/dev.h&gt;
</I>&gt;<i> +#include &lt;linux/can/error.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#define MAX_BITRATE		0x3e8
</I>
Dead code? At least it's not used anywhere.

&gt;<i> +
</I>&gt;<i> +#define MAX_MSG_OBJ		32
</I>&gt;<i> +#define MSG_OBJ_RX		0 /* The receive message object flag. */
</I>&gt;<i> +#define MSG_OBJ_TX		1 /* The transmit message object flag. */
</I>&gt;<i> +
</I>&gt;<i> +#define ENABLE			1 /* The enable flag */
</I>&gt;<i> +#define DISABLE			0 /* The disable flag */
</I>&gt;<i> +#define CAN_CTRL_INIT		0x0001 /* The INIT bit of CANCONT register. */
</I>&gt;<i> +#define CAN_CTRL_IE		0x0002 /* The IE bit of CAN control register */
</I>&gt;<i> +#define CAN_CTRL_IE_SIE_EIE	0x000e
</I>&gt;<i> +#define CAN_CTRL_CCE		0x0040
</I>&gt;<i> +#define CAN_CTRL_OPT		0x0080 /* The OPT bit of CANCONT register. */
</I>&gt;<i> +#define CAN_OPT_SILENT		0x0008 /* The Silent bit of CANOPT reg. */
</I>&gt;<i> +#define CAN_OPT_LBACK		0x0010 /* The LoopBack bit of CANOPT reg. */
</I>&gt;<i> +#define CAN_CMASK_RX_TX_SET	0x00f3
</I>&gt;<i> +#define CAN_CMASK_RX_TX_GET	0x0073
</I>&gt;<i> +#define CAN_CMASK_ALL		0xff
</I>&gt;<i> +#define CAN_CMASK_RDWR		0x80
</I>&gt;<i> +#define CAN_CMASK_ARB		0x20
</I>&gt;<i> +#define CAN_CMASK_CTRL		0x10
</I>&gt;<i> +#define CAN_CMASK_MASK		0x40
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_IF_MCONT_NEWDAT	0x8000
</I>&gt;<i> +#define CAN_IF_MCONT_INTPND	0x2000
</I>&gt;<i> +#define CAN_IF_MCONT_UMASK		0x1000
</I>&gt;<i> +#define CAN_IF_MCONT_TXIE		0x0800
</I>&gt;<i> +#define CAN_IF_MCONT_RXIE		0x0400
</I>&gt;<i> +#define CAN_IF_MCONT_RMTEN		0x0200
</I>&gt;<i> +#define CAN_IF_MCONT_TXRQXT		0x0100
</I>&gt;<i> +#define CAN_IF_MCONT_EOB		0x0080
</I>&gt;<i> +#define CAN_IF_MCONT_MSGLOST		0x4000
</I>&gt;<i> +#define CAN_MASK2_MDIR_MXTD		0xc000
</I>&gt;<i> +#define CAN_ID2_DIR			0x2000
</I>&gt;<i> +#define CAN_ID_MSGVAL			0x8000
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_STATUS_INT			0x8000
</I>&gt;<i> +#define CAN_IF_CREQ_BUSY		0x8000
</I>&gt;<i> +#define CAN_ID2_XTD			0x4000
</I>&gt;<i> +
</I>&gt;<i> +#define CAN_REC				0x00007f00
</I>&gt;<i> +#define CAN_TEC				0x000000ff
</I>&gt;<i> +
</I>&gt;<i> +#define PCH_RX_OK			0x00000010
</I>&gt;<i> +#define PCH_TX_OK			0x00000008
</I>&gt;<i> +#define PCH_BUS_OFF			0x00000080
</I>&gt;<i> +#define PCH_EWARN			0x00000040
</I>&gt;<i> +#define PCH_EPASSIV			0x00000020
</I>
&gt;<i> +#define PCH_LEC0			0x00000001
</I>&gt;<i> +#define PCH_LEC1			0x00000002
</I>&gt;<i> +#define PCH_LEC2			0x00000004
</I>&gt;<i> +#define PCH_LEC_ALL			(PCH_LEC0 | PCH_LEC1 | PCH_LEC2)
</I>&gt;<i> +#define PCH_STUF_ERR			PCH_LEC0
</I>&gt;<i> +#define PCH_FORM_ERR			PCH_LEC1
</I>&gt;<i> +#define PCH_ACK_ERR			(PCH_LEC0 | PCH_LEC1)
</I>&gt;<i> +#define PCH_BIT1_ERR			PCH_LEC2
</I>&gt;<i> +#define PCH_BIT0_ERR			(PCH_LEC0 | PCH_LEC2)
</I>&gt;<i> +#define PCH_CRC_ERR			(PCH_LEC1 | PCH_LEC2)
</I>
enum {
 	PCH_LEC_STUF_ERR = 0,
	PCH_LEC_FORM_ERR,
	PCH_LEC_ACK_ERR,
	...
	PCH_LEC_ALL
};	

Seems more appropriate. More comments below.

&gt;<i> +
</I>&gt;<i> +/* bit position of certain controller bits. */
</I>&gt;<i> +#define BIT_BITT_BRP			0
</I>&gt;<i> +#define BIT_BITT_SJW			6
</I>&gt;<i> +#define BIT_BITT_TSEG1			8
</I>&gt;<i> +#define BIT_BITT_TSEG2			12
</I>&gt;<i> +#define BIT_IF1_MCONT_RXIE		10
</I>&gt;<i> +#define BIT_IF2_MCONT_TXIE		11
</I>&gt;<i> +#define BIT_BRPE_BRPE			6
</I>&gt;<i> +#define BIT_ES_TXERRCNT			0
</I>&gt;<i> +#define BIT_ES_RXERRCNT			8
</I>&gt;<i> +#define MSK_BITT_BRP			0x3f
</I>&gt;<i> +#define MSK_BITT_SJW			0xc0
</I>&gt;<i> +#define MSK_BITT_TSEG1			0xf00
</I>&gt;<i> +#define MSK_BITT_TSEG2			0x7000
</I>&gt;<i> +#define MSK_BRPE_BRPE			0x3c0
</I>&gt;<i> +#define MSK_BRPE_GET			0x0f
</I>&gt;<i> +#define MSK_CTRL_IE_SIE_EIE		0x07
</I>&gt;<i> +#define MSK_MCONT_TXIE			0x08
</I>&gt;<i> +#define MSK_MCONT_RXIE			0x10
</I>&gt;<i> +#define PCH_CAN_NO_TX_BUFF		1
</I>&gt;<i> +#define PCI_DEVICE_ID_INTEL_PCH1_CAN	0x8818
</I>&gt;<i> +#define COUNTER_LIMIT 0xFFFF
</I>
Keep alignment?

&gt;<i> +#define PCH_CAN_CLK			50000	/* 50MHz */
</I>
Please specify it in Hz already here.

&gt;<i> +
</I>&gt;<i> +/* Total 32 OBJs */
</I>&gt;<i> +#define PCH_RX_OBJ_NUM	1
</I>&gt;<i> +#define PCH_TX_OBJ_NUM	1
</I>&gt;<i> +#define PCH_OBJ_NUM (PCH_TX_OBJ_NUM + PCH_RX_OBJ_NUM)
</I>
Please explain biefly what message object are use for what purpose.
Either here or in the initialization code.

&gt;<i> +
</I>&gt;<i> +#define	PCH_CAN_ACTIVE	0
</I>&gt;<i> +#define	PCH_CAN_LISTEN	1
</I>&gt;<i> +#define PCH_CAN_STOP	0
</I>&gt;<i> +#define PCH_CAN_RUN	1
</I>&gt;<i> +
</I>&gt;<i> +#define PCH_CAN_ENABLE	0
</I>&gt;<i> +#define PCH_CAN_DISABLE	1
</I>&gt;<i> +#define PCH_CAN_ALL	2
</I>&gt;<i> +#define PCH_CAN_NONE	3
</I>
The above are used in switch case and should therefore be anonymous
enums. I suggested to remove them because I'm not a real friend of the
helper functions which are just called *once*.

&gt;<i> +
</I>&gt;<i> +struct pch_can_regs {
</I>&gt;<i> +	u32 cont;
</I>&gt;<i> +	u32 stat;
</I>&gt;<i> +	u32 errc;
</I>&gt;<i> +	u32 bitt;
</I>&gt;<i> +	u32 intr;
</I>&gt;<i> +	u32 opt;
</I>&gt;<i> +	u32 brpe;
</I>&gt;<i> +	u32 reserve1;
</I>&gt;<i> +	u32 if1_creq;
</I>&gt;<i> +	u32 if1_cmask;
</I>&gt;<i> +	u32 if1_mask1;
</I>&gt;<i> +	u32 if1_mask2;
</I>&gt;<i> +	u32 if1_id1;
</I>&gt;<i> +	u32 if1_id2;
</I>&gt;<i> +	u32 if1_mcont;
</I>&gt;<i> +	u32 if1_dataa1;
</I>&gt;<i> +	u32 if1_dataa2;
</I>&gt;<i> +	u32 if1_datab1;
</I>&gt;<i> +	u32 if1_datab2;
</I>&gt;<i> +	u32 reserve2;
</I>&gt;<i> +	u32 reserve3[12];
</I>&gt;<i> +	u32 if2_creq;
</I>&gt;<i> +	u32 if2_cmask;
</I>&gt;<i> +	u32 if2_mask1;
</I>&gt;<i> +	u32 if2_mask2;
</I>&gt;<i> +	u32 if2_id1;
</I>&gt;<i> +	u32 if2_id2;
</I>&gt;<i> +	u32 if2_mcont;
</I>&gt;<i> +	u32 if2_dataa1;
</I>&gt;<i> +	u32 if2_dataa2;
</I>&gt;<i> +	u32 if2_datab1;
</I>&gt;<i> +	u32 if2_datab2;
</I>&gt;<i> +	u32 reserve4;
</I>&gt;<i> +	u32 reserve5[20];
</I>&gt;<i> +	u32 treq1;
</I>&gt;<i> +	u32 treq2;
</I>&gt;<i> +	u32 reserve6[2];
</I>&gt;<i> +	u32 reserve7[56];
</I>&gt;<i> +	u32 reserve8[3];
</I>&gt;<i> +	u32 srst;
</I>&gt;<i> +};
</I>
Nice.

&gt;<i> +struct pch_can_priv {
</I>&gt;<i> +	struct can_priv can;
</I>&gt;<i> +	void __iomem *base;
</I>&gt;<i> +	unsigned int can_num;
</I>&gt;<i> +	struct pci_dev *dev;
</I>&gt;<i> +	unsigned int tx_enable[MAX_MSG_OBJ];
</I>&gt;<i> +	unsigned int rx_enable[MAX_MSG_OBJ];
</I>&gt;<i> +	unsigned int rx_link[MAX_MSG_OBJ];
</I>&gt;<i> +	unsigned int int_enables;
</I>&gt;<i> +	unsigned int int_stat;
</I>&gt;<i> +	unsigned int bus_off_interrupt;
</I>&gt;<i> +	struct net_device *ndev;
</I>&gt;<i> +	spinlock_t msgif_reg_lock; /* Message Interface Registers Access Lock*/
</I>&gt;<i> +	unsigned int msg_obj[MAX_MSG_OBJ];
</I>&gt;<i> +	struct pch_can_regs *regs;
</I>
Please add __iomem. Do you need both, regs *and* base?

&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static struct can_bittiming_const pch_can_bittiming_const = {
</I>&gt;<i> +	.name = KBUILD_MODNAME,
</I>
Not sure what KBUILD_MODNAME is. Should be &quot;pch_can&quot;, the name of the
driver.

&gt;<i> +	.tseg1_min = 1,
</I>&gt;<i> +	.tseg1_max = 16,
</I>&gt;<i> +	.tseg2_min = 1,
</I>&gt;<i> +	.tseg2_max = 8,
</I>&gt;<i> +	.sjw_max = 4,
</I>&gt;<i> +	.brp_min = 1,
</I>&gt;<i> +	.brp_max = 1024, /* 6bit + extended 4bit */
</I>&gt;<i> +	.brp_inc = 1,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static const struct pci_device_id pch_can_pcidev_id[] __devinitdata = {
</I>&gt;<i> +	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_PCH1_CAN)},
</I>&gt;<i> +	{}
</I>&gt;<i> +};
</I>
Please use DEFINE_PCI_DEVICE_TABLE.

&gt;<i> +static inline void pch_can_bit_set(u32 *addr, u32 mask)
</I>&gt;<i> +{
</I>&gt;<i> +	iowrite32((ioread32(addr) | mask), addr);
</I>
Outer brackets not needed!

&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline void pch_can_bit_clear(u32 *addr, u32 mask)
</I>&gt;<i> +{
</I>&gt;<i> +	iowrite32((ioread32(addr) &amp; ~(mask)), addr);
</I>
Ditto.

&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_set_run_mode(struct pch_can_priv *priv, u32 mode)
</I>&gt;<i> +{
</I>&gt;<i> +	switch (mode) {
</I>&gt;<i> +	case PCH_CAN_RUN:
</I>&gt;<i> +		pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_INIT);
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	case PCH_CAN_STOP:
</I>&gt;<i> +		pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_INIT);
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	default:
</I>&gt;<i> +		dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;%s -&gt; Invalid Mode.\n&quot;, __func__);
</I>&gt;<i> +		break;
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_get_run_mode(struct pch_can_priv *priv, u32 *mode)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 reg_val = ioread32(&amp;(priv-&gt;regs)-&gt;cont);
</I>
I don't think you need the brackets around &quot;priv-&gt;regs&quot;. Therefore I
suggest s/&amp;(priv-&gt;regs)/&amp;priv-&gt;regs/ for the whole file.

&gt;<i> +
</I>&gt;<i> +	if (reg_val &amp; CAN_CTRL_INIT)
</I>&gt;<i> +		*mode = PCH_CAN_STOP;
</I>&gt;<i> +	else
</I>&gt;<i> +		*mode = PCH_CAN_RUN;
</I>&gt;<i> +}
</I>
These are the helper functions I complained about above. And reg_val is
not really needed.

&gt;<i> +static void pch_can_set_optmode(struct pch_can_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 reg_val = ioread32(&amp;(priv-&gt;regs)-&gt;opt);
</I>&gt;<i> +
</I>&gt;<i> +	if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LISTENONLY)
</I>&gt;<i> +		reg_val |= CAN_OPT_SILENT;
</I>&gt;<i> +
</I>&gt;<i> +	if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LOOPBACK)
</I>&gt;<i> +		reg_val |= CAN_OPT_LBACK;
</I>&gt;<i> +
</I>&gt;<i> +	pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_OPT);
</I>&gt;<i> +	iowrite32(reg_val, &amp;(priv-&gt;regs)-&gt;opt);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_set_int_custom(struct pch_can_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	/* Clearing the IE, SIE and EIE bits of Can control register. */
</I>&gt;<i> +	pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_IE_SIE_EIE);
</I>&gt;<i> +
</I>&gt;<i> +	/* Appropriately setting them. */
</I>&gt;<i> +	pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;cont,
</I>&gt;<i> +			((priv-&gt;int_enables &amp; MSK_CTRL_IE_SIE_EIE) &lt;&lt; 1));
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/* This function retrieves interrupt enabled for the CAN device. */
</I>&gt;<i> +static void pch_can_get_int_enables(struct pch_can_priv *priv, u32 *enables)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 reg_ctrl_val = ioread32(&amp;(priv-&gt;regs)-&gt;cont);
</I>&gt;<i> +
</I>&gt;<i> +	/* Obtaining the status of IE, SIE and EIE interrupt bits. */
</I>&gt;<i> +	*enables = ((reg_ctrl_val &amp; CAN_CTRL_IE_SIE_EIE) &gt;&gt; 1);
</I>
Do you really need an extra variable?

&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_set_int_enables(struct pch_can_priv *priv, u32 interrupt_no)
</I>&gt;<i> +{
</I>&gt;<i> +	switch (interrupt_no) {
</I>&gt;<i> +	case PCH_CAN_ENABLE:
</I>&gt;<i> +		pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_IE);
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	case PCH_CAN_DISABLE:
</I>&gt;<i> +		pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_IE);
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	case PCH_CAN_ALL:
</I>&gt;<i> +		pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_IE_SIE_EIE);
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	case PCH_CAN_NONE:
</I>&gt;<i> +		pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_IE_SIE_EIE);
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	default:
</I>&gt;<i> +		dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;Invalid interrupt number.\n&quot;);
</I>&gt;<i> +		break;
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_check_if1_busy(struct pch_can_priv *priv, u32 num)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 counter = COUNTER_LIMIT;
</I>&gt;<i> +	u32 if1_creq;
</I>&gt;<i> +
</I>&gt;<i> +	iowrite32(num, &amp;(priv-&gt;regs)-&gt;if1_creq);
</I>&gt;<i> +	while (counter) {
</I>&gt;<i> +		if1_creq = (ioread32(&amp;(priv-&gt;regs)-&gt;if1_creq)) &amp;
</I>&gt;<i> +				     CAN_IF_CREQ_BUSY;
</I>&gt;<i> +		if (!if1_creq)
</I>&gt;<i> +			break;
</I>&gt;<i> +		counter--;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (!counter)
</I>&gt;<i> +		dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;IF1 BUSY Flag is set forever.\n&quot;);
</I>
Please use a defined delay for the above timeout. How long does it
usually take the bit to toggle? A small delay, e.g. udelay(1) could be
fine. This function is called in the time critical path!

&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_check_if2_busy(struct pch_can_priv *priv, u32 num)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 counter = COUNTER_LIMIT;
</I>&gt;<i> +	u32 if2_creq;
</I>&gt;<i> +
</I>&gt;<i> +	iowrite32(num, &amp;(priv-&gt;regs)-&gt;if2_creq);
</I>&gt;<i> +	while (counter) {
</I>&gt;<i> +		if2_creq = (ioread32(&amp;(priv-&gt;regs)-&gt;if2_creq)) &amp;
</I>&gt;<i> +				     CAN_IF_CREQ_BUSY;
</I>&gt;<i> +		if (!if2_creq)
</I>&gt;<i> +			break;
</I>&gt;<i> +		counter--;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (!counter)
</I>&gt;<i> +		dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;IF2 BUSY Flag is set forever.\n&quot;);
</I>&gt;<i> +}
</I>
Duplicated code!

&gt;<i> +static void pch_can_set_rx_enable(struct pch_can_priv *priv, u32 buff_num,
</I>&gt;<i> +				  u32 set)
</I>&gt;<i> +{
</I>&gt;<i> +	unsigned long flags;
</I>&gt;<i> +
</I>&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> +	/*Reading the receive buffer data from RAM to Interface1 registers */
</I>
Space after /* ?

&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_GET, &amp;(priv-&gt;regs)-&gt;if1_cmask);
</I>&gt;<i> +	pch_can_check_if1_busy(priv, buff_num); /* Read from MsgRAN */
</I>&gt;<i> +
</I>&gt;<i> +	/* Setting the IF1MASK1 register to access MsgVal and RxIE bits */
</I>&gt;<i> +	iowrite32((CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL),
</I>&gt;<i> +		  (&amp;(priv-&gt;regs)-&gt;if1_cmask));
</I>&gt;<i> +
</I>&gt;<i> +	if (set == ENABLE) {
</I>&gt;<i> +		/* Setting the MsgVal and RxIE bits */
</I>&gt;<i> +		pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_mcont, CAN_IF_MCONT_RXIE);
</I>&gt;<i> +		pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_id2, CAN_ID_MSGVAL);
</I>&gt;<i> +
</I>&gt;<i> +	} else if (set == DISABLE) {
</I>&gt;<i> +		/* Resetting the MsgVal and RxIE bits */
</I>&gt;<i> +		pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_mcont, CAN_IF_MCONT_RXIE);
</I>&gt;<i> +		pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_id2, CAN_ID_MSGVAL);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	pch_can_check_if1_busy(priv, buff_num); /* Write to MsgRAM */
</I>&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_rx_enable_all(struct pch_can_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 i;
</I>&gt;<i> +
</I>&gt;<i> +	/* Traversing to obtain the object configured as receivers. */
</I>&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_RX)
</I>&gt;<i> +			pch_can_set_rx_enable(priv, i + 1, ENABLE);
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_rx_disable_all(struct pch_can_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 i;
</I>&gt;<i> +
</I>&gt;<i> +	/* Traversing to obtain the object configured as receivers. */
</I>&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_RX)
</I>&gt;<i> +			pch_can_set_rx_enable(priv, (i + 1), DISABLE);
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_set_tx_enable(struct pch_can_priv *priv, u32 buff_num,
</I>&gt;<i> +				 u32 set)
</I>&gt;<i> +{
</I>&gt;<i> +	unsigned long flags;
</I>&gt;<i> +
</I>&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> +	/* Reading the Msg buffer from Message RAM to Interface2 registers. */
</I>&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_GET, (&amp;(priv-&gt;regs)-&gt;if1_cmask));
</I>&gt;<i> +	pch_can_check_if1_busy(priv, buff_num);
</I>&gt;<i> +
</I>&gt;<i> +	/* Setting the IF2CMASK register for accessing the
</I>&gt;<i> +		MsgVal and TxIE bits */
</I>&gt;<i> +	iowrite32((CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL),
</I>&gt;<i> +		 (&amp;(priv-&gt;regs)-&gt;if1_cmask));
</I>&gt;<i> +
</I>&gt;<i> +	if (set == ENABLE) {
</I>&gt;<i> +		/* Setting the MsgVal and TxIE bits */
</I>&gt;<i> +		pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_mcont, CAN_IF_MCONT_TXIE);
</I>&gt;<i> +		pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_id2, CAN_ID_MSGVAL);
</I>&gt;<i> +	} else if (set == DISABLE) {
</I>&gt;<i> +		/* Resetting the MsgVal and TxIE bits. */
</I>&gt;<i> +		pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_mcont, CAN_IF_MCONT_TXIE);
</I>&gt;<i> +		pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_id2, CAN_ID_MSGVAL);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	pch_can_check_if1_busy(priv, buff_num); /* Write to MsgRAM */
</I>&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_tx_enable_all(struct pch_can_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 i;
</I>&gt;<i> +
</I>&gt;<i> +	/* Traversing to obtain the object configured as transmit object. */
</I>&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_TX)
</I>&gt;<i> +			pch_can_set_tx_enable(priv, (i + 1), ENABLE);
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_tx_disable_all(struct pch_can_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 i;
</I>&gt;<i> +
</I>&gt;<i> +	/* Traversing to obtain the object configured as transmit object. */
</I>&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_TX)
</I>&gt;<i> +			pch_can_set_tx_enable(priv, (i + 1), DISABLE);
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_get_rx_enable(struct pch_can_priv *priv, u32 buff_num,
</I>&gt;<i> +				 u32 *enable)
</I>&gt;<i> +{
</I>&gt;<i> +	unsigned long flags;
</I>&gt;<i> +
</I>&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_GET, (&amp;(priv-&gt;regs)-&gt;if1_cmask));
</I>&gt;<i> +	pch_can_check_if1_busy(priv, buff_num);
</I>&gt;<i> +
</I>&gt;<i> +	if (((ioread32(&amp;(priv-&gt;regs)-&gt;if1_id2)) &amp; CAN_ID_MSGVAL) &amp;&amp;
</I>&gt;<i> +			((ioread32(&amp;(priv-&gt;regs)-&gt;if1_mcont)) &amp;
</I>&gt;<i> +			CAN_IF_MCONT_RXIE))
</I>&gt;<i> +		*enable = ENABLE;
</I>&gt;<i> +	else
</I>&gt;<i> +		*enable = DISABLE;
</I>&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_get_tx_enable(struct pch_can_priv *priv, u32 buff_num,
</I>&gt;<i> +				 u32 *enable)
</I>&gt;<i> +{
</I>&gt;<i> +	unsigned long flags;
</I>&gt;<i> +
</I>&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_GET, &amp;(priv-&gt;regs)-&gt;if1_cmask);
</I>&gt;<i> +	pch_can_check_if1_busy(priv, buff_num);
</I>&gt;<i> +
</I>&gt;<i> +	if (((ioread32(&amp;(priv-&gt;regs)-&gt;if1_id2)) &amp; CAN_ID_MSGVAL) &amp;&amp;
</I>&gt;<i> +			((ioread32(&amp;(priv-&gt;regs)-&gt;if1_mcont)) &amp;
</I>&gt;<i> +			CAN_IF_MCONT_TXIE)) {
</I>&gt;<i> +		*enable = ENABLE;
</I>&gt;<i> +	} else {
</I>&gt;<i> +		*enable = DISABLE;
</I>&gt;<i> +	}
</I>&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pch_can_int_pending(struct pch_can_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	return ioread32(&amp;(priv-&gt;regs)-&gt;intr) &amp; 0xffff;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_set_rx_buffer_link(struct pch_can_priv *priv,
</I>&gt;<i> +				       u32 buffer_num, u32 set)
</I>&gt;<i> +{
</I>&gt;<i> +	unsigned long flags;
</I>&gt;<i> +
</I>&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_GET, &amp;(priv-&gt;regs)-&gt;if1_cmask);
</I>&gt;<i> +	pch_can_check_if1_busy(priv, buffer_num);
</I>&gt;<i> +	iowrite32((CAN_CMASK_RDWR | CAN_CMASK_CTRL), &amp;(priv-&gt;regs)-&gt;if1_cmask);
</I>&gt;<i> +	if (set == ENABLE)
</I>&gt;<i> +		pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_mcont, CAN_IF_MCONT_EOB);
</I>&gt;<i> +	else
</I>&gt;<i> +		pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_mcont, CAN_IF_MCONT_EOB);
</I>&gt;<i> +
</I>&gt;<i> +	pch_can_check_if1_busy(priv, buffer_num);
</I>&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_get_rx_buffer_link(struct pch_can_priv *priv,
</I>&gt;<i> +				       u32 buffer_num, u32 *link)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 reg_val;
</I>
Really needed?

&gt;<i> +	unsigned long flags;
</I>&gt;<i> +
</I>&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_GET, &amp;(priv-&gt;regs)-&gt;if1_cmask);
</I>&gt;<i> +	pch_can_check_if1_busy(priv, buffer_num);
</I>&gt;<i> +
</I>&gt;<i> +	reg_val = ioread32(&amp;(priv-&gt;regs)-&gt;if1_mcont);
</I>&gt;<i> +	if (reg_val &amp; CAN_IF_MCONT_EOB)
</I>&gt;<i> +		*link = DISABLE;
</I>&gt;<i> +	else
</I>&gt;<i> +		*link = ENABLE;
</I>&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_clear_buffers(struct pch_can_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 i;
</I>&gt;<i> +	u32 rx_buff_num;
</I>&gt;<i> +	u32 tx_buff_num;
</I>
Really needed?

&gt;<i> +
</I>&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_SET, &amp;(priv-&gt;regs)-&gt;if1_cmask);
</I>&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_SET, &amp;(priv-&gt;regs)-&gt;if2_cmask);
</I>&gt;<i> +	iowrite32(0xffff, &amp;(priv-&gt;regs)-&gt;if1_mask1);
</I>&gt;<i> +	iowrite32(0xffff, &amp;(priv-&gt;regs)-&gt;if1_mask2);
</I>&gt;<i> +	iowrite32(0xffff, &amp;(priv-&gt;regs)-&gt;if2_mask1);
</I>&gt;<i> +	iowrite32(0xffff, &amp;(priv-&gt;regs)-&gt;if2_mask2);
</I>&gt;<i> +
</I>&gt;<i> +	iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if1_id1);
</I>&gt;<i> +	iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if1_id2);
</I>&gt;<i> +	iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if2_id1);
</I>&gt;<i> +	iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if2_id2);
</I>&gt;<i> +	iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if1_mcont);
</I>&gt;<i> +	iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if2_mcont);
</I>&gt;<i> +	iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if1_dataa1);
</I>&gt;<i> +	iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if1_dataa2);
</I>&gt;<i> +	iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if1_datab1);
</I>&gt;<i> +	iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if1_datab2);
</I>&gt;<i> +	iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if2_dataa1);
</I>&gt;<i> +	iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if2_dataa2);
</I>&gt;<i> +	iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if2_datab1);
</I>&gt;<i> +	iowrite32(0x0, &amp;(priv-&gt;regs)-&gt;if2_datab2);
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 1; i &lt;= (MAX_MSG_OBJ / 2); i++) {
</I>&gt;<i> +		rx_buff_num = 2 * i;
</I>&gt;<i> +		tx_buff_num = (2 * i) - 1;
</I>&gt;<i> +
</I>&gt;<i> +		iowrite32(rx_buff_num, &amp;(priv-&gt;regs)-&gt;if1_creq);
</I>&gt;<i> +		iowrite32(tx_buff_num, &amp;(priv-&gt;regs)-&gt;if2_creq);
</I>&gt;<i> +
</I>&gt;<i> +		mdelay(10);
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 i;
</I>&gt;<i> +	unsigned long flags;
</I>&gt;<i> +
</I>&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> +	/* For accssing MsgVal, ID and EOB bit */
</I>&gt;<i> +	iowrite32((CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL),
</I>&gt;<i> +		 (&amp;(priv-&gt;regs)-&gt;if1_cmask));
</I>&gt;<i> +	iowrite32((CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL),
</I>&gt;<i> +		 (&amp;(priv-&gt;regs)-&gt;if2_cmask));
</I>&gt;<i> +	iowrite32(0x0, (&amp;(priv-&gt;regs)-&gt;if1_id1));
</I>&gt;<i> +	iowrite32(0x0, (&amp;(priv-&gt;regs)-&gt;if1_id2));
</I>&gt;<i> +
</I>&gt;<i> +	/* Resetting DIR bit for reception */
</I>&gt;<i> +	iowrite32(0x0, (&amp;(priv-&gt;regs)-&gt;if2_id1));
</I>&gt;<i> +
</I>&gt;<i> +	/* Setting DIR bit for transmission */
</I>&gt;<i> +	iowrite32((CAN_ID2_DIR | (0x7ff &lt;&lt; 2)),
</I>&gt;<i> +				(&amp;(priv-&gt;regs)-&gt;if2_id2));
</I>&gt;<i> +
</I>&gt;<i> +	/* Setting EOB bit for receiver */
</I>&gt;<i> +	iowrite32(CAN_IF_MCONT_EOB, &amp;(priv-&gt;regs)-&gt;if1_mcont);
</I>&gt;<i> +
</I>&gt;<i> +	/* Setting EOB bit for transmitter */
</I>&gt;<i> +	iowrite32(CAN_IF_MCONT_EOB, (&amp;(priv-&gt;regs)-&gt;if2_mcont));
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_RX)
</I>&gt;<i> +			pch_can_check_if1_busy(priv, i + 1);
</I>&gt;<i> +		else if (priv-&gt;msg_obj[i] == MSG_OBJ_TX)
</I>&gt;<i> +			pch_can_check_if2_busy(priv, i + 1);
</I>&gt;<i> +		else
</I>&gt;<i> +			dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;Invalid OBJ\n&quot;);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_RX) {
</I>&gt;<i> +			iowrite32(CAN_CMASK_RX_TX_GET,
</I>&gt;<i> +				&amp;(priv-&gt;regs)-&gt;if1_cmask);
</I>&gt;<i> +			pch_can_check_if1_busy(priv, i+1);
</I>&gt;<i> +
</I>&gt;<i> +			pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_id2, 0x1fff);
</I>&gt;<i> +			pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_id2, CAN_ID2_XTD);
</I>
Could'nt it be set just by one call?

&gt;<i> +			iowrite32(0, (&amp;(priv-&gt;regs)-&gt;if1_id1));
</I>&gt;<i> +			pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_id2, 0);
</I>&gt;<i> +			pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_mcont,
</I>&gt;<i> +					CAN_IF_MCONT_UMASK);
</I>&gt;<i> +			pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if2_mcont,
</I>&gt;<i> +					CAN_IF_MCONT_UMASK);
</I>&gt;<i> +
</I>&gt;<i> +			iowrite32(0, &amp;(priv-&gt;regs)-&gt;if1_mask1);
</I>&gt;<i> +			pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_mask2, 0x1fff);
</I>&gt;<i> +			pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_mask2,
</I>&gt;<i> +					  CAN_MASK2_MDIR_MXTD);
</I>&gt;<i> +
</I>&gt;<i> +			iowrite32(0, &amp;(priv-&gt;regs)-&gt;if2_mask1);
</I>&gt;<i> +			pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if2_mask2, 0x1fff);
</I>&gt;<i> +
</I>&gt;<i> +			/* Setting CMASK for writing */
</I>&gt;<i> +			iowrite32((CAN_CMASK_RDWR | CAN_CMASK_MASK |
</I>&gt;<i> +				   CAN_CMASK_ARB | CAN_CMASK_CTRL),
</I>&gt;<i> +				  (&amp;(priv-&gt;regs)-&gt;if1_cmask));
</I>&gt;<i> +
</I>&gt;<i> +			pch_can_check_if1_busy(priv, i+1);
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_open(struct pch_can_priv *priv)
</I>
Probably pch_can_init is the better name.

&gt;<i> +{
</I>&gt;<i> +	/* Stopping the Can device. */
</I>&gt;<i> +	pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;<i> +
</I>&gt;<i> +	/* Clearing all the message object buffers. */
</I>&gt;<i> +	pch_can_clear_buffers(priv);
</I>&gt;<i> +
</I>&gt;<i> +	/* Configuring the respective message object as either rx/tx object. */
</I>&gt;<i> +	pch_can_config_rx_tx_buffers(priv);
</I>&gt;<i> +
</I>&gt;<i> +	/* Enabling all receive objects. */
</I>&gt;<i> +	pch_can_rx_enable_all(priv);
</I>&gt;<i> +
</I>&gt;<i> +	/* Enabling all transmit objects. */
</I>&gt;<i> +	pch_can_tx_enable_all(priv);
</I>&gt;<i> +
</I>&gt;<i> +	/* Enabling the interrupts. */
</I>&gt;<i> +	pch_can_set_int_enables(priv, PCH_CAN_ALL);
</I>&gt;<i> +
</I>&gt;<i> +	/* Setting the CAN to run mode. */
</I>&gt;<i> +	pch_can_set_run_mode(priv, PCH_CAN_RUN);
</I>
Hm, you start the controller here... more later.

&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_release(struct pch_can_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	/* Stooping the CAN device. */
</I>&gt;<i> +	pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;<i> +
</I>&gt;<i> +	/* Disabling the interrupts. */
</I>&gt;<i> +	pch_can_set_int_enables(priv, PCH_CAN_NONE);
</I>&gt;<i> +
</I>&gt;<i> +	/* Disabling all the receive object. */
</I>&gt;<i> +	pch_can_rx_disable_all(priv);
</I>&gt;<i> +
</I>&gt;<i> +	/* Disabling all the transmit object. */
</I>&gt;<i> +	pch_can_tx_disable_all(priv);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/* This function clears interrupt(s) from the CAN device. */
</I>&gt;<i> +static void pch_can_int_clr(struct pch_can_priv *priv, u32 mask)
</I>&gt;<i> +{
</I>&gt;<i> +	if (mask == CAN_STATUS_INT) {
</I>&gt;<i> +		ioread32(&amp;(priv-&gt;regs)-&gt;stat);
</I>&gt;<i> +		return;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Clear interrupt for transmit object */
</I>&gt;<i> +	if (priv-&gt;msg_obj[mask - 1] == MSG_OBJ_TX) {
</I>&gt;<i> +		/* Setting CMASK for clearing interrupts for
</I>&gt;<i> +					 frame transmission. */
</I>&gt;<i> +		iowrite32((CAN_CMASK_RDWR | CAN_CMASK_CTRL | CAN_CMASK_ARB),
</I>&gt;<i> +					(&amp;(priv-&gt;regs)-&gt;if2_cmask));
</I>&gt;<i> +
</I>&gt;<i> +		/* Resetting the ID registers. */
</I>&gt;<i> +		pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if2_id2,
</I>&gt;<i> +			       (CAN_ID2_DIR | (0x7ff &lt;&lt; 2)));
</I>&gt;<i> +		iowrite32(0x0, (&amp;(priv-&gt;regs)-&gt;if2_id1));
</I>&gt;<i> +
</I>&gt;<i> +		/* Claring NewDat, TxRqst &amp; IntPnd */
</I>&gt;<i> +		pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if2_mcont,
</I>&gt;<i> +				  (CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND |
</I>&gt;<i> +				   CAN_IF_MCONT_TXRQXT));
</I>&gt;<i> +		pch_can_check_if2_busy(priv, mask);
</I>&gt;<i> +	}
</I>&gt;<i> +	/* Clear interrupt for receive object */
</I>&gt;<i> +	else if (priv-&gt;msg_obj[mask - 1] == MSG_OBJ_RX) {
</I>
Should be &quot;} else if ...&quot;

&gt;<i> +		/* Setting CMASK for clearing the reception interrupts. */
</I>&gt;<i> +		iowrite32((CAN_CMASK_RDWR | CAN_CMASK_CTRL | CAN_CMASK_ARB),
</I>&gt;<i> +			  (&amp;(priv-&gt;regs)-&gt;if2_cmask));
</I>&gt;<i> +
</I>&gt;<i> +		/* Clearing the Dir bit. */
</I>&gt;<i> +		pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if2_id2, CAN_ID2_DIR);
</I>&gt;<i> +
</I>&gt;<i> +		/* Clearing NewDat &amp; IntPnd */
</I>&gt;<i> +		pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if2_mcont,
</I>&gt;<i> +				  (CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND));
</I>&gt;<i> +
</I>&gt;<i> +		pch_can_check_if2_busy(priv, mask);
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pch_can_get_buffer_status(struct pch_can_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 reg_treq1;
</I>&gt;<i> +	u32 reg_treq2;
</I>
Really needed?

&gt;<i> +
</I>&gt;<i> +	/* Reading the transmission request registers. */
</I>&gt;<i> +	reg_treq1 = (ioread32(&amp;(priv-&gt;regs)-&gt;treq1) &amp; 0xffff);
</I>&gt;<i> +	reg_treq2 = ((ioread32(&amp;(priv-&gt;regs)-&gt;treq2) &amp; 0xffff) &lt;&lt; 16);
</I>&gt;<i> +
</I>&gt;<i> +	return reg_treq1 | reg_treq2;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_reset(struct pch_can_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	/* write to sw reset register */
</I>&gt;<i> +	iowrite32(1, (&amp;(priv-&gt;regs)-&gt;srst));
</I>&gt;<i> +	iowrite32(0, (&amp;(priv-&gt;regs)-&gt;srst));
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_msg_obj(struct net_device *ndev, u32 status)
</I>&gt;<i> +{
</I>&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	u32 reg;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	canid_t id;
</I>&gt;<i> +	u32 ide;
</I>&gt;<i> +	u32 rtr;
</I>&gt;<i> +	int i, j;
</I>&gt;<i> +	struct net_device_stats *stats = &amp;(priv-&gt;ndev-&gt;stats);
</I>&gt;<i> +
</I>&gt;<i> +	/* Reading the messsage object from the Message RAM */
</I>&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_GET, &amp;(priv-&gt;regs)-&gt;if2_cmask);
</I>&gt;<i> +	pch_can_check_if2_busy(priv, status);
</I>&gt;<i> +
</I>&gt;<i> +	/* Reading the MCONT register. */
</I>&gt;<i> +	reg = ioread32(&amp;(priv-&gt;regs)-&gt;if2_mcont);
</I>&gt;<i> +	reg &amp;= 0xffff;
</I>&gt;<i> +
</I>&gt;<i> +	/* If MsgLost bit set. */
</I>&gt;<i> +	if (reg &amp; CAN_IF_MCONT_MSGLOST) {
</I>&gt;<i> +		pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if2_mcont,
</I>&gt;<i> +				  CAN_IF_MCONT_MSGLOST);
</I>&gt;<i> +		dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;Msg Obj is overwritten.\n&quot;);
</I>
That should create an error message as well.

&gt;<i> +	}
</I>&gt;<i> +	/* Read the direction bit for determination of remote frame . */
</I>&gt;<i> +	rtr = (ioread32((&amp;(priv-&gt;regs)-&gt;if2_id2)) &amp;  CAN_ID2_DIR);
</I>&gt;<i> +	/* Clearing interrupts. */
</I>&gt;<i> +	pch_can_int_clr(priv, status);
</I>&gt;<i> +	/* Hanlde reception interrupt */
</I>
Typo!

&gt;<i> +	if (priv-&gt;msg_obj[status - 1] == MSG_OBJ_RX) {
</I>&gt;<i> +		if (!(reg &amp; CAN_IF_MCONT_NEWDAT)) {
</I>&gt;<i> +			dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;MCONT_NEWDAT isn't SET.\n&quot;);
</I>&gt;<i> +			return;
</I>&gt;<i> +		}
</I>&gt;<i> +		skb = alloc_can_skb(priv-&gt;ndev, &amp;cf);
</I>&gt;<i> +		if (!skb)
</I>&gt;<i> +			return;
</I>&gt;<i> +
</I>&gt;<i> +		ide = ((ioread32(&amp;(priv-&gt;regs)-&gt;if2_id2)) &amp; CAN_ID2_XTD) &gt;&gt; 14;
</I>&gt;<i> +		if (ide) {
</I>&gt;<i> +			id = (ioread32(&amp;(priv-&gt;regs)-&gt;if2_id1) &amp; 0xffff);
</I>&gt;<i> +			id |= (((ioread32(&amp;(priv-&gt;regs)-&gt;if2_id2)) &amp;
</I>&gt;<i> +					    0x1fff) &lt;&lt; 16);
</I>&gt;<i> +			cf-&gt;can_id = (id &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			id = (((ioread32(&amp;(priv-&gt;regs)-&gt;if2_id2)) &amp;
</I>&gt;<i> +					  (CAN_SFF_MASK &lt;&lt; 2)) &gt;&gt; 2);
</I>&gt;<i> +			cf-&gt;can_id = (id &amp; CAN_SFF_MASK);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		if (rtr) {
</I>&gt;<i> +			cf-&gt;can_dlc = 0;
</I>&gt;<i> +			cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			cf-&gt;can_dlc = ((ioread32(&amp;(priv-&gt;regs)-&gt;if2_mcont)) &amp;
</I>&gt;<i> +						   0x0f);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		/* Reading back the data. */
</I>&gt;<i> +		for (i = 0, j = 0; i &lt; cf-&gt;can_dlc; j++) {
</I>&gt;<i> +			reg = ioread32(&amp;(priv-&gt;regs)-&gt;if2_dataa1 + j*4);
</I>&gt;<i> +			cf-&gt;data[i++] = cpu_to_le32(reg &amp; 0xff);
</I>&gt;<i> +			if (i == cf-&gt;can_dlc)
</I>&gt;<i> +				break;
</I>&gt;<i> +			cf-&gt;data[i++] = cpu_to_le32((reg &amp; (0xff &lt;&lt; 8)) &gt;&gt; 8);
</I>&gt;<i> +		}
</I>&gt;<i> +		netif_rx(skb);
</I>&gt;<i> +		stats-&gt;rx_packets++;
</I>&gt;<i> +		stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +	} else if (priv-&gt;msg_obj[status - 1] == MSG_OBJ_TX) {
</I>&gt;<i> +		/* Hanlde transmission interrupt */
</I>
Typo!

&gt;<i> +		can_get_echo_skb(priv-&gt;ndev, 0);
</I>&gt;<i> +		netif_wake_queue(priv-&gt;ndev);
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_error(struct net_device *ndev, u32 status)
</I>&gt;<i> +{
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	u32 errc;
</I>&gt;<i> +	struct net_device_stats *stats = &amp;(priv-&gt;ndev-&gt;stats);
</I>&gt;<i> +
</I>&gt;<i> +	skb = alloc_can_err_skb(ndev, &amp;cf);
</I>&gt;<i> +	if (!skb) {
</I>&gt;<i> +		dev_err(&amp;ndev-&gt;dev, &quot;%s -&gt; No memory.\n&quot;, __func__);
</I>
Please drop the error message.

&gt;<i> +		return;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (status &amp; PCH_BUS_OFF) {
</I>&gt;<i> +		if (!priv-&gt;bus_off_interrupt) {
</I>&gt;<i> +			pch_can_tx_disable_all(priv);
</I>&gt;<i> +			pch_can_rx_disable_all(priv);
</I>&gt;<i> +
</I>&gt;<i> +			priv-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +			cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> +			can_bus_off(ndev);
</I>&gt;<i> +
</I>&gt;<i> +			priv-&gt;bus_off_interrupt = 1;
</I>&gt;<i> +			pch_can_set_run_mode(priv, PCH_CAN_RUN);
</I>
Hm, you automatically restart the contoller after a bus-off. That's not
the intended behaviour. It's up to the user to define how and when the
device should recover from bus-off. For further information read

<A HREF="http://lxr.linux.no/#linux+v2.6.35.7/Documentation/networking/can.txt#L767">http://lxr.linux.no/#linux+v2.6.35.7/Documentation/networking/can.txt#L767</A>

&gt;<i> +		}
</I>&gt;<i> +	}
</I>
&gt;<i> +	/* Warning interrupt. */
</I>&gt;<i> +	if (status &amp; PCH_EWARN) {
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_ERROR_WARNING;
</I>&gt;<i> +		priv-&gt;can.can_stats.error_warning++;
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +		errc = ioread32((&amp;(priv-&gt;regs)-&gt;errc));
</I>&gt;<i> +		if (((errc &amp; CAN_REC) &gt;&gt; 8) &gt; 96)
</I>&gt;<i> +			cf-&gt;data[1] |= CAN_ERR_CRTL_RX_WARNING;
</I>&gt;<i> +		if ((errc &amp; CAN_TEC) &gt; 96)
</I>&gt;<i> +			cf-&gt;data[1] |= CAN_ERR_CRTL_TX_WARNING;
</I>&gt;<i> +		dev_warn(&amp;ndev-&gt;dev, &quot;%s -&gt; Warning interrupt.\n&quot;, __func__);
</I>&gt;<i> +	}
</I>&gt;<i> +	/* Error passive interrupt. */
</I>&gt;<i> +	if (status &amp; PCH_EPASSIV) {
</I>&gt;<i> +		priv-&gt;can.can_stats.error_passive++;
</I>&gt;<i> +		priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +		errc = ioread32((&amp;(priv-&gt;regs)-&gt;errc));
</I>&gt;<i> +		if (((errc &amp; CAN_REC) &gt;&gt; 8) &gt; 127)
</I>&gt;<i> +			cf-&gt;data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> +		if ((errc &amp; CAN_TEC) &gt; 127)
</I>&gt;<i> +			cf-&gt;data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
</I>&gt;<i> +		dev_err(&amp;ndev-&gt;dev,
</I>&gt;<i> +			&quot;%s -&gt; Error interrupt.\n&quot;, __func__);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (status &amp; PCH_STUF_ERR)
</I>&gt;<i> +		cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;<i> +
</I>&gt;<i> +	if (status &amp; PCH_FORM_ERR)
</I>&gt;<i> +		cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;<i> +
</I>&gt;<i> +	if (status &amp; PCH_ACK_ERR)
</I>&gt;<i> +		cf-&gt;data[2] |= CAN_ERR_PROT_LOC_ACK | CAN_ERR_PROT_LOC_ACK_DEL;
</I>&gt;<i> +
</I>&gt;<i> +	if ((status &amp; PCH_BIT1_ERR) || (status &amp; PCH_BIT0_ERR))
</I>&gt;<i> +		cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
</I>&gt;<i> +
</I>&gt;<i> +	if (status &amp; PCH_CRC_ERR)
</I>&gt;<i> +		cf-&gt;data[2] |= CAN_ERR_PROT_LOC_CRC_SEQ |
</I>&gt;<i> +				CAN_ERR_PROT_LOC_CRC_DEL;
</I>&gt;<i> +
</I>&gt;<i> +	if (status &amp; PCH_LEC_ALL)
</I>&gt;<i> +		iowrite32(status | PCH_LEC_ALL,
</I>&gt;<i> +			  &amp;(priv-&gt;regs)-&gt;stat);
</I>
A bit-wise test of the above values is wrong, I believe. Please use the
switch statement instead.

&gt;<i> +
</I>&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;<i> +	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +	netif_rx(skb);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static irqreturn_t pch_can_handler(int irq, void *dev_id)
</I>
A better name making clear that it's the interrupt handler would be nice.

&gt;<i> +{
</I>&gt;<i> +	u32 int_stat;
</I>&gt;<i> +	u32 reg_stat;
</I>&gt;<i> +	struct net_device *ndev = (struct net_device *)dev_id;
</I>&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	int_stat = pch_can_int_pending(priv);
</I>&gt;<i> +
</I>&gt;<i> +	if (!int_stat)
</I>&gt;<i> +		return IRQ_NONE;
</I>&gt;<i> +
</I>&gt;<i> +	if (int_stat == CAN_STATUS_INT) {
</I>&gt;<i> +		reg_stat = ioread32((&amp;(priv-&gt;regs)-&gt;stat));
</I>&gt;<i> +		if (reg_stat &amp; (PCH_BUS_OFF | PCH_LEC_ALL | PCH_EWARN |
</I>&gt;<i> +								PCH_EPASSIV)) {
</I>&gt;<i> +			if ((reg_stat &amp; PCH_LEC_ALL) != PCH_LEC_ALL)
</I>&gt;<i> +				pch_can_error(ndev, reg_stat);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		/* Recover from Bus Off */
</I>&gt;<i> +		if (!reg_stat &amp;&amp; priv-&gt;bus_off_interrupt) {
</I>&gt;<i> +			priv-&gt;bus_off_interrupt = 0;
</I>&gt;<i> +			pch_can_tx_enable_all(priv);
</I>&gt;<i> +			pch_can_rx_enable_all(priv);
</I>&gt;<i> +
</I>&gt;<i> +			dev_info(&amp;priv-&gt;ndev-&gt;dev, &quot;BusOff stage recovered.\n&quot;);
</I>
Bogus bus-off handling, more later...

&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		if (reg_stat &amp; PCH_RX_OK)
</I>&gt;<i> +			pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;stat, PCH_RX_OK);
</I>&gt;<i> +
</I>&gt;<i> +		if (reg_stat &amp; PCH_TX_OK)
</I>&gt;<i> +			pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;stat, PCH_TX_OK);
</I>
Could be done in one call, I think.

&gt;<i> +		int_stat = pch_can_int_pending(priv);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if ((int_stat &gt; 0) &amp;&amp; (int_stat &lt;= MAX_MSG_OBJ))
</I>&gt;<i> +		pch_can_msg_obj(ndev, int_stat);
</I>&gt;<i> +
</I>&gt;<i> +	return IRQ_HANDLED;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pch_set_bittiming(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	const struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> +	u32 curr_mode;
</I>&gt;<i> +	u32 reg1; /* CANBIT */
</I>&gt;<i> +	u32 reg2; /* BEPE */
</I>
Why not &quot;u32 canbit&quot; then?

&gt;<i> +	u32 brp;
</I>&gt;<i> +
</I>&gt;<i> +	pch_can_get_run_mode(priv, &amp;curr_mode);
</I>&gt;<i> +	if (curr_mode == PCH_CAN_RUN)
</I>&gt;<i> +		pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>
The device is stopped when this function is called. Please remove.

&gt;<i> +
</I>&gt;<i> +	/* Setting the CCE bit for accessing the Can Timing register. */
</I>&gt;<i> +	pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_CCE);
</I>&gt;<i> +
</I>&gt;<i> +	brp = (bt-&gt;tq) / (1000000/PCH_CAN_CLK) - 1;
</I>&gt;<i> +	reg1 = brp &amp; MSK_BITT_BRP;
</I>&gt;<i> +	reg1 |= (bt-&gt;sjw - 1) &lt;&lt; BIT_BITT_SJW;
</I>&gt;<i> +	reg1 |= (bt-&gt;phase_seg1 + bt-&gt;prop_seg - 1) &lt;&lt; BIT_BITT_TSEG1;
</I>&gt;<i> +	reg1 |= (bt-&gt;phase_seg2 - 1) &lt;&lt; BIT_BITT_TSEG2;
</I>&gt;<i> +	reg2 = (brp &amp; MSK_BRPE_BRPE) &gt;&gt; BIT_BRPE_BRPE;
</I>&gt;<i> +	iowrite32(reg1, (&amp;(priv-&gt;regs)-&gt;bitt));
</I>&gt;<i> +	iowrite32(reg2, (&amp;(priv-&gt;regs)-&gt;brpe));
</I>&gt;<i> +	pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;cont, CAN_CTRL_CCE);
</I>&gt;<i> +
</I>&gt;<i> +	if (curr_mode == PCH_CAN_RUN)
</I>&gt;<i> +		pch_can_set_run_mode(priv, PCH_CAN_RUN);
</I>
Ditto.

&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void pch_can_start(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	if (priv-&gt;can.state != CAN_STATE_STOPPED)
</I>&gt;<i> +		pch_can_reset(priv);
</I>&gt;<i> +
</I>&gt;<i> +	pch_set_bittiming(ndev);
</I>&gt;<i> +	pch_can_set_optmode(priv);
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>
Hm, where do you really start the controller. I'm missing
pch_can_set_run_mode(priv, PCH_CAN_RUN).

&gt;<i> +	return;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pch_can_do_set_mode(struct net_device *ndev, enum can_mode mode)
</I>&gt;<i> +{
</I>&gt;<i> +	int ret = 0;
</I>&gt;<i> +
</I>&gt;<i> +	switch (mode) {
</I>&gt;<i> +	case CAN_MODE_START:
</I>&gt;<i> +		pch_can_start(ndev);
</I>&gt;<i> +		netif_wake_queue(ndev);
</I>&gt;<i> +		break;
</I>&gt;<i> +	default:
</I>&gt;<i> +		ret = -EOPNOTSUPP;
</I>&gt;<i> +		break;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return ret;
</I>&gt;<i> +}
</I>
Note that this function is called when the device will recover from bus-off.

&gt;<i> +static int pch_can_get_state(const struct net_device *ndev,
</I>&gt;<i> +			     enum can_state *state)
</I>&gt;<i> +{
</I>&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	*state = priv-&gt;can.state;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>
There is no need for that function as the driver handles state changes
in the interrupt handler.

&gt;<i> +static int pch_open(struct net_device *ndev)
</I>
That's confussing! Please use the prefix pch_can throught this file.

&gt;<i> +{
</I>&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	int retval;
</I>&gt;<i> +
</I>&gt;<i> +	pch_can_open(priv);
</I>
This function already starts the controller, which is too *early*.

&gt;<i> +
</I>&gt;<i> +	retval = pci_enable_msi(priv-&gt;dev);
</I>&gt;<i> +	if (retval) {
</I>&gt;<i> +		dev_err(&amp;ndev-&gt;dev, &quot;Unable to allocate MSI ret=%d\n&quot;, retval);
</I>&gt;<i> +		goto pci_en_msi_err;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Regsitering the interrupt. */
</I>&gt;<i> +	retval = request_irq(priv-&gt;dev-&gt;irq, pch_can_handler, IRQF_SHARED,
</I>&gt;<i> +			     ndev-&gt;name, ndev);
</I>&gt;<i> +	if (retval) {
</I>&gt;<i> +		dev_err(&amp;ndev-&gt;dev, &quot;request_irq failed.\n&quot;);
</I>&gt;<i> +		goto req_irq_err;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Assuming that no bus off interrupt. */
</I>&gt;<i> +	priv-&gt;bus_off_interrupt = 0;
</I>&gt;<i> +
</I>&gt;<i> +	/* Open common can device */
</I>&gt;<i> +	retval = open_candev(ndev);
</I>&gt;<i> +	if (retval) {
</I>&gt;<i> +		dev_err(ndev-&gt;dev.parent, &quot;open_candev() failed %d\n&quot;, retval);
</I>&gt;<i> +		goto err_open_candev;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	pch_can_start(ndev);
</I>
Thde above function should finally start the controller.

&gt;<i> +	netif_start_queue(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +err_open_candev:
</I>&gt;<i> +	free_irq(priv-&gt;dev-&gt;irq, ndev);
</I>&gt;<i> +req_irq_err:
</I>&gt;<i> +	pci_disable_msi(priv-&gt;dev);
</I>&gt;<i> +pci_en_msi_err:
</I>&gt;<i> +	pch_can_release(priv);
</I>&gt;<i> +
</I>&gt;<i> +	return retval;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pch_close(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	netif_stop_queue(ndev);
</I>&gt;<i> +	pch_can_release(priv);
</I>&gt;<i> +	free_irq(priv-&gt;dev-&gt;irq, ndev);
</I>&gt;<i> +	pci_disable_msi(priv-&gt;dev);
</I>&gt;<i> +	close_candev(ndev);
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pch_get_free_msg_obj(struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	u32 buffer_status = 0;
</I>&gt;<i> +	u32 tx_disable_counter = 0;
</I>&gt;<i> +	u32 tx_buffer_avail = 0;
</I>&gt;<i> +	u32 status;
</I>&gt;<i> +	s32 i;
</I>&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	/* Getting the message object status. */
</I>&gt;<i> +	buffer_status = (u32) pch_can_get_buffer_status(priv);
</I>&gt;<i> +
</I>&gt;<i> +	/* Getting the free transmit message object. */
</I>&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> +		if ((priv-&gt;msg_obj[i] == MSG_OBJ_TX)) {
</I>&gt;<i> +			/* Checking whether the object is enabled. */
</I>&gt;<i> +			pch_can_get_tx_enable(priv, i + 1, &amp;status);
</I>&gt;<i> +			if (status == ENABLE) {
</I>&gt;<i> +				if (!((buffer_status &gt;&gt; i) &amp; 1)) {
</I>&gt;<i> +					tx_buffer_avail = (i + 1);
</I>&gt;<i> +					break;
</I>&gt;<i> +				}
</I>&gt;<i> +			} else {
</I>&gt;<i> +				tx_disable_counter++;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* If no transmit object available. */
</I>&gt;<i> +	if (!tx_buffer_avail) {
</I>&gt;<i> +		/* If no object is enabled. */
</I>&gt;<i> +		if ((tx_disable_counter == PCH_TX_OBJ_NUM)) {
</I>&gt;<i> +			dev_err(&amp;ndev-&gt;dev, &quot;All tx buffers are disabled.\n&quot;);
</I>&gt;<i> +			return -EPERM;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			dev_err(&amp;ndev-&gt;dev, &quot;%s:No tx buf free.\n&quot;, __func__);
</I>&gt;<i> +			return -PCH_CAN_NO_TX_BUFF;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +	return tx_buffer_avail;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
</I>&gt;<i> +{
</I>&gt;<i> +	canid_t id;
</I>&gt;<i> +	u32 id1 = 0;
</I>&gt;<i> +	u32 id2 = 0;
</I>
Need these values to be preset?

&gt;<i> +	u32 run_mode;
</I>&gt;<i> +	u32 i, j;
</I>
It's common to use type &quot;int&quot; for the usual incrementer value... as you
do in other places as well. Please check!

&gt;<i> +	unsigned long flags;
</I>&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> +	struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> +	u32 tx_buffer_avail = 0;
</I>&gt;<i> +
</I>&gt;<i> +	if (can_dropped_invalid_skb(ndev, skb))
</I>&gt;<i> +		return NETDEV_TX_OK;
</I>&gt;<i> +
</I>&gt;<i> +	/* Getting the current CAN mode. */
</I>&gt;<i> +	pch_can_get_run_mode(priv, &amp;run_mode);
</I>&gt;<i> +	if (run_mode != PCH_CAN_RUN) {
</I>&gt;<i> +		dev_err(&amp;ndev-&gt;dev, &quot;CAN stopped on transmit attempt.\n&quot;);
</I>&gt;<i> +		return -EPERM;
</I>&gt;<i> +	}
</I>
Can this happen? I think this check can be removed. Anyway, -EPERM is
not a valid return value for that function.

&gt;<i> +
</I>&gt;<i> +	tx_buffer_avail = pch_get_free_msg_obj(ndev);
</I>&gt;<i> +	if (tx_buffer_avail &lt; 0)
</I>&gt;<i> +		return tx_buffer_avail;
</I>
Wrong return value?

&gt;<i> +
</I>&gt;<i> +	/* Attaining the lock. */
</I>&gt;<i> +	spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> +
</I>&gt;<i> +	/* Reading the Msg Obj from the Msg RAM to the Interface register. */
</I>&gt;<i> +	iowrite32(CAN_CMASK_RX_TX_GET, &amp;(priv-&gt;regs)-&gt;if1_cmask);
</I>&gt;<i> +	pch_can_check_if1_busy(priv, tx_buffer_avail);
</I>&gt;<i> +
</I>&gt;<i> +	/* Setting the CMASK register. */
</I>&gt;<i> +	pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_cmask, CAN_CMASK_ALL);
</I>&gt;<i> +
</I>&gt;<i> +	/* If ID extended is set. */
</I>&gt;<i> +	if (cf-&gt;can_id &amp; CAN_EFF_FLAG) {
</I>&gt;<i> +		id =  cf-&gt;can_id &amp; CAN_EFF_MASK;
</I>&gt;<i> +		id1 = id &amp; 0xffff;
</I>&gt;<i> +		id2 = ((id &amp; (0x1fff &lt;&lt; 16)) &gt;&gt; 16) | CAN_ID2_XTD;
</I>
Please use some more macro definitions for the sake of readability.

&gt;<i> +	} else {
</I>&gt;<i> +		id =  cf-&gt;can_id &amp; CAN_SFF_MASK;
</I>&gt;<i> +		id1 = 0;
</I>&gt;<i> +		id2 = ((id &amp; CAN_SFF_MASK) &lt;&lt; 2);
</I>&gt;<i> +	}
</I>&gt;<i> +	pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_id1, 0xffff);
</I>&gt;<i> +	pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_id2, 0x1fff | CAN_ID2_XTD);
</I>&gt;<i> +	pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_id1, id1);
</I>&gt;<i> +	pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_id2, id2);
</I>&gt;<i> +
</I>&gt;<i> +	/* If remote frame has to be transmitted.. */
</I>&gt;<i> +	if (cf-&gt;can_id &amp; CAN_RTR_FLAG)
</I>&gt;<i> +		pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_id2, CAN_ID2_DIR);
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0, j = 0; i &lt; cf-&gt;can_dlc; j++) {
</I>&gt;<i> +		iowrite32(le32_to_cpu(cf-&gt;data[i++]),
</I>&gt;<i> +			 (&amp;(priv-&gt;regs)-&gt;if1_dataa1) + j*4);
</I>&gt;<i> +		if (i == cf-&gt;can_dlc)
</I>&gt;<i> +			break;
</I>&gt;<i> +		iowrite32(le32_to_cpu(cf-&gt;data[i++] &lt;&lt; 8),
</I>&gt;<i> +			 (&amp;(priv-&gt;regs)-&gt;if1_dataa1) + j*4);
</I>&gt;<i> +	}
</I>&gt;<i> +	can_put_echo_skb(skb, ndev, 0);
</I>&gt;<i> +
</I>&gt;<i> +	/* Updating the size of the data. */
</I>&gt;<i> +	pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_mcont, 0x0f);
</I>&gt;<i> +	pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_mcont, cf-&gt;can_dlc);
</I>&gt;<i> +
</I>&gt;<i> +	/* Clearing IntPend, NewDat &amp; TxRqst */
</I>&gt;<i> +	pch_can_bit_clear(&amp;(priv-&gt;regs)-&gt;if1_mcont,
</I>&gt;<i> +			   (CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND |
</I>&gt;<i> +			    CAN_IF_MCONT_TXRQXT));
</I>&gt;<i> +
</I>&gt;<i> +	/* Setting NewDat, TxRqst bits */
</I>&gt;<i> +	pch_can_bit_set(&amp;(priv-&gt;regs)-&gt;if1_mcont,
</I>&gt;<i> +			 (CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_TXRQXT));
</I>&gt;<i> +
</I>&gt;<i> +	pch_can_check_if1_busy(priv, tx_buffer_avail);
</I>&gt;<i> +	spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> +
</I>&gt;<i> +	stats-&gt;tx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +	stats-&gt;tx_packets++;
</I>
That shoould be incremented when the TX done interrupt is handled.

&gt;<i> +
</I>&gt;<i> +	return NETDEV_TX_OK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static const struct net_device_ops pch_can_netdev_ops = {
</I>&gt;<i> +	.ndo_open		= pch_open,
</I>&gt;<i> +	.ndo_stop		= pch_close,
</I>&gt;<i> +	.ndo_start_xmit		= pch_xmit,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static void __devexit pch_can_remove(struct pci_dev *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev = pci_get_drvdata(pdev);
</I>&gt;<i> +	struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> +
</I>&gt;<i> +	unregister_candev(priv-&gt;ndev);
</I>&gt;<i> +	free_candev(priv-&gt;ndev);
</I>&gt;<i> +	pci_iounmap(pdev, priv-&gt;base);
</I>&gt;<i> +	pci_release_regions(pdev);
</I>&gt;<i> +	pci_disable_device(pdev);
</I>&gt;<i> +	pci_set_drvdata(pdev, NULL);
</I>&gt;<i> +	pch_can_reset(priv);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#ifdef CONFIG_PM
</I>&gt;<i> +static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
</I>&gt;<i> +{
</I>&gt;<i> +	int i;			/* Counter variable. */
</I>&gt;<i> +	int retval;		/* Return value. */
</I>&gt;<i> +	u32 buf_stat;	/* Variable for reading the transmit buffer status. */
</I>&gt;<i> +	u32 counter = 0xFFFFFF;
</I>&gt;<i> +
</I>&gt;<i> +	struct net_device *dev = pci_get_drvdata(pdev);
</I>&gt;<i> +	struct pch_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> +
</I>&gt;<i> +	/* Stop the CAN controller */
</I>&gt;<i> +	pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;<i> +
</I>&gt;<i> +	/* Indicate that we are aboutto/in suspend */
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_SLEEPING;
</I>&gt;<i> +
</I>&gt;<i> +	/* Waiting for all transmission to complete. */
</I>&gt;<i> +	while (counter) {
</I>&gt;<i> +		buf_stat = pch_can_get_buffer_status(priv);
</I>&gt;<i> +		if (!buf_stat)
</I>&gt;<i> +			break;
</I>&gt;<i> +		counter--;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (!counter)
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;%s -&gt; Transmission time out.\n&quot;, __func__);
</I>
Timeout without defined delay!

&gt;<i> +	/* Save interrupt configuration and then disable them */
</I>&gt;<i> +	pch_can_get_int_enables(priv, &amp;(priv-&gt;int_enables));
</I>&gt;<i> +	pch_can_set_int_enables(priv, PCH_CAN_DISABLE);
</I>&gt;<i> +
</I>&gt;<i> +	/* Save Tx buffer enable state */
</I>&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_TX)
</I>&gt;<i> +			pch_can_get_tx_enable(priv, (i + 1),
</I>&gt;<i> +					      &amp;(priv-&gt;tx_enable[i]));
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Disable all Transmit buffers */
</I>&gt;<i> +	pch_can_tx_disable_all(priv);
</I>&gt;<i> +
</I>&gt;<i> +	/* Save Rx buffer enable state */
</I>&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_RX) {
</I>&gt;<i> +			pch_can_get_rx_enable(priv, (i + 1),
</I>&gt;<i> +						&amp;(priv-&gt;rx_enable[i]));
</I>&gt;<i> +			pch_can_get_rx_buffer_link(priv, (i + 1),
</I>&gt;<i> +						&amp;(priv-&gt;rx_link[i]));
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Disable all Receive buffers */
</I>&gt;<i> +	pch_can_rx_disable_all(priv);
</I>&gt;<i> +	retval = pci_save_state(pdev);
</I>&gt;<i> +	if (retval) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;pci_save_state failed.\n&quot;);
</I>&gt;<i> +	} else {
</I>&gt;<i> +		pci_enable_wake(pdev, PCI_D3hot, 0);
</I>&gt;<i> +		pci_disable_device(pdev);
</I>&gt;<i> +		pci_set_power_state(pdev, pci_choose_state(pdev, state));
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return retval;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int pch_can_resume(struct pci_dev *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	int i;			/* Counter variable. */
</I>&gt;<i> +	int retval;		/* Return variable. */
</I>&gt;<i> +	struct net_device *dev = pci_get_drvdata(pdev);
</I>&gt;<i> +	struct pch_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> +
</I>&gt;<i> +	pci_set_power_state(pdev, PCI_D0);
</I>&gt;<i> +	pci_restore_state(pdev);
</I>&gt;<i> +	retval = pci_enable_device(pdev);
</I>&gt;<i> +	if (retval) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;pci_enable_device failed.\n&quot;);
</I>&gt;<i> +		return retval;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	pci_enable_wake(pdev, PCI_D3hot, 0);
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +
</I>&gt;<i> +	/* Disabling all interrupts. */
</I>&gt;<i> +	pch_can_set_int_enables(priv, PCH_CAN_DISABLE);
</I>&gt;<i> +
</I>&gt;<i> +	/* Setting the CAN device in Stop Mode. */
</I>&gt;<i> +	pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;<i> +
</I>&gt;<i> +	/* Configuring the transmit and receive buffers. */
</I>&gt;<i> +	pch_can_config_rx_tx_buffers(priv);
</I>&gt;<i> +
</I>&gt;<i> +	/* Restore the CAN state */
</I>&gt;<i> +	pch_set_bittiming(dev);
</I>&gt;<i> +
</I>&gt;<i> +	/* Listen/Active */
</I>&gt;<i> +	pch_can_set_optmode(priv);
</I>&gt;<i> +
</I>&gt;<i> +	/* Enabling the transmit buffer. */
</I>&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_TX) {
</I>&gt;<i> +			pch_can_set_tx_enable(priv, i + 1,
</I>&gt;<i> +					      priv-&gt;tx_enable[i]);
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Configuring the receive buffer and enabling them. */
</I>&gt;<i> +	for (i = 0; i &lt; PCH_OBJ_NUM; i++) {
</I>&gt;<i> +		if (priv-&gt;msg_obj[i] == MSG_OBJ_RX) {
</I>&gt;<i> +			/* Restore buffer link */
</I>&gt;<i> +			pch_can_set_rx_buffer_link(priv, i + 1,
</I>&gt;<i> +						   priv-&gt;rx_link[i]);
</I>&gt;<i> +
</I>&gt;<i> +			/* Restore buffer enables */
</I>&gt;<i> +			pch_can_set_rx_enable(priv, i + 1, priv-&gt;rx_enable[i]);
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Enable CAN Interrupts */
</I>&gt;<i> +	pch_can_set_int_custom(priv);
</I>&gt;<i> +
</I>&gt;<i> +	/* Restore Run Mode */
</I>&gt;<i> +	pch_can_set_run_mode(priv, PCH_CAN_RUN);
</I>&gt;<i> +
</I>&gt;<i> +	return retval;
</I>&gt;<i> +}
</I>
Are the suspend and resume functions tested?

&gt;<i> +#else
</I>&gt;<i> +#define pch_can_suspend NULL
</I>&gt;<i> +#define pch_can_resume NULL
</I>&gt;<i> +#endif
</I>
Add empty line here

&gt;<i> +static int __devinit pch_can_probe(struct pci_dev *pdev,
</I>&gt;<i> +				   const struct pci_device_id *id)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *ndev;
</I>&gt;<i> +	struct pch_can_priv *priv;
</I>&gt;<i> +	int rc;
</I>&gt;<i> +	int index;
</I>&gt;<i> +	void __iomem *addr;
</I>&gt;<i> +
</I>&gt;<i> +	rc = pci_enable_device(pdev);
</I>&gt;<i> +	if (rc) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;Failed pci_enable_device %d\n&quot;, rc);
</I>&gt;<i> +		goto probe_exit_endev;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	rc = pci_request_regions(pdev, KBUILD_MODNAME);
</I>&gt;<i> +	if (rc) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;Failed pci_request_regions %d\n&quot;, rc);
</I>&gt;<i> +		goto probe_exit_pcireq;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	addr = pci_iomap(pdev, 1, 0);
</I>&gt;<i> +	if (!addr) {
</I>&gt;<i> +		rc = -EIO;
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;Failed pci_iomap\n&quot;);
</I>&gt;<i> +		goto probe_exit_ipmap;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	ndev = alloc_candev(sizeof(struct pch_can_priv), 1);
</I>&gt;<i> +	if (!ndev) {
</I>&gt;<i> +		rc = -ENOMEM;
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;Failed alloc_candev\n&quot;);
</I>&gt;<i> +		goto probe_exit_alloc_candev;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	priv = netdev_priv(ndev);
</I>&gt;<i> +	priv-&gt;ndev = ndev;
</I>&gt;<i> +	priv-&gt;base = addr;
</I>&gt;<i> +	priv-&gt;regs = addr;
</I>&gt;<i> +	priv-&gt;dev = pdev;
</I>&gt;<i> +	priv-&gt;can.bittiming_const = &amp;pch_can_bittiming_const;
</I>&gt;<i> +	priv-&gt;can.do_set_mode = pch_can_do_set_mode;
</I>&gt;<i> +	priv-&gt;can.do_get_state = pch_can_get_state;
</I>
Not needed! See above.

Could you please also implement do_get_berr_counter().

&gt;<i> +	priv-&gt;can.ctrlmode_supported = CAN_CTRLMODE_LISTENONLY |
</I>&gt;<i> +				       CAN_CTRLMODE_LOOPBACK;
</I>&gt;<i> +	ndev-&gt;irq = pdev-&gt;irq;
</I>&gt;<i> +	ndev-&gt;flags |= IFF_ECHO;
</I>&gt;<i> +
</I>&gt;<i> +	pci_set_drvdata(pdev, ndev);
</I>&gt;<i> +	SET_NETDEV_DEV(ndev, &amp;pdev-&gt;dev);
</I>&gt;<i> +	ndev-&gt;netdev_ops = &amp;pch_can_netdev_ops;
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.clock.freq = PCH_CAN_CLK * 1000; /* Hz to KHz) */
</I>&gt;<i> +	for (index = 0; index &lt; PCH_RX_OBJ_NUM;)
</I>&gt;<i> +		priv-&gt;msg_obj[index++] = MSG_OBJ_RX;
</I>&gt;<i> +
</I>&gt;<i> +	for (index = index;  index &lt; PCH_OBJ_NUM;)
</I>&gt;<i> +		priv-&gt;msg_obj[index++] = MSG_OBJ_TX;
</I>&gt;<i> +
</I>&gt;<i> +	rc = register_candev(ndev);
</I>&gt;<i> +	if (rc) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;Failed register_candev %d\n&quot;, rc);
</I>&gt;<i> +		goto probe_exit_reg_candev;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +probe_exit_reg_candev:
</I>&gt;<i> +	free_candev(ndev);
</I>&gt;<i> +probe_exit_alloc_candev:
</I>&gt;<i> +	pci_iounmap(pdev, addr);
</I>&gt;<i> +probe_exit_ipmap:
</I>&gt;<i> +	pci_release_regions(pdev);
</I>&gt;<i> +probe_exit_pcireq:
</I>&gt;<i> +	pci_disable_device(pdev);
</I>&gt;<i> +probe_exit_endev:
</I>&gt;<i> +	return rc;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static struct pci_driver pch_can_pcidev = {
</I>&gt;<i> +	.name = KBUILD_MODNAME,
</I>&gt;<i> +	.id_table = pch_can_pcidev_id,
</I>&gt;<i> +	.probe = pch_can_probe,
</I>&gt;<i> +	.remove = __devexit_p(pch_can_remove),
</I>&gt;<i> +	.suspend = pch_can_suspend,
</I>&gt;<i> +	.resume = pch_can_resume,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int __init pch_can_pci_init(void)
</I>&gt;<i> +{
</I>&gt;<i> +	return pci_register_driver(&amp;pch_can_pcidev);
</I>&gt;<i> +}
</I>&gt;<i> +module_init(pch_can_pci_init);
</I>&gt;<i> +
</I>&gt;<i> +static void __exit pch_can_pci_exit(void)
</I>&gt;<i> +{
</I>&gt;<i> +	pci_unregister_driver(&amp;pch_can_pcidev);
</I>&gt;<i> +}
</I>&gt;<i> +module_exit(pch_can_pci_exit);
</I>&gt;<i> +
</I>&gt;<i> +MODULE_DESCRIPTION(&quot;Controller Area Network Driver&quot;);
</I>&gt;<i> +MODULE_LICENSE(&quot;GPL&quot;);
</I>
GPL v2 ?

&gt;<i> +MODULE_VERSION(&quot;0.94&quot;);
</I>&gt;<i> +MODULE_DEVICE_TABLE(pci, pch_can_pcidev_id);
</I>
Please add it below the declaration of pch_can_pcidev_id.

In this driver you are using just *one* RX object. This means that the
CPU must handle new messages as quickly as possible otherwise message
losses will happen, right?. For sure, this will not make user's happy.
Any chance to use more RX objects in FIFO mode?

Thanks,

Wolfgang.

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004682.html">[MeeGo-Dev][PATCH v3] Topcliff: Update PCH_CAN driver to 2.6.35
</A></li>
	<LI>Next message: <A HREF="004685.html">[MeeGo-Dev][PATCH v3] Topcliff: Update PCH_CAN driver to 2.6.35
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4684">[ date ]</a>
              <a href="thread.html#4684">[ thread ]</a>
              <a href="subject.html#4684">[ subject ]</a>
              <a href="author.html#4684">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
