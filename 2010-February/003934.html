<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH net-next-2.6 v2] can: mcp251x: Move to threaded interrupts	instead of workqueues.
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2010-February/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20net-next-2.6%20v2%5D%20can%3A%20mcp251x%3A%20Move%20to%20threaded%20interrupts%0A%09instead%20of%20workqueues.&In-Reply-To=%3Ccabda6421001312310o60843addq8d27e9be019e9efd%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003937.html">
   <LINK REL="Next"  HREF="003936.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH net-next-2.6 v2] can: mcp251x: Move to threaded interrupts	instead of workqueues.</H1>
    <B>christian pellegrin</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20net-next-2.6%20v2%5D%20can%3A%20mcp251x%3A%20Move%20to%20threaded%20interrupts%0A%09instead%20of%20workqueues.&In-Reply-To=%3Ccabda6421001312310o60843addq8d27e9be019e9efd%40mail.gmail.com%3E"
       TITLE="[PATCH net-next-2.6 v2] can: mcp251x: Move to threaded interrupts	instead of workqueues.">chripell at fsfe.org
       </A><BR>
    <I>Mon Feb  1 08:10:55 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003937.html">write: No buffer space available
</A></li>
        <LI>Next message: <A HREF="003936.html">write: No buffer space available
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3934">[ date ]</a>
              <a href="thread.html#3934">[ thread ]</a>
              <a href="subject.html#3934">[ subject ]</a>
              <a href="author.html#3934">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Please wait a moment for this patch because I had some reports of
possible problems.


On Sun, Jan 31, 2010 at 6:43 PM, Christian Pellegrin &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">chripell at fsfe.org</A>&gt; wrote:
&gt;<i> This patch addresses concerns about efficiency of handling incoming
</I>&gt;<i> packets. Handling of interrupts is done in a threaded interrupt handler
</I>&gt;<i> which has a smaller latency than workqueues. This change needed a rework
</I>&gt;<i> of the locking scheme that was much simplified. Some other (more or less
</I>&gt;<i> longstanding) bugs are fixed: utilization of just half of the RX
</I>&gt;<i> buffers, useless wait for interrupt on open, more reliable reset
</I>&gt;<i> sequence. The MERR interrupt is not used anymore: it overloads the CPU
</I>&gt;<i> in bus-off state without any additional information.
</I>&gt;<i>
</I>&gt;<i> Signed-off-by: Christian Pellegrin &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">chripell at fsfe.org</A>&gt;
</I>&gt;<i> ---
</I>&gt;<i> &#160;drivers/net/can/mcp251x.c | &#160;415 ++++++++++++++++++++++-----------------------
</I>&gt;<i> &#160;1 files changed, 202 insertions(+), 213 deletions(-)
</I>&gt;<i>
</I>&gt;<i> diff --git a/drivers/net/can/mcp251x.c b/drivers/net/can/mcp251x.c
</I>&gt;<i> index bbe186b..884d309 100644
</I>&gt;<i> --- a/drivers/net/can/mcp251x.c
</I>&gt;<i> +++ b/drivers/net/can/mcp251x.c
</I>&gt;<i> @@ -180,6 +180,14 @@
</I>&gt;<i> &#160;#define RXBEID0_OFF 4
</I>&gt;<i> &#160;#define RXBDLC_OFF &#160;5
</I>&gt;<i> &#160;#define RXBDAT_OFF &#160;6
</I>&gt;<i> +#define RXFSIDH(n) ((n) * 4)
</I>&gt;<i> +#define RXFSIDL(n) ((n) * 4 + 1)
</I>&gt;<i> +#define RXFEID8(n) ((n) * 4 + 2)
</I>&gt;<i> +#define RXFEID0(n) ((n) * 4 + 3)
</I>&gt;<i> +#define RXMSIDH(n) ((n) * 4 + 0x20)
</I>&gt;<i> +#define RXMSIDL(n) ((n) * 4 + 0x21)
</I>&gt;<i> +#define RXMEID8(n) ((n) * 4 + 0x22)
</I>&gt;<i> +#define RXMEID0(n) ((n) * 4 + 0x23)
</I>&gt;<i>
</I>&gt;<i> &#160;#define GET_BYTE(val, byte) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;\
</I>&gt;<i> &#160; &#160; &#160; &#160;(((val) &gt;&gt; ((byte) * 8)) &amp; 0xff)
</I>&gt;<i> @@ -219,7 +227,8 @@ struct mcp251x_priv {
</I>&gt;<i> &#160; &#160; &#160; &#160;struct net_device *net;
</I>&gt;<i> &#160; &#160; &#160; &#160;struct spi_device *spi;
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; struct mutex spi_lock; /* SPI buffer lock */
</I>&gt;<i> + &#160; &#160; &#160; struct mutex mcp_lock; /* SPI device lock */
</I>&gt;<i> +
</I>&gt;<i> &#160; &#160; &#160; &#160;u8 *spi_tx_buf;
</I>&gt;<i> &#160; &#160; &#160; &#160;u8 *spi_rx_buf;
</I>&gt;<i> &#160; &#160; &#160; &#160;dma_addr_t spi_tx_dma;
</I>&gt;<i> @@ -227,11 +236,11 @@ struct mcp251x_priv {
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;struct sk_buff *tx_skb;
</I>&gt;<i> &#160; &#160; &#160; &#160;int tx_len;
</I>&gt;<i> +
</I>&gt;<i> &#160; &#160; &#160; &#160;struct workqueue_struct *wq;
</I>&gt;<i> &#160; &#160; &#160; &#160;struct work_struct tx_work;
</I>&gt;<i> - &#160; &#160; &#160; struct work_struct irq_work;
</I>&gt;<i> - &#160; &#160; &#160; struct completion awake;
</I>&gt;<i> - &#160; &#160; &#160; int wake;
</I>&gt;<i> + &#160; &#160; &#160; struct work_struct restart_work;
</I>&gt;<i> +
</I>&gt;<i> &#160; &#160; &#160; &#160;int force_quit;
</I>&gt;<i> &#160; &#160; &#160; &#160;int after_suspend;
</I>&gt;<i> &#160;#define AFTER_SUSPEND_UP 1
</I>&gt;<i> @@ -245,7 +254,8 @@ static void mcp251x_clean(struct net_device *net)
</I>&gt;<i> &#160;{
</I>&gt;<i> &#160; &#160; &#160; &#160;struct mcp251x_priv *priv = netdev_priv(net);
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; net-&gt;stats.tx_errors++;
</I>&gt;<i> + &#160; &#160; &#160; if (priv-&gt;tx_skb || priv-&gt;tx_len)
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; net-&gt;stats.tx_errors++;
</I>&gt;<i> &#160; &#160; &#160; &#160;if (priv-&gt;tx_skb)
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;dev_kfree_skb(priv-&gt;tx_skb);
</I>&gt;<i> &#160; &#160; &#160; &#160;if (priv-&gt;tx_len)
</I>&gt;<i> @@ -300,16 +310,12 @@ static u8 mcp251x_read_reg(struct spi_device *spi, uint8_t reg)
</I>&gt;<i> &#160; &#160; &#160; &#160;struct mcp251x_priv *priv = dev_get_drvdata(&amp;spi-&gt;dev);
</I>&gt;<i> &#160; &#160; &#160; &#160;u8 val = 0;
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; mutex_lock(&amp;priv-&gt;spi_lock);
</I>&gt;<i> -
</I>&gt;<i> &#160; &#160; &#160; &#160;priv-&gt;spi_tx_buf[0] = INSTRUCTION_READ;
</I>&gt;<i> &#160; &#160; &#160; &#160;priv-&gt;spi_tx_buf[1] = reg;
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;mcp251x_spi_trans(spi, 3);
</I>&gt;<i> &#160; &#160; &#160; &#160;val = priv-&gt;spi_rx_buf[2];
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; mutex_unlock(&amp;priv-&gt;spi_lock);
</I>&gt;<i> -
</I>&gt;<i> &#160; &#160; &#160; &#160;return val;
</I>&gt;<i> &#160;}
</I>&gt;<i>
</I>&gt;<i> @@ -317,15 +323,11 @@ static void mcp251x_write_reg(struct spi_device *spi, u8 reg, uint8_t val)
</I>&gt;<i> &#160;{
</I>&gt;<i> &#160; &#160; &#160; &#160;struct mcp251x_priv *priv = dev_get_drvdata(&amp;spi-&gt;dev);
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; mutex_lock(&amp;priv-&gt;spi_lock);
</I>&gt;<i> -
</I>&gt;<i> &#160; &#160; &#160; &#160;priv-&gt;spi_tx_buf[0] = INSTRUCTION_WRITE;
</I>&gt;<i> &#160; &#160; &#160; &#160;priv-&gt;spi_tx_buf[1] = reg;
</I>&gt;<i> &#160; &#160; &#160; &#160;priv-&gt;spi_tx_buf[2] = val;
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;mcp251x_spi_trans(spi, 3);
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; mutex_unlock(&amp;priv-&gt;spi_lock);
</I>&gt;<i> &#160;}
</I>&gt;<i>
</I>&gt;<i> &#160;static void mcp251x_write_bits(struct spi_device *spi, u8 reg,
</I>&gt;<i> @@ -333,16 +335,12 @@ static void mcp251x_write_bits(struct spi_device *spi, u8 reg,
</I>&gt;<i> &#160;{
</I>&gt;<i> &#160; &#160; &#160; &#160;struct mcp251x_priv *priv = dev_get_drvdata(&amp;spi-&gt;dev);
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; mutex_lock(&amp;priv-&gt;spi_lock);
</I>&gt;<i> -
</I>&gt;<i> &#160; &#160; &#160; &#160;priv-&gt;spi_tx_buf[0] = INSTRUCTION_BIT_MODIFY;
</I>&gt;<i> &#160; &#160; &#160; &#160;priv-&gt;spi_tx_buf[1] = reg;
</I>&gt;<i> &#160; &#160; &#160; &#160;priv-&gt;spi_tx_buf[2] = mask;
</I>&gt;<i> &#160; &#160; &#160; &#160;priv-&gt;spi_tx_buf[3] = val;
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;mcp251x_spi_trans(spi, 4);
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; mutex_unlock(&amp;priv-&gt;spi_lock);
</I>&gt;<i> &#160;}
</I>&gt;<i>
</I>&gt;<i> &#160;static void mcp251x_hw_tx_frame(struct spi_device *spi, u8 *buf,
</I>&gt;<i> @@ -358,10 +356,8 @@ static void mcp251x_hw_tx_frame(struct spi_device *spi, u8 *buf,
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_write_reg(spi, TXBCTRL(tx_buf_idx) + i,
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;buf[i]);
</I>&gt;<i> &#160; &#160; &#160; &#160;} else {
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; mutex_lock(&amp;priv-&gt;spi_lock);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;memcpy(priv-&gt;spi_tx_buf, buf, TXBDAT_OFF + len);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_spi_trans(spi, TXBDAT_OFF + len);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; mutex_unlock(&amp;priv-&gt;spi_lock);
</I>&gt;<i> &#160; &#160; &#160; &#160;}
</I>&gt;<i> &#160;}
</I>&gt;<i>
</I>&gt;<i> @@ -408,13 +404,9 @@ static void mcp251x_hw_rx_frame(struct spi_device *spi, u8 *buf,
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;for (; i &lt; (RXBDAT_OFF + len); i++)
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;buf[i] = mcp251x_read_reg(spi, RXBCTRL(buf_idx) + i);
</I>&gt;<i> &#160; &#160; &#160; &#160;} else {
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; mutex_lock(&amp;priv-&gt;spi_lock);
</I>&gt;<i> -
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;priv-&gt;spi_tx_buf[RXBCTRL_OFF] = INSTRUCTION_READ_RXB(buf_idx);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_spi_trans(spi, SPI_TRANSFER_BUF_LEN);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;memcpy(buf, priv-&gt;spi_rx_buf, SPI_TRANSFER_BUF_LEN);
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; mutex_unlock(&amp;priv-&gt;spi_lock);
</I>&gt;<i> &#160; &#160; &#160; &#160;}
</I>&gt;<i> &#160;}
</I>&gt;<i>
</I>&gt;<i> @@ -467,21 +459,6 @@ static void mcp251x_hw_sleep(struct spi_device *spi)
</I>&gt;<i> &#160; &#160; &#160; &#160;mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_SLEEP);
</I>&gt;<i> &#160;}
</I>&gt;<i>
</I>&gt;<i> -static void mcp251x_hw_wakeup(struct spi_device *spi)
</I>&gt;<i> -{
</I>&gt;<i> - &#160; &#160; &#160; struct mcp251x_priv *priv = dev_get_drvdata(&amp;spi-&gt;dev);
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; priv-&gt;wake = 1;
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; /* Can only wake up by generating a wake-up interrupt. */
</I>&gt;<i> - &#160; &#160; &#160; mcp251x_write_bits(spi, CANINTE, CANINTE_WAKIE, CANINTE_WAKIE);
</I>&gt;<i> - &#160; &#160; &#160; mcp251x_write_bits(spi, CANINTF, CANINTF_WAKIF, CANINTF_WAKIF);
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; /* Wait until the device is awake */
</I>&gt;<i> - &#160; &#160; &#160; if (!wait_for_completion_timeout(&amp;priv-&gt;awake, HZ))
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; dev_err(&amp;spi-&gt;dev, &quot;MCP251x didn't wake-up\n&quot;);
</I>&gt;<i> -}
</I>&gt;<i> -
</I>&gt;<i> &#160;static netdev_tx_t mcp251x_hard_start_xmit(struct sk_buff *skb,
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; struct net_device *net)
</I>&gt;<i> &#160;{
</I>&gt;<i> @@ -490,7 +467,6 @@ static netdev_tx_t mcp251x_hard_start_xmit(struct sk_buff *skb,
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;if (priv-&gt;tx_skb || priv-&gt;tx_len) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;dev_warn(&amp;spi-&gt;dev, &quot;hard_xmit called while tx busy\n&quot;);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; netif_stop_queue(net);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return NETDEV_TX_BUSY;
</I>&gt;<i> &#160; &#160; &#160; &#160;}
</I>&gt;<i>
</I>&gt;<i> @@ -511,12 +487,13 @@ static int mcp251x_do_set_mode(struct net_device *net, enum can_mode mode)
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;switch (mode) {
</I>&gt;<i> &#160; &#160; &#160; &#160;case CAN_MODE_START:
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_clean(net);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;/* We have to delay work since SPI I/O may sleep */
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;priv-&gt;restart_tx = 1;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (priv-&gt;can.restart_ms == 0)
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;priv-&gt;after_suspend = AFTER_SUSPEND_RESTART;
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; queue_work(priv-&gt;wq, &amp;priv-&gt;irq_work);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; queue_work(priv-&gt;wq, &amp;priv-&gt;restart_work);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;
</I>&gt;<i> &#160; &#160; &#160; &#160;default:
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return -EOPNOTSUPP;
</I>&gt;<i> @@ -525,7 +502,7 @@ static int mcp251x_do_set_mode(struct net_device *net, enum can_mode mode)
</I>&gt;<i> &#160; &#160; &#160; &#160;return 0;
</I>&gt;<i> &#160;}
</I>&gt;<i>
</I>&gt;<i> -static void mcp251x_set_normal_mode(struct spi_device *spi)
</I>&gt;<i> +static int mcp251x_set_normal_mode(struct spi_device *spi)
</I>&gt;<i> &#160;{
</I>&gt;<i> &#160; &#160; &#160; &#160;struct mcp251x_priv *priv = dev_get_drvdata(&amp;spi-&gt;dev);
</I>&gt;<i> &#160; &#160; &#160; &#160;unsigned long timeout;
</I>&gt;<i> @@ -533,8 +510,7 @@ static void mcp251x_set_normal_mode(struct spi_device *spi)
</I>&gt;<i> &#160; &#160; &#160; &#160;/* Enable interrupts */
</I>&gt;<i> &#160; &#160; &#160; &#160;mcp251x_write_reg(spi, CANINTE,
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;CANINTE_ERRIE | CANINTE_TX2IE | CANINTE_TX1IE |
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; CANINTE_TX0IE | CANINTE_RX1IE | CANINTE_RX0IE |
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; CANINTF_MERRF);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; CANINTE_TX0IE | CANINTE_RX1IE | CANINTE_RX0IE);
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LOOPBACK) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;/* Put device into loopback mode */
</I>&gt;<i> @@ -555,11 +531,12 @@ static void mcp251x_set_normal_mode(struct spi_device *spi)
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (time_after(jiffies, timeout)) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;dev_err(&amp;spi-&gt;dev, &quot;MCP251x didn't&quot;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;&quot; enter in normal mode\n&quot;);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; return;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; return -EBUSY;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i> &#160; &#160; &#160; &#160;}
</I>&gt;<i> &#160; &#160; &#160; &#160;priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> + &#160; &#160; &#160; return 0;
</I>&gt;<i> &#160;}
</I>&gt;<i>
</I>&gt;<i> &#160;static int mcp251x_do_set_bittiming(struct net_device *net)
</I>&gt;<i> @@ -590,33 +567,39 @@ static int mcp251x_setup(struct net_device *net, struct mcp251x_priv *priv,
</I>&gt;<i> &#160;{
</I>&gt;<i> &#160; &#160; &#160; &#160;mcp251x_do_set_bittiming(net);
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; /* Enable RX0-&gt;RX1 buffer roll over and disable filters */
</I>&gt;<i> - &#160; &#160; &#160; mcp251x_write_bits(spi, RXBCTRL(0),
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;RXBCTRL_BUKT | RXBCTRL_RXM0 | RXBCTRL_RXM1,
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;RXBCTRL_BUKT | RXBCTRL_RXM0 | RXBCTRL_RXM1);
</I>&gt;<i> - &#160; &#160; &#160; mcp251x_write_bits(spi, RXBCTRL(1),
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;RXBCTRL_RXM0 | RXBCTRL_RXM1,
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;RXBCTRL_RXM0 | RXBCTRL_RXM1);
</I>&gt;<i> + &#160; &#160; &#160; mcp251x_write_reg(spi, RXBCTRL(0),
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; RXBCTRL_BUKT | RXBCTRL_RXM0 | RXBCTRL_RXM1);
</I>&gt;<i> + &#160; &#160; &#160; mcp251x_write_reg(spi, RXBCTRL(1),
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; RXBCTRL_RXM0 | RXBCTRL_RXM1);
</I>&gt;<i> &#160; &#160; &#160; &#160;return 0;
</I>&gt;<i> &#160;}
</I>&gt;<i>
</I>&gt;<i> -static void mcp251x_hw_reset(struct spi_device *spi)
</I>&gt;<i> +static int mcp251x_hw_reset(struct spi_device *spi)
</I>&gt;<i> &#160;{
</I>&gt;<i> &#160; &#160; &#160; &#160;struct mcp251x_priv *priv = dev_get_drvdata(&amp;spi-&gt;dev);
</I>&gt;<i> &#160; &#160; &#160; &#160;int ret;
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; mutex_lock(&amp;priv-&gt;spi_lock);
</I>&gt;<i> + &#160; &#160; &#160; unsigned long timeout;
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;priv-&gt;spi_tx_buf[0] = INSTRUCTION_RESET;
</I>&gt;<i> -
</I>&gt;<i> &#160; &#160; &#160; &#160;ret = spi_write(spi, priv-&gt;spi_tx_buf, 1);
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; mutex_unlock(&amp;priv-&gt;spi_lock);
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; if (ret)
</I>&gt;<i> + &#160; &#160; &#160; if (ret) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;dev_err(&amp;spi-&gt;dev, &quot;reset failed: ret = %d\n&quot;, ret);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; return -EIO;
</I>&gt;<i> + &#160; &#160; &#160; }
</I>&gt;<i> +
</I>&gt;<i> &#160; &#160; &#160; &#160;/* Wait for reset to finish */
</I>&gt;<i> + &#160; &#160; &#160; timeout = jiffies + HZ;
</I>&gt;<i> &#160; &#160; &#160; &#160;mdelay(10);
</I>&gt;<i> + &#160; &#160; &#160; while ((mcp251x_read_reg(spi, CANSTAT) &amp; CANCTRL_REQOP_MASK)
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160;!= CANCTRL_REQOP_CONF) {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; schedule();
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (time_after(jiffies, timeout)) {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; dev_err(&amp;spi-&gt;dev, &quot;MCP251x didn't&quot;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &quot; enter in conf mode after reset\n&quot;);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; return -EBUSY;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; }
</I>&gt;<i> + &#160; &#160; &#160; }
</I>&gt;<i> + &#160; &#160; &#160; return 0;
</I>&gt;<i> &#160;}
</I>&gt;<i>
</I>&gt;<i> &#160;static int mcp251x_hw_probe(struct spi_device *spi)
</I>&gt;<i> @@ -640,63 +623,17 @@ static int mcp251x_hw_probe(struct spi_device *spi)
</I>&gt;<i> &#160; &#160; &#160; &#160;return (st1 == 0x80 &amp;&amp; st2 == 0x07) ? 1 : 0;
</I>&gt;<i> &#160;}
</I>&gt;<i>
</I>&gt;<i> -static irqreturn_t mcp251x_can_isr(int irq, void *dev_id)
</I>&gt;<i> -{
</I>&gt;<i> - &#160; &#160; &#160; struct net_device *net = (struct net_device *)dev_id;
</I>&gt;<i> - &#160; &#160; &#160; struct mcp251x_priv *priv = netdev_priv(net);
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; /* Schedule bottom half */
</I>&gt;<i> - &#160; &#160; &#160; if (!work_pending(&amp;priv-&gt;irq_work))
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; queue_work(priv-&gt;wq, &amp;priv-&gt;irq_work);
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; return IRQ_HANDLED;
</I>&gt;<i> -}
</I>&gt;<i> -
</I>&gt;<i> -static int mcp251x_open(struct net_device *net)
</I>&gt;<i> +static void mcp251x_open_clean(struct net_device *net)
</I>&gt;<i> &#160;{
</I>&gt;<i> &#160; &#160; &#160; &#160;struct mcp251x_priv *priv = netdev_priv(net);
</I>&gt;<i> &#160; &#160; &#160; &#160;struct spi_device *spi = priv-&gt;spi;
</I>&gt;<i> &#160; &#160; &#160; &#160;struct mcp251x_platform_data *pdata = spi-&gt;dev.platform_data;
</I>&gt;<i> - &#160; &#160; &#160; int ret;
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; ret = open_candev(net);
</I>&gt;<i> - &#160; &#160; &#160; if (ret) {
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; dev_err(&amp;spi-&gt;dev, &quot;unable to set initial baudrate!\n&quot;);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; return ret;
</I>&gt;<i> - &#160; &#160; &#160; }
</I>&gt;<i>
</I>&gt;<i> + &#160; &#160; &#160; free_irq(spi-&gt;irq, priv);
</I>&gt;<i> + &#160; &#160; &#160; mcp251x_hw_sleep(spi);
</I>&gt;<i> &#160; &#160; &#160; &#160;if (pdata-&gt;transceiver_enable)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; pdata-&gt;transceiver_enable(1);
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; priv-&gt;force_quit = 0;
</I>&gt;<i> - &#160; &#160; &#160; priv-&gt;tx_skb = NULL;
</I>&gt;<i> - &#160; &#160; &#160; priv-&gt;tx_len = 0;
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; ret = request_irq(spi-&gt;irq, mcp251x_can_isr,
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; IRQF_TRIGGER_FALLING, DEVICE_NAME, net);
</I>&gt;<i> - &#160; &#160; &#160; if (ret) {
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; dev_err(&amp;spi-&gt;dev, &quot;failed to acquire irq %d\n&quot;, spi-&gt;irq);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (pdata-&gt;transceiver_enable)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; pdata-&gt;transceiver_enable(0);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; close_candev(net);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; return ret;
</I>&gt;<i> - &#160; &#160; &#160; }
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; mcp251x_hw_wakeup(spi);
</I>&gt;<i> - &#160; &#160; &#160; mcp251x_hw_reset(spi);
</I>&gt;<i> - &#160; &#160; &#160; ret = mcp251x_setup(net, priv, spi);
</I>&gt;<i> - &#160; &#160; &#160; if (ret) {
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; free_irq(spi-&gt;irq, net);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_hw_sleep(spi);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (pdata-&gt;transceiver_enable)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; pdata-&gt;transceiver_enable(0);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; close_candev(net);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; return ret;
</I>&gt;<i> - &#160; &#160; &#160; }
</I>&gt;<i> - &#160; &#160; &#160; mcp251x_set_normal_mode(spi);
</I>&gt;<i> - &#160; &#160; &#160; netif_wake_queue(net);
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; return 0;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; pdata-&gt;transceiver_enable(0);
</I>&gt;<i> + &#160; &#160; &#160; close_candev(net);
</I>&gt;<i> &#160;}
</I>&gt;<i>
</I>&gt;<i> &#160;static int mcp251x_stop(struct net_device *net)
</I>&gt;<i> @@ -707,17 +644,19 @@ static int mcp251x_stop(struct net_device *net)
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;close_candev(net);
</I>&gt;<i>
</I>&gt;<i> + &#160; &#160; &#160; priv-&gt;force_quit = 1;
</I>&gt;<i> + &#160; &#160; &#160; free_irq(spi-&gt;irq, priv);
</I>&gt;<i> + &#160; &#160; &#160; destroy_workqueue(priv-&gt;wq);
</I>&gt;<i> + &#160; &#160; &#160; priv-&gt;wq = NULL;
</I>&gt;<i> +
</I>&gt;<i> + &#160; &#160; &#160; mutex_lock(&amp;priv-&gt;mcp_lock);
</I>&gt;<i> +
</I>&gt;<i> &#160; &#160; &#160; &#160;/* Disable and clear pending interrupts */
</I>&gt;<i> &#160; &#160; &#160; &#160;mcp251x_write_reg(spi, CANINTE, 0x00);
</I>&gt;<i> &#160; &#160; &#160; &#160;mcp251x_write_reg(spi, CANINTF, 0x00);
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; priv-&gt;force_quit = 1;
</I>&gt;<i> - &#160; &#160; &#160; free_irq(spi-&gt;irq, net);
</I>&gt;<i> - &#160; &#160; &#160; flush_workqueue(priv-&gt;wq);
</I>&gt;<i> -
</I>&gt;<i> &#160; &#160; &#160; &#160;mcp251x_write_reg(spi, TXBCTRL(0), 0);
</I>&gt;<i> - &#160; &#160; &#160; if (priv-&gt;tx_skb || priv-&gt;tx_len)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_clean(net);
</I>&gt;<i> + &#160; &#160; &#160; mcp251x_clean(net);
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;mcp251x_hw_sleep(spi);
</I>&gt;<i>
</I>&gt;<i> @@ -726,9 +665,27 @@ static int mcp251x_stop(struct net_device *net)
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i>
</I>&gt;<i> + &#160; &#160; &#160; mutex_unlock(&amp;priv-&gt;mcp_lock);
</I>&gt;<i> +
</I>&gt;<i> &#160; &#160; &#160; &#160;return 0;
</I>&gt;<i> &#160;}
</I>&gt;<i>
</I>&gt;<i> +static void mcp251x_error_skb(struct net_device *net, int can_id, int data1)
</I>&gt;<i> +{
</I>&gt;<i> + &#160; &#160; &#160; struct sk_buff *skb;
</I>&gt;<i> + &#160; &#160; &#160; struct can_frame *frame;
</I>&gt;<i> +
</I>&gt;<i> + &#160; &#160; &#160; skb = alloc_can_err_skb(net, &amp;frame);
</I>&gt;<i> + &#160; &#160; &#160; if (skb) {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; frame-&gt;can_id = can_id;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; frame-&gt;data[1] = data1;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; netif_rx(skb);
</I>&gt;<i> + &#160; &#160; &#160; } else {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; dev_err(&amp;net-&gt;dev,
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &quot;cannot allocate error skb\n&quot;);
</I>&gt;<i> + &#160; &#160; &#160; }
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> &#160;static void mcp251x_tx_work_handler(struct work_struct *ws)
</I>&gt;<i> &#160;{
</I>&gt;<i> &#160; &#160; &#160; &#160;struct mcp251x_priv *priv = container_of(ws, struct mcp251x_priv,
</I>&gt;<i> @@ -737,33 +694,32 @@ static void mcp251x_tx_work_handler(struct work_struct *ws)
</I>&gt;<i> &#160; &#160; &#160; &#160;struct net_device *net = priv-&gt;net;
</I>&gt;<i> &#160; &#160; &#160; &#160;struct can_frame *frame;
</I>&gt;<i>
</I>&gt;<i> + &#160; &#160; &#160; mutex_lock(&amp;priv-&gt;mcp_lock);
</I>&gt;<i> &#160; &#160; &#160; &#160;if (priv-&gt;tx_skb) {
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; frame = (struct can_frame *)priv-&gt;tx_skb-&gt;data;
</I>&gt;<i> -
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (priv-&gt;can.state == CAN_STATE_BUS_OFF) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_clean(net);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; netif_wake_queue(net);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; return;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; } else {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; frame = (struct can_frame *)priv-&gt;tx_skb-&gt;data;
</I>&gt;<i> +
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (frame-&gt;can_dlc &gt; CAN_FRAME_MAX_DATA_LEN)
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; frame-&gt;can_dlc = CAN_FRAME_MAX_DATA_LEN;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_hw_tx(spi, frame, 0);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; priv-&gt;tx_len = 1 + frame-&gt;can_dlc;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; can_put_echo_skb(priv-&gt;tx_skb, net, 0);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; priv-&gt;tx_skb = NULL;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (frame-&gt;can_dlc &gt; CAN_FRAME_MAX_DATA_LEN)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; frame-&gt;can_dlc = CAN_FRAME_MAX_DATA_LEN;
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_hw_tx(spi, frame, 0);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; priv-&gt;tx_len = 1 + frame-&gt;can_dlc;
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; can_put_echo_skb(priv-&gt;tx_skb, net, 0);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; priv-&gt;tx_skb = NULL;
</I>&gt;<i> &#160; &#160; &#160; &#160;}
</I>&gt;<i> + &#160; &#160; &#160; mutex_unlock(&amp;priv-&gt;mcp_lock);
</I>&gt;<i> &#160;}
</I>&gt;<i>
</I>&gt;<i> -static void mcp251x_irq_work_handler(struct work_struct *ws)
</I>&gt;<i> +static void mcp251x_restart_work_handler(struct work_struct *ws)
</I>&gt;<i> &#160;{
</I>&gt;<i> &#160; &#160; &#160; &#160;struct mcp251x_priv *priv = container_of(ws, struct mcp251x_priv,
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;irq_work);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;restart_work);
</I>&gt;<i> &#160; &#160; &#160; &#160;struct spi_device *spi = priv-&gt;spi;
</I>&gt;<i> &#160; &#160; &#160; &#160;struct net_device *net = priv-&gt;net;
</I>&gt;<i> - &#160; &#160; &#160; u8 txbnctrl;
</I>&gt;<i> - &#160; &#160; &#160; u8 intf;
</I>&gt;<i> - &#160; &#160; &#160; enum can_state new_state;
</I>&gt;<i>
</I>&gt;<i> + &#160; &#160; &#160; mutex_lock(&amp;priv-&gt;mcp_lock);
</I>&gt;<i> &#160; &#160; &#160; &#160;if (priv-&gt;after_suspend) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mdelay(10);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_hw_reset(spi);
</I>&gt;<i> @@ -772,45 +728,54 @@ static void mcp251x_irq_work_handler(struct work_struct *ws)
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_set_normal_mode(spi);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;} else if (priv-&gt;after_suspend &amp; AFTER_SUSPEND_UP) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;netif_device_attach(net);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; /* Clean since we lost tx buffer */
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (priv-&gt;tx_skb || priv-&gt;tx_len) {
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_clean(net);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; netif_wake_queue(net);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; }
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_clean(net);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_set_normal_mode(spi);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; netif_wake_queue(net);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;} else {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_hw_sleep(spi);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;priv-&gt;after_suspend = 0;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; priv-&gt;force_quit = 0;
</I>&gt;<i> &#160; &#160; &#160; &#160;}
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; if (priv-&gt;can.restart_ms == 0 &amp;&amp; priv-&gt;can.state == CAN_STATE_BUS_OFF)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; return;
</I>&gt;<i> + &#160; &#160; &#160; if (priv-&gt;restart_tx) {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; priv-&gt;restart_tx = 0;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_write_reg(spi, TXBCTRL(0), 0);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_clean(net);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; netif_wake_queue(net);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_error_skb(net, CAN_ERR_RESTARTED, 0);
</I>&gt;<i> + &#160; &#160; &#160; }
</I>&gt;<i> + &#160; &#160; &#160; mutex_unlock(&amp;priv-&gt;mcp_lock);
</I>&gt;<i> +}
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; while (!priv-&gt;force_quit &amp;&amp; !freezing(current)) {
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; u8 eflag = mcp251x_read_reg(spi, EFLG);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; int can_id = 0, data1 = 0;
</I>&gt;<i> +static irqreturn_t mcp251x_can_ist(int irq, void *dev_id)
</I>&gt;<i> +{
</I>&gt;<i> + &#160; &#160; &#160; struct mcp251x_priv *priv = dev_id;
</I>&gt;<i> + &#160; &#160; &#160; struct spi_device *spi = priv-&gt;spi;
</I>&gt;<i> + &#160; &#160; &#160; struct net_device *net = priv-&gt;net;
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_write_reg(spi, EFLG, 0x00);
</I>&gt;<i> + &#160; &#160; &#160; mutex_lock(&amp;priv-&gt;mcp_lock);
</I>&gt;<i> + &#160; &#160; &#160; while (!priv-&gt;force_quit) {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; enum can_state new_state;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; u8 intf = mcp251x_read_reg(spi, CANINTF);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; u8 eflag;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; int can_id = 0, data1 = 0;
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (priv-&gt;restart_tx) {
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; priv-&gt;restart_tx = 0;
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_write_reg(spi, TXBCTRL(0), 0);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (priv-&gt;tx_skb || priv-&gt;tx_len)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_clean(net);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; netif_wake_queue(net);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; can_id |= CAN_ERR_RESTARTED;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (intf &amp; CANINTF_RX0IF) {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_hw_rx(spi, 0);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; /* Free one buffer ASAP */
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_write_bits(spi, CANINTF, intf &amp; CANINTF_RX0IF,
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;0x00);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (priv-&gt;wake) {
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; /* Wait whilst the device wakes up */
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mdelay(10);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; priv-&gt;wake = 0;
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; }
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (intf &amp; CANINTF_RX1IF)
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_hw_rx(spi, 1);
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; intf = mcp251x_read_reg(spi, CANINTF);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_write_bits(spi, CANINTF, intf, 0x00);
</I>&gt;<i>
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; eflag = mcp251x_read_reg(spi, EFLG);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_write_reg(spi, EFLG, 0x00);
</I>&gt;<i> +
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;/* Update can state */
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (eflag &amp; EFLG_TXBO) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;new_state = CAN_STATE_BUS_OFF;
</I>&gt;<i> @@ -851,59 +816,31 @@ static void mcp251x_irq_work_handler(struct work_struct *ws)
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;priv-&gt;can.state = new_state;
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; if ((intf &amp; CANINTF_ERRIF) || (can_id &amp; CAN_ERR_RESTARTED)) {
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; struct sk_buff *skb;
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; struct can_frame *frame;
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; /* Create error frame */
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; skb = alloc_can_err_skb(net, &amp;frame);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (skb) {
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; /* Set error frame flags based on bus state */
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; frame-&gt;can_id = can_id;
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; frame-&gt;data[1] = data1;
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; /* Update net stats for overflows */
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (eflag &amp; (EFLG_RX0OVR | EFLG_RX1OVR)) {
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (eflag &amp; EFLG_RX0OVR)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; net-&gt;stats.rx_over_errors++;
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (eflag &amp; EFLG_RX1OVR)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; net-&gt;stats.rx_over_errors++;
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; frame-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; frame-&gt;data[1] |=
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; CAN_ERR_CRTL_RX_OVERFLOW;
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; }
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; netif_rx(skb);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; } else {
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; dev_info(&amp;spi-&gt;dev,
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;&quot;cannot allocate error skb\n&quot;);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (intf &amp; CANINTF_ERRIF) {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; /* Handle overflow counters */
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (eflag &amp; (EFLG_RX0OVR | EFLG_RX1OVR)) {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (eflag &amp; EFLG_RX0OVR)
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; net-&gt;stats.rx_over_errors++;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (eflag &amp; EFLG_RX1OVR)
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; net-&gt;stats.rx_over_errors++;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; can_id |= CAN_ERR_CRTL;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; data1 |= CAN_ERR_CRTL_RX_OVERFLOW;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_error_skb(net, can_id, data1);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (priv-&gt;can.state == CAN_STATE_BUS_OFF) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (priv-&gt;can.restart_ms == 0) {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; priv-&gt;force_quit = 1;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;can_bus_off(net);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_hw_sleep(spi);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; return;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; break;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (intf == 0)
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (intf &amp; CANINTF_WAKIF)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; complete(&amp;priv-&gt;awake);
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (intf &amp; CANINTF_MERRF) {
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; /* If there are pending Tx buffers, restart queue */
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; txbnctrl = mcp251x_read_reg(spi, TXBCTRL(0));
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (!(txbnctrl &amp; TXBCTRL_TXREQ)) {
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (priv-&gt;tx_skb || priv-&gt;tx_len)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_clean(net);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; netif_wake_queue(net);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; }
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; }
</I>&gt;<i> -
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (intf &amp; (CANINTF_TX2IF | CANINTF_TX1IF | CANINTF_TX0IF)) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;net-&gt;stats.tx_packets++;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;net-&gt;stats.tx_bytes += priv-&gt;tx_len - 1;
</I>&gt;<i> @@ -914,12 +851,66 @@ static void mcp251x_irq_work_handler(struct work_struct *ws)
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;netif_wake_queue(net);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (intf &amp; CANINTF_RX0IF)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_hw_rx(spi, 0);
</I>&gt;<i> + &#160; &#160; &#160; }
</I>&gt;<i> + &#160; &#160; &#160; mutex_unlock(&amp;priv-&gt;mcp_lock);
</I>&gt;<i> + &#160; &#160; &#160; return IRQ_HANDLED;
</I>&gt;<i> +}
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (intf &amp; CANINTF_RX1IF)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_hw_rx(spi, 1);
</I>&gt;<i> +static int mcp251x_open(struct net_device *net)
</I>&gt;<i> +{
</I>&gt;<i> + &#160; &#160; &#160; struct mcp251x_priv *priv = netdev_priv(net);
</I>&gt;<i> + &#160; &#160; &#160; struct spi_device *spi = priv-&gt;spi;
</I>&gt;<i> + &#160; &#160; &#160; struct mcp251x_platform_data *pdata = spi-&gt;dev.platform_data;
</I>&gt;<i> + &#160; &#160; &#160; int ret;
</I>&gt;<i> +
</I>&gt;<i> + &#160; &#160; &#160; ret = open_candev(net);
</I>&gt;<i> + &#160; &#160; &#160; if (ret) {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; dev_err(&amp;spi-&gt;dev, &quot;unable to set initial baudrate!\n&quot;);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; return ret;
</I>&gt;<i> + &#160; &#160; &#160; }
</I>&gt;<i> +
</I>&gt;<i> + &#160; &#160; &#160; mutex_lock(&amp;priv-&gt;mcp_lock);
</I>&gt;<i> + &#160; &#160; &#160; if (pdata-&gt;transceiver_enable)
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; pdata-&gt;transceiver_enable(1);
</I>&gt;<i> +
</I>&gt;<i> + &#160; &#160; &#160; priv-&gt;force_quit = 0;
</I>&gt;<i> + &#160; &#160; &#160; priv-&gt;tx_skb = NULL;
</I>&gt;<i> + &#160; &#160; &#160; priv-&gt;tx_len = 0;
</I>&gt;<i> +
</I>&gt;<i> + &#160; &#160; &#160; ret = request_threaded_irq(spi-&gt;irq, NULL, mcp251x_can_ist,
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; IRQF_TRIGGER_FALLING, DEVICE_NAME, priv);
</I>&gt;<i> + &#160; &#160; &#160; if (ret) {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; dev_err(&amp;spi-&gt;dev, &quot;failed to acquire irq %d\n&quot;, spi-&gt;irq);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (pdata-&gt;transceiver_enable)
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; pdata-&gt;transceiver_enable(0);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; close_candev(net);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; goto open_unlock;
</I>&gt;<i> + &#160; &#160; &#160; }
</I>&gt;<i> +
</I>&gt;<i> + &#160; &#160; &#160; priv-&gt;wq = create_freezeable_workqueue(&quot;mcp251x_wq&quot;);
</I>&gt;<i> + &#160; &#160; &#160; INIT_WORK(&amp;priv-&gt;tx_work, mcp251x_tx_work_handler);
</I>&gt;<i> + &#160; &#160; &#160; INIT_WORK(&amp;priv-&gt;restart_work, mcp251x_restart_work_handler);
</I>&gt;<i> +
</I>&gt;<i> + &#160; &#160; &#160; ret = mcp251x_hw_reset(spi);
</I>&gt;<i> + &#160; &#160; &#160; if (ret) {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_open_clean(net);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; goto open_unlock;
</I>&gt;<i> + &#160; &#160; &#160; }
</I>&gt;<i> + &#160; &#160; &#160; ret = mcp251x_setup(net, priv, spi);
</I>&gt;<i> + &#160; &#160; &#160; if (ret) {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_open_clean(net);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; goto open_unlock;
</I>&gt;<i> &#160; &#160; &#160; &#160;}
</I>&gt;<i> + &#160; &#160; &#160; ret = mcp251x_set_normal_mode(spi);
</I>&gt;<i> + &#160; &#160; &#160; if (ret) {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_open_clean(net);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; goto open_unlock;
</I>&gt;<i> + &#160; &#160; &#160; }
</I>&gt;<i> + &#160; &#160; &#160; netif_wake_queue(net);
</I>&gt;<i> +
</I>&gt;<i> +open_unlock:
</I>&gt;<i> + &#160; &#160; &#160; mutex_unlock(&amp;priv-&gt;mcp_lock);
</I>&gt;<i> + &#160; &#160; &#160; return ret;
</I>&gt;<i> &#160;}
</I>&gt;<i>
</I>&gt;<i> &#160;static const struct net_device_ops mcp251x_netdev_ops = {
</I>&gt;<i> @@ -961,7 +952,7 @@ static int __devinit mcp251x_can_probe(struct spi_device *spi)
</I>&gt;<i> &#160; &#160; &#160; &#160;dev_set_drvdata(&amp;spi-&gt;dev, priv);
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;priv-&gt;spi = spi;
</I>&gt;<i> - &#160; &#160; &#160; mutex_init(&amp;priv-&gt;spi_lock);
</I>&gt;<i> + &#160; &#160; &#160; mutex_init(&amp;priv-&gt;mcp_lock);
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;/* If requested, allocate DMA buffers */
</I>&gt;<i> &#160; &#160; &#160; &#160;if (mcp251x_enable_dma) {
</I>&gt;<i> @@ -1010,18 +1001,12 @@ static int __devinit mcp251x_can_probe(struct spi_device *spi)
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;SET_NETDEV_DEV(net, &amp;spi-&gt;dev);
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; priv-&gt;wq = create_freezeable_workqueue(&quot;mcp251x_wq&quot;);
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; INIT_WORK(&amp;priv-&gt;tx_work, mcp251x_tx_work_handler);
</I>&gt;<i> - &#160; &#160; &#160; INIT_WORK(&amp;priv-&gt;irq_work, mcp251x_irq_work_handler);
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; init_completion(&amp;priv-&gt;awake);
</I>&gt;<i> -
</I>&gt;<i> &#160; &#160; &#160; &#160;/* Configure the SPI bus */
</I>&gt;<i> &#160; &#160; &#160; &#160;spi-&gt;mode = SPI_MODE_0;
</I>&gt;<i> &#160; &#160; &#160; &#160;spi-&gt;bits_per_word = 8;
</I>&gt;<i> &#160; &#160; &#160; &#160;spi_setup(spi);
</I>&gt;<i>
</I>&gt;<i> + &#160; &#160; &#160; /* Here is OK to not lock the MCP, no one knows about it yet */
</I>&gt;<i> &#160; &#160; &#160; &#160;if (!mcp251x_hw_probe(spi)) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;dev_info(&amp;spi-&gt;dev, &quot;Probe failed\n&quot;);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;goto error_probe;
</I>&gt;<i> @@ -1064,10 +1049,6 @@ static int __devexit mcp251x_can_remove(struct spi_device *spi)
</I>&gt;<i> &#160; &#160; &#160; &#160;unregister_candev(net);
</I>&gt;<i> &#160; &#160; &#160; &#160;free_candev(net);
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; priv-&gt;force_quit = 1;
</I>&gt;<i> - &#160; &#160; &#160; flush_workqueue(priv-&gt;wq);
</I>&gt;<i> - &#160; &#160; &#160; destroy_workqueue(priv-&gt;wq);
</I>&gt;<i> -
</I>&gt;<i> &#160; &#160; &#160; &#160;if (mcp251x_enable_dma) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;dma_free_coherent(&amp;spi-&gt;dev, PAGE_SIZE,
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;priv-&gt;spi_tx_buf, priv-&gt;spi_tx_dma);
</I>&gt;<i> @@ -1089,6 +1070,12 @@ static int mcp251x_can_suspend(struct spi_device *spi, pm_message_t state)
</I>&gt;<i> &#160; &#160; &#160; &#160;struct mcp251x_priv *priv = dev_get_drvdata(&amp;spi-&gt;dev);
</I>&gt;<i> &#160; &#160; &#160; &#160;struct net_device *net = priv-&gt;net;
</I>&gt;<i>
</I>&gt;<i> + &#160; &#160; &#160; priv-&gt;force_quit = 1;
</I>&gt;<i> + &#160; &#160; &#160; disable_irq(spi-&gt;irq);
</I>&gt;<i> + &#160; &#160; &#160; /*
</I>&gt;<i> + &#160; &#160; &#160; &#160;* Note: at this point neither IST nor workqueues are running.
</I>&gt;<i> + &#160; &#160; &#160; &#160;* open/stop cannot be called anyway so locking is not needed
</I>&gt;<i> + &#160; &#160; &#160; &#160;*/
</I>&gt;<i> &#160; &#160; &#160; &#160;if (netif_running(net)) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;netif_device_detach(net);
</I>&gt;<i>
</I>&gt;<i> @@ -1115,16 +1102,18 @@ static int mcp251x_can_resume(struct spi_device *spi)
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;if (priv-&gt;after_suspend &amp; AFTER_SUSPEND_POWER) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;pdata-&gt;power_enable(1);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; queue_work(priv-&gt;wq, &amp;priv-&gt;irq_work);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; queue_work(priv-&gt;wq, &amp;priv-&gt;restart_work);
</I>&gt;<i> &#160; &#160; &#160; &#160;} else {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (priv-&gt;after_suspend &amp; AFTER_SUSPEND_UP) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (pdata-&gt;transceiver_enable)
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;pdata-&gt;transceiver_enable(1);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; queue_work(priv-&gt;wq, &amp;priv-&gt;irq_work);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; queue_work(priv-&gt;wq, &amp;priv-&gt;restart_work);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;} else {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;priv-&gt;after_suspend = 0;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i> &#160; &#160; &#160; &#160;}
</I>&gt;<i> + &#160; &#160; &#160; priv-&gt;force_quit = 0;
</I>&gt;<i> + &#160; &#160; &#160; enable_irq(spi-&gt;irq);
</I>&gt;<i> &#160; &#160; &#160; &#160;return 0;
</I>&gt;<i> &#160;}
</I>&gt;<i> &#160;#else
</I>&gt;<i> --
</I>&gt;<i> 1.5.6.5
</I>&gt;<i>
</I>&gt;<i>
</I>


-- 
Christian Pellegrin, see <A HREF="http://www.evolware.org/chri/">http://www.evolware.org/chri/</A>
&quot;Real Programmers don't play tennis, or any other sport which requires
you to change clothes. Mountain climbing is OK, and Real Programmers
wear their climbing boots to work in case a mountain should suddenly
spring up in the middle of the computer room.&quot;

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003937.html">write: No buffer space available
</A></li>
	<LI>Next message: <A HREF="003936.html">write: No buffer space available
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3934">[ date ]</a>
              <a href="thread.html#3934">[ thread ]</a>
              <a href="subject.html#3934">[ subject ]</a>
              <a href="author.html#3934">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
