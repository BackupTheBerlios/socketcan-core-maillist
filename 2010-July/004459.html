<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH] CAN: Add Flexcan CAN controller driver
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2010-July/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20CAN%3A%20Add%20Flexcan%20CAN%20controller%20driver&In-Reply-To=%3C4C3F55A9.8030307%40grandegger.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004457.html">
   <LINK REL="Next"  HREF="004460.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH] CAN: Add Flexcan CAN controller driver</H1>
    <B>Wolfgang Grandegger</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%5D%20CAN%3A%20Add%20Flexcan%20CAN%20controller%20driver&In-Reply-To=%3C4C3F55A9.8030307%40grandegger.com%3E"
       TITLE="[PATCH] CAN: Add Flexcan CAN controller driver">wg at grandegger.com
       </A><BR>
    <I>Thu Jul 15 20:38:33 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="004457.html">[PATCH] CAN: Add Flexcan CAN controller driver
</A></li>
        <LI>Next message: <A HREF="004460.html">[PATCH] CAN: Add Flexcan CAN controller driver
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4459">[ date ]</a>
              <a href="thread.html#4459">[ thread ]</a>
              <a href="subject.html#4459">[ subject ]</a>
              <a href="author.html#4459">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Marc,

On 07/15/2010 12:00 AM, Marc Kleine-Budde wrote:
&gt;<i> From: Sascha Hauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">s.hauer at pengutronix.de</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> This core is found on some Freescale SoCs and also some Coldfire
</I>&gt;<i> SoCs. Support for Coldfire is missing though at the moment as
</I>&gt;<i> they have an older revision of the core which does not have RX FIFO
</I>&gt;<i> support.
</I>&gt;<i> 
</I>&gt;<i> Signed-off-by: Sascha Hauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">s.hauer at pengutronix.de</A>&gt;
</I>&gt;<i> Signed-off-by: Marc Kleine-Budde &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">mkl at pengutronix.de</A>&gt;
</I>&gt;<i> ---
</I>&gt;<i> 
</I>&gt;<i> Changes to prev version:
</I>&gt;<i> * The is now GPLv2 (only) as no one complained.
</I>&gt;<i> 
</I>&gt;<i> The patch applies to current net-next-2.6/master.
</I>&gt;<i> If there aren't any objections please consider applying this patch.
</I>&gt;<i> Wolfgang, can I an Acked-by?
</I>
I realized a few issues. You can add my &quot;acked-by&quot; when they are fixed.

&gt;<i> 
</I>&gt;<i> Cheers, Marc
</I>&gt;<i> 
</I>&gt;<i> P.S.:
</I>&gt;<i> This patch can be pulled, too:
</I>&gt;<i> 
</I>&gt;<i> The following changes since commit fae88f7eedae42c955075aec7a0cd27545f81511:
</I>&gt;<i> 
</I>&gt;<i>   Merge branch 'for-davem' of <A HREF="git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-next-2.6">git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-next-2.6</A> (2010-07-13 14:25:13 -0700)
</I>&gt;<i> 
</I>&gt;<i> are available in the git repository at:
</I>&gt;<i> 
</I>&gt;<i>   <A HREF="git://git.pengutronix.de/git/mkl/linux-2.6.git">git://git.pengutronix.de/git/mkl/linux-2.6.git</A> for-net-next-2.6
</I>&gt;<i> 
</I>&gt;<i> Sascha Hauer (1):
</I>&gt;<i>       CAN: Add Flexcan CAN controller driver
</I>&gt;<i> 
</I>&gt;<i>  drivers/net/can/Kconfig              |    6 +
</I>&gt;<i>  drivers/net/can/Makefile             |    1 +
</I>&gt;<i>  drivers/net/can/flexcan.c            | 1005 ++++++++++++++++++++++++++++++++++
</I>&gt;<i>  include/linux/can/platform/flexcan.h |   20 +
</I>&gt;<i>  4 files changed, 1032 insertions(+), 0 deletions(-)
</I>&gt;<i>  create mode 100644 drivers/net/can/flexcan.c
</I>&gt;<i>  create mode 100644 include/linux/can/platform/flexcan.h
</I>&gt;<i> 
</I>&gt;<i> diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
</I>&gt;<i> index 2c5227c..3f13299 100644
</I>&gt;<i> --- a/drivers/net/can/Kconfig
</I>&gt;<i> +++ b/drivers/net/can/Kconfig
</I>&gt;<i> @@ -73,6 +73,12 @@ config CAN_JANZ_ICAN3
</I>&gt;<i>  	  This driver can also be built as a module. If so, the module will be
</I>&gt;<i>  	  called janz-ican3.ko.
</I>&gt;<i>  
</I>&gt;<i> +config CAN_FLEXCAN
</I>&gt;<i> +	tristate &quot;Support for Freescale FLEXCAN based chips&quot;
</I>&gt;<i> +	depends on CAN_DEV
</I>
Some more arch specific dependencies would be nice.

&gt;<i> +	---help---
</I>&gt;<i> +	  Say Y here if you want to support for Freescale FlexCAN.
</I>&gt;<i> +
</I>&gt;<i>  source &quot;drivers/net/can/mscan/Kconfig&quot;
</I>&gt;<i>  
</I>&gt;<i>  source &quot;drivers/net/can/sja1000/Kconfig&quot;
</I>&gt;<i> diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
</I>&gt;<i> index 9047cd0..0057537 100644
</I>&gt;<i> --- a/drivers/net/can/Makefile
</I>&gt;<i> +++ b/drivers/net/can/Makefile
</I>&gt;<i> @@ -16,5 +16,6 @@ obj-$(CONFIG_CAN_TI_HECC)	+= ti_hecc.o
</I>&gt;<i>  obj-$(CONFIG_CAN_MCP251X)	+= mcp251x.o
</I>&gt;<i>  obj-$(CONFIG_CAN_BFIN)		+= bfin_can.o
</I>&gt;<i>  obj-$(CONFIG_CAN_JANZ_ICAN3)	+= janz-ican3.o
</I>&gt;<i> +obj-$(CONFIG_CAN_FLEXCAN)	+= flexcan.o
</I>&gt;<i>  
</I>&gt;<i>  ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
</I>&gt;<i> diff --git a/drivers/net/can/flexcan.c b/drivers/net/can/flexcan.c
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..a3180ba
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/drivers/net/can/flexcan.c
</I>&gt;<i> @@ -0,0 +1,1005 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * flexcan.c - FLEXCAN CAN controller driver
</I>&gt;<i> + *
</I>&gt;<i> + * Copyright (c) 2005-2006 Varma Electronics Oy
</I>&gt;<i> + * Copyright (c) 2009 Sascha Hauer, Pengutronix
</I>&gt;<i> + * Copyright (c) 2010 Marc Kleine-Budde, Pengutronix
</I>&gt;<i> + *
</I>&gt;<i> + * Based on code originally by Andrey Volkov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">avolkov at varma-el.com</A>&gt;
</I>&gt;<i> + *
</I>&gt;<i> + * LICENCE:
</I>&gt;<i> + * This program is free software; you can redistribute it and/or
</I>&gt;<i> + * modify it under the terms of the GNU General Public License as
</I>&gt;<i> + * published by the Free Software Foundation version 2.
</I>&gt;<i> + *
</I>&gt;<i> + * This program is distributed in the hope that it will be useful,
</I>&gt;<i> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
</I>&gt;<i> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</I>&gt;<i> + * GNU General Public License for more details.
</I>&gt;<i> + *
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> +#include &lt;linux/can.h&gt;
</I>&gt;<i> +#include &lt;linux/can/dev.h&gt;
</I>&gt;<i> +#include &lt;linux/can/error.h&gt;
</I>&gt;<i> +#include &lt;linux/can/platform/flexcan.h&gt;
</I>&gt;<i> +#include &lt;linux/clk.h&gt;
</I>&gt;<i> +#include &lt;linux/delay.h&gt;
</I>&gt;<i> +#include &lt;linux/if_arp.h&gt;
</I>&gt;<i> +#include &lt;linux/if_ether.h&gt;
</I>&gt;<i> +#include &lt;linux/interrupt.h&gt;
</I>&gt;<i> +#include &lt;linux/io.h&gt;
</I>&gt;<i> +#include &lt;linux/kernel.h&gt;
</I>&gt;<i> +#include &lt;linux/list.h&gt;
</I>&gt;<i> +#include &lt;linux/module.h&gt;
</I>&gt;<i> +#include &lt;linux/platform_device.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;mach/clock.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#define DRV_NAME		&quot;flexcan&quot;
</I>&gt;<i> +#define FLEXCAN_NAPI_WEIGHT	8
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/* FLEXCAN module configuration register (CANMCR) bits */
</I>&gt;<i> +#define FLEXCAN_MCR_MDIS		BIT(31)
</I>&gt;<i> +#define FLEXCAN_MCR_FRZ			BIT(30)
</I>&gt;<i> +#define FLEXCAN_MCR_FEN			BIT(29)
</I>&gt;<i> +#define FLEXCAN_MCR_HALT		BIT(28)
</I>&gt;<i> +#define FLEXCAN_MCR_NOT_RDY		BIT(27)
</I>&gt;<i> +#define FLEXCAN_MCR_WAK_MSK		BIT(26)
</I>&gt;<i> +#define FLEXCAN_MCR_SOFTRST		BIT(25)
</I>&gt;<i> +#define FLEXCAN_MCR_FRZ_ACK		BIT(24)
</I>&gt;<i> +#define FLEXCAN_MCR_SUPV		BIT(23)
</I>&gt;<i> +#define FLEXCAN_MCR_SLF_WAK		BIT(22)
</I>&gt;<i> +#define FLEXCAN_MCR_WRN_EN		BIT(21)
</I>&gt;<i> +#define FLEXCAN_MCR_LPM_ACK		BIT(20)
</I>&gt;<i> +#define FLEXCAN_MCR_WAK_SRC		BIT(19)
</I>&gt;<i> +#define FLEXCAN_MCR_DOZE		BIT(18)
</I>&gt;<i> +#define FLEXCAN_MCR_SRX_DIS		BIT(17)
</I>&gt;<i> +#define FLEXCAN_MCR_BCC			BIT(16)
</I>&gt;<i> +#define FLEXCAN_MCR_LPRIO_EN		BIT(13)
</I>&gt;<i> +#define FLEXCAN_MCR_AEN			BIT(12)
</I>&gt;<i> +#define FLEXCAN_MCR_MAXMB(x)		((x) &amp; 0xf)
</I>&gt;<i> +#define FLEXCAN_MCR_IDAM_A		(0 &lt;&lt; 8)
</I>&gt;<i> +#define FLEXCAN_MCR_IDAM_B		(1 &lt;&lt; 8)
</I>&gt;<i> +#define FLEXCAN_MCR_IDAM_C		(2 &lt;&lt; 8)
</I>&gt;<i> +#define FLEXCAN_MCR_IDAM_D		(3 &lt;&lt; 8)
</I>&gt;<i> +
</I>&gt;<i> +/* FLEXCAN control register (CANCTRL) bits */
</I>&gt;<i> +#define FLEXCAN_CTRL_PRESDIV(x)		(((x) &amp; 0xff) &lt;&lt; 24)
</I>&gt;<i> +#define FLEXCAN_CTRL_RJW(x)		(((x) &amp; 0x03) &lt;&lt; 22)
</I>&gt;<i> +#define FLEXCAN_CTRL_PSEG1(x)		(((x) &amp; 0x07) &lt;&lt; 19)
</I>&gt;<i> +#define FLEXCAN_CTRL_PSEG2(x)		(((x) &amp; 0x07) &lt;&lt; 16)
</I>&gt;<i> +#define FLEXCAN_CTRL_BOFF_MSK		BIT(15)
</I>&gt;<i> +#define FLEXCAN_CTRL_ERR_MSK		BIT(14)
</I>&gt;<i> +#define FLEXCAN_CTRL_CLK_SRC		BIT(13)
</I>&gt;<i> +#define FLEXCAN_CTRL_LPB		BIT(12)
</I>&gt;<i> +#define FLEXCAN_CTRL_TWRN_MSK		BIT(11)
</I>&gt;<i> +#define FLEXCAN_CTRL_RWRN_MSK		BIT(10)
</I>&gt;<i> +#define FLEXCAN_CTRL_SMP		BIT(7)
</I>&gt;<i> +#define FLEXCAN_CTRL_BOFF_REC		BIT(6)
</I>&gt;<i> +#define FLEXCAN_CTRL_TSYNC		BIT(5)
</I>&gt;<i> +#define FLEXCAN_CTRL_LBUF		BIT(4)
</I>&gt;<i> +#define FLEXCAN_CTRL_LOM		BIT(3)
</I>&gt;<i> +#define FLEXCAN_CTRL_PROPSEG(x)		((x) &amp; 0x07)
</I>&gt;<i> +
</I>&gt;<i> +/* FLEXCAN error and status register (ESR) bits */
</I>&gt;<i> +#define FLEXCAN_ESR_TWRN_INT		BIT(17)
</I>&gt;<i> +#define FLEXCAN_ESR_RWRN_INT		BIT(16)
</I>&gt;<i> +#define FLEXCAN_ESR_BIT1_ERR		BIT(15)
</I>&gt;<i> +#define FLEXCAN_ESR_BIT0_ERR		BIT(14)
</I>&gt;<i> +#define FLEXCAN_ESR_ACK_ERR		BIT(13)
</I>&gt;<i> +#define FLEXCAN_ESR_CRC_ERR		BIT(12)
</I>&gt;<i> +#define FLEXCAN_ESR_FRM_ERR		BIT(11)
</I>&gt;<i> +#define FLEXCAN_ESR_STF_ERR		BIT(10)
</I>&gt;<i> +#define FLEXCAN_ESR_TX_WRN		BIT(9)
</I>&gt;<i> +#define FLEXCAN_ESR_RX_WRN		BIT(8)
</I>&gt;<i> +#define FLEXCAN_ESR_IDLE		BIT(7)
</I>&gt;<i> +#define FLEXCAN_ESR_TXRX		BIT(6)
</I>&gt;<i> +#define FLEXCAN_EST_FLT_CONF_SHIFT	(4)
</I>&gt;<i> +#define FLEXCAN_ESR_FLT_CONF_MASK	(0x2 &lt;&lt; FLEXCAN_EST_FLT_CONF_SHIFT)
</I>&gt;<i> +#define FLEXCAN_ESR_FLT_CONF_ACTIVE	(0x0 &lt;&lt; FLEXCAN_EST_FLT_CONF_SHIFT)
</I>&gt;<i> +#define FLEXCAN_ESR_FLT_CONF_PASSIVE	(0x1 &lt;&lt; FLEXCAN_EST_FLT_CONF_SHIFT)
</I>&gt;<i> +#define FLEXCAN_ESR_BOFF_INT		BIT(2)
</I>&gt;<i> +#define FLEXCAN_ESR_ERR_INT		BIT(1)
</I>&gt;<i> +#define FLEXCAN_ESR_WAK_INT		BIT(0)
</I>&gt;<i> +#define FLEXCAN_ESR_ERR_FRAME \
</I>&gt;<i> +	(FLEXCAN_ESR_BIT1_ERR | FLEXCAN_ESR_BIT0_ERR | \
</I>&gt;<i> +	 FLEXCAN_ESR_ACK_ERR | FLEXCAN_ESR_CRC_ERR | \
</I>&gt;<i> +	 FLEXCAN_ESR_FRM_ERR | FLEXCAN_ESR_STF_ERR)
</I>&gt;<i> +#define FLEXCAN_ESR_ERR_LINE \
</I>&gt;<i> +	(FLEXCAN_ESR_TWRN_INT | FLEXCAN_ESR_RWRN_INT | FLEXCAN_ESR_BOFF_INT)
</I>&gt;<i> +
</I>&gt;<i> +/* FLEXCAN interrupt flag register (IFLAG) bits */
</I>&gt;<i> +#define FLEXCAN_TX_BUF_ID		8
</I>&gt;<i> +#define FLEXCAN_IFLAG_BUF(x)		BIT(x)
</I>&gt;<i> +#define FLEXCAN_IFLAG_RX_FIFO_OVERFLOW	BIT(7)
</I>&gt;<i> +#define FLEXCAN_IFLAG_RX_FIFO_WARN	BIT(6)
</I>&gt;<i> +#define FLEXCAN_IFLAG_RX_FIFO_AVAILABLE	BIT(5)
</I>&gt;<i> +#define FLEXCAN_IFLAG_DEFAULT \
</I>&gt;<i> +	(FLEXCAN_IFLAG_RX_FIFO_OVERFLOW | FLEXCAN_IFLAG_RX_FIFO_AVAILABLE | \
</I>&gt;<i> +	 FLEXCAN_IFLAG_BUF(FLEXCAN_TX_BUF_ID))
</I>&gt;<i> +
</I>&gt;<i> +/* FLEXCAN message buffers */
</I>&gt;<i> +#define FLEXCAN_MB_CNT_CODE(x)		(((x) &amp; 0xf) &lt;&lt; 24)
</I>&gt;<i> +#define FLEXCAN_MB_CNT_SRR		BIT(22)
</I>&gt;<i> +#define FLEXCAN_MB_CNT_IDE		BIT(21)
</I>&gt;<i> +#define FLEXCAN_MB_CNT_RTR		BIT(20)
</I>&gt;<i> +#define FLEXCAN_MB_CNT_LENGTH(x)	(((x) &amp; 0xf) &lt;&lt; 16)
</I>&gt;<i> +#define FLEXCAN_MB_CNT_TIMESTAMP(x)	((x) &amp; 0xffff)
</I>&gt;<i> +
</I>&gt;<i> +#define FLEXCAN_MB_CODE_MASK		(0xf0ffffff)
</I>&gt;<i> +
</I>&gt;<i> +/* Structure of the message buffer */
</I>&gt;<i> +struct flexcan_mb {
</I>&gt;<i> +	u32 can_ctrl;
</I>&gt;<i> +	u32 can_id;
</I>&gt;<i> +	u32 data[2];
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/* Structure of the hardware registers */
</I>&gt;<i> +struct flexcan_regs {
</I>&gt;<i> +	u32 mcr;		/* 0x00 */
</I>&gt;<i> +	u32 ctrl;		/* 0x04 */
</I>&gt;<i> +	u32 timer;		/* 0x08 */
</I>&gt;<i> +	u32 _reserved1;		/* 0x0c */
</I>&gt;<i> +	u32 rxgmask;		/* 0x10 */
</I>&gt;<i> +	u32 rx14mask;		/* 0x14 */
</I>&gt;<i> +	u32 rx15mask;		/* 0x18 */
</I>&gt;<i> +	u32 ecr;		/* 0x1c */
</I>&gt;<i> +	u32 esr;		/* 0x20 */
</I>&gt;<i> +	u32 imask2;		/* 0x24 */
</I>&gt;<i> +	u32 imask1;		/* 0x28 */
</I>&gt;<i> +	u32 iflag2;		/* 0x2c */
</I>&gt;<i> +	u32 iflag1;		/* 0x30 */
</I>&gt;<i> +	u32 _reserved2[19];
</I>&gt;<i> +	struct flexcan_mb cantxfg[64];
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct flexcan_priv {
</I>&gt;<i> +	struct can_priv can;
</I>&gt;<i> +	struct net_device *dev;
</I>&gt;<i> +	struct napi_struct napi;
</I>&gt;<i> +
</I>&gt;<i> +	void __iomem *base;
</I>&gt;<i> +	u32 reg_esr;
</I>&gt;<i> +	u32 reg_ctrl_default;
</I>&gt;<i> +
</I>&gt;<i> +	struct clk *clk;
</I>&gt;<i> +	struct flexcan_platform_data *pdata;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static struct can_bittiming_const flexcan_bittiming_const = {
</I>&gt;<i> +	.name = DRV_NAME,
</I>&gt;<i> +	.tseg1_min = 4,
</I>&gt;<i> +	.tseg1_max = 16,
</I>&gt;<i> +	.tseg2_min = 2,
</I>&gt;<i> +	.tseg2_max = 8,
</I>&gt;<i> +	.sjw_max = 4,
</I>&gt;<i> +	.brp_min = 1,
</I>&gt;<i> +	.brp_max = 256,
</I>&gt;<i> +	.brp_inc = 1,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * Swtich transceiver on or off
</I>&gt;<i> + */
</I>&gt;<i> +static void flexcan_transceiver_switch(const struct flexcan_priv *priv, int on)
</I>&gt;<i> +{
</I>&gt;<i> +	if (priv-&gt;pdata &amp;&amp; priv-&gt;pdata-&gt;transceiver_switch)
</I>&gt;<i> +		priv-&gt;pdata-&gt;transceiver_switch(on);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline void flexcan_chip_enable(struct flexcan_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	struct flexcan_regs __iomem *regs = priv-&gt;base;
</I>&gt;<i> +	u32 reg;
</I>&gt;<i> +
</I>&gt;<i> +	reg = readl(&amp;regs-&gt;mcr);
</I>&gt;<i> +	reg &amp;= ~FLEXCAN_MCR_MDIS;
</I>&gt;<i> +	writel(reg, &amp;regs-&gt;mcr);
</I>&gt;<i> +
</I>&gt;<i> +	udelay(10);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static inline void flexcan_chip_disable(struct flexcan_priv *priv)
</I>&gt;<i> +{
</I>&gt;<i> +	struct flexcan_regs __iomem *regs = priv-&gt;base;
</I>&gt;<i> +	u32 reg;
</I>&gt;<i> +
</I>&gt;<i> +	reg = readl(&amp;regs-&gt;mcr);
</I>&gt;<i> +	reg |= FLEXCAN_MCR_MDIS;
</I>&gt;<i> +	writel(reg, &amp;regs-&gt;mcr);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int flexcan_get_berr_counter(const struct net_device *dev,
</I>&gt;<i> +				    struct can_berr_counter *bec)
</I>&gt;<i> +{
</I>&gt;<i> +	const struct flexcan_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct flexcan_regs __iomem *regs = priv-&gt;base;
</I>&gt;<i> +	u32 reg = readl(&amp;regs-&gt;ecr);
</I>&gt;<i> +
</I>&gt;<i> +	bec-&gt;txerr = (reg &gt;&gt; 0) &amp; 0xff;
</I>&gt;<i> +	bec-&gt;rxerr = (reg &gt;&gt; 8) &amp; 0xff;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static int flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	const struct flexcan_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> +	struct flexcan_regs __iomem *regs = priv-&gt;base;
</I>&gt;<i> +	struct can_frame *frame = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> +	u32 can_id;
</I>&gt;<i> +	u32 ctrl = FLEXCAN_MB_CNT_CODE(0xc) | (frame-&gt;can_dlc &lt;&lt; 16);
</I>&gt;<i> +
</I>&gt;<i> +	if (can_dropped_invalid_skb(dev, skb))
</I>&gt;<i> +		return NETDEV_TX_OK;
</I>&gt;<i> +
</I>&gt;<i> +	netif_stop_queue(dev);
</I>&gt;<i> +
</I>&gt;<i> +	if (frame-&gt;can_id &amp; CAN_EFF_FLAG) {
</I>&gt;<i> +		can_id = frame-&gt;can_id &amp; CAN_EFF_MASK;
</I>&gt;<i> +		ctrl |= FLEXCAN_MB_CNT_IDE | FLEXCAN_MB_CNT_SRR;
</I>&gt;<i> +	} else {
</I>&gt;<i> +		can_id = (frame-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; 18;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (frame-&gt;can_id &amp; CAN_RTR_FLAG)
</I>&gt;<i> +		ctrl |= FLEXCAN_MB_CNT_RTR;
</I>&gt;<i> +
</I>&gt;<i> +	if (frame-&gt;can_dlc &gt; 0) {
</I>&gt;<i> +		u32 data;
</I>&gt;<i> +		data = frame-&gt;data[0] &lt;&lt; 24;
</I>&gt;<i> +		data |= frame-&gt;data[1] &lt;&lt; 16;
</I>&gt;<i> +		data |= frame-&gt;data[2] &lt;&lt; 8;
</I>&gt;<i> +		data |= frame-&gt;data[3];
</I>&gt;<i> +		writel(data, &amp;regs-&gt;cantxfg[FLEXCAN_TX_BUF_ID].data[0]);
</I>&gt;<i> +	}
</I>
IIRC, in your review of J&#252;rgens patch you suggested to use be32_to_cpu here.

&gt;<i> +	if (frame-&gt;can_dlc &gt; 3) {
</I>&gt;<i> +		u32 data;
</I>&gt;<i> +		data = frame-&gt;data[4] &lt;&lt; 24;
</I>&gt;<i> +		data |= frame-&gt;data[5] &lt;&lt; 16;
</I>&gt;<i> +		data |= frame-&gt;data[6] &lt;&lt; 8;
</I>&gt;<i> +		data |= frame-&gt;data[7];
</I>&gt;<i> +		writel(data, &amp;regs-&gt;cantxfg[FLEXCAN_TX_BUF_ID].data[1]);
</I>&gt;<i> +	}
</I>
Ditto.

&gt;<i> +	writel(can_id, &amp;regs-&gt;cantxfg[FLEXCAN_TX_BUF_ID].can_id);
</I>&gt;<i> +	writel(ctrl, &amp;regs-&gt;cantxfg[FLEXCAN_TX_BUF_ID].can_ctrl);
</I>&gt;<i> +
</I>&gt;<i> +	kfree_skb(skb);
</I>&gt;<i> +
</I>&gt;<i> +	stats-&gt;tx_bytes += frame-&gt;can_dlc;
</I>&gt;<i> +
</I>&gt;<i> +	return NETDEV_TX_OK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static void flexcan_poll_err_frame(struct net_device *dev,
</I>&gt;<i> +				   struct can_frame *cf, u32 reg_esr)
</I>&gt;<i> +{
</I>&gt;<i> +	struct flexcan_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	int error_warning = 0, rx_errors = 0, tx_errors = 0;
</I>&gt;<i> +
</I>&gt;<i> +	if (reg_esr &amp; FLEXCAN_ESR_BIT1_ERR) {
</I>&gt;<i> +		rx_errors = 1;
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
</I>&gt;<i> +		cf-&gt;data[2] |= CAN_ERR_PROT_BIT1;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (reg_esr &amp; FLEXCAN_ESR_BIT0_ERR) {
</I>&gt;<i> +		rx_errors = 1;
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
</I>&gt;<i> +		cf-&gt;data[2] |= CAN_ERR_PROT_BIT0;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (reg_esr &amp; FLEXCAN_ESR_FRM_ERR) {
</I>&gt;<i> +		rx_errors = 1;
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
</I>&gt;<i> +		cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (reg_esr &amp; FLEXCAN_ESR_STF_ERR) {
</I>&gt;<i> +		rx_errors = 1;
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
</I>&gt;<i> +		cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +	if (reg_esr &amp; FLEXCAN_ESR_ACK_ERR) {
</I>&gt;<i> +		tx_errors = 1;
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_ACK;
</I>
This is a bus-error as well. Therefore I think it should be:

	if (reg_esr &amp; FLEXCAN_ESR_ACK_ERR) {
		tx_errors = 1;
		cf-&gt;can_id |= CAN_ERR_ACK;
		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
		cf-&gt;data[3] |= CAN_ERR_PROT_LOC_ACK; /* ACK slot */
	}

I need to check what CAN_ERR_ACK is intended for. Then, cf-&gt;can_id could
be preset with &quot;CAN_ERR_PROT | CAN_ERR_BUSERROR&quot; at the beginning.

&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (error_warning)
</I>&gt;<i> +		priv-&gt;can.can_stats.error_warning++;
</I>
Hm, error_warning is always 0 !?

&gt;<i> +	if (rx_errors)
</I>&gt;<i> +		dev-&gt;stats.rx_errors++;
</I>&gt;<i> +	if (tx_errors)
</I>&gt;<i> +		dev-&gt;stats.tx_errors++;
</I>&gt;<i> +
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void flexcan_poll_err(struct net_device *dev, u32 reg_esr)
</I>&gt;<i> +{
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +
</I>&gt;<i> +	skb = alloc_can_err_skb(dev, &amp;cf);
</I>&gt;<i> +	if (unlikely(!skb))
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	flexcan_poll_err_frame(dev, cf, reg_esr);
</I>&gt;<i> +	netif_receive_skb(skb);
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;stats.rx_packets++;
</I>&gt;<i> +	dev-&gt;stats.rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void flexcan_read_fifo(const struct net_device *dev, struct can_frame *cf)
</I>&gt;<i> +{
</I>&gt;<i> +	const struct flexcan_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct flexcan_regs __iomem *regs = priv-&gt;base;
</I>&gt;<i> +	struct flexcan_mb __iomem *mb = &amp;regs-&gt;cantxfg[0];
</I>&gt;<i> +	u32 reg_ctrl, reg_id;
</I>&gt;<i> +
</I>&gt;<i> +	reg_ctrl = readl(&amp;mb-&gt;can_ctrl);
</I>&gt;<i> +	reg_id = readl(&amp;mb-&gt;can_id);
</I>&gt;<i> +	if (reg_ctrl &amp; FLEXCAN_MB_CNT_IDE)
</I>&gt;<i> +		cf-&gt;can_id = ((reg_id &gt;&gt; 0) &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
</I>&gt;<i> +	else
</I>&gt;<i> +		cf-&gt;can_id = (reg_id &gt;&gt; 18) &amp; CAN_SFF_MASK;
</I>&gt;<i> +
</I>&gt;<i> +	if (reg_ctrl &amp; FLEXCAN_MB_CNT_RTR)
</I>&gt;<i> +		cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> +	cf-&gt;can_dlc = get_can_dlc((reg_ctrl &gt;&gt; 16) &amp; 0xf);
</I>&gt;<i> +
</I>&gt;<i> +	*(__be32 *)(cf-&gt;data + 0) = cpu_to_be32(readl(&amp;mb-&gt;data[0]));
</I>&gt;<i> +	*(__be32 *)(cf-&gt;data + 4) = cpu_to_be32(readl(&amp;mb-&gt;data[1]));
</I>&gt;<i> +
</I>&gt;<i> +	/* mark as read */
</I>&gt;<i> +	writel(FLEXCAN_IFLAG_RX_FIFO_AVAILABLE, &amp;regs-&gt;iflag1);
</I>&gt;<i> +	readl(&amp;regs-&gt;timer);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void flexcan_read_frame(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +
</I>&gt;<i> +	skb = alloc_can_skb(dev, &amp;cf);
</I>&gt;<i> +	if (unlikely(!skb)) {
</I>&gt;<i> +		stats-&gt;rx_dropped++;
</I>&gt;<i> +		return;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	flexcan_read_fifo(dev, cf);
</I>&gt;<i> +	netif_receive_skb(skb);
</I>&gt;<i> +
</I>&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;<i> +	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int flexcan_poll(struct napi_struct *napi, int quota)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *dev = napi-&gt;dev;
</I>&gt;<i> +	const struct flexcan_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct flexcan_regs __iomem *regs = priv-&gt;base;
</I>&gt;<i> +	u32 reg_iflag1, reg_esr;
</I>&gt;<i> +	int work_done = 0;
</I>&gt;<i> +
</I>&gt;<i> +	reg_iflag1 = readl(&amp;regs-&gt;iflag1);
</I>&gt;<i> +
</I>&gt;<i> +	/* first handle RX-FIFO */
</I>&gt;<i> +	while (reg_iflag1 &amp; FLEXCAN_IFLAG_RX_FIFO_AVAILABLE &amp;&amp;
</I>&gt;<i> +	       work_done &lt; quota) {
</I>&gt;<i> +		flexcan_read_frame(dev);
</I>&gt;<i> +
</I>&gt;<i> +		work_done++;
</I>&gt;<i> +		reg_iflag1 = readl(&amp;regs-&gt;iflag1);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * The error bits are clear on read,
</I>&gt;<i> +	 * so use saved value from irq handler.
</I>&gt;<i> +	 */
</I>&gt;<i> +	reg_esr = readl(&amp;regs-&gt;esr) | priv-&gt;reg_esr;
</I>
Re-reading reg_esr may cause lost of state changes.

&gt;<i> +	if (work_done &lt; quota) {
</I>&gt;<i> +		flexcan_poll_err(dev, reg_esr);
</I>
An error frame is created here for each call of flexcan_poll(), not only
in case of errors.

&gt;<i> +		work_done++;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (work_done &lt; quota) {
</I>&gt;<i> +		napi_complete(napi);
</I>&gt;<i> +		/* enable IRQs */
</I>&gt;<i> +		writel(FLEXCAN_IFLAG_DEFAULT, &amp;regs-&gt;imask1);
</I>&gt;<i> +		writel(priv-&gt;reg_ctrl_default, &amp;regs-&gt;ctrl);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return work_done;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void flexcan_irq_err_state(struct net_device *dev,
</I>&gt;<i> +				  struct can_frame *cf, enum can_state new_state)
</I>&gt;<i> +{
</I>&gt;<i> +	struct flexcan_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct can_berr_counter bec;
</I>&gt;<i> +
</I>&gt;<i> +	flexcan_get_berr_counter(dev, &amp;bec);
</I>&gt;<i> +
</I>&gt;<i> +	switch (priv-&gt;can.state) {
</I>&gt;<i> +	case CAN_STATE_ERROR_ACTIVE:
</I>&gt;<i> +		/*
</I>&gt;<i> +		 * from: ERROR_ACTIVE
</I>&gt;<i> +		 * to  : ERROR_WARNING, ERROR_PASSIVE, BUS_OFF
</I>&gt;<i> +		 * =&gt;  : there was a warning int
</I>&gt;<i> +		 */
</I>&gt;<i> +		if (new_state &gt;= CAN_STATE_ERROR_WARNING &amp;&amp;
</I>&gt;<i> +		    new_state &lt;= CAN_STATE_BUS_OFF) {
</I>&gt;<i> +			dev_dbg(dev-&gt;dev.parent, &quot;Error Warning IRQ\n&quot;);
</I>&gt;<i> +			priv-&gt;can.can_stats.error_warning++;
</I>&gt;<i> +
</I>&gt;<i> +			cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +			cf-&gt;data[1] = (bec.txerr &gt; bec.rxerr) ?
</I>&gt;<i> +				CAN_ERR_CRTL_TX_WARNING :
</I>&gt;<i> +				CAN_ERR_CRTL_RX_WARNING;
</I>&gt;<i> +		}
</I>&gt;<i> +	case CAN_STATE_ERROR_WARNING:	/* fallthrough */
</I>&gt;<i> +		/*
</I>&gt;<i> +		 * from: ERROR_ACTIVE, ERROR_WARNING
</I>&gt;<i> +		 * to  : ERROR_PASSIVE, BUS_OFF
</I>&gt;<i> +		 * =&gt;  : error passive int
</I>&gt;<i> +		 */
</I>&gt;<i> +		if (new_state &gt;= CAN_STATE_ERROR_PASSIVE &amp;&amp;
</I>&gt;<i> +		    new_state &lt;= CAN_STATE_BUS_OFF) {
</I>&gt;<i> +			dev_dbg(dev-&gt;dev.parent, &quot;Error Passive IRQ\n&quot;);
</I>&gt;<i> +			priv-&gt;can.can_stats.error_passive++;
</I>&gt;<i> +
</I>&gt;<i> +			cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +			cf-&gt;data[1] = (bec.txerr &gt; bec.rxerr) ?
</I>&gt;<i> +				CAN_ERR_CRTL_TX_PASSIVE :
</I>&gt;<i> +				CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> +		}
</I>&gt;<i> +		break;
</I>&gt;<i> +	case CAN_STATE_BUS_OFF:
</I>&gt;<i> +		dev_err(dev-&gt;dev.parent,
</I>&gt;<i> +			&quot;BUG! hardware recovered automatically from BUS_OFF\n&quot;);
</I>&gt;<i> +		break;
</I>&gt;<i> +	default:
</I>&gt;<i> +		break;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* process state changes depending on the new state */
</I>&gt;<i> +	switch (new_state) {
</I>&gt;<i> +	case CAN_STATE_BUS_OFF:
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> +		can_bus_off(dev);
</I>&gt;<i> +		break;
</I>&gt;<i> +	default:
</I>&gt;<i> +		break;
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void flexcan_irq_err(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct flexcan_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct flexcan_regs __iomem *regs = priv-&gt;base;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	enum can_state new_state;
</I>&gt;<i> +	u32 reg_esr;
</I>&gt;<i> +	int flt;
</I>&gt;<i> +
</I>&gt;<i> +	reg_esr = readl(&amp;regs-&gt;esr);
</I>
As discussed, reg_esr is re-read here. Should probably be passed via
function argument.

&gt;<i> +	writel(reg_esr, &amp;regs-&gt;esr);
</I>&gt;<i> +
</I>&gt;<i> +	flt = reg_esr &amp; FLEXCAN_ESR_FLT_CONF_MASK;
</I>&gt;<i> +	if (likely(flt == FLEXCAN_ESR_FLT_CONF_ACTIVE)) {
</I>&gt;<i> +		if (likely(!(reg_esr &amp; (FLEXCAN_ESR_TX_WRN |
</I>&gt;<i> +					FLEXCAN_ESR_RX_WRN))))
</I>&gt;<i> +			new_state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +		else
</I>&gt;<i> +			new_state = CAN_STATE_ERROR_WARNING;
</I>&gt;<i> +	} else if (unlikely(flt == FLEXCAN_ESR_FLT_CONF_PASSIVE))
</I>&gt;<i> +		new_state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> +	else
</I>&gt;<i> +		new_state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +
</I>&gt;<i> +	/* state hasn't changed */
</I>&gt;<i> +	if (likely(new_state == priv-&gt;can.state))
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	skb = alloc_can_err_skb(dev, &amp;cf);
</I>&gt;<i> +	if (unlikely(!skb))
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	flexcan_irq_err_state(dev, cf, new_state);
</I>&gt;<i> +	netif_rx(skb);
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;stats.rx_packets++;
</I>&gt;<i> +	dev-&gt;stats.rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.state = new_state;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static irqreturn_t flexcan_irq(int irq, void *dev_id)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *dev = dev_id;
</I>&gt;<i> +	struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> +	struct flexcan_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct flexcan_regs __iomem *regs = priv-&gt;base;
</I>&gt;<i> +	u32 reg_iflag1, reg_esr;
</I>&gt;<i> +
</I>&gt;<i> +	reg_iflag1 = readl(&amp;regs-&gt;iflag1);
</I>&gt;<i> +	reg_esr = readl(&amp;regs-&gt;esr);
</I>&gt;<i> +
</I>&gt;<i> +	/* receive or error interrupt -&gt; napi */
</I>&gt;<i> +	if ((reg_iflag1 &amp; FLEXCAN_IFLAG_RX_FIFO_AVAILABLE) ||
</I>&gt;<i> +	    (reg_esr &amp; FLEXCAN_ESR_ERR_FRAME)) {
</I>&gt;<i> +		/*
</I>&gt;<i> +		 * The error bits are cleared on read,
</I>&gt;<i> +		 * save for later use.
</I>&gt;<i> +		 */
</I>&gt;<i> +		priv-&gt;reg_esr = reg_esr;
</I>&gt;<i> +		writel(FLEXCAN_IFLAG_DEFAULT &amp; ~FLEXCAN_IFLAG_RX_FIFO_AVAILABLE,
</I>&gt;<i> +		       &amp;regs-&gt;imask1);
</I>&gt;<i> +		writel(priv-&gt;reg_ctrl_default &amp; ~FLEXCAN_CTRL_ERR_MSK,
</I>&gt;<i> +		       &amp;regs-&gt;ctrl);
</I>&gt;<i> +		napi_schedule(&amp;priv-&gt;napi);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* FIFO overflow */
</I>&gt;<i> +	if (reg_iflag1 &amp; FLEXCAN_IFLAG_RX_FIFO_OVERFLOW) {
</I>&gt;<i> +		writel(FLEXCAN_IFLAG_RX_FIFO_OVERFLOW, &amp;regs-&gt;iflag1);
</I>&gt;<i> +		dev-&gt;stats.rx_over_errors++;
</I>&gt;<i> +		dev-&gt;stats.rx_errors++;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* transmission complete interrupt */
</I>&gt;<i> +	if (reg_iflag1 &amp; (1 &lt;&lt; FLEXCAN_TX_BUF_ID)) {
</I>&gt;<i> +		stats-&gt;tx_packets++;
</I>
Where is stats-&gt;tx_bytes incremented?

&gt;<i> +		writel((1 &lt;&lt; FLEXCAN_TX_BUF_ID), &amp;regs-&gt;iflag1);
</I>&gt;<i> +		netif_wake_queue(dev);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* handle state changes */
</I>&gt;<i> +	flexcan_irq_err(dev);
</I>
This does create and send an error message for *each* interrupt, even
for non-error interrupts (RX and TX).

Also, state changes are handled in the hard-irq context, while the
errors are handle in the soft-irq context. This looks tricky and error
prune to me as both are derived from the esr register. State changes and
errors might not be realized in the correct order, etc. It might be
saver to handle both in the poll routine by a common function.

&gt;<i> +
</I>&gt;<i> +	return IRQ_HANDLED;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void flexcan_set_bittiming(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	const struct flexcan_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	const struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> +	struct flexcan_regs __iomem *regs = priv-&gt;base;
</I>&gt;<i> +	u32 reg;
</I>&gt;<i> +
</I>&gt;<i> +	reg = readl(&amp;regs-&gt;ctrl);
</I>&gt;<i> +	reg &amp;= ~(FLEXCAN_CTRL_PRESDIV(0xff) |
</I>&gt;<i> +		 FLEXCAN_CTRL_RJW(0x3) |
</I>&gt;<i> +		 FLEXCAN_CTRL_PSEG1(0x7) |
</I>&gt;<i> +		 FLEXCAN_CTRL_PSEG2(0x7) |
</I>&gt;<i> +		 FLEXCAN_CTRL_PROPSEG(0x7) |
</I>&gt;<i> +		 FLEXCAN_CTRL_LPB |
</I>&gt;<i> +		 FLEXCAN_CTRL_SMP |
</I>&gt;<i> +		 FLEXCAN_CTRL_LOM);
</I>&gt;<i> +
</I>&gt;<i> +	reg |= FLEXCAN_CTRL_PRESDIV(bt-&gt;brp - 1) |
</I>&gt;<i> +		FLEXCAN_CTRL_PSEG1(bt-&gt;phase_seg1 - 1) |
</I>&gt;<i> +		FLEXCAN_CTRL_PSEG2(bt-&gt;phase_seg2 - 1) |
</I>&gt;<i> +		FLEXCAN_CTRL_RJW(bt-&gt;sjw - 1) |
</I>&gt;<i> +		FLEXCAN_CTRL_PROPSEG(bt-&gt;prop_seg - 1);
</I>&gt;<i> +
</I>&gt;<i> +	if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LOOPBACK)
</I>&gt;<i> +		reg |= FLEXCAN_CTRL_LPB;
</I>&gt;<i> +	if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LISTENONLY)
</I>&gt;<i> +		reg |= FLEXCAN_CTRL_LOM;
</I>&gt;<i> +	if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES)
</I>&gt;<i> +		reg |= FLEXCAN_CTRL_SMP;
</I>&gt;<i> +
</I>&gt;<i> +	dev_info(dev-&gt;dev.parent, &quot;writing ctrl=0x%08x\n&quot;, reg);
</I>&gt;<i> +	writel(reg, &amp;regs-&gt;ctrl);
</I>&gt;<i> +
</I>&gt;<i> +	/* print chip status */
</I>&gt;<i> +	dev_dbg(dev-&gt;dev.parent, &quot;%s: mcr=0x%08x ctrl=0x%08x\n&quot;, __func__,
</I>&gt;<i> +		readl(&amp;regs-&gt;mcr), readl(&amp;regs-&gt;ctrl));
</I>
This seems especially useful for development. Please check the other
dev_dbg's as well.

&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * flexcan_chip_start
</I>&gt;<i> + *
</I>&gt;<i> + * this functions is entered with clocks enabled
</I>&gt;<i> + *
</I>&gt;<i> + */
</I>&gt;<i> +static int flexcan_chip_start(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct flexcan_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct flexcan_regs __iomem *regs = priv-&gt;base;
</I>&gt;<i> +	unsigned int i;
</I>&gt;<i> +	int err;
</I>&gt;<i> +	u32 reg_mcr, reg_ctrl;
</I>&gt;<i> +
</I>&gt;<i> +	/* enable module */
</I>&gt;<i> +	flexcan_chip_enable(priv);
</I>&gt;<i> +
</I>&gt;<i> +	/* soft reset */
</I>&gt;<i> +	writel(FLEXCAN_MCR_SOFTRST, &amp;regs-&gt;mcr);
</I>&gt;<i> +	udelay(10);
</I>&gt;<i> +
</I>&gt;<i> +	reg_mcr = readl(&amp;regs-&gt;mcr);
</I>&gt;<i> +	if (reg_mcr &amp; FLEXCAN_MCR_SOFTRST) {
</I>&gt;<i> +		dev_err(dev-&gt;dev.parent,
</I>&gt;<i> +			&quot;Failed to softreset can module (mcr=0x%08x)\n&quot;, reg_mcr);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto out;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	flexcan_set_bittiming(dev);
</I>&gt;<i> +
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * MCR
</I>&gt;<i> +	 *
</I>&gt;<i> +	 * enable freeze
</I>&gt;<i> +	 * enable fifo
</I>&gt;<i> +	 * halt now
</I>&gt;<i> +	 * only supervisor access
</I>&gt;<i> +	 * enable warning int
</I>&gt;<i> +	 * choose format C
</I>&gt;<i> +	 *
</I>&gt;<i> +	 */
</I>&gt;<i> +	reg_mcr = readl(&amp;regs-&gt;mcr);
</I>&gt;<i> +	reg_mcr |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_FEN | FLEXCAN_MCR_HALT |
</I>&gt;<i> +		FLEXCAN_MCR_SUPV | FLEXCAN_MCR_WRN_EN |
</I>&gt;<i> +		FLEXCAN_MCR_IDAM_C;
</I>&gt;<i> +	dev_dbg(dev-&gt;dev.parent, &quot;%s: writing mcr=0x%08x&quot;, __func__, reg_mcr);
</I>&gt;<i> +	writel(reg_mcr, &amp;regs-&gt;mcr);
</I>&gt;<i> +
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * CTRL
</I>&gt;<i> +	 *
</I>&gt;<i> +	 * enable bus off interrupt
</I>&gt;<i> +	 * disable auto busoff recovery
</I>&gt;<i> +	 * enable tx and rx warning interrupt
</I>&gt;<i> +	 * transmit lowest buffer first
</I>&gt;<i> +	 */
</I>&gt;<i> +	reg_ctrl = readl(&amp;regs-&gt;ctrl);
</I>&gt;<i> +	reg_ctrl |= FLEXCAN_CTRL_BOFF_MSK |FLEXCAN_CTRL_BOFF_REC |
</I>&gt;<i> +		FLEXCAN_CTRL_TWRN_MSK | FLEXCAN_CTRL_RWRN_MSK |
</I>&gt;<i> +		FLEXCAN_CTRL_LBUF;
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * TODO: for now turn on the error interrupt, otherwise we
</I>&gt;<i> +	 * don't get any warning or bus passive interrupts.
</I>&gt;<i> +	 */
</I>&gt;<i> +	reg_ctrl |= FLEXCAN_CTRL_ERR_MSK;
</I>&gt;<i> +
</I>&gt;<i> +	/* save for later use */
</I>&gt;<i> +	priv-&gt;reg_ctrl_default = reg_ctrl;
</I>&gt;<i> +	dev_dbg(dev-&gt;dev.parent, &quot;%s: writing ctrl=0x%08x&quot;, __func__, reg_ctrl);
</I>&gt;<i> +	writel(reg_ctrl, &amp;regs-&gt;ctrl);
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i &lt; ARRAY_SIZE(regs-&gt;cantxfg); i++) {
</I>&gt;<i> +		writel(0, &amp;regs-&gt;cantxfg[i].can_ctrl);
</I>&gt;<i> +		writel(0, &amp;regs-&gt;cantxfg[i].can_id);
</I>&gt;<i> +		writel(0, &amp;regs-&gt;cantxfg[i].data[0]);
</I>&gt;<i> +		writel(0, &amp;regs-&gt;cantxfg[i].data[1]);
</I>&gt;<i> +
</I>&gt;<i> +		/* put MB into rx queue */
</I>&gt;<i> +		writel(FLEXCAN_MB_CNT_CODE(0x4), &amp;regs-&gt;cantxfg[i].can_ctrl);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* acceptance mask/acceptance code (accept everything) */
</I>&gt;<i> +	writel(0x0, &amp;regs-&gt;rxgmask);
</I>&gt;<i> +	writel(0x0, &amp;regs-&gt;rx14mask);
</I>&gt;<i> +	writel(0x0, &amp;regs-&gt;rx15mask);
</I>&gt;<i> +
</I>&gt;<i> +	flexcan_transceiver_switch(priv, 1);
</I>&gt;<i> +
</I>&gt;<i> +	/* synchronize with the can bus */
</I>&gt;<i> +	reg_mcr = readl(&amp;regs-&gt;mcr);
</I>&gt;<i> +	reg_mcr &amp;= ~FLEXCAN_MCR_HALT;
</I>&gt;<i> +	writel(reg_mcr, &amp;regs-&gt;mcr);
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +
</I>&gt;<i> +	/* enable FIFO interrupts */
</I>&gt;<i> +	writel(FLEXCAN_IFLAG_DEFAULT, &amp;regs-&gt;imask1);
</I>&gt;<i> +
</I>&gt;<i> +	/* print chip status */
</I>&gt;<i> +	dev_dbg(dev-&gt;dev.parent, &quot;%s: mcr=0x%08x ctrl=0x%08x\n&quot;, __func__,
</I>&gt;<i> +		readl(&amp;regs-&gt;mcr), readl(&amp;regs-&gt;ctrl));
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> + out:
</I>&gt;<i> +	flexcan_chip_disable(priv);
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * flexcan_chip_stop
</I>&gt;<i> + *
</I>&gt;<i> + * this functions is entered with clocks enabled
</I>&gt;<i> + *
</I>&gt;<i> + */
</I>&gt;<i> +static void flexcan_chip_stop(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct flexcan_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct flexcan_regs __iomem *regs = priv-&gt;base;
</I>&gt;<i> +	u32 reg;
</I>&gt;<i> +
</I>&gt;<i> +	/* Disable all interrupts */
</I>&gt;<i> +	writel(0, &amp;regs-&gt;imask1);
</I>&gt;<i> +
</I>&gt;<i> +	/* Disable + halt module */
</I>&gt;<i> +	reg = readl(&amp;regs-&gt;mcr);
</I>&gt;<i> +	reg |= FLEXCAN_MCR_MDIS | FLEXCAN_MCR_HALT;
</I>&gt;<i> +	writel(reg, &amp;regs-&gt;mcr);
</I>&gt;<i> +
</I>&gt;<i> +	flexcan_transceiver_switch(priv, 0);
</I>&gt;<i> +	priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> +
</I>&gt;<i> +	return;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int flexcan_open(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct flexcan_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	int err;
</I>&gt;<i> +
</I>&gt;<i> +	clk_enable(priv-&gt;clk);
</I>&gt;<i> +
</I>&gt;<i> +	err = open_candev(dev);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		goto out;
</I>&gt;<i> +
</I>&gt;<i> +	err = request_irq(dev-&gt;irq, flexcan_irq, IRQF_SHARED, dev-&gt;name, dev);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		goto out_close;
</I>&gt;<i> +
</I>&gt;<i> +	/* start chip and queuing */
</I>&gt;<i> +	err = flexcan_chip_start(dev);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		goto out_close;
</I>&gt;<i> +	napi_enable(&amp;priv-&gt;napi);
</I>&gt;<i> +	netif_start_queue(dev);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> + out_close:
</I>&gt;<i> +	close_candev(dev);
</I>&gt;<i> + out:
</I>&gt;<i> +	clk_disable(priv-&gt;clk);
</I>&gt;<i> +
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int flexcan_close(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct flexcan_priv *priv = netdev_priv(dev);
</I>&gt;<i> +
</I>&gt;<i> +	netif_stop_queue(dev);
</I>&gt;<i> +	napi_disable(&amp;priv-&gt;napi);
</I>&gt;<i> +	flexcan_chip_stop(dev);
</I>&gt;<i> +
</I>&gt;<i> +	free_irq(dev-&gt;irq, dev);
</I>&gt;<i> +	clk_disable(priv-&gt;clk);
</I>&gt;<i> +
</I>&gt;<i> +	close_candev(dev);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int flexcan_set_mode(struct net_device *dev, enum can_mode mode)
</I>&gt;<i> +{
</I>&gt;<i> +	int err;
</I>&gt;<i> +
</I>&gt;<i> +	switch (mode) {
</I>&gt;<i> +	case CAN_MODE_START:
</I>&gt;<i> +		err = flexcan_chip_start(dev);
</I>&gt;<i> +		if (err)
</I>&gt;<i> +			return err;
</I>&gt;<i> +
</I>&gt;<i> +		netif_wake_queue(dev);
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	default:
</I>&gt;<i> +		return -EOPNOTSUPP;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static const struct net_device_ops flexcan_netdev_ops = {
</I>&gt;<i> +	.ndo_open	= flexcan_open,
</I>&gt;<i> +	.ndo_stop	= flexcan_close,
</I>&gt;<i> +	.ndo_start_xmit	= flexcan_start_xmit,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int __devinit register_flexcandev(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct flexcan_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct flexcan_regs __iomem *regs = priv-&gt;base;
</I>&gt;<i> +	u32 reg, err;
</I>&gt;<i> +
</I>&gt;<i> +	clk_enable(priv-&gt;clk);
</I>&gt;<i> +
</I>&gt;<i> +	/* select &quot;bus clock&quot;, chip must be disabled */
</I>&gt;<i> +	flexcan_chip_disable(priv);
</I>&gt;<i> +	reg = readl(&amp;regs-&gt;ctrl);
</I>&gt;<i> +	reg |= FLEXCAN_CTRL_CLK_SRC;
</I>&gt;<i> +	writel(reg, &amp;regs-&gt;ctrl);
</I>&gt;<i> +
</I>&gt;<i> +	flexcan_chip_enable(priv);
</I>&gt;<i> +
</I>&gt;<i> +	/* set freeze, halt and activate FIFO, restrict register access */
</I>&gt;<i> +	reg = readl(&amp;regs-&gt;mcr);
</I>&gt;<i> +	reg |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT |
</I>&gt;<i> +		FLEXCAN_MCR_FEN | FLEXCAN_MCR_SUPV;
</I>&gt;<i> +	writel(reg, &amp;regs-&gt;mcr);
</I>&gt;<i> +
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * Currently we only support newer versions of this core
</I>&gt;<i> +	 * featuring a RX FIFO. Older cores found on some Coldfire
</I>&gt;<i> +	 * derivates are not yet supported.
</I>&gt;<i> +	 */
</I>&gt;<i> +	reg = readl(&amp;regs-&gt;mcr);
</I>&gt;<i> +	if (!(reg &amp; FLEXCAN_MCR_FEN)) {
</I>&gt;<i> +		dev_err(dev-&gt;dev.parent,
</I>&gt;<i> +			&quot;Could not enable RX FIFO, unsupported core\n&quot;);
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto out;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	err = register_candev(dev);
</I>&gt;<i> +
</I>&gt;<i> + out:
</I>&gt;<i> +	/* disable core and turn off clocks */
</I>&gt;<i> +	flexcan_chip_disable(priv);
</I>&gt;<i> +	clk_disable(priv-&gt;clk);
</I>&gt;<i> +
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void __devexit unregister_flexcandev(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	unregister_candev(dev);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int __devinit flexcan_probe(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *dev;
</I>&gt;<i> +	struct flexcan_priv *priv;
</I>&gt;<i> +	struct resource *mem;
</I>&gt;<i> +	struct clk *clk;
</I>&gt;<i> +	void __iomem *base;
</I>&gt;<i> +	resource_size_t mem_size;
</I>&gt;<i> +	int err, irq;
</I>&gt;<i> +
</I>&gt;<i> +	clk = clk_get(&amp;pdev-&gt;dev, NULL);
</I>&gt;<i> +	if (IS_ERR(clk)) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;no clock defined\n&quot;);
</I>&gt;<i> +		err = PTR_ERR(clk);
</I>&gt;<i> +		goto failed_clock;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;<i> +	irq = platform_get_irq(pdev, 0);
</I>&gt;<i> +	if (!mem || irq &lt;= 0) {
</I>&gt;<i> +		err = -ENODEV;
</I>&gt;<i> +		goto failed_get;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	mem_size = resource_size(mem);
</I>&gt;<i> +	if (!request_mem_region(mem-&gt;start, mem_size, pdev-&gt;name)) {
</I>&gt;<i> +		err = -EBUSY;
</I>&gt;<i> +		goto failed_req;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	base = ioremap(mem-&gt;start, mem_size);
</I>&gt;<i> +	if (!base) {
</I>&gt;<i> +		err = -ENOMEM;
</I>&gt;<i> +		goto failed_map;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	dev = alloc_candev(sizeof(struct flexcan_priv), 0);
</I>&gt;<i> +	if (!dev) {
</I>&gt;<i> +		err = -ENOMEM;
</I>&gt;<i> +		goto failed_alloc;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;netdev_ops = &amp;flexcan_netdev_ops;
</I>&gt;<i> +	dev-&gt;irq = irq;
</I>&gt;<i> +	dev-&gt;flags |= IFF_ECHO; /* we support local echo in hardware */
</I>&gt;<i> +
</I>&gt;<i> +	priv = netdev_priv(dev);
</I>&gt;<i> +	priv-&gt;can.clock.freq = clk_get_rate(clk);
</I>&gt;<i> +	priv-&gt;can.bittiming_const = &amp;flexcan_bittiming_const;
</I>&gt;<i> +	priv-&gt;can.do_set_mode = flexcan_set_mode;
</I>&gt;<i> +	priv-&gt;can.do_get_berr_counter = flexcan_get_berr_counter;
</I>&gt;<i> +	priv-&gt;can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |
</I>&gt;<i> +		CAN_CTRLMODE_LISTENONLY	| CAN_CTRLMODE_3_SAMPLES;
</I>&gt;<i> +	priv-&gt;base = base;
</I>&gt;<i> +	priv-&gt;dev = dev;
</I>&gt;<i> +	priv-&gt;clk = clk;
</I>&gt;<i> +	priv-&gt;pdata = pdev-&gt;dev.platform_data;
</I>&gt;<i> +
</I>&gt;<i> +	netif_napi_add(dev, &amp;priv-&gt;napi, flexcan_poll, FLEXCAN_NAPI_WEIGHT);
</I>&gt;<i> +
</I>&gt;<i> +	dev_set_drvdata(&amp;pdev-&gt;dev, dev);
</I>&gt;<i> +	SET_NETDEV_DEV(dev, &amp;pdev-&gt;dev);
</I>&gt;<i> +
</I>&gt;<i> +	err = register_flexcandev(dev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(&amp;pdev-&gt;dev, &quot;registering netdev failed\n&quot;);
</I>&gt;<i> +		goto failed_register;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	dev_info(&amp;pdev-&gt;dev, &quot;device registered (reg_base=%p, irq=%d)\n&quot;,
</I>&gt;<i> +		 priv-&gt;base, dev-&gt;irq);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> + failed_register:
</I>&gt;<i> +	free_candev(dev);
</I>&gt;<i> + failed_alloc:
</I>&gt;<i> +	iounmap(base);
</I>&gt;<i> + failed_map:
</I>&gt;<i> +	release_mem_region(mem-&gt;start, mem_size);
</I>&gt;<i> + failed_req:
</I>&gt;<i> +	clk_put(clk);
</I>&gt;<i> + failed_get:
</I>&gt;<i> + failed_clock:
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int __devexit flexcan_remove(struct platform_device *pdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *dev = platform_get_drvdata(pdev);
</I>&gt;<i> +	struct flexcan_priv *priv = netdev_priv(dev);
</I>&gt;<i> +	struct resource *mem;
</I>&gt;<i> +
</I>&gt;<i> +	unregister_flexcandev(dev);
</I>&gt;<i> +	platform_set_drvdata(pdev, NULL);
</I>&gt;<i> +	free_candev(dev);
</I>&gt;<i> +	iounmap(priv-&gt;base);
</I>&gt;<i> +
</I>&gt;<i> +	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;<i> +	release_mem_region(mem-&gt;start, resource_size(mem));
</I>&gt;<i> +
</I>&gt;<i> +	clk_put(priv-&gt;clk);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static struct platform_driver flexcan_driver = {
</I>&gt;<i> +	.driver.name = DRV_NAME,
</I>&gt;<i> +	.probe = flexcan_probe,
</I>&gt;<i> +	.remove = __devexit_p(flexcan_remove),
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int __init flexcan_init(void)
</I>&gt;<i> +{
</I>&gt;<i> +	pr_info(&quot;%s netdevice driver\n&quot;, DRV_NAME);
</I>&gt;<i> +	return platform_driver_register(&amp;flexcan_driver);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void __exit flexcan_exit(void)
</I>&gt;<i> +{
</I>&gt;<i> +	platform_driver_unregister(&amp;flexcan_driver);
</I>&gt;<i> +	pr_info(&quot;%s: driver removed\n&quot;, DRV_NAME);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +module_init(flexcan_init);
</I>&gt;<i> +module_exit(flexcan_exit);
</I>&gt;<i> +
</I>&gt;<i> +MODULE_AUTHOR(&quot;Sascha Hauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kernel at pengutronix.de</A>&gt;, &quot;
</I>&gt;<i> +	      &quot;Marc Kleine-Budde &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kernel at pengutronix.de</A>&gt;&quot;);
</I>&gt;<i> +MODULE_LICENSE(&quot;GPL v2&quot;);
</I>&gt;<i> +MODULE_DESCRIPTION(&quot;CAN port driver for flexcan based chip&quot;);
</I>&gt;<i> diff --git a/include/linux/can/platform/flexcan.h b/include/linux/can/platform/flexcan.h
</I>&gt;<i> new file mode 100644
</I>&gt;<i> index 0000000..72b713a
</I>&gt;<i> --- /dev/null
</I>&gt;<i> +++ b/include/linux/can/platform/flexcan.h
</I>&gt;<i> @@ -0,0 +1,20 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * Copyright (C) 2010 Marc Kleine-Budde &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kernel at pengutronix.de</A>&gt;
</I>&gt;<i> + *
</I>&gt;<i> + * This file is released under the GPLv2
</I>&gt;<i> + *
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#ifndef __CAN_PLATFORM_FLEXCAN_H
</I>&gt;<i> +#define __CAN_PLATFORM_FLEXCAN_H
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * struct flexcan_platform_data - flex CAN controller platform data
</I>&gt;<i> + * @transceiver_enable:         - called to power on/off the transceiver
</I>&gt;<i> + *
</I>&gt;<i> + */
</I>&gt;<i> +struct flexcan_platform_data {
</I>&gt;<i> +	void (*transceiver_switch)(int enable);
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +#endif /* __CAN_PLATFORM_FLEXCAN_H */
</I>
Wolfgang.

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004457.html">[PATCH] CAN: Add Flexcan CAN controller driver
</A></li>
	<LI>Next message: <A HREF="004460.html">[PATCH] CAN: Add Flexcan CAN controller driver
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4459">[ date ]</a>
              <a href="thread.html#4459">[ thread ]</a>
              <a href="subject.html#4459">[ subject ]</a>
              <a href="author.html#4459">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
