<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH net-next-2.6 v2] can: Topcliff: PCH_CAN driver: Fix build	warnings
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2010-November/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20net-next-2.6%20v2%5D%20can%3A%20Topcliff%3A%20PCH_CAN%20driver%3A%20Fix%20build%0A%09warnings&In-Reply-To=%3C00fe01cb8009%2462e11410%2466f8800a%40maildom.okisemi.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004933.html">
   <LINK REL="Next"  HREF="004932.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH net-next-2.6 v2] can: Topcliff: PCH_CAN driver: Fix build	warnings</H1>
    <B>Tomoya MORINAGA</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20net-next-2.6%20v2%5D%20can%3A%20Topcliff%3A%20PCH_CAN%20driver%3A%20Fix%20build%0A%09warnings&In-Reply-To=%3C00fe01cb8009%2462e11410%2466f8800a%40maildom.okisemi.com%3E"
       TITLE="[PATCH net-next-2.6 v2] can: Topcliff: PCH_CAN driver: Fix build	warnings">tomoya-linux at dsn.okisemi.com
       </A><BR>
    <I>Tue Nov  9 13:26:50 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="004933.html">[PATCH net-next-2.6 v2] can: Topcliff: PCH_CAN driver: Fix build	warnings
</A></li>
        <LI>Next message: <A HREF="004932.html">[PATCH net-next-2.6 v2] can: Topcliff: PCH_CAN driver: Fix build	warnings
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4931">[ date ]</a>
              <a href="thread.html#4931">[ thread ]</a>
              <a href="subject.html#4931">[ subject ]</a>
              <a href="author.html#4931">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Sorry, for late response.
----- Original Message ----- 
From: &quot;Tomoya MORINAGA&quot; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">tomoya-linux at dsn.okisemi.com</A>&gt;
To: &quot;Tomoya MORINAGA&quot; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">tomoya-linux at dsn.okisemi.com</A>&gt;
Sent: Tuesday, November 09, 2010 7:39 PM
Subject: Re: [PATCH net-next-2.6 v2] can: Topcliff: PCH_CAN driver: Fix build warnings


&gt;<i> On 11/02/2010 11:27 AM, Tomoya MORINAGA wrote:
</I>&gt;<i> &gt; On Saturday, October 30, 2010 1:23 AM,  Marc Kleine-Budde wrote:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;&gt; The driver has already been merged. Please send incremental patches
</I>&gt;<i> &gt;&gt;&gt; against david's net-2.6 branch.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Here a review, find comments inline. Lets talk about my remarks, please
</I>&gt;<i> &gt;&gt; answer inline and don't delete the code.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Can you please explain me your locking sheme? If I understand the
</I>&gt;<i> &gt;&gt; documenation correctly the two message interfaces can be used mutual.
</I>&gt;<i> &gt;&gt; And you use one for rx the other one for tx.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I show our locking scheme.
</I>&gt;<i> &gt; When CPU accesses MessageRAM via IF1, CPU protect until read-modify-write
</I>&gt;<i> &gt; so that IF2 access not occurred, vice versa.
</I>&gt;<i> 
</I>&gt;<i> Why is that needed?
</I>
For MessageRAM data consistency.

&gt;<i> 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Please use netdev_&lt;level&gt; instead of dev_&lt;level&gt; for debug.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; --- /dev/null
</I>&gt;<i> &gt;&gt;&gt; +++ b/drivers/net/can/pch_can.c
</I>&gt;<i> &gt;&gt;&gt; @@ -0,0 +1,1436 @@
</I>&gt;<i> &gt;&gt;&gt; +/*
</I>&gt;<i> &gt;&gt;&gt; + * Copyright (C) 1999 - 2010 Intel Corporation.
</I>&gt;<i> &gt;&gt;&gt; + * Copyright (C) 2010 OKI SEMICONDUCTOR CO., LTD.
</I>&gt;<i> &gt;&gt;&gt; + *
</I>&gt;<i> &gt;&gt;&gt; + * This program is free software; you can redistribute it and/or modify
</I>&gt;<i> &gt;&gt;&gt; + * it under the terms of the GNU General Public License as published by
</I>&gt;<i> &gt;&gt;&gt; + * the Free Software Foundation; version 2 of the License.
</I>&gt;<i> &gt;&gt;&gt; + *
</I>&gt;<i> &gt;&gt;&gt; + * This program is distributed in the hope that it will be useful,
</I>&gt;<i> &gt;&gt;&gt; + * but WITHOUT ANY WARRANTY; without even the implied warranty of
</I>&gt;<i> &gt;&gt;&gt; + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</I>&gt;<i> &gt;&gt;&gt; + * GNU General Public License for more details.
</I>&gt;<i> &gt;&gt;&gt; + *
</I>&gt;<i> &gt;&gt;&gt; + * You should have received a copy of the GNU General Public License
</I>&gt;<i> &gt;&gt;&gt; + * along with this program; if not, write to the Free Software
</I>&gt;<i> &gt;&gt;&gt; + * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
</I>&gt;<i> &gt;&gt;&gt; + */
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +#include &lt;linux/interrupt.h&gt;
</I>&gt;<i> &gt;&gt;&gt; +#include &lt;linux/delay.h&gt;
</I>&gt;<i> &gt;&gt;&gt; +#include &lt;linux/io.h&gt;
</I>&gt;<i> &gt;&gt;&gt; +#include &lt;linux/module.h&gt;
</I>&gt;<i> &gt;&gt;&gt; +#include &lt;linux/sched.h&gt;
</I>&gt;<i> &gt;&gt;&gt; +#include &lt;linux/pci.h&gt;
</I>&gt;<i> &gt;&gt;&gt; +#include &lt;linux/init.h&gt;
</I>&gt;<i> &gt;&gt;&gt; +#include &lt;linux/kernel.h&gt;
</I>&gt;<i> &gt;&gt;&gt; +#include &lt;linux/types.h&gt;
</I>&gt;<i> &gt;&gt;&gt; +#include &lt;linux/errno.h&gt;
</I>&gt;<i> &gt;&gt;&gt; +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> &gt;&gt;&gt; +#include &lt;linux/skbuff.h&gt;
</I>&gt;<i> &gt;&gt;&gt; +#include &lt;linux/can.h&gt;
</I>&gt;<i> &gt;&gt;&gt; +#include &lt;linux/can/dev.h&gt;
</I>&gt;<i> &gt;&gt;&gt; +#include &lt;linux/can/error.h&gt;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +#define MAX_MSG_OBJ  32
</I>&gt;<i> &gt;&gt;&gt; +#define MSG_OBJ_RX  0 /* The receive message object flag. */
</I>&gt;<i> &gt;&gt;&gt; +#define MSG_OBJ_TX  1 /* The transmit message object flag. */
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_CTRL_INIT  0x0001 /* The INIT bit of CANCONT register. */
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_CTRL_IE  0x0002 /* The IE bit of CAN control register */
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_CTRL_IE_SIE_EIE 0x000e
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_CTRL_CCE  0x0040
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_CTRL_OPT  0x0080 /* The OPT bit of CANCONT register. */
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_OPT_SILENT  0x0008 /* The Silent bit of CANOPT reg. */
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_OPT_LBACK  0x0010 /* The LoopBack bit of CANOPT reg. */
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_CMASK_RX_TX_SET 0x00f3
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_CMASK_RX_TX_GET 0x0073
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_CMASK_ALL  0xff
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_CMASK_RDWR  0x80
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_CMASK_ARB  0x20
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_CMASK_CTRL  0x10
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_CMASK_MASK  0x40
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_CMASK_NEWDAT 0x04
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_CMASK_CLRINTPND 0x08
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_IF_MCONT_NEWDAT 0x8000
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_IF_MCONT_INTPND 0x2000
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_IF_MCONT_UMASK 0x1000
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_IF_MCONT_TXIE 0x0800
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_IF_MCONT_RXIE 0x0400
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_IF_MCONT_RMTEN 0x0200
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_IF_MCONT_TXRQXT 0x0100
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_IF_MCONT_EOB 0x0080
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_IF_MCONT_DLC 0x000f
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_IF_MCONT_MSGLOST 0x4000
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_MASK2_MDIR_MXTD 0xc000
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_ID2_DIR  0x2000
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_ID_MSGVAL  0x8000
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_STATUS_INT  0x8000
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_IF_CREQ_BUSY 0x8000
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_ID2_XTD  0x4000
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_REC   0x00007f00
</I>&gt;<i> &gt;&gt;&gt; +#define CAN_TEC   0x000000ff
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; A prefix for like PCH_ instead of CAN_ for all those define above would
</I>&gt;<i> &gt;&gt; be fine to avoid namespace clashes and/or confusion with the defines from the socketcan framework.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_RX_OK  0x00000010
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_TX_OK  0x00000008
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_BUS_OFF  0x00000080
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_EWARN  0x00000040
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_EPASSIV  0x00000020
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_LEC0  0x00000001
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_LEC1  0x00000002
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_LEC2  0x00000004
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; These are just single set bit, please use BIT()
</I>&gt;<i> &gt;&gt; Consider adding the name of the corresponding register to the define's
</I>&gt;<i> &gt;&gt; name.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_LEC_ALL  (PCH_LEC0 | PCH_LEC1 | PCH_LEC2)
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_STUF_ERR  PCH_LEC0
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_FORM_ERR  PCH_LEC1
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_ACK_ERR  (PCH_LEC0 | PCH_LEC1)
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_BIT1_ERR  PCH_LEC2
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_BIT0_ERR  (PCH_LEC0 | PCH_LEC2)
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_CRC_ERR  (PCH_LEC1 | PCH_LEC2)
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +/* bit position of certain controller bits. */
</I>&gt;<i> &gt;&gt;&gt; +#define BIT_BITT_BRP  0
</I>&gt;<i> &gt;&gt;&gt; +#define BIT_BITT_SJW  6
</I>&gt;<i> &gt;&gt;&gt; +#define BIT_BITT_TSEG1  8
</I>&gt;<i> &gt;&gt;&gt; +#define BIT_BITT_TSEG2  12
</I>&gt;<i> &gt;&gt;&gt; +#define BIT_IF1_MCONT_RXIE 10
</I>&gt;<i> &gt;&gt;&gt; +#define BIT_IF2_MCONT_TXIE 11
</I>&gt;<i> &gt;&gt;&gt; +#define BIT_BRPE_BRPE  6
</I>&gt;<i> &gt;&gt;&gt; +#define BIT_ES_TXERRCNT  0
</I>&gt;<i> &gt;&gt;&gt; +#define BIT_ES_RXERRCNT  8
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; these are usually called SHIFT
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.  Is the below TRUE ?
</I>&gt;<i> &gt; e.g.#define PCH_SHIFT_BITT_BRP 0
</I>&gt;<i> 
</I>&gt;<i> I would put the SHIFT at the end, YMMV
</I>&gt;<i> 
</I>&gt;<i> #define PCH_BIT_BRP_SHIFT
</I>
I agree.

&gt;<i> 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +#define MSK_BITT_BRP  0x3f
</I>&gt;<i> &gt;&gt;&gt; +#define MSK_BITT_SJW  0xc0
</I>&gt;<i> &gt;&gt;&gt; +#define MSK_BITT_TSEG1  0xf00
</I>&gt;<i> &gt;&gt;&gt; +#define MSK_BITT_TSEG2  0x7000
</I>&gt;<i> &gt;&gt;&gt; +#define MSK_BRPE_BRPE  0x3c0
</I>&gt;<i> &gt;&gt;&gt; +#define MSK_BRPE_GET  0x0f
</I>&gt;<i> &gt;&gt;&gt; +#define MSK_CTRL_IE_SIE_EIE 0x07
</I>&gt;<i> &gt;&gt;&gt; +#define MSK_MCONT_TXIE  0x08
</I>&gt;<i> &gt;&gt;&gt; +#define MSK_MCONT_RXIE  0x10
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; MSK or MASK is okay, however the last two are just single bits.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Please add a PCH_ prefix here, too.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_CAN_NO_TX_BUFF 1
</I>&gt;<i> &gt;&gt;&gt; +#define COUNTER_LIMIT  10
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; dito
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_CAN_CLK  50000000 /* 50MHz */
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +/*
</I>&gt;<i> &gt;&gt;&gt; + * Define the number of message object.
</I>&gt;<i> &gt;&gt;&gt; + * PCH CAN communications are done via Message RAM.
</I>&gt;<i> &gt;&gt;&gt; + * The Message RAM consists of 32 message objects.
</I>&gt;<i> &gt;&gt;&gt; + */
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_RX_OBJ_NUM  26  /* 1~ PCH_RX_OBJ_NUM is Rx*/
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_TX_OBJ_NUM  6  /* PCH_RX_OBJ_NUM is RX ~ Tx*/
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_OBJ_NUM  (PCH_TX_OBJ_NUM + PCH_RX_OBJ_NUM)
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; You define MAX_MSG_OBJ earlier, seems like two names for the same value.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; In case, a use uses all message objects(=32), you are right.
</I>&gt;<i> &gt; But user does not alway use all message object.
</I>&gt;<i> 
</I>&gt;<i> No one will change these values if the driver isn't buggy. And it
</I>&gt;<i> doesn't make any sense to not use all objects.
</I>
I see.
I will delete PCH_OBJ_NUM or MAX_MSG_OBJ.

&gt;<i> 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +#define PCH_FIFO_THRESH  16
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +enum pch_can_mode {
</I>&gt;<i> &gt;&gt;&gt; + PCH_CAN_ENABLE,
</I>&gt;<i> &gt;&gt;&gt; + PCH_CAN_DISABLE,
</I>&gt;<i> &gt;&gt;&gt; + PCH_CAN_ALL,
</I>&gt;<i> &gt;&gt;&gt; + PCH_CAN_NONE,
</I>&gt;<i> &gt;&gt;&gt; + PCH_CAN_STOP,
</I>&gt;<i> &gt;&gt;&gt; + PCH_CAN_RUN,
</I>&gt;<i> &gt;&gt;&gt; +};
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +struct pch_can_regs {
</I>&gt;<i> &gt;&gt;&gt; + u32 cont;
</I>&gt;<i> &gt;&gt;&gt; + u32 stat;
</I>&gt;<i> &gt;&gt;&gt; + u32 errc;
</I>&gt;<i> &gt;&gt;&gt; + u32 bitt;
</I>&gt;<i> &gt;&gt;&gt; + u32 intr;
</I>&gt;<i> &gt;&gt;&gt; + u32 opt;
</I>&gt;<i> &gt;&gt;&gt; + u32 brpe;
</I>&gt;<i> &gt;&gt;&gt; + u32 reserve1;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; VVVV
</I>&gt;<i> &gt;&gt;&gt; + u32 if1_creq;
</I>&gt;<i> &gt;&gt;&gt; + u32 if1_cmask;
</I>&gt;<i> &gt;&gt;&gt; + u32 if1_mask1;
</I>&gt;<i> &gt;&gt;&gt; + u32 if1_mask2;
</I>&gt;<i> &gt;&gt;&gt; + u32 if1_id1;
</I>&gt;<i> &gt;&gt;&gt; + u32 if1_id2;
</I>&gt;<i> &gt;&gt;&gt; + u32 if1_mcont;
</I>&gt;<i> &gt;&gt;&gt; + u32 if1_dataa1;
</I>&gt;<i> &gt;&gt;&gt; + u32 if1_dataa2;
</I>&gt;<i> &gt;&gt;&gt; + u32 if1_datab1;
</I>&gt;<i> &gt;&gt;&gt; + u32 if1_datab2;
</I>&gt;<i> &gt;&gt; ^^^^
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; these registers and....
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; + u32 reserve2;
</I>&gt;<i> &gt;&gt;&gt; + u32 reserve3[12];
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; ...and these
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; VVVV
</I>&gt;<i> &gt;&gt;&gt; + u32 if2_creq;
</I>&gt;<i> &gt;&gt;&gt; + u32 if2_cmask;
</I>&gt;<i> &gt;&gt;&gt; + u32 if2_mask1;
</I>&gt;<i> &gt;&gt;&gt; + u32 if2_mask2;
</I>&gt;<i> &gt;&gt;&gt; + u32 if2_id1;
</I>&gt;<i> &gt;&gt;&gt; + u32 if2_id2;
</I>&gt;<i> &gt;&gt;&gt; + u32 if2_mcont;
</I>&gt;<i> &gt;&gt;&gt; + u32 if2_dataa1;
</I>&gt;<i> &gt;&gt;&gt; + u32 if2_dataa2;
</I>&gt;<i> &gt;&gt;&gt; + u32 if2_datab1;
</I>&gt;<i> &gt;&gt;&gt; + u32 if2_datab2;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; ^^^^
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; ...are identical. I suggest to make a struct defining a complete
</I>&gt;<i> &gt;&gt; &quot;Message Interface Register Set&quot;. If you include the correct number of
</I>&gt;<i> &gt;&gt; reserved bytes in the struct, you can have an array of two of these
</I>&gt;<i> &gt;&gt; structs in the struct pch_can_regs.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; To me, IMHOHO, it looks insignificant point.
</I>&gt;<i> &gt; Please show the merit ?
</I>&gt;<i> 
</I>&gt;<i> See Wolfgangs comments. You can get rid of duplicated code....
</I>
Using this method, I can't image to be able to reduce code size, now.
However I will try it.


&gt;<i> 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; + u32 reserve4;
</I>&gt;<i> &gt;&gt;&gt; + u32 reserve5[20];
</I>&gt;<i> &gt;&gt;&gt; + u32 treq1;
</I>&gt;<i> &gt;&gt;&gt; + u32 treq2;
</I>&gt;<i> &gt;&gt;&gt; + u32 reserve6[2];
</I>&gt;<i> &gt;&gt;&gt; + u32 reserve7[56];
</I>&gt;<i> &gt;&gt;&gt; + u32 reserve8[3];
</I>&gt;<i> &gt;&gt;&gt; + u32 srst;
</I>&gt;<i> &gt;&gt;&gt; +};
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +struct pch_can_priv {
</I>&gt;<i> &gt;&gt;&gt; + struct can_priv can;
</I>&gt;<i> &gt;&gt;&gt; + struct pci_dev *dev;
</I>&gt;<i> &gt;&gt;&gt; + unsigned int tx_enable[MAX_MSG_OBJ];
</I>&gt;<i> &gt;&gt;&gt; + unsigned int rx_enable[MAX_MSG_OBJ];
</I>&gt;<i> &gt;&gt;&gt; + unsigned int rx_link[MAX_MSG_OBJ];
</I>&gt;<i> &gt;&gt;&gt; + unsigned int int_enables;
</I>&gt;<i> &gt;&gt;&gt; + unsigned int int_stat;
</I>&gt;<i> &gt;&gt;&gt; + struct net_device *ndev;
</I>&gt;<i> &gt;&gt;&gt; + spinlock_t msgif_reg_lock; /* Message Interface Registers Access Lock*/
</I>&gt;<i> &gt;&gt;                                                                             ^^^
</I>&gt;<i> &gt;&gt; please add a whitespace
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; + unsigned int msg_obj[MAX_MSG_OBJ];
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_regs __iomem *regs;
</I>&gt;<i> &gt;&gt;&gt; + struct napi_struct napi;
</I>&gt;<i> &gt;&gt;&gt; + unsigned int tx_obj; /* Point next Tx Obj index */
</I>&gt;<i> &gt;&gt;&gt; + unsigned int use_msi;
</I>&gt;<i> &gt;&gt;&gt; +};
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static struct can_bittiming_const pch_can_bittiming_const = {
</I>&gt;<i> &gt;&gt;&gt; + .name = &quot;pch_can&quot;,
</I>&gt;<i> &gt;&gt;&gt; + .tseg1_min = 1,
</I>&gt;<i> &gt;&gt;&gt; + .tseg1_max = 16,
</I>&gt;<i> &gt;&gt;&gt; + .tseg2_min = 1,
</I>&gt;<i> &gt;&gt;&gt; + .tseg2_max = 8,
</I>&gt;<i> &gt;&gt;&gt; + .sjw_max = 4,
</I>&gt;<i> &gt;&gt;&gt; + .brp_min = 1,
</I>&gt;<i> &gt;&gt;&gt; + .brp_max = 1024, /* 6bit + extended 4bit */
</I>&gt;<i> &gt;&gt;&gt; + .brp_inc = 1,
</I>&gt;<i> &gt;&gt;&gt; +};
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static DEFINE_PCI_DEVICE_TABLE(pch_pci_tbl) = {
</I>&gt;<i> &gt;&gt;&gt; + {PCI_VENDOR_ID_INTEL, 0x8818, PCI_ANY_ID, PCI_ANY_ID,},
</I>&gt;<i> &gt;&gt;&gt; + {0,}
</I>&gt;<i> &gt;&gt;&gt; +};
</I>&gt;<i> &gt;&gt;&gt; +MODULE_DEVICE_TABLE(pci, pch_pci_tbl);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static inline void pch_can_bit_set(u32 *addr, u32 mask)
</I>&gt;<i> &gt;&gt;                                       ^^^^^
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; that should be an void __iomem *, see mail I've send the other day.
</I>&gt;<i> &gt;&gt; Please use sparse to check for this kinds of errors.
</I>&gt;<i> &gt;&gt; (Compile the driver with C=2, i.e.: make drivers/net/can/pch_can.ko C=2)
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(ioread32(addr) | mask, addr);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static inline void pch_can_bit_clear(u32 *addr, u32 mask)
</I>&gt;<i> &gt;&gt;                                         ^^^^^
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; dito
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(ioread32(addr) &amp; ~mask, addr);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_set_run_mode(struct pch_can_priv *priv,
</I>&gt;<i> &gt;&gt;&gt; +     enum pch_can_mode mode)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + switch (mode) {
</I>&gt;<i> &gt;&gt;&gt; + case PCH_CAN_RUN:
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_INIT);
</I>&gt;<i> &gt;&gt;&gt; +  break;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + case PCH_CAN_STOP:
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_INIT);
</I>&gt;<i> &gt;&gt;&gt; +  break;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + default:
</I>&gt;<i> &gt;&gt;&gt; +  dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;%s -&gt; Invalid Mode.\n&quot;, __func__);
</I>&gt;<i> &gt;&gt;&gt; +  break;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_set_optmode(struct pch_can_priv *priv)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + u32 reg_val = ioread32(&amp;priv-&gt;regs-&gt;opt);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LISTENONLY)
</I>&gt;<i> &gt;&gt;&gt; +  reg_val |= CAN_OPT_SILENT;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LOOPBACK)
</I>&gt;<i> &gt;&gt;&gt; +  reg_val |= CAN_OPT_LBACK;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_OPT);
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(reg_val, &amp;priv-&gt;regs-&gt;opt);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; IMHO the function name is missleading, if I understand the code
</I>&gt;<i> &gt;&gt; correctly, this functions triggers the transmission of the message.
</I>&gt;<i> &gt;&gt; After this it checks for busy, 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Yes, your understanding is TRUE.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt; but
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_check_if_busy(u32 __iomem *creq_addr, u32 num)
</I>&gt;<i> &gt;&gt;                                      ^^^^
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Yes, me too.
</I>&gt;<i> &gt; I will rename the function name.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; How about &quot;pch_can_rw_msg_obj&quot;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt; that should probaby be a void
</I>&gt;<i> &gt; What't the above mean ?
</I>&gt;<i> &gt; pch_can_check_if_busy is already &quot;void&quot; function.
</I>&gt;<i> 
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_check_if_busy(u32 __iomem *creq_addr, u32 num)
</I>&gt;<i> &gt;&gt;                                     ^^^^
</I>&gt;<i> 
</I>&gt;<i> That u32 should be a void.
</I>
I agree.

&gt;<i> 
</I>&gt;<i> BTW: Does the Intel chip support x64? If so, have you tested the driver
</I>&gt;<i> on a 64 bit kernel.
</I>&gt;<i> 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + u32 counter = COUNTER_LIMIT;
</I>&gt;<i> &gt;&gt;&gt; + u32 ifx_creq;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(num, creq_addr);
</I>&gt;<i> &gt;&gt;&gt; + while (counter) {
</I>&gt;<i> &gt;&gt;&gt; +  ifx_creq = ioread32(creq_addr) &amp; CAN_IF_CREQ_BUSY;
</I>&gt;<i> &gt;&gt;&gt; +  if (!ifx_creq)
</I>&gt;<i> &gt;&gt;&gt; +   break;
</I>&gt;<i> &gt;&gt;&gt; +  counter--;
</I>&gt;<i> &gt;&gt;&gt; +  udelay(1);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; + if (!counter)
</I>&gt;<i> &gt;&gt;&gt; +  pr_err(&quot;%s:IF1 BUSY Flag is set forever.\n&quot;, __func__);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_set_int_enables(struct pch_can_priv *priv,
</I>&gt;<i> &gt;&gt;&gt; +        enum pch_can_mode interrupt_no)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + switch (interrupt_no) {
</I>&gt;<i> &gt;&gt;&gt; + case PCH_CAN_ENABLE:
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_IE);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; noone uses this case.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +  break;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + case PCH_CAN_DISABLE:
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_IE);
</I>&gt;<i> &gt;&gt;&gt; +  break;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + case PCH_CAN_ALL:
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_IE_SIE_EIE);
</I>&gt;<i> &gt;&gt;&gt; +  break;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + case PCH_CAN_NONE:
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_IE_SIE_EIE);
</I>&gt;<i> &gt;&gt;&gt; +  break;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + default:
</I>&gt;<i> &gt;&gt;&gt; +  dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;Invalid interrupt number.\n&quot;);
</I>&gt;<i> &gt;&gt;&gt; +  break;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_set_rx_enable(struct pch_can_priv *priv, u32 buff_num,
</I>&gt;<i> &gt;&gt;&gt; +      int set)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + unsigned long flags;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; + /* Reading the receive buffer data from RAM to Interface1 registers */
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;<i> &gt;&gt;&gt; + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buff_num);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Setting the IF1MASK1 register to access MsgVal and RxIE bits */
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL,
</I>&gt;<i> &gt;&gt;&gt; +    &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + if (set == 1) {
</I>&gt;<i> &gt;&gt;&gt; +  /* Setting the MsgVal and RxIE bits */
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if1_mcont, CAN_IF_MCONT_RXIE);
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if1_id2, CAN_ID_MSGVAL);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + } else if (set == 0) {
</I>&gt;<i> &gt;&gt;&gt; +  /* Resetting the MsgVal and RxIE bits */
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont, CAN_IF_MCONT_RXIE);
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_id2, CAN_ID_MSGVAL);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buff_num);
</I>&gt;<i> &gt;&gt;&gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_rx_enable_all(struct pch_can_priv *priv)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + int i;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Traversing to obtain the object configured as receivers. */
</I>&gt;<i> &gt;&gt;&gt; + for (i = 1; i &lt;= PCH_RX_OBJ_NUM; i++)
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_set_rx_enable(priv, i, 1);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_rx_disable_all(struct pch_can_priv *priv)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + int i;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Traversing to obtain the object configured as receivers. */
</I>&gt;<i> &gt;&gt;&gt; + for (i = 1; i &lt;= PCH_RX_OBJ_NUM; i++)
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_set_rx_enable(priv, i, 0);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_set_tx_enable(struct pch_can_priv *priv, u32 buff_num,
</I>&gt;<i> &gt;&gt;&gt; +     u32 set)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + unsigned long flags;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; + /* Reading the Msg buffer from Message RAM to Interface2 registers. */
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;<i> &gt;&gt;&gt; + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, buff_num);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Setting the IF2CMASK register for accessing the
</I>&gt;<i> &gt;&gt;&gt; +  MsgVal and TxIE bits */
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL,
</I>&gt;<i> &gt;&gt;&gt; +   &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + if (set == 1) {
</I>&gt;<i> &gt;&gt;&gt; +  /* Setting the MsgVal and TxIE bits */
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_mcont, CAN_IF_MCONT_TXIE);
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id2, CAN_ID_MSGVAL);
</I>&gt;<i> &gt;&gt;&gt; + } else if (set == 0) {
</I>&gt;<i> &gt;&gt;&gt; +  /* Resetting the MsgVal and TxIE bits. */
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_mcont, CAN_IF_MCONT_TXIE);
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_id2, CAN_ID_MSGVAL);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, buff_num);
</I>&gt;<i> &gt;&gt;&gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_tx_enable_all(struct pch_can_priv *priv)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + int i;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Traversing to obtain the object configured as transmit object. */
</I>&gt;<i> &gt;&gt;&gt; + for (i = PCH_RX_OBJ_NUM + 1; i &lt;= PCH_OBJ_NUM; i++)
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_set_tx_enable(priv, i, 1);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_tx_disable_all(struct pch_can_priv *priv)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + int i;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Traversing to obtain the object configured as transmit object. */
</I>&gt;<i> &gt;&gt;&gt; + for (i = PCH_RX_OBJ_NUM + 1; i &lt;= PCH_OBJ_NUM; i++)
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_set_tx_enable(priv, i, 0);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static int pch_can_int_pending(struct pch_can_priv *priv)
</I>&gt;<i> &gt;&gt;           ^^^
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; make it u32 as it returns a register value, or a u16 as you only use
</I>&gt;<i> &gt;&gt; the 16 lower bits.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree. I will modify to u32.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + return ioread32(&amp;priv-&gt;regs-&gt;intr) &amp; 0xffff;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_clear_buffers(struct pch_can_priv *priv)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + int i; /* Msg Obj ID (1~32) */
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + for (i = 1; i &lt;= PCH_RX_OBJ_NUM; i++) {
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; IMHO the readability would be improved if you define something like
</I>&gt;<i> &gt;&gt; PCH_RX_OBJ_START and PCH_RX_OBJ_END.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(CAN_CMASK_RX_TX_SET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0xffff, &amp;priv-&gt;regs-&gt;if1_mask1);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0xffff, &amp;priv-&gt;regs-&gt;if1_mask2);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_id1);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_id2);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_mcont);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_dataa1);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_dataa2);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_datab1);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_datab2);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK |
</I>&gt;<i> &gt;&gt;&gt; +     CAN_CMASK_ARB | CAN_CMASK_CTRL,
</I>&gt;<i> &gt;&gt;&gt; +     &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, i);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + for (i = PCH_RX_OBJ_NUM + 1; i &lt;= PCH_OBJ_NUM; i++) {
</I>&gt;<i> &gt;&gt;                  ^^^^^^^^^^^^^^^^^^
</I>&gt;<i> &gt;&gt; dito for TX objects
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(CAN_CMASK_RX_TX_SET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0xffff, &amp;priv-&gt;regs-&gt;if2_mask1);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0xffff, &amp;priv-&gt;regs-&gt;if2_mask2);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_id1);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_id2);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_mcont);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_dataa1);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_dataa2);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_datab1);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_datab2);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK | CAN_CMASK_ARB |
</I>&gt;<i> &gt;&gt;&gt; +     CAN_CMASK_CTRL, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, i);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + int i;
</I>&gt;<i> &gt;&gt;&gt; + unsigned long flags;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + for (i = 1; i &lt;= PCH_RX_OBJ_NUM; i++) {
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, i);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; If I understand the code correctly, the about function triggers a
</I>&gt;<i> &gt;&gt; transfer. Why do you first trigger a transfer, then set the message contents....
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; For doing Read-Modify-Write.
</I>&gt;<i> &gt; As to fixed parameter of message object, it doesn't be modified every access.
</I>&gt;<i> 
</I>&gt;<i> I see.
</I>&gt;<i> 
</I>&gt;<i> &gt; We will modify to write only.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_id1);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if1_id2);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if1_mcont, CAN_IF_MCONT_UMASK);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;     Why do you set the &quot;Use acceptance mask&quot; bit? We want to receive
</I>&gt;<i> &gt;&gt;     all can messages.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Without &quot;Use acceptance mask&quot; means received packet matched ID[28:0] only.
</I>&gt;<i> &gt; As a result, filter is enabled.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; With &quot;Use acceptance mask&quot; and setting Msk[0:28]=all 1, all packets can be received(=No filter state) 
</I>&gt;<i> 
</I>&gt;<i> Thanks for the explenation.
</I>&gt;<i> 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  /* Set FIFO mode set to 0 except last Rx Obj*/
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont, CAN_IF_MCONT_EOB);
</I>&gt;<i> &gt;&gt;&gt; +  /* In case FIFO mode, Last EoB of Rx Obj must be 1 */
</I>&gt;<i> &gt;&gt;&gt; +  if (i == (PCH_RX_OBJ_NUM - 1))
</I>&gt;<i> &gt;&gt;&gt; +   pch_can_bit_set(&amp;priv-&gt;regs-&gt;if1_mcont,
</I>&gt;<i> &gt;&gt;&gt; +     CAN_IF_MCONT_EOB);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;     Make it if () { } else { }, please.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Sorry, I can't understand.
</I>&gt;<i> &gt; else {} is not necessary.
</I>&gt;<i> 
</I>&gt;<i> Please look at the code block above, again. You frist clean the bit
</I>&gt;<i> unconditionally, then you set the bit in the if. Please make it:
</I>&gt;<i> 
</I>&gt;<i> if (last)
</I>&gt;<i>  set_bit
</I>&gt;<i> else
</I>&gt;<i>  clear_bit
</I>
I understand.
I will modify like above.
Thanks.

&gt;<i> 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0, &amp;priv-&gt;regs-&gt;if1_mask1);
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mask2,
</I>&gt;<i> &gt;&gt;&gt; +      0x1fff | CAN_MASK2_MDIR_MXTD);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  /* Setting CMASK for writing */
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK | CAN_CMASK_ARB |
</I>&gt;<i> &gt;&gt;&gt; +     CAN_CMASK_CTRL, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, i);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; ...and then trigger the transfer again?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; This means Read-Modify-Write.
</I>&gt;<i> 
</I>&gt;<i> ic
</I>&gt;<i> 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + for (i = PCH_RX_OBJ_NUM + 1; i &lt;= PCH_OBJ_NUM; i++) {
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, i);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; same question about triggering the transfer 2 times applied here, too
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; ditto.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  /* Resetting DIR bit for reception */
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_id1);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_id2);
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id2, CAN_ID2_DIR);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Can you combine the two accesses to &gt;if2_id2 into one?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  /* Setting EOB bit for transmitter */
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(CAN_IF_MCONT_EOB, &amp;priv-&gt;regs-&gt;if2_mcont);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_mcont,
</I>&gt;<i> &gt;&gt;&gt; +    CAN_IF_MCONT_UMASK);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; dito for if2_mcont
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; ditto.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0, &amp;priv-&gt;regs-&gt;if2_mask1);
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_mask2, 0x1fff);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  /* Setting CMASK for writing */
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK | CAN_CMASK_ARB |
</I>&gt;<i> &gt;&gt;&gt; +     CAN_CMASK_CTRL, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, i);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_init(struct pch_can_priv *priv)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + /* Stopping the Can device. */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Clearing all the message object buffers. */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_clear_buffers(priv);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Configuring the respective message object as either rx/tx object. */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_config_rx_tx_buffers(priv);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Enabling the interrupts. */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_set_int_enables(priv, PCH_CAN_ALL);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_release(struct pch_can_priv *priv)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + /* Stooping the CAN device. */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Disabling the interrupts. */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_set_int_enables(priv, PCH_CAN_NONE);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Disabling all the receive object. */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_rx_disable_all(priv);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Disabling all the transmit object. */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_tx_disable_all(priv);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +/* This function clears interrupt(s) from the CAN device. */
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_int_clr(struct pch_can_priv *priv, u32 mask)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + if (mask == CAN_STATUS_INT) {
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; is this a valid case?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; This &quot;if&quot; is always false.
</I>&gt;<i> &gt; I will delete this condition.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +  ioread32(&amp;priv-&gt;regs-&gt;stat);
</I>&gt;<i> &gt;&gt;&gt; +  return;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Clear interrupt for transmit object */
</I>&gt;<i> &gt;&gt;&gt; + if ((mask &gt;= 1) &amp;&amp; (mask &lt;= PCH_RX_OBJ_NUM)) {
</I>&gt;<i> &gt;&gt;&gt; +  /* Setting CMASK for clearing the reception interrupts. */
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL | CAN_CMASK_ARB,
</I>&gt;<i> &gt;&gt;&gt; +     &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  /* Clearing the Dir bit. */
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_id2, CAN_ID2_DIR);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  /* Clearing NewDat &amp; IntPnd */
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont,
</I>&gt;<i> &gt;&gt;&gt; +      CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, mask);
</I>&gt;<i> &gt;&gt;&gt; + } else if ((mask &gt; PCH_RX_OBJ_NUM) &amp;&amp; (mask &lt;= PCH_OBJ_NUM)) {
</I>&gt;<i> &gt;&gt;&gt; +  /* Setting CMASK for clearing interrupts for
</I>&gt;<i> &gt;&gt;&gt; +     frame transmission. */
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; /*
</I>&gt;<i> &gt;&gt;  * this is the prefered style of multi line comments,
</I>&gt;<i> &gt;&gt;  * please adjust you comments
</I>&gt;<i> &gt;&gt;  */
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I understand.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL | CAN_CMASK_ARB,
</I>&gt;<i> &gt;&gt;&gt; +     &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  /* Resetting the ID registers. */
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id2,
</I>&gt;<i> &gt;&gt;&gt; +          CAN_ID2_DIR | (0x7ff &lt;&lt; 2));
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0x0, &amp;priv-&gt;regs-&gt;if2_id1);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  /* Claring NewDat, TxRqst &amp; IntPnd */
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_mcont,
</I>&gt;<i> &gt;&gt;&gt; +      CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND |
</I>&gt;<i> &gt;&gt;&gt; +      CAN_IF_MCONT_TXRQXT);
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, mask);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static u32 pch_can_get_buffer_status(struct pch_can_priv *priv)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + return (ioread32(&amp;priv-&gt;regs-&gt;treq1) &amp; 0xffff) |
</I>&gt;<i> &gt;&gt;&gt; +        ((ioread32(&amp;priv-&gt;regs-&gt;treq2) &amp; 0xffff) &lt;&lt; 16);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; the second 0xffff is not needed, as the return value is u32 and you shift by 16.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_reset(struct pch_can_priv *priv)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + /* write to sw reset register */
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(1, &amp;priv-&gt;regs-&gt;srst);
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(0, &amp;priv-&gt;regs-&gt;srst);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_error(struct net_device *ndev, u32 status)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + struct sk_buff *skb;
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt;&gt;&gt; + struct can_frame *cf;
</I>&gt;<i> &gt;&gt;&gt; + u32 errc;
</I>&gt;<i> &gt;&gt;&gt; + struct net_device_stats *stats = &amp;(priv-&gt;ndev-&gt;stats);
</I>&gt;<i> &gt;&gt;&gt; + enum can_state state = priv-&gt;can.state;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + skb = alloc_can_err_skb(ndev, &amp;cf);
</I>&gt;<i> &gt;&gt;&gt; + if (!skb)
</I>&gt;<i> &gt;&gt;&gt; +  return;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + if (status &amp; PCH_BUS_OFF) {
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_tx_disable_all(priv);
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_rx_disable_all(priv);
</I>&gt;<i> &gt;&gt;&gt; +  state = CAN_STATE_BUS_OFF;
</I>&gt;<i> &gt;&gt;&gt; +  cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> &gt;&gt;&gt; +  can_bus_off(ndev);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Warning interrupt. */
</I>&gt;<i> &gt;&gt;&gt; + if (status &amp; PCH_EWARN) {
</I>&gt;<i> &gt;&gt;&gt; +  state = CAN_STATE_ERROR_WARNING;
</I>&gt;<i> &gt;&gt;&gt; +  priv-&gt;can.can_stats.error_warning++;
</I>&gt;<i> &gt;&gt;&gt; +  cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> &gt;&gt;&gt; +  errc = ioread32(&amp;priv-&gt;regs-&gt;errc);
</I>&gt;<i> &gt;&gt;&gt; +  if (((errc &amp; CAN_REC) &gt;&gt; 8) &gt; 96)
</I>&gt;<i> &gt;&gt;&gt; +   cf-&gt;data[1] |= CAN_ERR_CRTL_RX_WARNING;
</I>&gt;<i> &gt;&gt;&gt; +  if ((errc &amp; CAN_TEC) &gt; 96)
</I>&gt;<i> &gt;&gt;&gt; +   cf-&gt;data[1] |= CAN_ERR_CRTL_TX_WARNING;
</I>&gt;<i> &gt;&gt;&gt; +  dev_warn(&amp;ndev-&gt;dev,
</I>&gt;<i> &gt;&gt;&gt; +   &quot;%s -&gt; Error Counter is more than 96.\n&quot;, __func__);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Please use just &quot;debug&quot; level not warning here. Consider to use
</I>&gt;<i> &gt;&gt; netdev_dbg() instead. IMHO the __func__ can be dropped and the
</I>&gt;<i> &gt;&gt; &quot;official&quot; name for the error is &quot;Error Warning&quot;.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I want to know the reason.
</I>&gt;<i> &gt; Why is it not dev_warn but netdev_dbg ?
</I>&gt;<i> 
</I>&gt;<i> If you use warning level it would end up on the console or and in the
</I>&gt;<i> syslog. It's quite complicated (for programs) to get information from
</I>&gt;<i> there. This is why we send CAN error frames. They hold the same
</I>&gt;<i> information but int a binary form, thus it's easier to process.
</I>
I understand the reason.
BTW, Why do you say not dev_dbg but netdev_dbg ?

&gt;<i> 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; + /* Error passive interrupt. */
</I>&gt;<i> &gt;&gt;&gt; + if (status &amp; PCH_EPASSIV) {
</I>&gt;<i> &gt;&gt;&gt; +  priv-&gt;can.can_stats.error_passive++;
</I>&gt;<i> &gt;&gt;&gt; +  state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> &gt;&gt;&gt; +  cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> &gt;&gt;&gt; +  errc = ioread32(&amp;priv-&gt;regs-&gt;errc);
</I>&gt;<i> &gt;&gt;&gt; +  if (((errc &amp; CAN_REC) &gt;&gt; 8) &gt; 127)
</I>&gt;<i> &gt;&gt;&gt; +   cf-&gt;data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> &gt;&gt;&gt; +  if ((errc &amp; CAN_TEC) &gt; 127)
</I>&gt;<i> &gt;&gt;&gt; +   cf-&gt;data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
</I>&gt;<i> &gt;&gt;&gt; +  dev_err(&amp;ndev-&gt;dev,
</I>&gt;<i> &gt;&gt;&gt; +   &quot;%s -&gt; CAN controller is ERROR PASSIVE .\n&quot;, __func__);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; dito
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; ditto
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + if (status &amp; PCH_LEC_ALL) {
</I>&gt;<i> &gt;&gt;&gt; +  priv-&gt;can.can_stats.bus_error++;
</I>&gt;<i> &gt;&gt;&gt; +  stats-&gt;rx_errors++;
</I>&gt;<i> &gt;&gt;&gt; +  switch (status &amp; PCH_LEC_ALL) {
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; I suggest to convert to a if-bit-set because there might be more than
</I>&gt;<i> &gt;&gt; one bit set.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +  case PCH_STUF_ERR:
</I>&gt;<i> &gt;&gt;&gt; +   cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;<i> &gt;&gt;&gt; +   break;
</I>&gt;<i> &gt;&gt;&gt; +  case PCH_FORM_ERR:
</I>&gt;<i> &gt;&gt;&gt; +   cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;<i> &gt;&gt;&gt; +   break;
</I>&gt;<i> &gt;&gt;&gt; +  case PCH_ACK_ERR:
</I>&gt;<i> &gt;&gt;&gt; +   cf-&gt;data[2] |= CAN_ERR_PROT_LOC_ACK |
</I>&gt;<i> &gt;&gt;&gt; +           CAN_ERR_PROT_LOC_ACK_DEL;
</I>&gt;<i> &gt;&gt;&gt; +   break;
</I>&gt;<i> &gt;&gt;&gt; +  case PCH_BIT1_ERR:
</I>&gt;<i> &gt;&gt;&gt; +  case PCH_BIT0_ERR:
</I>&gt;<i> &gt;&gt;&gt; +   cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
</I>&gt;<i> &gt;&gt;&gt; +   break;
</I>&gt;<i> &gt;&gt;&gt; +  case PCH_CRC_ERR:
</I>&gt;<i> &gt;&gt;&gt; +   cf-&gt;data[2] |= CAN_ERR_PROT_LOC_CRC_SEQ |
</I>&gt;<i> &gt;&gt;&gt; +           CAN_ERR_PROT_LOC_CRC_DEL;
</I>&gt;<i> &gt;&gt;&gt; +   break;
</I>&gt;<i> &gt;&gt;&gt; +  default:
</I>&gt;<i> &gt;&gt;&gt; +   iowrite32(status | PCH_LEC_ALL, &amp;priv-&gt;regs-&gt;stat);
</I>&gt;<i> &gt;&gt;&gt; +   break;
</I>&gt;<i> &gt;&gt;&gt; +  }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;can.state = state;
</I>&gt;<i> &gt;&gt;&gt; + netif_receive_skb(skb);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + stats-&gt;rx_packets++;
</I>&gt;<i> &gt;&gt;&gt; + stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static irqreturn_t pch_can_interrupt(int irq, void *dev_id)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + struct net_device *ndev = (struct net_device *)dev_id;
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + pch_can_set_int_enables(priv, PCH_CAN_NONE);
</I>&gt;<i> &gt;&gt;&gt; + napi_schedule(&amp;priv-&gt;napi);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + return IRQ_HANDLED;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_fifo_thresh(struct pch_can_priv *priv, int obj_id)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + if (obj_id &lt; PCH_FIFO_THRESH) {
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL |
</I>&gt;<i> &gt;&gt;&gt; +     CAN_CMASK_ARB, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  /* Clearing the Dir bit. */
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_id2, CAN_ID2_DIR);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  /* Clearing NewDat &amp; IntPnd */
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont,
</I>&gt;<i> &gt;&gt;&gt; +      CAN_IF_MCONT_INTPND);
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, obj_id);
</I>&gt;<i> &gt;&gt;&gt; + } else if (obj_id &gt; PCH_FIFO_THRESH) {
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_int_clr(priv, obj_id);
</I>&gt;<i> &gt;&gt;&gt; + } else if (obj_id == PCH_FIFO_THRESH) {
</I>&gt;<i> &gt;&gt;&gt; +  int cnt;
</I>&gt;<i> &gt;&gt;&gt; +  for (cnt = 0; cnt &lt; PCH_FIFO_THRESH; cnt++)
</I>&gt;<i> &gt;&gt;&gt; +   pch_can_int_clr(priv, cnt+1);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static int pch_can_rx_msg_lost(struct net_device *ndev, int obj_id)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt;&gt;&gt; + struct net_device_stats *stats = &amp;(priv-&gt;ndev-&gt;stats);
</I>&gt;<i> &gt;&gt;&gt; + struct sk_buff *skb;
</I>&gt;<i> &gt;&gt;&gt; + struct can_frame *cf;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + dev_err(&amp;priv-&gt;ndev-&gt;dev, &quot;Msg Obj is overwritten.\n&quot;);
</I>&gt;<i> &gt;&gt;&gt; + pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont,
</I>&gt;<i> &gt;&gt;&gt; +     CAN_IF_MCONT_MSGLOST);
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL,
</I>&gt;<i> &gt;&gt;&gt; +    &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;<i> &gt;&gt;&gt; + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, obj_id);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + skb = alloc_can_err_skb(ndev, &amp;cf);
</I>&gt;<i> &gt;&gt;&gt; + if (!skb)
</I>&gt;<i> &gt;&gt;&gt; +  return -ENOMEM;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;can.can_stats.error_passive++;
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> &gt;&gt;&gt; + cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> &gt;&gt;&gt; + cf-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
</I>&gt;<i> &gt;&gt;&gt; + stats-&gt;rx_over_errors++;
</I>&gt;<i> &gt;&gt;&gt; + stats-&gt;rx_errors++;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + netif_receive_skb(skb);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + return 0;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static int pch_can_rx_normal(struct net_device *ndev, u32 obj_num, int quota)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + u32 reg;
</I>&gt;<i> &gt;&gt;&gt; + canid_t id;
</I>&gt;<i> &gt;&gt;&gt; + u32 ide;
</I>&gt;<i> &gt;&gt;&gt; + u32 rtr;
</I>&gt;<i> &gt;&gt;&gt; + int rcv_pkts = 0;
</I>&gt;<i> &gt;&gt;&gt; + int rtn;
</I>&gt;<i> &gt;&gt;&gt; + int next_flag = 0;
</I>&gt;<i> &gt;&gt;&gt; + struct sk_buff *skb;
</I>&gt;<i> &gt;&gt;&gt; + struct can_frame *cf;
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt;&gt;&gt; + struct net_device_stats *stats = &amp;(priv-&gt;ndev-&gt;stats);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Reading the messsage object from the Message RAM */
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;<i> &gt;&gt;&gt; + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, obj_num);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Reading the MCONT register. */
</I>&gt;<i> &gt;&gt;&gt; + reg = ioread32(&amp;priv-&gt;regs-&gt;if1_mcont);
</I>&gt;<i> &gt;&gt;&gt; + reg &amp;= 0xffff;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + for (; (!(reg &amp; CAN_IF_MCONT_EOB)) &amp;&amp; (quota &gt; 0);
</I>&gt;<i> &gt;&gt;&gt; +      obj_num++, next_flag = 0) {
</I>&gt;<i> &gt;&gt;&gt; +  /* If MsgLost bit set. */
</I>&gt;<i> &gt;&gt;&gt; +  if (reg &amp; CAN_IF_MCONT_MSGLOST) {
</I>&gt;<i> &gt;&gt;&gt; +   rtn = pch_can_rx_msg_lost(ndev, obj_num);
</I>&gt;<i> &gt;&gt;&gt; +   if (!rtn)
</I>&gt;<i> &gt;&gt;&gt; +    return rtn;
</I>&gt;<i> &gt;&gt;&gt; +   rcv_pkts++;
</I>&gt;<i> &gt;&gt;&gt; +   quota--;
</I>&gt;<i> &gt;&gt;&gt; +   next_flag = 1;
</I>&gt;<i> &gt;&gt;&gt; +  } else if (!(reg &amp; CAN_IF_MCONT_NEWDAT))
</I>&gt;<i> &gt;&gt;&gt; +   next_flag = 1;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; after rearanging the code (see below..) you should be able to use a continue here.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +  if (!next_flag) {
</I>&gt;<i> &gt;&gt;&gt; +   skb = alloc_can_skb(priv-&gt;ndev, &amp;cf);
</I>&gt;<i> &gt;&gt;&gt; +   if (!skb)
</I>&gt;<i> &gt;&gt;&gt; +    return -ENOMEM;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +   /* Get Received data */
</I>&gt;<i> &gt;&gt;&gt; +   ide = ((ioread32(&amp;priv-&gt;regs-&gt;if1_id2)) &amp; CAN_ID2_XTD);
</I>&gt;<i> &gt;&gt;&gt; +   if (ide) {
</I>&gt;<i> &gt;&gt;&gt; +    id = (ioread32(&amp;priv-&gt;regs-&gt;if1_id1) &amp; 0xffff);
</I>&gt;<i> &gt;&gt;&gt; +    id |= (((ioread32(&amp;priv-&gt;regs-&gt;if1_id2)) &amp;
</I>&gt;<i> &gt;&gt;&gt; +          0x1fff) &lt;&lt; 16);
</I>&gt;<i> &gt;&gt;&gt; +    cf-&gt;can_id = (id &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
</I>&gt;<i> &gt;&gt;                                               ^^^^^^^^^^^^^^^^^
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; is the mask needed, you mask the if1_id{1,2} already
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I will delete
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +   } else {
</I>&gt;<i> &gt;&gt;&gt; +    id = (((ioread32(&amp;priv-&gt;regs-&gt;if1_id2)) &amp;
</I>&gt;<i> &gt;&gt;&gt; +        (CAN_SFF_MASK &lt;&lt; 2)) &gt;&gt; 2);
</I>&gt;<i> &gt;&gt;&gt; +    cf-&gt;can_id = (id &amp; CAN_SFF_MASK);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; one mask can go away
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +   }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +   rtr = ioread32(&amp;priv-&gt;regs-&gt;if1_id2) &amp;  CAN_ID2_DIR;
</I>&gt;<i> &gt;&gt;                                                               ^^
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; remove one space
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +   if (rtr)
</I>&gt;<i> &gt;&gt;&gt; +    cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +   cf-&gt;can_dlc = get_can_dlc((ioread32(&amp;priv-&gt;regs-&gt;
</I>&gt;<i> &gt;&gt;&gt; +         if1_mcont)) &amp; 0xF);
</I>&gt;<i> &gt;&gt;&gt; +   *(u16 *)(cf-&gt;data + 0) = ioread16(&amp;priv-&gt;regs-&gt;
</I>&gt;<i> &gt;&gt;&gt; +         if1_dataa1);
</I>&gt;<i> &gt;&gt;&gt; +   *(u16 *)(cf-&gt;data + 2) = ioread16(&amp;priv-&gt;regs-&gt;
</I>&gt;<i> &gt;&gt;&gt; +         if1_dataa2);
</I>&gt;<i> &gt;&gt;&gt; +   *(u16 *)(cf-&gt;data + 4) = ioread16(&amp;priv-&gt;regs-&gt;
</I>&gt;<i> &gt;&gt;&gt; +         if1_datab1);
</I>&gt;<i> &gt;&gt;&gt; +   *(u16 *)(cf-&gt;data + 6) = ioread16(&amp;priv-&gt;regs-&gt;
</I>&gt;<i> &gt;&gt;&gt; +         if1_datab2);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; are you sure, the bytes in the can package a in the correct order.
</I>&gt;<i> &gt;&gt; Please test your pch_can against a non pch_can system.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Unfortunately, we don't have non pch_can system.
</I>&gt;<i> 
</I>&gt;<i> Have a look a the driver/net/can/usb subdir and buy one of those. It
</I>&gt;<i> really hard to find bugs if you test against your own driver.
</I>
We can't buy this right now for few budget.
But I heard we have &quot;CANalyzer&quot;.
Using this, we can test this endian concern.
But we may need much time for studying how to use.

&gt;<i> 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +   netif_receive_skb(skb);
</I>&gt;<i> &gt;&gt;&gt; +   rcv_pkts++;
</I>&gt;<i> &gt;&gt;&gt; +   stats-&gt;rx_packets++;
</I>&gt;<i> &gt;&gt;&gt; +   quota--;
</I>&gt;<i> &gt;&gt;&gt; +   stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +   pch_fifo_thresh(priv, obj_num);
</I>&gt;<i> &gt;&gt;&gt; +  }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  /* Reading the messsage object from the Message RAM */
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, obj_num + 1);
</I>&gt;<i> &gt;&gt;&gt; +  reg = ioread32(&amp;priv-&gt;regs-&gt;if1_mcont);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; this is almost the same code as before the the loop, can you rearange
</I>&gt;<i> &gt;&gt; the code to avoid duplication?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + return rcv_pkts;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_tx_complete(struct net_device *ndev, u32 int_stat)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt;&gt;&gt; + struct net_device_stats *stats = &amp;(priv-&gt;ndev-&gt;stats);
</I>&gt;<i> &gt;&gt;&gt; + unsigned long flags;
</I>&gt;<i> &gt;&gt;&gt; + u32 dlc;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + can_get_echo_skb(ndev, int_stat - PCH_RX_OBJ_NUM - 1);
</I>&gt;<i> &gt;&gt;&gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(CAN_CMASK_RX_TX_GET | CAN_CMASK_CLRINTPND,
</I>&gt;<i> &gt;&gt;&gt; +    &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;<i> &gt;&gt;&gt; + dlc = ioread32(&amp;priv-&gt;regs-&gt;if2_mcont) &amp; CAN_IF_MCONT_DLC;
</I>&gt;<i> &gt;&gt;&gt; + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, int_stat);
</I>&gt;<i> &gt;&gt;&gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; + if (dlc &gt; 8)
</I>&gt;<i> &gt;&gt;&gt; +  dlc = 8;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; use get_can_dlc
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; + stats-&gt;tx_bytes += dlc;
</I>&gt;<i> &gt;&gt;&gt; + stats-&gt;tx_packets++;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static int pch_can_rx_poll(struct napi_struct *napi, int quota)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + struct net_device *ndev = napi-&gt;dev;
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt;&gt;&gt; + u32 int_stat;
</I>&gt;<i> &gt;&gt;&gt; + int rcv_pkts = 0;
</I>&gt;<i> &gt;&gt;&gt; + u32 reg_stat;
</I>&gt;<i> &gt;&gt;&gt; + unsigned long flags;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + int_stat = pch_can_int_pending(priv);
</I>&gt;<i> &gt;&gt;&gt; + if (!int_stat)
</I>&gt;<i> &gt;&gt;&gt; +  goto END;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + if ((int_stat == CAN_STATUS_INT) &amp;&amp; (quota &gt; 0)) {
</I>&gt;<i> &gt;&gt;&gt; +  reg_stat = ioread32(&amp;priv-&gt;regs-&gt;stat);
</I>&gt;<i> &gt;&gt;&gt; +  if (reg_stat &amp; (PCH_BUS_OFF | PCH_LEC_ALL)) {
</I>&gt;<i> &gt;&gt;&gt; +   if ((reg_stat &amp; PCH_LEC_ALL) != PCH_LEC_ALL) {
</I>&gt;<i> &gt;&gt;&gt; +    pch_can_error(ndev, reg_stat);
</I>&gt;<i> &gt;&gt;&gt; +    quota--;
</I>&gt;<i> &gt;&gt;&gt; +   }
</I>&gt;<i> &gt;&gt;&gt; +  }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  if (reg_stat &amp; PCH_TX_OK) {
</I>&gt;<i> &gt;&gt;&gt; +   spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; +   iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;<i> &gt;&gt;&gt; +   pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq,
</I>&gt;<i> &gt;&gt;&gt; +            ioread32(&amp;priv-&gt;regs-&gt;intr));
</I>&gt;<i> &gt;&gt;                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Isn't this &quot;int_stat&quot;. Might it be possilbe that regs-&gt;intr changes
</I>&gt;<i> &gt;&gt; between the pch_can_int_pending and here?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; This code was mistake.
</I>&gt;<i> &gt; This condition, message object is not acccessed.
</I>&gt;<i> &gt; Thus, pch_can_check_if_busy can be deleted.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; What should this transfer do?
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +   spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; +   pch_can_bit_clear(&amp;priv-&gt;regs-&gt;stat, PCH_TX_OK);
</I>&gt;<i> &gt;&gt;&gt; +  }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  if (reg_stat &amp; PCH_RX_OK)
</I>&gt;<i> &gt;&gt;&gt; +   pch_can_bit_clear(&amp;priv-&gt;regs-&gt;stat, PCH_RX_OK);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  int_stat = pch_can_int_pending(priv);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + if (quota == 0)
</I>&gt;<i> &gt;&gt;&gt; +  goto END;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + if ((int_stat &gt;= 1) &amp;&amp; (int_stat &lt;= PCH_RX_OBJ_NUM)) {
</I>&gt;<i> &gt;&gt;&gt; +  spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; +  rcv_pkts += pch_can_rx_normal(ndev, int_stat, quota);
</I>&gt;<i> &gt;&gt;&gt; +  spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; +  quota -= rcv_pkts;
</I>&gt;<i> &gt;&gt;&gt; +  if (rcv_pkts &lt; 0)
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; how can this happen?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; My mistake.
</I>&gt;<i> &gt; if (quota &lt; 0) is TRUE.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +   goto END;
</I>&gt;<i> &gt;&gt;&gt; + } else if ((int_stat &gt; PCH_RX_OBJ_NUM) &amp;&amp; (int_stat &lt;= PCH_OBJ_NUM)) {
</I>&gt;<i> &gt;&gt;&gt; +  /* Handle transmission interrupt */
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_tx_complete(ndev, int_stat);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +END:
</I>&gt;<i> &gt;&gt;&gt; + napi_complete(napi);
</I>&gt;<i> &gt;&gt;&gt; + pch_can_set_int_enables(priv, PCH_CAN_ALL);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + return rcv_pkts;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static int pch_set_bittiming(struct net_device *ndev)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt;&gt;&gt; + const struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> &gt;&gt;&gt; + u32 canbit;
</I>&gt;<i> &gt;&gt;&gt; + u32 bepe;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Setting the CCE bit for accessing the Can Timing register. */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_CCE);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + canbit = (bt-&gt;brp - 1) &amp; MSK_BITT_BRP;
</I>&gt;<i> &gt;&gt;&gt; + canbit |= (bt-&gt;sjw - 1) &lt;&lt; BIT_BITT_SJW;
</I>&gt;<i> &gt;&gt;&gt; + canbit |= (bt-&gt;phase_seg1 + bt-&gt;prop_seg - 1) &lt;&lt; BIT_BITT_TSEG1;
</I>&gt;<i> &gt;&gt;&gt; + canbit |= (bt-&gt;phase_seg2 - 1) &lt;&lt; BIT_BITT_TSEG2;
</I>&gt;<i> &gt;&gt;&gt; + bepe = ((bt-&gt;brp - 1) &amp; MSK_BRPE_BRPE) &gt;&gt; BIT_BRPE_BRPE;
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(canbit, &amp;priv-&gt;regs-&gt;bitt);
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(bepe, &amp;priv-&gt;regs-&gt;brpe);
</I>&gt;<i> &gt;&gt;&gt; + pch_can_bit_clear(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_CCE);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + return 0;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_start(struct net_device *ndev)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + if (priv-&gt;can.state != CAN_STATE_STOPPED)
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_reset(priv);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + pch_set_bittiming(ndev);
</I>&gt;<i> &gt;&gt;&gt; + pch_can_set_optmode(priv);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + pch_can_tx_enable_all(priv);
</I>&gt;<i> &gt;&gt;&gt; + pch_can_rx_enable_all(priv);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Setting the CAN to run mode. */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_set_run_mode(priv, PCH_CAN_RUN);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + return;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static int pch_can_do_set_mode(struct net_device *ndev, enum can_mode mode)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + int ret = 0;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + switch (mode) {
</I>&gt;<i> &gt;&gt;&gt; + case CAN_MODE_START:
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_start(ndev);
</I>&gt;<i> &gt;&gt;&gt; +  netif_wake_queue(ndev);
</I>&gt;<i> &gt;&gt;&gt; +  break;
</I>&gt;<i> &gt;&gt;&gt; + default:
</I>&gt;<i> &gt;&gt;&gt; +  ret = -EOPNOTSUPP;
</I>&gt;<i> &gt;&gt;&gt; +  break;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + return ret;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static int pch_can_open(struct net_device *ndev)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt;&gt;&gt; + int retval;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Regsitering the interrupt. */
</I>&gt;<i> &gt;&gt;&gt; + retval = request_irq(priv-&gt;dev-&gt;irq, pch_can_interrupt, IRQF_SHARED,
</I>&gt;<i> &gt;&gt;&gt; +        ndev-&gt;name, ndev);
</I>&gt;<i> &gt;&gt;&gt; + if (retval) {
</I>&gt;<i> &gt;&gt;&gt; +  dev_err(&amp;ndev-&gt;dev, &quot;request_irq failed.\n&quot;);
</I>&gt;<i> &gt;&gt;&gt; +  goto req_irq_err;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Open common can device */
</I>&gt;<i> &gt;&gt;&gt; + retval = open_candev(ndev);
</I>&gt;<i> &gt;&gt;&gt; + if (retval) {
</I>&gt;<i> &gt;&gt;&gt; +  dev_err(ndev-&gt;dev.parent, &quot;open_candev() failed %d\n&quot;, retval);
</I>&gt;<i> &gt;&gt;&gt; +  goto err_open_candev;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + pch_can_init(priv);
</I>&gt;<i> &gt;&gt;&gt; + pch_can_start(ndev);
</I>&gt;<i> &gt;&gt;&gt; + napi_enable(&amp;priv-&gt;napi);
</I>&gt;<i> &gt;&gt;&gt; + netif_start_queue(ndev);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + return 0;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +err_open_candev:
</I>&gt;<i> &gt;&gt;&gt; + free_irq(priv-&gt;dev-&gt;irq, ndev);
</I>&gt;<i> &gt;&gt;&gt; +req_irq_err:
</I>&gt;<i> &gt;&gt;&gt; + pch_can_release(priv);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + return retval;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static int pch_close(struct net_device *ndev)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + netif_stop_queue(ndev);
</I>&gt;<i> &gt;&gt;&gt; + napi_disable(&amp;priv-&gt;napi);
</I>&gt;<i> &gt;&gt;&gt; + pch_can_release(priv);
</I>&gt;<i> &gt;&gt;&gt; + free_irq(priv-&gt;dev-&gt;irq, ndev);
</I>&gt;<i> &gt;&gt;&gt; + close_candev(ndev);
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> &gt;&gt;&gt; + return 0;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + unsigned long flags;
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt;&gt;&gt; + struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> &gt;&gt;&gt; + int tx_buffer_avail = 0;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; What I'm totally missing is the TX flow controll. Your driver has to
</I>&gt;<i> &gt;&gt; ensure that the package leave the controller in the order that come
</I>&gt;<i> &gt;&gt; into the xmit function. Further you have to stop your xmit queue if
</I>&gt;<i> &gt;&gt; you're out of tx objects and reenable if you have a object free.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Use netif_stop_queue() and netif_wake_queue() for this.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; In this code, I think &quot;out of tx objects&quot; cannot be  occurred.
</I>&gt;<i> 
</I>&gt;<i> It's not a matter of code it's the hardware. You cannot put more than a
</I>&gt;<i> certain number of CAN frames into the hardware. If you have a CAN bus at
</I>&gt;<i> a certain speed, you can only send a certain number of CAN frames in a
</I>&gt;<i> second. So you cannot push more than this amount of frames/s into the
</I>&gt;<i> hardware.
</I>&gt;<i> 
</I>&gt;<i> &gt; Nevertheless, are netif_stop_queue() and netif_wake_queue() is necessary ?
</I>&gt;<i> 
</I>&gt;<i> Yes.
</I>
I can' understand your issue.
Please can you hear my opinion?

Please see the head of pch_xmit.

&gt;<i> &gt; + if (priv-&gt;tx_obj == (PCH_OBJ_NUM + 1)) { /* Point tail Obj + 1 */
</I>&gt;<i> &gt; +  while (ioread32(&amp;priv-&gt;regs-&gt;treq2) &amp; 0xfc00)
</I>&gt;<i> &gt; +   udelay(1);
</I>
When points tail of Tx message object,
this driver waits until completion of all tx messaeg objects.
Thus, application/driver ought not to be able to put Tx object exceed the number of tx message object.
Thus I think these code(netif_stop_queue/netif_wake_queue) are completely redundant.

&gt;<i> 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + if (can_dropped_invalid_skb(ndev, skb))
</I>&gt;<i> &gt;&gt;&gt; +  return NETDEV_TX_OK;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + if (priv-&gt;tx_obj == (PCH_OBJ_NUM + 1)) { /* Point tail Obj + 1 */
</I>&gt;<i> &gt;&gt;&gt; +  while (ioread32(&amp;priv-&gt;regs-&gt;treq2) &amp; 0xfc00)
</I>&gt;<i> &gt;&gt;&gt; +   udelay(1);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; please no (possible) infinite delays!
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I will add break processing.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +  priv-&gt;tx_obj = PCH_RX_OBJ_NUM + 1; /* Point head of Tx Obj ID */
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + tx_buffer_avail = priv-&gt;tx_obj;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; why has the &quot;object&quot; become a &quot;buffer&quot; now? :)
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; You are right.
</I>&gt;<i> &gt; I will modify the name.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;tx_obj++;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Attaining the lock. */
</I>&gt;<i> &gt;&gt;&gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Setting the CMASK register to set value*/
</I>&gt;<i> &gt;&gt;                                                  ^^^
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; pleas add a whitespace
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I agree.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(CAN_CMASK_RX_TX_SET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* If ID extended is set. */
</I>&gt;<i> &gt;&gt;&gt; + if (cf-&gt;can_id &amp; CAN_EFF_FLAG) {
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(cf-&gt;can_id &amp; 0xffff, &amp;priv-&gt;regs-&gt;if2_id1);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(((cf-&gt;can_id &gt;&gt; 16) &amp; 0x1fff) | CAN_ID2_XTD,
</I>&gt;<i> &gt;&gt;&gt; +       &amp;priv-&gt;regs-&gt;if2_id2);
</I>&gt;<i> &gt;&gt;&gt; + } else {
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(0, &amp;priv-&gt;regs-&gt;if2_id1);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32((cf-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; 2,
</I>&gt;<i> &gt;&gt;&gt; +      &amp;priv-&gt;regs-&gt;if2_id2);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id2, CAN_ID_MSGVAL);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Do you need to do a read-modify-write of the hardware register? Please
</I>&gt;<i> &gt;&gt; prepare the values you want to write to hardware, then do it.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Current design policy for read/write message object,
</I>&gt;<i> &gt; the driver is designed with Read-Modify-Write.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I will modify to Write only for reducing accessing Message RAM.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* If remote frame has to be transmitted.. */
</I>&gt;<i> &gt;&gt;&gt; + if (!(cf-&gt;can_id &amp; CAN_RTR_FLAG))
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_id2, CAN_ID2_DIR);
</I>&gt;<i> &gt;&gt; dito
</I>&gt;<i> &gt;&gt;&gt; + /* If remote frame has to be transmitted.. */
</I>&gt;<i> &gt;&gt;&gt; + if (cf-&gt;can_id &amp; CAN_RTR_FLAG)
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if2_id2, CAN_ID2_DIR);
</I>&gt;<i> &gt;&gt; dito
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Copy data to register */
</I>&gt;<i> &gt;&gt;&gt; + if (cf-&gt;can_dlc &gt; 0) {
</I>&gt;<i> &gt;&gt;&gt; +  u32 data1 = *((u16 *)&amp;cf-&gt;data[0]);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(data1, &amp;priv-&gt;regs-&gt;if2_dataa1);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; do you think you send the bytes in correct order?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Let me study this endianess.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; + if (cf-&gt;can_dlc &gt; 2) {
</I>&gt;<i> &gt;&gt;&gt; +  u32 data1 = *((u16 *)&amp;cf-&gt;data[2]);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(data1, &amp;priv-&gt;regs-&gt;if2_dataa2);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; + if (cf-&gt;can_dlc &gt; 4) {
</I>&gt;<i> &gt;&gt;&gt; +  u32 data1 = *((u16 *)&amp;cf-&gt;data[4]);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(data1, &amp;priv-&gt;regs-&gt;if2_datab1);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; + if (cf-&gt;can_dlc &gt; 6) {
</I>&gt;<i> &gt;&gt;&gt; +  u32 data1 = *((u16 *)&amp;cf-&gt;data[6]);
</I>&gt;<i> &gt;&gt;&gt; +  iowrite32(data1, &amp;priv-&gt;regs-&gt;if2_datab2);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + can_put_echo_skb(skb, ndev, tx_buffer_avail - PCH_RX_OBJ_NUM - 1);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Set the size of the data. */
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(cf-&gt;can_dlc, &amp;priv-&gt;regs-&gt;if2_mcont);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Update if2_mcont */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_mcont,
</I>&gt;<i> &gt;&gt;&gt; +   CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_TXRQXT |
</I>&gt;<i> &gt;&gt;&gt; +   CAN_IF_MCONT_TXIE);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; pleae first perpare your value, then write to hardware.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; ditto.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + if (tx_buffer_avail == PCH_RX_OBJ_NUM) /* If points tail of FIFO  */
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if2_mcont, CAN_IF_MCONT_EOB);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; dito
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Is EOB relevant for TX objects?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; This is mistake. No meaning for tx.
</I>&gt;<i> &gt; I will modify.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt; + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, tx_buffer_avail);
</I>&gt;<i> &gt;&gt;&gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + return NETDEV_TX_OK;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static const struct net_device_ops pch_can_netdev_ops = {
</I>&gt;<i> &gt;&gt;&gt; + .ndo_open  = pch_can_open,
</I>&gt;<i> &gt;&gt;&gt; + .ndo_stop  = pch_close,
</I>&gt;<i> &gt;&gt;&gt; + .ndo_start_xmit  = pch_xmit,
</I>&gt;<i> &gt;&gt;&gt; +};
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void __devexit pch_can_remove(struct pci_dev *pdev)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + struct net_device *ndev = pci_get_drvdata(pdev);
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_priv *priv = netdev_priv(ndev);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + unregister_candev(priv-&gt;ndev);
</I>&gt;<i> &gt;&gt;&gt; + pci_iounmap(pdev, priv-&gt;regs);
</I>&gt;<i> &gt;&gt;&gt; + if (priv-&gt;use_msi)
</I>&gt;<i> &gt;&gt;&gt; +  pci_disable_msi(priv-&gt;dev);
</I>&gt;<i> &gt;&gt;&gt; + pci_release_regions(pdev);
</I>&gt;<i> &gt;&gt;&gt; + pci_disable_device(pdev);
</I>&gt;<i> &gt;&gt;&gt; + pci_set_drvdata(pdev, NULL);
</I>&gt;<i> &gt;&gt;&gt; + free_candev(priv-&gt;ndev);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +#ifdef CONFIG_PM
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_set_int_custom(struct pch_can_priv *priv)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + /* Clearing the IE, SIE and EIE bits of Can control register. */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_bit_clear(&amp;priv-&gt;regs-&gt;cont, CAN_CTRL_IE_SIE_EIE);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Appropriately setting them. */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_bit_set(&amp;priv-&gt;regs-&gt;cont,
</I>&gt;<i> &gt;&gt;&gt; +   ((priv-&gt;int_enables &amp; MSK_CTRL_IE_SIE_EIE) &lt;&lt; 1));
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +/* This function retrieves interrupt enabled for the CAN device. */
</I>&gt;<i> &gt;&gt;&gt; +static u32 pch_can_get_int_enables(struct pch_can_priv *priv)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + /* Obtaining the status of IE, SIE and EIE interrupt bits. */
</I>&gt;<i> &gt;&gt;&gt; + return (ioread32(&amp;priv-&gt;regs-&gt;cont) &amp; CAN_CTRL_IE_SIE_EIE) &gt;&gt; 1;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static u32 pch_can_get_rx_enable(struct pch_can_priv *priv, u32 buff_num)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + unsigned long flags;
</I>&gt;<i> &gt;&gt;&gt; + u32 enable;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;<i> &gt;&gt;&gt; + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buff_num);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + if (((ioread32(&amp;priv-&gt;regs-&gt;if1_id2)) &amp; CAN_ID_MSGVAL) &amp;&amp;
</I>&gt;<i> &gt;&gt;&gt; +   ((ioread32(&amp;priv-&gt;regs-&gt;if1_mcont)) &amp;
</I>&gt;<i> &gt;&gt;&gt; +   CAN_IF_MCONT_RXIE))
</I>&gt;<i> &gt;&gt;&gt; +  enable = 1;
</I>&gt;<i> &gt;&gt;&gt; + else
</I>&gt;<i> &gt;&gt;&gt; +  enable = 0;
</I>&gt;<i> &gt;&gt;&gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; + return enable;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static u32 pch_can_get_tx_enable(struct pch_can_priv *priv, u32 buff_num)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + unsigned long flags;
</I>&gt;<i> &gt;&gt;&gt; + u32 enable;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if2_cmask);
</I>&gt;<i> &gt;&gt;&gt; + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if2_creq, buff_num);
</I>&gt;<i> &gt;&gt;&gt; + if (((ioread32(&amp;priv-&gt;regs-&gt;if2_id2)) &amp; CAN_ID_MSGVAL) &amp;&amp;
</I>&gt;<i> &gt;&gt;&gt; +   ((ioread32(&amp;priv-&gt;regs-&gt;if2_mcont)) &amp;
</I>&gt;<i> &gt;&gt;&gt; +   CAN_IF_MCONT_TXIE)) {
</I>&gt;<i> &gt;&gt;&gt; +  enable = 1;
</I>&gt;<i> &gt;&gt;&gt; + } else {
</I>&gt;<i> &gt;&gt;&gt; +  enable = 0;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + return enable;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void pch_can_set_rx_buffer_link(struct pch_can_priv *priv,
</I>&gt;<i> &gt;&gt;&gt; +           u32 buffer_num, u32 set)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + unsigned long flags;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;<i> &gt;&gt;&gt; + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buffer_num);
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;<i> &gt;&gt;&gt; + if (set == 1)
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_clear(&amp;priv-&gt;regs-&gt;if1_mcont, CAN_IF_MCONT_EOB);
</I>&gt;<i> &gt;&gt;&gt; + else
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_bit_set(&amp;priv-&gt;regs-&gt;if1_mcont, CAN_IF_MCONT_EOB);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buffer_num);
</I>&gt;<i> &gt;&gt;&gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static u32 pch_can_get_rx_buffer_link(struct pch_can_priv *priv, u32 buffer_num)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + unsigned long flags;
</I>&gt;<i> &gt;&gt;&gt; + u32 link;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + spin_lock_irqsave(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; + iowrite32(CAN_CMASK_RX_TX_GET, &amp;priv-&gt;regs-&gt;if1_cmask);
</I>&gt;<i> &gt;&gt;&gt; + pch_can_check_if_busy(&amp;priv-&gt;regs-&gt;if1_creq, buffer_num);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + if (ioread32(&amp;priv-&gt;regs-&gt;if1_mcont) &amp; CAN_IF_MCONT_EOB)
</I>&gt;<i> &gt;&gt;&gt; +  link = 0;
</I>&gt;<i> &gt;&gt;&gt; + else
</I>&gt;<i> &gt;&gt;&gt; +  link = 1;
</I>&gt;<i> &gt;&gt;&gt; + spin_unlock_irqrestore(&amp;priv-&gt;msgif_reg_lock, flags);
</I>&gt;<i> &gt;&gt;&gt; + return link;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + int i;
</I>&gt;<i> &gt;&gt;&gt; + int retval;
</I>&gt;<i> &gt;&gt;&gt; + u32 buf_stat; /* Variable for reading the transmit buffer status. */
</I>&gt;<i> &gt;&gt;&gt; + u32 counter = COUNTER_LIMIT;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + struct net_device *dev = pci_get_drvdata(pdev);
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Stop the CAN controller */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Indicate that we are aboutto/in suspend */
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Waiting for all transmission to complete. */
</I>&gt;<i> &gt;&gt;&gt; + while (counter) {
</I>&gt;<i> &gt;&gt;&gt; +  buf_stat = pch_can_get_buffer_status(priv);
</I>&gt;<i> &gt;&gt;&gt; +  if (!buf_stat)
</I>&gt;<i> &gt;&gt;&gt; +   break;
</I>&gt;<i> &gt;&gt;&gt; +  counter--;
</I>&gt;<i> &gt;&gt;&gt; +  udelay(1);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; + if (!counter)
</I>&gt;<i> &gt;&gt;&gt; +  dev_err(&amp;pdev-&gt;dev, &quot;%s -&gt; Transmission time out.\n&quot;, __func__);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Save interrupt configuration and then disable them */
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;int_enables = pch_can_get_int_enables(priv);
</I>&gt;<i> &gt;&gt;&gt; + pch_can_set_int_enables(priv, PCH_CAN_DISABLE);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Save Tx buffer enable state */
</I>&gt;<i> &gt;&gt;&gt; + for (i = PCH_RX_OBJ_NUM + 1; i &lt;= PCH_OBJ_NUM; i++)
</I>&gt;<i> &gt;&gt;&gt; +  priv-&gt;tx_enable[i] = pch_can_get_tx_enable(priv, i);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Disable all Transmit buffers */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_tx_disable_all(priv);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Save Rx buffer enable state */
</I>&gt;<i> &gt;&gt;&gt; + for (i = 1; i &lt;= PCH_RX_OBJ_NUM; i++) {
</I>&gt;<i> &gt;&gt;&gt; +  priv-&gt;rx_enable[i] = pch_can_get_rx_enable(priv, i);
</I>&gt;<i> &gt;&gt;&gt; +  priv-&gt;rx_link[i] = pch_can_get_rx_buffer_link(priv, i);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Disable all Receive buffers */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_rx_disable_all(priv);
</I>&gt;<i> &gt;&gt;&gt; + retval = pci_save_state(pdev);
</I>&gt;<i> &gt;&gt;&gt; + if (retval) {
</I>&gt;<i> &gt;&gt;&gt; +  dev_err(&amp;pdev-&gt;dev, &quot;pci_save_state failed.\n&quot;);
</I>&gt;<i> &gt;&gt;&gt; + } else {
</I>&gt;<i> &gt;&gt;&gt; +  pci_enable_wake(pdev, PCI_D3hot, 0);
</I>&gt;<i> &gt;&gt;&gt; +  pci_disable_device(pdev);
</I>&gt;<i> &gt;&gt;&gt; +  pci_set_power_state(pdev, pci_choose_state(pdev, state));
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + return retval;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static int pch_can_resume(struct pci_dev *pdev)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + int i;
</I>&gt;<i> &gt;&gt;&gt; + int retval;
</I>&gt;<i> &gt;&gt;&gt; + struct net_device *dev = pci_get_drvdata(pdev);
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + pci_set_power_state(pdev, PCI_D0);
</I>&gt;<i> &gt;&gt;&gt; + pci_restore_state(pdev);
</I>&gt;<i> &gt;&gt;&gt; + retval = pci_enable_device(pdev);
</I>&gt;<i> &gt;&gt;&gt; + if (retval) {
</I>&gt;<i> &gt;&gt;&gt; +  dev_err(&amp;pdev-&gt;dev, &quot;pci_enable_device failed.\n&quot;);
</I>&gt;<i> &gt;&gt;&gt; +  return retval;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + pci_enable_wake(pdev, PCI_D3hot, 0);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Disabling all interrupts. */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_set_int_enables(priv, PCH_CAN_DISABLE);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Setting the CAN device in Stop Mode. */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_set_run_mode(priv, PCH_CAN_STOP);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Configuring the transmit and receive buffers. */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_config_rx_tx_buffers(priv);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Restore the CAN state */
</I>&gt;<i> &gt;&gt;&gt; + pch_set_bittiming(dev);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Listen/Active */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_set_optmode(priv);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Enabling the transmit buffer. */
</I>&gt;<i> &gt;&gt;&gt; + for (i = 1; i &lt;= PCH_RX_OBJ_NUM; i++)
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_set_tx_enable(priv, i, priv-&gt;tx_enable[i]);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Configuring the receive buffer and enabling them. */
</I>&gt;<i> &gt;&gt;&gt; + for (i = PCH_RX_OBJ_NUM + 1; i &lt;= PCH_OBJ_NUM; i++) {
</I>&gt;<i> &gt;&gt;&gt; +  /* Restore buffer link */
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_set_rx_buffer_link(priv, i, priv-&gt;rx_link[i]);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +  /* Restore buffer enables */
</I>&gt;<i> &gt;&gt;&gt; +  pch_can_set_rx_enable(priv, i, priv-&gt;rx_enable[i]);
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Enable CAN Interrupts */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_set_int_custom(priv);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + /* Restore Run Mode */
</I>&gt;<i> &gt;&gt;&gt; + pch_can_set_run_mode(priv, PCH_CAN_RUN);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + return retval;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +#else
</I>&gt;<i> &gt;&gt;&gt; +#define pch_can_suspend NULL
</I>&gt;<i> &gt;&gt;&gt; +#define pch_can_resume NULL
</I>&gt;<i> &gt;&gt;&gt; +#endif
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static int pch_can_get_berr_counter(const struct net_device *dev,
</I>&gt;<i> &gt;&gt;&gt; +        struct can_berr_counter *bec)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + bec-&gt;txerr = ioread32(&amp;priv-&gt;regs-&gt;errc) &amp; CAN_TEC;
</I>&gt;<i> &gt;&gt;&gt; + bec-&gt;rxerr = (ioread32(&amp;priv-&gt;regs-&gt;errc) &amp; CAN_REC) &gt;&gt; 8;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + return 0;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static int __devinit pch_can_probe(struct pci_dev *pdev,
</I>&gt;<i> &gt;&gt;&gt; +       const struct pci_device_id *id)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + struct net_device *ndev;
</I>&gt;<i> &gt;&gt;&gt; + struct pch_can_priv *priv;
</I>&gt;<i> &gt;&gt;&gt; + int rc;
</I>&gt;<i> &gt;&gt;&gt; + void __iomem *addr;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + rc = pci_enable_device(pdev);
</I>&gt;<i> &gt;&gt;&gt; + if (rc) {
</I>&gt;<i> &gt;&gt;&gt; +  dev_err(&amp;pdev-&gt;dev, &quot;Failed pci_enable_device %d\n&quot;, rc);
</I>&gt;<i> &gt;&gt;&gt; +  goto probe_exit_endev;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + rc = pci_request_regions(pdev, KBUILD_MODNAME);
</I>&gt;<i> &gt;&gt;&gt; + if (rc) {
</I>&gt;<i> &gt;&gt;&gt; +  dev_err(&amp;pdev-&gt;dev, &quot;Failed pci_request_regions %d\n&quot;, rc);
</I>&gt;<i> &gt;&gt;&gt; +  goto probe_exit_pcireq;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + addr = pci_iomap(pdev, 1, 0);
</I>&gt;<i> &gt;&gt;&gt; + if (!addr) {
</I>&gt;<i> &gt;&gt;&gt; +  rc = -EIO;
</I>&gt;<i> &gt;&gt;&gt; +  dev_err(&amp;pdev-&gt;dev, &quot;Failed pci_iomap\n&quot;);
</I>&gt;<i> &gt;&gt;&gt; +  goto probe_exit_ipmap;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + ndev = alloc_candev(sizeof(struct pch_can_priv), PCH_TX_OBJ_NUM);
</I>&gt;<i> &gt;&gt;&gt; + if (!ndev) {
</I>&gt;<i> &gt;&gt;&gt; +  rc = -ENOMEM;
</I>&gt;<i> &gt;&gt;&gt; +  dev_err(&amp;pdev-&gt;dev, &quot;Failed alloc_candev\n&quot;);
</I>&gt;<i> &gt;&gt;&gt; +  goto probe_exit_alloc_candev;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + priv = netdev_priv(ndev);
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;ndev = ndev;
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;regs = addr;
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;dev = pdev;
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;can.bittiming_const = &amp;pch_can_bittiming_const;
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;can.do_set_mode = pch_can_do_set_mode;
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;can.do_get_berr_counter = pch_can_get_berr_counter;
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;can.ctrlmode_supported = CAN_CTRLMODE_LISTENONLY |
</I>&gt;<i> &gt;&gt;&gt; +           CAN_CTRLMODE_LOOPBACK;
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;tx_obj = PCH_RX_OBJ_NUM + 1; /* Point head of Tx Obj */
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + ndev-&gt;irq = pdev-&gt;irq;
</I>&gt;<i> &gt;&gt;&gt; + ndev-&gt;flags |= IFF_ECHO;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + pci_set_drvdata(pdev, ndev);
</I>&gt;<i> &gt;&gt;&gt; + SET_NETDEV_DEV(ndev, &amp;pdev-&gt;dev);
</I>&gt;<i> &gt;&gt;&gt; + ndev-&gt;netdev_ops = &amp;pch_can_netdev_ops;
</I>&gt;<i> &gt;&gt;&gt; + priv-&gt;can.clock.freq = PCH_CAN_CLK; /* Hz */
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + netif_napi_add(ndev, &amp;priv-&gt;napi, pch_can_rx_poll, PCH_RX_OBJ_NUM);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + rc = pci_enable_msi(priv-&gt;dev);
</I>&gt;<i> &gt;&gt;&gt; + if (rc) {
</I>&gt;<i> &gt;&gt;&gt; +  dev_info(&amp;ndev-&gt;dev, &quot;PCH CAN opened without MSI\n&quot;);
</I>&gt;<i> &gt;&gt;&gt; +  priv-&gt;use_msi = 0;
</I>&gt;<i> &gt;&gt;&gt; + } else {
</I>&gt;<i> &gt;&gt;&gt; +  dev_info(&amp;ndev-&gt;dev, &quot;PCH CAN opened with MSI\n&quot;);
</I>&gt;<i> &gt;&gt;&gt; +  priv-&gt;use_msi = 1;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + rc = register_candev(ndev);
</I>&gt;<i> &gt;&gt;&gt; + if (rc) {
</I>&gt;<i> &gt;&gt;&gt; +  dev_err(&amp;pdev-&gt;dev, &quot;Failed register_candev %d\n&quot;, rc);
</I>&gt;<i> &gt;&gt;&gt; +  goto probe_exit_reg_candev;
</I>&gt;<i> &gt;&gt;&gt; + }
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; + return 0;
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +probe_exit_reg_candev:
</I>&gt;<i> &gt;&gt;&gt; + free_candev(ndev);
</I>&gt;<i> &gt;&gt;&gt; +probe_exit_alloc_candev:
</I>&gt;<i> &gt;&gt;&gt; + pci_iounmap(pdev, addr);
</I>&gt;<i> &gt;&gt;&gt; +probe_exit_ipmap:
</I>&gt;<i> &gt;&gt;&gt; + pci_release_regions(pdev);
</I>&gt;<i> &gt;&gt;&gt; +probe_exit_pcireq:
</I>&gt;<i> &gt;&gt;&gt; + pci_disable_device(pdev);
</I>&gt;<i> &gt;&gt;&gt; +probe_exit_endev:
</I>&gt;<i> &gt;&gt;&gt; + return rc;
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static struct pci_driver pch_can_pcidev = {
</I>&gt;<i> &gt;&gt;&gt; + .name = &quot;pch_can&quot;,
</I>&gt;<i> &gt;&gt;&gt; + .id_table = pch_pci_tbl,
</I>&gt;<i> &gt;&gt;&gt; + .probe = pch_can_probe,
</I>&gt;<i> &gt;&gt;&gt; + .remove = __devexit_p(pch_can_remove),
</I>&gt;<i> &gt;&gt;&gt; + .suspend = pch_can_suspend,
</I>&gt;<i> &gt;&gt;&gt; + .resume = pch_can_resume,
</I>&gt;<i> &gt;&gt;&gt; +};
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static int __init pch_can_pci_init(void)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + return pci_register_driver(&amp;pch_can_pcidev);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +module_init(pch_can_pci_init);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +static void __exit pch_can_pci_exit(void)
</I>&gt;<i> &gt;&gt;&gt; +{
</I>&gt;<i> &gt;&gt;&gt; + pci_unregister_driver(&amp;pch_can_pcidev);
</I>&gt;<i> &gt;&gt;&gt; +}
</I>&gt;<i> &gt;&gt;&gt; +module_exit(pch_can_pci_exit);
</I>&gt;<i> &gt;&gt;&gt; +
</I>&gt;<i> &gt;&gt;&gt; +MODULE_DESCRIPTION(&quot;Intel EG20T PCH CAN(Controller Area Network) Driver&quot;);
</I>&gt;<i> &gt;&gt;&gt; +MODULE_LICENSE(&quot;GPL v2&quot;);
</I>&gt;<i> &gt;&gt;&gt; +MODULE_VERSION(&quot;0.94&quot;);
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; cheers, Marc
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; -- 
</I>&gt;<i> &gt;&gt; Pengutronix e.K.                  | Marc Kleine-Budde           |
</I>&gt;<i> &gt;&gt; Industrial Linux Solutions        | Phone: +49-231-2826-924     |
</I>&gt;<i> &gt;&gt; Vertretung West/Dortmund          | Fax:   +49-5121-206917-5555 |
</I>&gt;<i> &gt;&gt; Amtsgericht Hildesheim, HRA 2686  | <A HREF="http://www.pengutronix.de">http://www.pengutronix.de</A>   |
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Thanks, Tomoya(OKI SEMICONDUCTOR CO., LTD.)
</I>&gt;<i> 
</I>&gt;<i> cheers, Marc
</I>&gt;<i> 
</I>&gt;<i> -- 
</I>&gt;<i> Pengutronix e.K.                  | Marc Kleine-Budde           |
</I>&gt;<i> Industrial Linux Solutions        | Phone: +49-231-2826-924     |
</I>&gt;<i> Vertretung West/Dortmund          | Fax:   +49-5121-206917-5555 |
</I>&gt;<i> Amtsgericht Hildesheim, HRA 2686  | <A HREF="http://www.pengutronix.de">http://www.pengutronix.de</A>   |
</I>&gt;<i> 
</I>&gt;<i>
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004933.html">[PATCH net-next-2.6 v2] can: Topcliff: PCH_CAN driver: Fix build	warnings
</A></li>
	<LI>Next message: <A HREF="004932.html">[PATCH net-next-2.6 v2] can: Topcliff: PCH_CAN driver: Fix build	warnings
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4931">[ date ]</a>
              <a href="thread.html#4931">[ thread ]</a>
              <a href="subject.html#4931">[ subject ]</a>
              <a href="author.html#4931">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
