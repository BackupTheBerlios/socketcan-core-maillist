<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Comments on at91_can.c
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-August/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20Comments%20on%20at91_can.c&In-Reply-To=%3C4A83FBA6.2010405%40grandegger.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002894.html">
   <LINK REL="Next"  HREF="002860.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Comments on at91_can.c</H1>
    <B>Wolfgang Grandegger</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20Comments%20on%20at91_can.c&In-Reply-To=%3C4A83FBA6.2010405%40grandegger.com%3E"
       TITLE="Comments on at91_can.c">wg at grandegger.com
       </A><BR>
    <I>Thu Aug 13 13:40:22 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002894.html">dlc check in driver
</A></li>
        <LI>Next message: <A HREF="002860.html">Comments on at91_can.c
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2859">[ date ]</a>
              <a href="thread.html#2859">[ thread ]</a>
              <a href="subject.html#2859">[ subject ]</a>
              <a href="author.html#2859">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

it follows a quick review of the at91 driver from &quot;branches/netlink&quot;. I
see various coding style issues. Please check with checkpatch.pl and
fix. Note that you can use

 ./strip-src -m -i -v 2.6.31 kernel/2.6/drivers/net/can/at91_can.c

to get a reasonable file version for kernel inclusion. Also, dev_dbg's
for development are not any more acceptable for kernel inclusion.
Restrict them to a level userful for normal users, e.g. reporting state
changes and error conditions.

&gt;<i> /*
</I>&gt;<i>  * at91_can.c -  CAN network driver for AT91 SoC CAN controller
</I>&gt;<i>  *
</I>&gt;<i>  * (C) 2007 by Hans J. Koch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">hjk at linutronix.de</A>&gt;
</I>&gt;<i>  * (C) 2008 by Marc Kleine-Budde &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kernel at pengutronix.de</A>&gt;
</I>&gt;<i>  *
</I>&gt;<i>  * This software may be distributed under the terms of the GNU General
</I>&gt;<i>  * Public License (&quot;GPL&quot;) version 2 as distributed in the 'COPYING'
</I>&gt;<i>  * file from the main directory of the linux kernel source.
</I>&gt;<i>  *
</I>&gt;<i>  * Send feedback to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">socketcan-users at lists.berlios.de</A>&gt;
</I>&gt;<i>  *
</I>&gt;<i>  */
</I>&gt;<i> 
</I>&gt;<i> #include &lt;linux/platform_device.h&gt;
</I>&gt;<i> #include &lt;linux/interrupt.h&gt;
</I>&gt;<i> #include &lt;linux/netdevice.h&gt;
</I>&gt;<i> #include &lt;linux/spinlock.h&gt;
</I>&gt;<i> #include &lt;linux/module.h&gt;
</I>&gt;<i> #include &lt;linux/kernel.h&gt;
</I>&gt;<i> #include &lt;linux/string.h&gt;
</I>&gt;<i> #include &lt;linux/if_arp.h&gt;
</I>&gt;<i> #include &lt;linux/skbuff.h&gt;
</I>&gt;<i> #include &lt;linux/types.h&gt;
</I>&gt;<i> #include &lt;linux/errno.h&gt;
</I>&gt;<i> #include &lt;linux/init.h&gt;
</I>&gt;<i> #include &lt;linux/clk.h&gt;
</I>&gt;<i> 
</I>&gt;<i> #include &lt;socketcan/can.h&gt;
</I>&gt;<i> #include &lt;socketcan/can/error.h&gt;
</I>&gt;<i> #include &lt;socketcan/can/dev.h&gt;
</I>&gt;<i> 
</I>&gt;<i> #include &lt;mach/board.h&gt;
</I>&gt;<i> 
</I>&gt;<i> #define DRV_NAME		&quot;at91_can&quot;
</I>&gt;<i> #define MAX_INTERRUPT_WORK	4
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * RX/TX Mailbox split
</I>&gt;<i>  * don't dare to touch
</I>&gt;<i>  */
</I>&gt;<i> #define AT91_MB_RX_NUM		12
</I>&gt;<i> #define AT91_MB_TX_SHIFT	2
</I>&gt;<i> 
</I>&gt;<i> #define AT91_MB_RX_FIRST	0
</I>&gt;<i> #define AT91_MB_RX_LAST		(AT91_MB_RX_FIRST + AT91_MB_RX_NUM - 1)
</I>&gt;<i> #define AT91_MB_RX_BANKS	3
</I>&gt;<i> #define AT91_MB_RX_BANK_WIDTH	(AT91_MB_RX_NUM / AT91_MB_RX_BANKS)
</I>&gt;<i> #define AT91_MB_RX_BANK_MASK(i)	(((1 &lt;&lt; AT91_MB_RX_BANK_WIDTH) - 1) &lt;&lt; \
</I>&gt;<i> 				(AT91_MB_RX_BANK_WIDTH * (i)))
</I>&gt;<i> 
</I>&gt;<i> #define AT91_MB_TX_NUM		(1 &lt;&lt; AT91_MB_TX_SHIFT)
</I>&gt;<i> #define AT91_MB_TX_FIRST	(AT91_MB_RX_LAST + 1)
</I>&gt;<i> #define AT91_MB_TX_LAST		(AT91_MB_TX_FIRST + AT91_MB_TX_NUM - 1)
</I>&gt;<i> 
</I>&gt;<i> /* Common registers */
</I>&gt;<i> enum at91_reg {
</I>&gt;<i> 	AT91_MR		= 0x000,
</I>&gt;<i> 	AT91_IER	= 0x004,
</I>&gt;<i> 	AT91_IDR	= 0x008,
</I>&gt;<i> 	AT91_IMR	= 0x00C,
</I>&gt;<i> 	AT91_SR		= 0x010,
</I>&gt;<i> 	AT91_BR		= 0x014,
</I>&gt;<i> 	AT91_TIM	= 0x018,
</I>&gt;<i> 	AT91_TIMESTP	= 0x01C,
</I>&gt;<i> 	AT91_ECR	= 0x020,
</I>&gt;<i> 	AT91_TCR	= 0x024,
</I>&gt;<i> 	AT91_ACR	= 0x028,
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> /* Mailbox registers (0 &lt;= i &lt;= 15) */
</I>&gt;<i> #define AT91_MMR(i)		(enum at91_reg)(0x200 + ((i) * 0x20))
</I>&gt;<i> #define AT91_MAM(i)		(enum at91_reg)(0x204 + ((i) * 0x20))
</I>&gt;<i> #define AT91_MID(i)		(enum at91_reg)(0x208 + ((i) * 0x20))
</I>&gt;<i> #define AT91_MFID(i)		(enum at91_reg)(0x20C + ((i) * 0x20))
</I>&gt;<i> #define AT91_MSR(i)		(enum at91_reg)(0x210 + ((i) * 0x20))
</I>&gt;<i> #define AT91_MDL(i)		(enum at91_reg)(0x214 + ((i) * 0x20))
</I>&gt;<i> #define AT91_MDH(i)		(enum at91_reg)(0x218 + ((i) * 0x20))
</I>&gt;<i> #define AT91_MCR(i)		(enum at91_reg)(0x21C + ((i) * 0x20))
</I>&gt;<i> 
</I>&gt;<i> /* Register bits */
</I>&gt;<i> #define AT91_MR_AT91EN		(1 &lt;&lt; 0)
</I>&gt;<i> #define AT91_MR_LPM		(1 &lt;&lt; 1)
</I>&gt;<i> #define AT91_MR_ABM		(1 &lt;&lt; 2)
</I>&gt;<i> #define AT91_MR_OVL		(1 &lt;&lt; 3)
</I>&gt;<i> #define AT91_MR_TEOF		(1 &lt;&lt; 4)
</I>&gt;<i> #define AT91_MR_TTM		(1 &lt;&lt; 5)
</I>&gt;<i> #define AT91_MR_TIMFRZ		(1 &lt;&lt; 6)
</I>&gt;<i> #define AT91_MR_DRPT		(1 &lt;&lt; 7)
</I>&gt;<i> 
</I>&gt;<i> #define AT91_SR_RBSY		(1 &lt;&lt; 29)
</I>&gt;<i> 
</I>&gt;<i> #define AT91_MMR_PRIO_SHIFT	16
</I>&gt;<i> 
</I>&gt;<i> #define AT91_MID_MIDE		(1 &lt;&lt; 29)
</I>&gt;<i> 
</I>&gt;<i> #define AT91_MSR_MRTR		(1 &lt;&lt; 20)
</I>&gt;<i> #define AT91_MSR_MABT		(1 &lt;&lt; 22)
</I>&gt;<i> #define AT91_MSR_MRDY		(1 &lt;&lt; 23)
</I>&gt;<i> #define AT91_MSR_MMI		(1 &lt;&lt; 24)
</I>&gt;<i> 
</I>&gt;<i> #define AT91_MCR_MRTR		(1 &lt;&lt; 20)
</I>&gt;<i> #define AT91_MCR_MTCR		(1 &lt;&lt; 23)
</I>&gt;<i> 
</I>&gt;<i> /* Mailbox Modes */
</I>&gt;<i> enum at91_mb_mode {
</I>&gt;<i> 	AT91_MB_MODE_DISABLED	= 0,
</I>&gt;<i> 	AT91_MB_MODE_RX		= 1,
</I>&gt;<i> 	AT91_MB_MODE_RX_OVRWR	= 2,
</I>&gt;<i> 	AT91_MB_MODE_TX		= 3,
</I>&gt;<i> 	AT91_MB_MODE_CONSUMER	= 4,
</I>&gt;<i> 	AT91_MB_MODE_PRODUCER	= 5,
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> /* Interrupt mask bits */
</I>&gt;<i> #define AT91_IRQ_MB_RX		((1 &lt;&lt; (AT91_MB_RX_LAST + 1)) \
</I>&gt;<i> 				- (1 &lt;&lt; AT91_MB_RX_FIRST))
</I>&gt;<i> #define AT91_IRQ_MB_TX		((1 &lt;&lt; (AT91_MB_TX_LAST + 1)) \
</I>&gt;<i> 				- (1 &lt;&lt; AT91_MB_TX_FIRST))
</I>&gt;<i> #define AT91_IRQ_MB_AL		(AT91_IRQ_MB_RX | AT91_IRQ_MB_TX)
</I>&gt;<i> 
</I>&gt;<i> #define AT91_IRQ_ERRA		(1 &lt;&lt; 16)
</I>&gt;<i> #define AT91_IRQ_WARN		(1 &lt;&lt; 17)
</I>&gt;<i> #define AT91_IRQ_ERRP		(1 &lt;&lt; 18)
</I>&gt;<i> #define AT91_IRQ_BOFF		(1 &lt;&lt; 19)
</I>&gt;<i> #define AT91_IRQ_SLEEP		(1 &lt;&lt; 20)
</I>&gt;<i> #define AT91_IRQ_WAKEUP		(1 &lt;&lt; 21)
</I>&gt;<i> #define AT91_IRQ_TOVF		(1 &lt;&lt; 22)
</I>&gt;<i> #define AT91_IRQ_TSTP		(1 &lt;&lt; 23)
</I>&gt;<i> #define AT91_IRQ_CERR		(1 &lt;&lt; 24)
</I>&gt;<i> #define AT91_IRQ_SERR		(1 &lt;&lt; 25)
</I>&gt;<i> #define AT91_IRQ_AERR		(1 &lt;&lt; 26)
</I>&gt;<i> #define AT91_IRQ_FERR		(1 &lt;&lt; 27)
</I>&gt;<i> #define AT91_IRQ_BERR		(1 &lt;&lt; 28)
</I>&gt;<i> 
</I>&gt;<i> #define	AT91_IRQ_ERR_ALL	0x1fff0000
</I>&gt;<i> #define AT91_IRQ_ERR_CANFRAME	(AT91_IRQ_CERR | AT91_IRQ_SERR | \
</I>&gt;<i> 				 AT91_IRQ_AERR | AT91_IRQ_FERR | AT91_IRQ_BERR)
</I>&gt;<i> #define AT91_IRQ_ERR_LINE	(AT91_IRQ_ERRA | AT91_IRQ_WARN | \
</I>&gt;<i> 				 AT91_IRQ_ERRP | AT91_IRQ_BOFF)
</I>&gt;<i> 
</I>&gt;<i> struct at91_priv {
</I>&gt;<i> 	struct can_priv		can;	/* must be the first member! */
</I>&gt;<i> 
</I>&gt;<i> 	struct clk		*clk;
</I>&gt;<i> 	struct at91_can_data	*pdata;
</I>&gt;<i> 
</I>&gt;<i> #define AT91_NEXT_PRIO_SHIFT	(AT91_MB_TX_SHIFT)
</I>&gt;<i> #define AT91_NEXT_PRIO_MASK	(0xf &lt;&lt; AT91_MB_TX_SHIFT)
</I>&gt;<i> #define AT91_NEXT_MB_MASK	(AT91_MB_TX_NUM - 1)
</I>&gt;<i> #define AT91_NEXT_MASK		((AT91_MB_TX_NUM - 1) | AT91_NEXT_PRIO_MASK)
</I>

I personally prefer having such definitions above the struct.

&gt;<i> 	unsigned int		tx_next;
</I>&gt;<i> 	unsigned int		tx_echo;
</I>&gt;<i> 
</I>&gt;<i> 	unsigned int		rx_bank;
</I>&gt;<i> 	void __iomem		*reg_base; /* ioremap'ed address to registers */
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> static struct can_bittiming_const at91_bittiming_const = {
</I>&gt;<i> 	.tseg1_min = 4,
</I>&gt;<i> 	.tseg1_max = 16,
</I>&gt;<i> 	.tseg2_min = 2,
</I>&gt;<i> 	.tseg2_max = 8,
</I>&gt;<i> 	.sjw_max = 4,
</I>&gt;<i> 	.brp_min = 2,
</I>&gt;<i> 	.brp_max = 128,
</I>&gt;<i> 	.brp_inc = 1,
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> static inline int get_tx_next_mb(struct at91_priv *priv)
</I>&gt;<i> {
</I>&gt;<i> 	return (priv-&gt;tx_next &amp; AT91_NEXT_MB_MASK) + AT91_MB_TX_FIRST;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static inline int get_tx_next_prio(struct at91_priv *priv)
</I>&gt;<i> {
</I>&gt;<i> 	return (priv-&gt;tx_next &gt;&gt; AT91_NEXT_PRIO_SHIFT) &amp; 0xf;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static inline int get_tx_echo_mb(struct at91_priv *priv)
</I>&gt;<i> {
</I>&gt;<i> 	return (priv-&gt;tx_echo &amp; AT91_NEXT_MB_MASK) + AT91_MB_TX_FIRST;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> static inline u32 at91_read(struct net_device *dev, enum at91_reg reg)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	return readl(priv-&gt;reg_base + reg);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static inline void
</I>&gt;<i> at91_write(struct net_device *dev, enum at91_reg reg, u32 value)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	writel(value, priv-&gt;reg_base + reg);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> static inline void
</I>&gt;<i> set_mb_mode_prio(struct net_device *dev, int mb, enum at91_mb_mode mode,
</I>&gt;<i> 		int prio)
</I>&gt;<i> {
</I>&gt;<i> 	at91_write(dev, AT91_MMR(mb),
</I>&gt;<i> 		   (mode &lt;&lt; 24) |
</I>&gt;<i> 		   (prio &lt;&lt; 16));
</I>&gt;<i> }
</I>
Does fit on one line!

&gt;<i> static inline void
</I>&gt;<i> set_mb_mode(struct net_device *dev, int mb, enum at91_mb_mode mode)
</I>&gt;<i> {
</I>&gt;<i> 	set_mb_mode_prio(dev, mb, mode, 0);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * Enable or disable transceiver
</I>&gt;<i>  */
</I>&gt;<i> static void enable_can_transceiver(struct at91_priv *priv, int enable)
</I>&gt;<i> {
</I>&gt;<i> 	if (priv-&gt;pdata &amp;&amp; priv-&gt;pdata-&gt;transceiver_enable)
</I>&gt;<i> 		priv-&gt;pdata-&gt;transceiver_enable(enable);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * theory of operation:
</I>&gt;<i>  *
</I>&gt;<i>  * Accoring to the datasheet priority 0 is the highest priority, 15 is
</I>&gt;<i>  * the lowest. If two mailboxes have the same priority level the
</I>&gt;<i>  * message of the mailbox with the lowest number is sent first.
</I>&gt;<i>  *
</I>&gt;<i>  * We use the first TX mailbox mailbox (AT91_MB_TX_FIRST) with prio 0,
</I>&gt;<i>  * then the next mailbox with prio 0, and so on, until all mailboxes
</I>&gt;<i>  * are used. Then we start from the beginning with mailbox
</I>&gt;<i>  * AT91_MB_TX_FIRST, but with prio 1, mailbox AT91_MB_TX_FIRST + 1
</I>&gt;<i>  * prio 1. When we reach the last mailbox with prio 15, we have to
</I>&gt;<i>  * stop sending, waiting for all messages to be delivered, than start
</I>&gt;<i>  * again with mailbox AT91_MB_TX_FIRST prio 0.
</I>&gt;<i>  *
</I>&gt;<i>  * We use the priv-&gt;tx_next as counter for the next transmission
</I>&gt;<i>  * mailbox, but without the offset AT91_MB_TX_FIRST. The lower bits
</I>&gt;<i>  * encode the mailbox number, the upper 4 bits the mailbox priority:
</I>&gt;<i>  *
</I>&gt;<i>  * priv-&gt;tx_next = (prio &lt;&lt; AT91_NEXT_PRIO_SHIFT) ||
</I>&gt;<i>  *                 (mb - AT91_MB_TX_FIRST);
</I>&gt;<i>  *
</I>&gt;<i>  */
</I>&gt;<i> static int at91_start_xmit(struct sk_buff *skb, struct net_device *dev)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> 	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> 	u32 reg_mid, reg_mcr;
</I>&gt;<i> 	int mb, prio;
</I>&gt;<i> 
</I>&gt;<i> 	mb = get_tx_next_mb(priv);
</I>&gt;<i> 	prio = get_tx_next_prio(priv);
</I>&gt;<i> 
</I>&gt;<i> 	if (!(at91_read(dev, AT91_MSR(mb)) &amp; AT91_MSR_MRDY)) {
</I>&gt;<i> 		BUG();
</I>&gt;<i> 		/* FIXME: kfree? stats? */
</I>&gt;<i> 		return -EBUSY;
</I>&gt;<i> 	}
</I>
That's an invalid return value. I also think it's not good that a
hardware error brings down the system. Fix the FIXME.

&gt;<i> 
</I>&gt;<i> 	if (cf-&gt;can_id &amp; CAN_EFF_FLAG)
</I>&gt;<i> 		reg_mid = (cf-&gt;can_id &amp; CAN_EFF_MASK) | AT91_MID_MIDE;
</I>&gt;<i> 	else
</I>&gt;<i> 		reg_mid = (cf-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; 18;
</I>&gt;<i> 
</I>&gt;<i> 	reg_mcr = ((cf-&gt;can_id &amp; CAN_RTR_FLAG) ? AT91_MCR_MRTR : 0 ) |
</I>&gt;<i> 		(cf-&gt;can_dlc &lt;&lt; 16) |
</I>&gt;<i> 		AT91_MCR_MTCR;
</I>
Fits well on two lines.

&gt;<i> 
</I>&gt;<i> 	/* disable MB while writing ID (see datasheet) */
</I>&gt;<i> 	set_mb_mode(dev, mb, AT91_MB_MODE_DISABLED);
</I>&gt;<i> 	at91_write(dev, AT91_MID(mb), reg_mid);
</I>&gt;<i> 	set_mb_mode_prio(dev, mb, AT91_MB_MODE_TX, prio);
</I>&gt;<i> 
</I>&gt;<i> 	at91_write(dev, AT91_MDL(mb), *(u32 *)(cf-&gt;data + 0));
</I>&gt;<i> 	at91_write(dev, AT91_MDH(mb), *(u32 *)(cf-&gt;data + 4));
</I>&gt;<i> 
</I>&gt;<i> 	/* This triggers transmission */
</I>&gt;<i> 	wmb();
</I>
Do we need that wmb()?

&gt;<i> 	at91_write(dev, AT91_MCR(mb), reg_mcr);
</I>&gt;<i> 
</I>&gt;<i> 	stats-&gt;tx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> 	dev-&gt;trans_start = jiffies;
</I>&gt;<i> 
</I>&gt;<i> 	/* _NOTE_: substract AT91_MB_TX_FIRST offset from mb! */
</I>&gt;<i> 	can_put_echo_skb(skb, dev, mb - AT91_MB_TX_FIRST);
</I>&gt;<i> 
</I>&gt;<i> 	/*
</I>&gt;<i> 	 * we have to stop the queue and deliver all messages in case
</I>&gt;<i> 	 * of a prio+mb counter wrap around. This is the case if
</I>&gt;<i> 	 * tx_next buffer prio and mailbox equals 0.
</I>&gt;<i> 	 *
</I>&gt;<i> 	 * also stop the queue if next buffer is still in use
</I>&gt;<i> 	 * (== not ready)
</I>&gt;<i> 	 */
</I>&gt;<i> 	priv-&gt;tx_next++;
</I>&gt;<i> 	if (!(at91_read(dev, AT91_MSR(get_tx_next_mb(priv))) &amp;
</I>&gt;<i> 	      AT91_MSR_MRDY) ||
</I>&gt;<i> 	    (priv-&gt;tx_next &amp; AT91_NEXT_MASK) == 0) {
</I>&gt;<i> 		netif_stop_queue(dev);
</I>&gt;<i> 		dev_dbg(ND2D(dev),
</I>&gt;<i> 			&quot;stopping netif_queue, priv-&gt;tx_next=%d, &quot;
</I>&gt;<i> 			&quot;prio=%d, mb=%d\n&quot;,
</I>&gt;<i> 			priv-&gt;tx_next,
</I>&gt;<i> 			get_tx_next_prio(priv),
</I>&gt;<i> 			get_tx_next_mb(priv));
</I>&gt;<i> 	}
</I>
Devel debugging? Is it useful for the real users?

&gt;<i> 	/* Enable interrupt for this mailbox */
</I>&gt;<i> 	at91_write(dev, AT91_IER, 1 &lt;&lt; mb);
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>
Please use &quot;return NETDEV_TX_OK&quot;.

&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> /**
</I>&gt;<i>  * at91_clear_bank - clear and reactive bank
</I>&gt;<i>  * @dev: net device
</I>&gt;<i>  * @bank: bank to clear
</I>&gt;<i>  *
</I>&gt;<i>  * Clears and reenables IRQs on given bank in order to enable
</I>&gt;<i>  * reception of new CAN messages
</I>&gt;<i>  */
</I>&gt;<i> static void at91_clear_bank(struct net_device *dev, int bank)
</I>&gt;<i> {
</I>&gt;<i> 	int last, i;
</I>&gt;<i> 	u32 mask;
</I>&gt;<i> 
</I>&gt;<i> 	last = AT91_MB_RX_BANK_WIDTH * (bank + 1);
</I>&gt;<i> 	for (i = AT91_MB_RX_BANK_WIDTH * bank; i &lt; last; i++)
</I>&gt;<i> 		at91_write(dev, AT91_MCR(i), AT91_MCR_MTCR);
</I>&gt;<i> 
</I>&gt;<i> 	mask = AT91_MB_RX_BANK_MASK(bank);
</I>&gt;<i> 	at91_write(dev, AT91_IER, mask);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> /**
</I>&gt;<i>  * at91_read_mb - read CAN msg from mailbox (lowlevel impl)
</I>&gt;<i>  * @dev: net device
</I>&gt;<i>  * @mb: mailbox number to read from
</I>&gt;<i>  * @cf: can frame where to store message
</I>&gt;<i>  *
</I>&gt;<i>  * Reads a CAN message from the given mailbox and stores data into
</I>&gt;<i>  * given can frame. &quot;mb&quot; and &quot;cf&quot; must be valid.
</I>&gt;<i>  */
</I>&gt;<i> static void at91_read_mb(struct net_device *dev, int mb, struct can_frame *cf)
</I>&gt;<i> {
</I>&gt;<i> 	u32 reg_msr, reg_mid, reg_mdl, reg_mdh;
</I>&gt;<i> 
</I>&gt;<i> 	reg_mid = at91_read(dev, AT91_MID(mb));
</I>&gt;<i> 	if (reg_mid &amp; AT91_MID_MIDE)
</I>&gt;<i> 		cf-&gt;can_id = ((reg_mid &gt;&gt;  0) &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
</I>&gt;<i> 	else
</I>&gt;<i> 		cf-&gt;can_id =  (reg_mid &gt;&gt; 18) &amp; CAN_SFF_MASK;
</I>&gt;<i> 
</I>&gt;<i> 	reg_msr = at91_read(dev, AT91_MSR(mb));
</I>&gt;<i> 	if (reg_msr &amp; AT91_MSR_MRTR)
</I>&gt;<i> 		cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> 	cf-&gt;can_dlc = (reg_msr &gt;&gt; 16) &amp; 0xf;
</I>&gt;<i> 
</I>&gt;<i> 	reg_mdl = at91_read(dev, AT91_MDL(mb));
</I>&gt;<i> 	reg_mdh = at91_read(dev, AT91_MDH(mb));
</I>&gt;<i> 
</I>&gt;<i> 	*(u32 *)(cf-&gt;data + 0) = reg_mdl;
</I>&gt;<i> 	*(u32 *)(cf-&gt;data + 4) = reg_mdh;
</I>&gt;<i> 
</I>&gt;<i> 	/*  FIXME: take care about AT91_MB_MODE_RX_OVRWR mb */
</I>
FIXME.

&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> /**
</I>&gt;<i>  * at91_read_msg - read CAN message from mailbox
</I>&gt;<i>  * @dev: net device
</I>&gt;<i>  * @mb: mail box to read from
</I>&gt;<i>  *
</I>&gt;<i>  * Reads a CAN message from given mailbox, and put into linux network
</I>&gt;<i>  * RX queue, does all housekeeping chores (stats, ...)
</I>&gt;<i>  */
</I>&gt;<i> static void at91_read_msg(struct net_device *dev, int mb)
</I>&gt;<i> {
</I>&gt;<i> 	struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> 	struct can_frame *cf;
</I>&gt;<i> 	struct sk_buff *skb;
</I>&gt;<i> 
</I>&gt;<i> 	skb = netdev_alloc_skb(dev, sizeof(struct can_frame));
</I>&gt;<i> 	if (unlikely(!skb)) {
</I>&gt;<i> 		if (net_ratelimit())
</I>&gt;<i> 			dev_warn(ND2D(dev),
</I>&gt;<i> 				 &quot;Memory squeeze, dropping packet.\n&quot;);
</I>&gt;<i> 		stats-&gt;rx_dropped++;
</I>&gt;<i> 		return;
</I>&gt;<i> 	}
</I>&gt;<i> 	skb-&gt;protocol = htons(ETH_P_CAN);
</I>
Please add

	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;


&gt;<i> 	cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
</I>&gt;<i> 
</I>&gt;<i> 	at91_read_mb(dev, mb, cf);
</I>&gt;<i> 
</I>&gt;<i> 	netif_rx(skb);
</I>&gt;<i> 
</I>&gt;<i> 	dev-&gt;last_rx = jiffies;
</I>&gt;<i> 	stats-&gt;rx_packets++;
</I>&gt;<i> 	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * theory of operation
</I>&gt;<i>  *
</I>&gt;<i>  * 12 of the 16 mailboxes on the chip are reserved for RX. we split
</I>&gt;<i>  * them into 3 groups (3 x 4 mbs) a.k.a banks.
</I>&gt;<i>  *
</I>&gt;<i>  * like it or not, but the chip always saves a received CAN message
</I>&gt;<i>  * into the first free mailbox it finds. This makes it very difficult
</I>&gt;<i>  * to read the messages in the right order from the chip. This is how
</I>&gt;<i>  * we work around that problem:
</I>&gt;<i>  *
</I>&gt;<i>  * The first message goes into mb nr. 0 and issues an interrupt. We
</I>&gt;<i>  * read it, do _not_ reenable the mb (to receive another message), but
</I>&gt;<i>  * disable the interrupt though. This is done for the first bank
</I>&gt;<i>  * (i.e. mailbox 0-3).
</I>&gt;<i>  *
</I>&gt;<i>  *   bank0    bank1    bank2
</I>&gt;<i>  *   __^__    __^__    __^__
</I>&gt;<i>  *  /     \  /     \  /     \
</I>&gt;<i>  * +-+-+-+-++-+-+-+-++-+-+-+-+
</I>&gt;<i>  * |x|x|x|x|| | | | || | | | |
</I>&gt;<i>  * +-+-+-+-++-+-+-+-++-+-+-+-+
</I>&gt;<i>  *  0 0 0 0  0 0 0 0  0 0 1 1  \ mail
</I>&gt;<i>  *  0 1 2 3  4 5 6 7  8 9 0 1  / box
</I>&gt;<i>  *
</I>&gt;<i>  * Then we switch to bank 1. If this bank is full, too, we reenable
</I>&gt;<i>  * bank number 0, and switch to bank 2. Imagine bank 2 like an overflow
</I>&gt;<i>  * bank, which takes CAN messages if bank 1 is full, but bank 0 not
</I>&gt;<i>  * cleared yet. In other words: from the reception of a message into
</I>&gt;<i>  * mb 7, we have the &quot;four mailboxes&quot; (of bank 2) time to enter the
</I>&gt;<i>  * interrupt service routine and reenable bank 0.
</I>&gt;<i>  *
</I>&gt;<i>  * Nevertheless, after reenabling bank 0, we look at bank 2 first, to
</I>&gt;<i>  * see if there are some messages. Then we reactivate bank 1 and 2,
</I>&gt;<i>  * and switch to bank 0.
</I>&gt;<i>  *
</I>&gt;<i>  */
</I>&gt;<i> static void at91_irq_rx(struct net_device *dev, u32 reg_sr)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	unsigned long *addr = (unsigned long *)&amp;reg_sr;
</I>&gt;<i> 	int mb;
</I>&gt;<i> 
</I>&gt;<i> 	/* masking of reg_sr not needed, already done by at91_irq */
</I>&gt;<i> 
</I>&gt;<i> 	mb = find_next_bit(addr, AT91_MB_RX_NUM,
</I>&gt;<i> 			   AT91_MB_RX_BANK_WIDTH * priv-&gt;rx_bank);
</I>&gt;<i> 	while (mb &lt; AT91_MB_RX_NUM) {
</I>&gt;<i> 		dev_dbg(ND2D(dev),
</I>&gt;<i> 			&quot;%s: SR=0x%08x, mb=%d, mb_bit=0x%04x, rx_bank=%d\n&quot;,
</I>&gt;<i> 			__func__, reg_sr, mb, 1 &lt;&lt; mb, priv-&gt;rx_bank);
</I>
Devel debugging?

&gt;<i> 		at91_read_msg(dev, mb);
</I>&gt;<i> 
</I>&gt;<i> 		/* disable interrupt */
</I>&gt;<i> 		at91_write(dev, AT91_IDR, 1 &lt;&lt; mb);
</I>&gt;<i> 
</I>&gt;<i> 		/* find next pending mailbox */
</I>&gt;<i> 		mb = find_next_bit(addr, AT91_MB_RX_NUM, mb + 1);
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	switch (priv-&gt;rx_bank) {
</I>&gt;<i> 	case 0:
</I>&gt;<i> 		if (!(at91_read(dev, AT91_IMR) &amp; AT91_MB_RX_BANK_MASK(0)))
</I>&gt;<i> 			priv-&gt;rx_bank = 1;
</I>&gt;<i> 		break;
</I>&gt;<i> 	case 1:
</I>&gt;<i> 		if (!(at91_read(dev, AT91_IMR) &amp; AT91_MB_RX_BANK_MASK(1))) {
</I>&gt;<i> 			at91_clear_bank(dev, 0);
</I>&gt;<i> 			priv-&gt;rx_bank = 2;
</I>&gt;<i> 		}
</I>&gt;<i> 		break;
</I>&gt;<i> 	case 2:
</I>&gt;<i> 		at91_clear_bank(dev, 1);
</I>&gt;<i> 		at91_clear_bank(dev, 2);
</I>&gt;<i> 		priv-&gt;rx_bank = 0;
</I>&gt;<i> 		break;
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * theory of operation:
</I>&gt;<i>  *
</I>&gt;<i>  * priv-&gt;tx_echo holds the number of the oldest can_frame put for
</I>&gt;<i>  * transmission into the hardware, but not yet ACKed by the CAN tx
</I>&gt;<i>  * complete IRQ.
</I>&gt;<i>  *
</I>&gt;<i>  * We iterate from priv-&gt;tx_echo to priv-&gt;tx_next and check if the
</I>&gt;<i>  * packet has been transmitted, echo it back to the CAN framework. If
</I>&gt;<i>  * we discover a not yet transmitted package, stop looking for more.
</I>&gt;<i>  *
</I>&gt;<i>  */
</I>&gt;<i> static void at91_irq_tx(struct net_device *dev, u32 reg_sr)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	u32 reg_msr;
</I>&gt;<i> 	int mb;
</I>&gt;<i> 
</I>&gt;<i> 	/* masking of reg_sr not needed, already done by at91_irq */
</I>&gt;<i> 
</I>&gt;<i> 	for (/* nix */; priv-&gt;tx_echo &lt; priv-&gt;tx_next; priv-&gt;tx_echo++) {
</I>&gt;<i> 		mb = get_tx_echo_mb(priv);
</I>&gt;<i> 
</I>&gt;<i> 		/* no event in mailbox? */
</I>&gt;<i> 		if (!(reg_sr &amp; (1 &lt;&lt; mb)))
</I>&gt;<i> 			break;
</I>&gt;<i> 
</I>&gt;<i> 		reg_msr = at91_read(dev, AT91_MSR(mb));
</I>&gt;<i> 
</I>&gt;<i> 		/* FIXME: BUGON no ready | abort */
</I>
Fix it. A BUG_ON might be to heavy, though.

&gt;<i> 
</I>&gt;<i> 		dev_dbg(ND2D(dev),
</I>&gt;<i> 			&quot;%s: SR=0x%08x, mb=%d, mb_bit=0x%04x, mb status: %s, &quot;
</I>&gt;<i> 			&quot;tx_next=%d, tx_echo=%d\n&quot;,
</I>&gt;<i> 			__func__, reg_sr, mb, 1 &lt;&lt; mb,
</I>&gt;<i> 			reg_msr &amp; AT91_MSR_MRDY ? &quot;MRDY&quot; : &quot;MABT&quot;,
</I>&gt;<i> 			priv-&gt;tx_next, priv-&gt;tx_echo);
</I>
Heavy devel debug output?

&gt;<i> 		/* Disable irq for this TX mailbox */
</I>&gt;<i> 		at91_write(dev, AT91_IDR, 1 &lt;&lt; mb);
</I>&gt;<i> 
</I>&gt;<i> 		/*
</I>&gt;<i> 		 * only echo if mailbox signals us a transfer
</I>&gt;<i> 		 * complete (MSR_MRDY). Otherwise it's a tansfer
</I>&gt;<i> 		 * abort. &quot;can_bus_off()&quot; takes care about the skbs
</I>&gt;<i> 		 * parked in the echo queue.
</I>&gt;<i> 		 */
</I>&gt;<i> 		if (likely(reg_msr &amp; AT91_MSR_MRDY)) {
</I>&gt;<i> 			/* _NOTE_: substract AT91_MB_TX_FIRST offset from mb! */
</I>&gt;<i> 			can_get_echo_skb(dev, mb - AT91_MB_TX_FIRST);
</I>&gt;<i> 			dev-&gt;stats.tx_packets++;
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/*
</I>&gt;<i> 	 * restart queue if we don't have a wrap around but restart if
</I>&gt;<i> 	 * we get a TX int for the last can frame directly before a
</I>&gt;<i> 	 * wrap around.
</I>&gt;<i> 	 */
</I>&gt;<i> 	if ((priv-&gt;tx_next &amp; AT91_NEXT_MASK) != 0 ||
</I>&gt;<i> 	    (priv-&gt;tx_echo &amp; AT91_NEXT_MASK) == 0)
</I>&gt;<i> 		netif_wake_queue(dev);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> static void at91_irq_err_canframe(struct net_device *dev, u32 reg_sr)
</I>&gt;<i> {
</I>&gt;<i> 	/* CRC error */
</I>&gt;<i> 	if (reg_sr &amp; AT91_IRQ_CERR)
</I>&gt;<i> 		dev_dbg(ND2D(dev), &quot;CERR irq\n&quot;);
</I>&gt;<i> 
</I>&gt;<i> 	/* stuffing error */
</I>&gt;<i> 	if (reg_sr &amp; AT91_IRQ_SERR)
</I>&gt;<i> 		dev_dbg(ND2D(dev), &quot;SERR irq\n&quot;);
</I>&gt;<i> 
</I>&gt;<i> 	/* Acknowledgement error */
</I>&gt;<i> 	if (reg_sr &amp; AT91_IRQ_AERR)
</I>&gt;<i> 		dev_dbg(ND2D(dev), &quot;AERR irq\n&quot;);
</I>&gt;<i> 
</I>&gt;<i> 	/* form error */
</I>&gt;<i> 	if (reg_sr &amp; AT91_IRQ_FERR)
</I>&gt;<i> 		dev_dbg(ND2D(dev), &quot;FERR irq\n&quot;);
</I>&gt;<i> 
</I>&gt;<i> 	/* bit error */
</I>&gt;<i> 	if (reg_sr &amp; AT91_IRQ_BERR)
</I>&gt;<i> 		dev_dbg(ND2D(dev), &quot;BERR irq\n&quot;);
</I>&gt;<i> }
</I>
Hm, this function seems not to be used. The dev_dbg's are OK, but also
error frames should be created for these errors and the netdev and CAN
statistics incremented accordingly.

&gt;<i> 
</I>&gt;<i> static void at91_irq_err(struct net_device *dev, u32 reg_sr_masked)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	enum can_state new_state;
</I>&gt;<i> 	u32 reg_sr, reg_ecr, reg_idr, reg_ier;
</I>&gt;<i> 	u8 tec, rec;
</I>&gt;<i> 
</I>&gt;<i> 	reg_sr = at91_read(dev, AT91_SR);
</I>&gt;<i> 	reg_ecr = at91_read(dev, AT91_ECR);
</I>&gt;<i> 	tec = reg_ecr &gt;&gt; 16;
</I>&gt;<i> 	rec = reg_ecr &amp; 0xff;
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(ND2D(dev), &quot;%s: TEC=%3d%s, REC=%3d, bits set: %s%s%s%s\n&quot;,
</I>&gt;<i> 		__func__,
</I>&gt;<i> 		tec,
</I>&gt;<i> 		reg_sr &amp; AT91_IRQ_BOFF ? &quot; (bus-off!)&quot; : &quot;&quot;,
</I>&gt;<i> 		rec,
</I>&gt;<i> 		reg_sr &amp; AT91_IRQ_ERRA ? &quot;ERRA &quot; : &quot;&quot;,
</I>&gt;<i> 		reg_sr &amp; AT91_IRQ_WARN ? &quot;WARN &quot; : &quot;&quot;,
</I>&gt;<i> 		reg_sr &amp; AT91_IRQ_ERRP ? &quot;ERRP &quot; : &quot;&quot;,
</I>&gt;<i> 		reg_sr &amp; AT91_IRQ_BOFF ? &quot;BOFF &quot; : &quot;&quot;);
</I>
Already reported above.

&gt;<i> 	/* we need to look at the unmasked reg_sr */
</I>&gt;<i> 	if (unlikely(reg_sr &amp; AT91_IRQ_BOFF))
</I>&gt;<i> 		new_state = CAN_STATE_BUS_OFF;
</I>&gt;<i> 	else if (unlikely(reg_sr &amp; AT91_IRQ_ERRP))
</I>&gt;<i> 		new_state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> 	else if (unlikely(reg_sr &amp; AT91_IRQ_WARN))
</I>&gt;<i> 		new_state = CAN_STATE_ERROR_WARNING;
</I>&gt;<i> 	else if (likely(reg_sr &amp; AT91_IRQ_ERRA))
</I>&gt;<i> 		new_state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> 	else {
</I>&gt;<i> 		BUG();	/* FIXME */
</I>
Hm, a dev_err would be enough, I believe.

&gt;<i> 		return;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* state hasn't changed, no error in canframe */
</I>&gt;<i> 	if (new_state == priv-&gt;can.state &amp;&amp;
</I>&gt;<i> 	    !(reg_sr_masked &amp; AT91_IRQ_ERR_CANFRAME))
</I>&gt;<i> 		return;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 	switch (priv-&gt;can.state) {
</I>&gt;<i> 	case CAN_STATE_ERROR_ACTIVE:
</I>&gt;<i> 		/*
</I>&gt;<i> 		 * from: ACTIVE
</I>&gt;<i> 		 * to  : BUS_WARNING, BUS_PASSIVE, BUS_OFF
</I>&gt;<i> 		 * =&gt;  : there was a warning int
</I>&gt;<i> 		 */
</I>&gt;<i> 		if (new_state &gt;= CAN_STATE_ERROR_WARNING &amp;&amp;
</I>&gt;<i> 		    new_state &lt;= CAN_STATE_BUS_OFF)
</I>&gt;<i> 			priv-&gt;can.can_stats.error_warning++;
</I>&gt;<i> 	case CAN_STATE_ERROR_WARNING:	/* fallthrough */
</I>&gt;<i> 		/*
</I>&gt;<i> 		 * from: ACTIVE, BUS_WARNING
</I>&gt;<i> 		 * to  : BUS_PASSIVE, BUS_OFF
</I>&gt;<i> 		 * =&gt;  : error passive int
</I>&gt;<i> 		 */
</I>&gt;<i> 		if (new_state &gt;= CAN_STATE_ERROR_PASSIVE &amp;&amp;
</I>&gt;<i> 		    new_state &lt;= CAN_STATE_BUS_OFF)
</I>&gt;<i> 			priv-&gt;can.can_stats.error_passive++;
</I>&gt;<i> 		break;
</I>&gt;<i> 	case CAN_STATE_BUS_OFF:
</I>&gt;<i> 		/*
</I>&gt;<i> 		 * this is a crude chip, happens very often that it is
</I>&gt;<i> 		 * in BUS_OFF but still tries to send a package. on
</I>&gt;<i> 		 * success it leaves bus off. so we have to reenable
</I>&gt;<i> 		 * the carrier.
</I>&gt;<i> 		 */
</I>&gt;<i> 		if (new_state &lt;= CAN_STATE_ERROR_PASSIVE)
</I>&gt;<i> 			netif_carrier_on(dev);
</I>&gt;<i> 		break;
</I>&gt;<i> 	default:
</I>&gt;<i> 		break;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 	/* process state changes depending on the new state */
</I>&gt;<i> 	switch (new_state) {
</I>&gt;<i> 	case CAN_STATE_ERROR_ACTIVE:
</I>&gt;<i> 		/*
</I>&gt;<i> 		 * actually we want to enable AT91_IRQ_WARN here, but
</I>&gt;<i> 		 * it screws up the system under certain
</I>&gt;<i> 		 * circumstances. so just enable AT91_IRQ_ERRP, thus
</I>&gt;<i> 		 * the &quot;fallthrough&quot;
</I>&gt;<i> 		 */
</I>&gt;<i> 	case CAN_STATE_ERROR_WARNING:	/* fallthrough */
</I>&gt;<i> 		reg_idr = AT91_IRQ_ERRA | AT91_IRQ_WARN | AT91_IRQ_BOFF;
</I>&gt;<i> 		reg_ier = AT91_IRQ_ERRP;
</I>&gt;<i> 		break;
</I>&gt;<i> 	case CAN_STATE_ERROR_PASSIVE:
</I>&gt;<i> 		reg_idr = AT91_IRQ_ERRA | AT91_IRQ_WARN | AT91_IRQ_ERRP;
</I>&gt;<i> 		reg_ier = AT91_IRQ_BOFF;
</I>&gt;<i> 		break;
</I>&gt;<i> 	case CAN_STATE_BUS_OFF:
</I>&gt;<i> 		reg_idr = AT91_IRQ_ERRA | AT91_IRQ_ERRP |
</I>&gt;<i> 			AT91_IRQ_WARN | AT91_IRQ_BOFF;
</I>&gt;<i> 		reg_ier = 0;
</I>&gt;<i> 
</I>&gt;<i> 		/*
</I>&gt;<i> 		 * FIXME: really abort?
</I>&gt;<i> 		 *
</I>&gt;<i> 		 * a somewhat &quot;special&quot; chip, even in BUS_OFF mode, it
</I>&gt;<i> 		 * accesses the bus. this is a no-no. we try to abort
</I>&gt;<i> 		 * transfers on all mailboxes. but the chip doesn't
</I>&gt;<i> 		 * seem to handle this correctly. a stuck-in-transfer
</I>&gt;<i> 		 * message isn't aborted. after bringing the CAN bus
</I>&gt;<i> 		 * back xin shape again, the stuck-in-transfer message
</I>&gt;<i> 		 * is tranferred and its MRDY bit is set. all other
</I>&gt;<i> 		 * queued messages are aborted (not send) their MABT
</I>&gt;<i> 		 * bit in MSR is _not_ set but the MRDY bit, too.
</I>&gt;<i> 		 */
</I>&gt;<i> 		dev_dbg(ND2D(dev), &quot;%s: aborting transfers, due to BUS OFF\n&quot;,
</I>&gt;<i> 			__func__);
</I>&gt;<i> 
</I>&gt;<i> 		at91_write(dev, AT91_ACR, AT91_IRQ_MB_TX);
</I>&gt;<i> 
</I>&gt;<i> 		can_bus_off(dev);
</I>&gt;<i> 		break;
</I>&gt;<i> 	default:
</I>&gt;<i> 		break;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(ND2D(dev), &quot;%s: writing IDR=0x%08x, IER=0x%08x\n&quot;,
</I>&gt;<i> 		__func__, reg_idr, reg_ier);
</I>
Devel debugging?

&gt;<i> 	at91_write(dev, AT91_IDR, reg_idr);
</I>&gt;<i> 	at91_write(dev, AT91_IER, reg_ier);
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 	{
</I>&gt;<i> 		struct sk_buff *skb;
</I>&gt;<i> 		struct can_frame *cf;
</I>&gt;<i> 
</I>&gt;<i> 		skb = netdev_alloc_skb(dev, sizeof(struct can_frame));
</I>&gt;<i> 		if (unlikely(!skb))
</I>&gt;<i> 			goto out;
</I>&gt;<i> 
</I>&gt;<i> 		skb-&gt;protocol = htons(ETH_P_CAN);
</I>
Please add

		skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;

&gt;<i> 		cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
</I>&gt;<i> 		memset(cf, 0, sizeof(struct can_frame));
</I>&gt;<i> 
</I>&gt;<i> 		cf-&gt;can_id  = CAN_ERR_FLAG;
</I>&gt;<i> 		cf-&gt;can_dlc = CAN_ERR_DLC;
</I>&gt;<i> 
</I>&gt;<i> 		switch (new_state) {
</I>&gt;<i> 		case CAN_STATE_ERROR_WARNING:
</I>&gt;<i> 		case CAN_STATE_ERROR_PASSIVE:
</I>&gt;<i> 			cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> 
</I>&gt;<i> 			if (new_state == CAN_STATE_ERROR_WARNING)
</I>&gt;<i> 				cf-&gt;data[1] = (tec &gt; rec) ?
</I>&gt;<i> 					CAN_ERR_CRTL_TX_WARNING :
</I>&gt;<i> 					CAN_ERR_CRTL_RX_WARNING;
</I>&gt;<i> 			else
</I>&gt;<i> 				cf-&gt;data[1] = (tec &gt; rec) ?
</I>&gt;<i> 					CAN_ERR_CRTL_TX_PASSIVE :
</I>&gt;<i> 					CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> 
</I>&gt;<i> 			break;
</I>&gt;<i> 		case CAN_STATE_BUS_OFF:
</I>&gt;<i> 			cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> 			break;
</I>&gt;<i> 		default:
</I>&gt;<i> 			break;
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 		netif_rx(skb);
</I>&gt;<i> 
</I>&gt;<i> 		dev-&gt;last_rx = jiffies;
</I>&gt;<i> 		dev-&gt;stats.rx_packets++;
</I>&gt;<i> 		dev-&gt;stats.rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> 	}
</I>
Please consider putting this block in a separete function. Error frames
are created for state changes, that's fine.

&gt;<i>  out:
</I>&gt;<i> 	priv-&gt;can.state = new_state;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * interrupt handler
</I>&gt;<i>  */
</I>&gt;<i> static irqreturn_t at91_irq(int irq, void *ndev_id)
</I>&gt;<i> {
</I>&gt;<i> 	struct net_device *dev = ndev_id;
</I>&gt;<i> 	irqreturn_t handled = IRQ_NONE;
</I>&gt;<i> 	u32 reg_sr, reg_imr;
</I>&gt;<i> 	int boguscnt = MAX_INTERRUPT_WORK;
</I>&gt;<i> 
</I>&gt;<i> 	do {
</I>&gt;<i> 		reg_sr = at91_read(dev, AT91_SR);
</I>&gt;<i> 		reg_imr = at91_read(dev, AT91_IMR);
</I>&gt;<i> 		dev_dbg(ND2D(dev), &quot;%s: SR=0x%08x, IMR=0x%08x, [0x%08x]\n&quot;,
</I>&gt;<i> 			__func__,
</I>&gt;<i> 			reg_sr, reg_imr, reg_sr &amp; reg_imr);
</I>
Heavy debug output!

&gt;<i> 
</I>&gt;<i> 		/* Ignore masked interrupts */
</I>&gt;<i> 		reg_sr &amp;= reg_imr;
</I>&gt;<i> 		if (!reg_sr)
</I>&gt;<i> 			goto exit;
</I>&gt;<i> 
</I>&gt;<i> 		handled = IRQ_HANDLED;
</I>&gt;<i> 
</I>&gt;<i> 		if (reg_sr &amp; AT91_IRQ_MB_RX) {
</I>&gt;<i> 			/* receive interrupt */
</I>&gt;<i> 			at91_irq_rx(dev, reg_sr);
</I>&gt;<i> 		}
</I>
Coding style!

&gt;<i> 		if (reg_sr &amp; AT91_IRQ_MB_TX) {
</I>&gt;<i> 			/* transmission complete interrupt */
</I>&gt;<i> 			at91_irq_tx(dev, reg_sr);
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i> 		at91_irq_err(dev, reg_sr);
</I>&gt;<i> 
</I>&gt;<i> 	} while (--boguscnt &gt; 0);
</I>&gt;<i> 
</I>&gt;<i> 	if (unlikely(boguscnt &lt;= 0)) {
</I>&gt;<i> 		dev_warn(ND2D(dev), &quot;Too much work at interrupt, &quot;
</I>&gt;<i> 			 &quot;status (at enter): 0x%08x, now: 0x%08x\n&quot;,
</I>&gt;<i> 			 reg_sr,
</I>&gt;<i> 			 at91_read(dev, AT91_SR) &amp; at91_read(dev, AT91_IMR));
</I>&gt;<i> 
</I>&gt;<i> 		/* Clear all interrupt sources. */
</I>&gt;<i> 		/* FIXME: do it? */
</I>
Fix it.

&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i>  exit:
</I>&gt;<i> 	return handled;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> static void at91_setup_mailboxes(struct net_device *dev)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	int i;
</I>&gt;<i> 
</I>&gt;<i> 	/*
</I>&gt;<i> 	 * The first 12 mailboxes are used as a reception FIFO. The
</I>&gt;<i> 	 * last mailbox is configured with overwrite option. The
</I>&gt;<i> 	 * overwrite flag indicates a FIFO overflow.
</I>&gt;<i> 	 */
</I>&gt;<i> 	/* FIXME: clear accept regs (MID/MAM) */
</I>&gt;<i> 	for (i = AT91_MB_RX_FIRST; i &lt; AT91_MB_RX_LAST; i++)
</I>&gt;<i> 		set_mb_mode(dev, i, AT91_MB_MODE_RX);
</I>&gt;<i> 	set_mb_mode(dev, AT91_MB_RX_LAST, AT91_MB_MODE_RX_OVRWR);
</I>&gt;<i> 
</I>&gt;<i> 	/* The last 4 mailboxes are used for transmitting. */
</I>&gt;<i> 	for (i = AT91_MB_TX_FIRST; i &lt;= AT91_MB_TX_LAST; i++)
</I>&gt;<i> 		set_mb_mode_prio(dev, i, AT91_MB_MODE_TX, 0);
</I>&gt;<i> 
</I>&gt;<i> 
</I>
Two empty lines!

&gt;<i> 	/* reset both tx and rx helper pointers */
</I>&gt;<i> 	priv-&gt;tx_next = priv-&gt;tx_echo = priv-&gt;rx_bank = 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static int at91_set_bittiming(struct net_device *dev)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> 	u32 reg_br;
</I>&gt;<i> 
</I>&gt;<i> 	reg_br = ((priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES) &lt;&lt; 24) |
</I>&gt;<i> 		((bt-&gt;brp        - 1) &lt;&lt; 16) |
</I>&gt;<i> 		((bt-&gt;sjw        - 1) &lt;&lt; 12) |
</I>&gt;<i> 		((bt-&gt;prop_seg   - 1) &lt;&lt;  8) |
</I>&gt;<i> 		((bt-&gt;phase_seg1 - 1) &lt;&lt;  4) |
</I>&gt;<i> 		((bt-&gt;phase_seg2 - 1) &lt;&lt;  0);
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(ND2D(dev), &quot;writing AT91_BR: 0x%08x, can_sys_clock: %d\n&quot;,
</I>&gt;<i> 		  reg_br, priv-&gt;can.clock.freq);
</I>
Could you please use dev_info() here like for the other drivers, but
without printing the frequency.


&gt;<i> 	at91_write(dev, AT91_BR, reg_br);
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> static void at91_chip_start(struct net_device *dev)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	u32 reg_mr, reg_ier;
</I>&gt;<i> 
</I>&gt;<i> 	/* disable interrupts */
</I>&gt;<i> 	at91_write(dev, AT91_IDR, 0x1fffffff);
</I>&gt;<i> 
</I>&gt;<i> 	/* disable chip */
</I>&gt;<i> 	reg_mr = at91_read(dev, AT91_MR);
</I>&gt;<i> 	at91_write(dev, AT91_MR, reg_mr &amp; ~AT91_MR_AT91EN);
</I>&gt;<i> 	wmb();
</I>&gt;<i> 
</I>&gt;<i> 	at91_setup_mailboxes(dev);
</I>&gt;<i> 
</I>&gt;<i> 	enable_can_transceiver(priv, 1);
</I>&gt;<i> 
</I>&gt;<i> 	/* enable chip */
</I>&gt;<i> 	reg_mr = at91_read(dev, AT91_MR);
</I>&gt;<i> 	at91_write(dev, AT91_MR, reg_mr | AT91_MR_AT91EN);
</I>&gt;<i> 
</I>&gt;<i> 	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> 
</I>&gt;<i> 	/* Enable interrupts */
</I>&gt;<i> 	reg_ier =
</I>&gt;<i> 		AT91_IRQ_MB_RX |
</I>&gt;<i> 		AT91_IRQ_ERRP;	/* AT91_IRQ_WARN screws up system */
</I>&gt;<i> /* 		AT91_IRQ_CERR | AT91_IRQ_SERR |	AT91_IRQ_AERR | */
</I>&gt;<i> /* 		AT91_IRQ_FERR |	AT91_IRQ_BERR; */
</I>

Remove comments, please. It fits also on one line.

&gt;<i> 	at91_write(dev, AT91_IDR, 0x1fffffff);
</I>&gt;<i> 	at91_write(dev, AT91_IER, reg_ier);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> static void at91_chip_stop(struct net_device *dev)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	u32 reg_mr;
</I>&gt;<i> 
</I>&gt;<i> 	/* disable interrupts */
</I>&gt;<i> 	at91_write(dev, AT91_IDR, 0x1fffffff);
</I>&gt;<i> 
</I>&gt;<i> 	reg_mr = at91_read(dev, AT91_MR);
</I>&gt;<i> 	at91_write(dev, AT91_MR, reg_mr &amp; ~AT91_MR_AT91EN);
</I>&gt;<i> 
</I>&gt;<i> 	priv-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> 	enable_can_transceiver(priv, 0);
</I>
enable_can_transceiver() ???

&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> static int at91_open(struct net_device *dev)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	int err;
</I>&gt;<i> 
</I>&gt;<i> 	clk_enable(priv-&gt;clk);
</I>&gt;<i> 
</I>&gt;<i> 	/* check or determine and set bittime */
</I>&gt;<i> 	err = open_candev(dev);
</I>&gt;<i> 	if (err)
</I>&gt;<i> 		goto out;
</I>&gt;<i> 
</I>&gt;<i> 	/* register interrupt handler */
</I>&gt;<i> 	if (request_irq(dev-&gt;irq, at91_irq, IRQF_SHARED,
</I>&gt;<i> 			dev-&gt;name, dev)) {
</I>&gt;<i> 		err = -EAGAIN;
</I>&gt;<i> 		goto out_close;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* start chip and queuing */
</I>&gt;<i> 	at91_chip_start(dev);
</I>&gt;<i> 	netif_start_queue(dev);
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> 
</I>&gt;<i>  out_close:
</I>&gt;<i> 	close_candev(dev);
</I>&gt;<i>  out:
</I>&gt;<i> 	clk_disable(priv-&gt;clk);
</I>&gt;<i> 
</I>&gt;<i> 	return err;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * stop CAN bus activity
</I>&gt;<i>  */
</I>&gt;<i> static int at91_close(struct net_device *dev)
</I>&gt;<i> {
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 
</I>&gt;<i> 	netif_stop_queue(dev);
</I>&gt;<i> 
</I>&gt;<i> 	at91_chip_stop(dev);
</I>&gt;<i> 	free_irq(dev-&gt;irq, dev);
</I>&gt;<i> 	clk_disable(priv-&gt;clk);
</I>&gt;<i> 
</I>&gt;<i> 	close_candev(dev);
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> static int at91_set_mode(struct net_device *dev, u32 _mode)
</I>&gt;<i> {
</I>&gt;<i> 	enum can_mode mode = _mode;
</I>&gt;<i> 
</I>&gt;<i> 	switch (mode) {
</I>&gt;<i> 	case CAN_MODE_START:
</I>&gt;<i> 		dev_dbg(ND2D(dev), &quot;%s: CAN_MODE_START requested\n&quot;, __func__);
</I>
The calling function will already print a message.

&gt;<i> 
</I>&gt;<i> 		at91_chip_start(dev);
</I>&gt;<i> 		netif_wake_queue(dev);
</I>&gt;<i> 		break;
</I>&gt;<i> 
</I>&gt;<i> 	default:
</I>&gt;<i> 		return -EOPNOTSUPP;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> #if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
</I>&gt;<i> static const struct net_device_ops at91_netdev_ops = {
</I>&gt;<i> 	.ndo_open	= at91_open,
</I>&gt;<i> 	.ndo_stop	= at91_close,
</I>&gt;<i> 	.ndo_start_xmit	= at91_start_xmit,
</I>&gt;<i> };
</I>&gt;<i> #endif
</I>&gt;<i> 
</I>&gt;<i> static int __init at91_can_probe(struct platform_device *pdev)
</I>&gt;<i> {
</I>&gt;<i> 	struct net_device *dev;
</I>&gt;<i> 	struct at91_priv *priv;
</I>&gt;<i> 	struct resource *res;
</I>&gt;<i> 	struct clk *clk;
</I>&gt;<i> 	void __iomem *addr;
</I>&gt;<i> 	int err, irq;
</I>&gt;<i> 
</I>&gt;<i> 	clk = clk_get(&amp;pdev-&gt;dev, &quot;can_clk&quot;);
</I>&gt;<i> 	if (IS_ERR(clk)) {
</I>&gt;<i> 		dev_err(&amp;pdev-&gt;dev, &quot;no clock defined\n&quot;);
</I>&gt;<i> 		err = -ENODEV;
</I>&gt;<i> 		goto exit;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;<i> 	irq = platform_get_irq(pdev, 0);
</I>&gt;<i> 	if (!res || !irq) {
</I>&gt;<i> 		err = -ENODEV;
</I>&gt;<i> 		goto exit_put;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	if (!request_mem_region(res-&gt;start,
</I>&gt;<i> 				res-&gt;end - res-&gt;start + 1,
</I>&gt;<i> 				pdev-&gt;name)) {
</I>&gt;<i> 		err = -EBUSY;
</I>&gt;<i> 		goto exit_put;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	addr = ioremap_nocache(res-&gt;start, res-&gt;end - res-&gt;start + 1);
</I>&gt;<i> 	if (!addr) {
</I>&gt;<i> 		err = -ENOMEM;
</I>&gt;<i> 		goto exit_release;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	dev = alloc_candev(sizeof(struct at91_priv));
</I>&gt;<i> 	if (!dev) {
</I>&gt;<i> 		err = -ENOMEM;
</I>&gt;<i> 		goto exit_iounmap;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> #if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,28)
</I>&gt;<i> 	dev-&gt;netdev_ops		= &amp;at91_netdev_ops;
</I>&gt;<i> #else
</I>&gt;<i> 	dev-&gt;open		= at91_open;
</I>&gt;<i> 	dev-&gt;stop		= at91_close;
</I>&gt;<i> 	dev-&gt;hard_start_xmit	= at91_start_xmit;
</I>&gt;<i> #endif
</I>&gt;<i> 	dev-&gt;irq		= irq;
</I>&gt;<i> 	dev-&gt;flags		|= IFF_ECHO;
</I>&gt;<i> 
</I>&gt;<i> 	priv = netdev_priv(dev);
</I>&gt;<i> 	priv-&gt;can.clock.freq		= clk_get_rate(clk);
</I>&gt;<i> 	priv-&gt;can.bittiming_const	= &amp;at91_bittiming_const;
</I>&gt;<i> 	priv-&gt;can.do_set_bittiming	= at91_set_bittiming;
</I>&gt;<i> 	priv-&gt;can.do_set_mode		= at91_set_mode;
</I>&gt;<i> 	priv-&gt;clk			= clk;
</I>&gt;<i> 	priv-&gt;reg_base			= addr;
</I>&gt;<i> 
</I>&gt;<i> 	priv-&gt;pdata		= pdev-&gt;dev.platform_data;
</I>&gt;<i> 
</I>&gt;<i> 	dev_set_drvdata(&amp;pdev-&gt;dev, dev);
</I>&gt;<i> 	SET_NETDEV_DEV(dev, &amp;pdev-&gt;dev);
</I>&gt;<i> 
</I>&gt;<i> 	err = register_candev(dev);
</I>&gt;<i> 	if (err) {
</I>&gt;<i> 		dev_err(&amp;pdev-&gt;dev, &quot;registering netdev failed\n&quot;);
</I>&gt;<i> 		goto exit_free;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 	dev_info(&amp;pdev-&gt;dev, &quot;device registered (reg_base=%#p, irq=%d)\n&quot;,
</I>&gt;<i> 		 priv-&gt;reg_base, dev-&gt;irq);
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> 
</I>&gt;<i>  exit_free:
</I>&gt;<i> 	free_netdev(dev);
</I>&gt;<i>  exit_iounmap:
</I>&gt;<i> 	iounmap(addr);
</I>&gt;<i>  exit_release:
</I>&gt;<i> 	release_mem_region(res-&gt;start, res-&gt;end - res-&gt;start + 1);
</I>&gt;<i>  exit_put:
</I>&gt;<i> 	clk_put(clk);
</I>&gt;<i>  exit:
</I>&gt;<i> 	return err;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> static int __devexit at91_can_remove(struct platform_device *pdev)
</I>&gt;<i> {
</I>&gt;<i> 	struct net_device *dev = platform_get_drvdata(pdev);
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(dev);
</I>&gt;<i> 	struct resource *res;
</I>&gt;<i> 
</I>&gt;<i> 	unregister_netdev(dev);
</I>&gt;<i> 
</I>&gt;<i> 	platform_set_drvdata(pdev, NULL);
</I>&gt;<i> 
</I>&gt;<i> 	free_netdev(dev);
</I>&gt;<i> 
</I>&gt;<i> 	iounmap(priv-&gt;reg_base);
</I>&gt;<i> 
</I>&gt;<i> 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;<i> 	release_mem_region(res-&gt;start, res-&gt;end - res-&gt;start + 1);
</I>&gt;<i> 
</I>&gt;<i> 	clk_put(priv-&gt;clk);
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> #ifdef CONFIG_PM
</I>&gt;<i> static int at91_can_suspend(struct platform_device *pdev,
</I>&gt;<i> 			    pm_message_t mesg)
</I>&gt;<i> {
</I>&gt;<i> 	struct net_device *net_dev = platform_get_drvdata(pdev);
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(net_dev);
</I>&gt;<i> 
</I>&gt;<i> 	if (netif_running(net_dev)) {
</I>&gt;<i> 		/* TODO Disable IRQ? */
</I>&gt;<i> 		netif_stop_queue(net_dev);
</I>&gt;<i> 		netif_device_detach(net_dev);
</I>&gt;<i> 		enable_can_transceiver(priv, 0);
</I>&gt;<i> 		clk_disable(priv-&gt;clk);
</I>&gt;<i> 	}
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> static int at91_can_resume(struct platform_device *pdev)
</I>&gt;<i> {
</I>&gt;<i> 	struct net_device *net_dev = platform_get_drvdata(pdev);
</I>&gt;<i> 	struct at91_priv *priv = netdev_priv(net_dev);
</I>&gt;<i> 
</I>&gt;<i> 	if (netif_running(net_dev)) {
</I>&gt;<i> 		clk_enable(priv-&gt;clk);
</I>&gt;<i> 		enable_can_transceiver(priv, 1);
</I>&gt;<i> 		netif_device_attach(net_dev);
</I>&gt;<i> 		netif_start_queue(net_dev);
</I>&gt;<i> 		/* TODO Enable IRQ? */
</I>&gt;<i> 	}
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> #else
</I>&gt;<i> #define at91_can_suspend	NULL
</I>&gt;<i> #define at91_can_resume		NULL
</I>&gt;<i> #endif
</I>
Has the PM code been tested?

&gt;<i> 
</I>&gt;<i> static struct platform_driver at91_can_driver = {
</I>&gt;<i> 	.probe		= at91_can_probe,
</I>&gt;<i> 	.remove		= __devexit_p(at91_can_remove),
</I>&gt;<i> 	.suspend	= at91_can_suspend,
</I>&gt;<i> 	.resume		= at91_can_resume,
</I>&gt;<i> 	.driver		= {
</I>&gt;<i> 		.name	= DRV_NAME,
</I>&gt;<i> 		.owner	= THIS_MODULE,
</I>&gt;<i> 	},
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> static int __init at91_can_module_init(void)
</I>&gt;<i> {
</I>&gt;<i> 	printk(KERN_INFO &quot;%s netdevice driver\n&quot;, DRV_NAME);
</I>&gt;<i> 	return platform_driver_register(&amp;at91_can_driver);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void __exit at91_can_module_exit(void)
</I>&gt;<i> {
</I>&gt;<i> 	platform_driver_unregister(&amp;at91_can_driver);
</I>&gt;<i> 	printk(KERN_INFO &quot;%s: driver removed\n&quot;, DRV_NAME);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> module_init(at91_can_module_init);
</I>&gt;<i> module_exit(at91_can_module_exit);
</I>&gt;<i> 
</I>&gt;<i> MODULE_AUTHOR(&quot;Marc Kleine-Budde &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">mkl at pengutronix.de</A>&gt;&quot;);
</I>&gt;<i> MODULE_LICENSE(&quot;GPL v2&quot;);
</I>&gt;<i> MODULE_DESCRIPTION(&quot;LLCF/socketcan '&quot; DRV_NAME &quot;' network device driver&quot;);
</I>
Please correct the module description, especially remove LLCF.

Apart from that the drives look good. Well I'm just back from holiday
and may have missed something.

Wolfgang.

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002894.html">dlc check in driver
</A></li>
	<LI>Next message: <A HREF="002860.html">Comments on at91_can.c
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2859">[ date ]</a>
              <a href="thread.html#2859">[ thread ]</a>
              <a href="subject.html#2859">[ subject ]</a>
              <a href="author.html#2859">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
