<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH V2] net-next-2.6:can: add TI CAN (HECC) driver
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20V2%5D%20net-next-2.6%3Acan%3A%20add%20TI%20CAN%20%28HECC%29%20driver&In-Reply-To=%3C1251958885-12257-1-git-send-email-anantgole%40ti.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002963.html">
   <LINK REL="Next"  HREF="002965.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH V2] net-next-2.6:can: add TI CAN (HECC) driver</H1>
    <B>Anant Gole</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20V2%5D%20net-next-2.6%3Acan%3A%20add%20TI%20CAN%20%28HECC%29%20driver&In-Reply-To=%3C1251958885-12257-1-git-send-email-anantgole%40ti.com%3E"
       TITLE="[PATCH V2] net-next-2.6:can: add TI CAN (HECC) driver">anantgole at ti.com
       </A><BR>
    <I>Thu Sep  3 08:21:25 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002963.html">(ATTicket:560142) Re: Comments on at91_can.c
</A></li>
        <LI>Next message: <A HREF="002965.html">[PATCH V2] net-next-2.6:can: add TI CAN (HECC) driver
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2964">[ date ]</a>
              <a href="thread.html#2964">[ thread ]</a>
              <a href="subject.html#2964">[ subject ]</a>
              <a href="author.html#2964">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>TI HECC (High End CAN Ctonroller) module is found on many TI devices.
It has 32 hardware mailboxes with full implementation of CAN protocol
version 2.0B with bus speeds up to 1Mbps. Specifications of the
module are available at TI web &lt;<A HREF="http://www.ti.com">http://www.ti.com</A>&gt;

This driver is tested on a newer OMAP device EVM.

Signed-off-by: Anant Gole &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">anantgole at ti.com</A>&gt;
---
 drivers/net/can/Kconfig              |    9 +
 drivers/net/can/Makefile             |    2 +
 drivers/net/can/ti_hecc.c            |  997 ++++++++++++++++++++++++++++++++++
 include/linux/can/platform/ti_hecc.h |   40 ++
 4 files changed, 1048 insertions(+), 0 deletions(-)
 delete mode 100644 drivers/mtd/maps/sbc8240.c
 create mode 100644 drivers/net/can/ti_hecc.c
 create mode 100644 include/linux/can/platform/ti_hecc.h

diff --git a/drivers/mtd/maps/sbc8240.c b/drivers/mtd/maps/sbc8240.c
deleted file mode 100644
index e69de29..0000000
diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
index 30ae55d..fae62df 100644
--- a/drivers/net/can/Kconfig
+++ b/drivers/net/can/Kconfig
@@ -75,6 +75,15 @@ config CAN_KVASER_PCI
 	  This driver is for the the PCIcanx and PCIcan cards (1, 2 or
 	  4 channel) from Kvaser (<A HREF="http://www.kvaser.com">http://www.kvaser.com</A>).
 
+config CAN_TI_HECC
+        depends on CAN_DEV
+        tristate &quot;TI High End CAN Controller (HECC)&quot;
+        default N
+        ---help---
+	  This driver adds support for TI High End CAN Controller module
+	  found on many TI devices. The specifications of this module are
+	  are available from TI web (<A HREF="http://www.ti.com">http://www.ti.com</A>)
+
 config CAN_DEBUG_DEVICES
 	bool &quot;CAN devices debugging messages&quot;
 	depends on CAN
diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
index 523a941..d923512 100644
--- a/drivers/net/can/Makefile
+++ b/drivers/net/can/Makefile
@@ -9,4 +9,6 @@ can-dev-y			:= dev.o
 
 obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
 
+obj-$(CONFIG_CAN_TI_HECC)	+= ti_hecc.o
+
 ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
diff --git a/drivers/net/can/ti_hecc.c b/drivers/net/can/ti_hecc.c
new file mode 100644
index 0000000..e8c2763
--- /dev/null
+++ b/drivers/net/can/ti_hecc.c
@@ -0,0 +1,997 @@
+/*
+ * TI HECC (CAN) device driver
+ *
+ * This driver supports TI's HECC (High End CAN Controller module) and the
+ * specs for the same is available at &lt;<A HREF="http://www.ti.com">http://www.ti.com</A>&gt;
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated - <A HREF="http://www.ti.com/">http://www.ti.com/</A>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed as is WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * Your platform definitions should specify module ram offsets and interrupt
+ * number to use as follows:
+ *
+ * static struct ti_hecc_platform_data omap3517_evm_hecc_pdata = {
+ *         .scc_hecc_offset        = 0,
+ *         .scc_ram_offset         = 0x3000,
+ *         .hecc_ram_offset        = 0x3000,
+ *         .mbox_offset            = 0x2000,
+ *         .int_line               = 0,
+ *         .revision               = 1,
+ * };
+ *
+ * Please see include/can/platform/ti_hecc.h for description of above fields
+ *
+ */
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/sched.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/fcntl.h&gt;
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/ptrace.h&gt;
+#include &lt;linux/string.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/netdevice.h&gt;
+#include &lt;linux/if_arp.h&gt;
+#include &lt;linux/if_ether.h&gt;
+#include &lt;linux/skbuff.h&gt;
+#include &lt;linux/delay.h&gt;
+#include &lt;linux/platform_device.h&gt;
+#include &lt;linux/clk.h&gt;
+#include &lt;linux/io.h&gt;
+#include &lt;linux/can.h&gt;
+#include &lt;linux/can/dev.h&gt;
+#include &lt;linux/can/error.h&gt;
+#include &lt;linux/can/platform/ti_hecc.h&gt;
+
+#define DRV_NAME &quot;ti_hecc&quot;
+#define HECC_MODULE_VERSION     &quot;0.3&quot;
+MODULE_VERSION(HECC_MODULE_VERSION);
+#define DRV_DESC &quot;TI High End CAN Controller Driver &quot; HECC_MODULE_VERSION
+
+#define HECC_MAX_MAILBOXES	32	/* hardware mboxes - do not change */
+#define MAX_TX_PRIO		0x3F	/* hardware value - do not change */
+
+#if (CAN_ECHO_SKB_MAX &gt; 16)
+#define TI_HECC_MAX_TX_MBOX	16
+#else
+#define TI_HECC_MAX_TX_MBOX	CAN_ECHO_SKB_MAX
+#endif
+#define TI_HECC_MAX_RX_MBOX	(HECC_MAX_MAILBOXES - TI_HECC_MAX_TX_MBOX)
+
+#define TI_HECC_DEF_NAPI_WEIGHT	TI_HECC_MAX_RX_MBOX
+
+/* TI HECC module registers */
+
+#define HECC_CANME		0x0	/* Mailbox enable */
+#define HECC_CANMD		0x4	/* Mailbox direction */
+#define HECC_CANTRS		0x8	/* Transmit request set */
+#define HECC_CANTRR		0xC	/* Transmit request */
+#define HECC_CANTA		0x10	/* Transmission acknowledge */
+#define HECC_CANAA		0x14	/* Abort acknowledge */
+#define HECC_CANRMP		0x18	/* Receive message pending */
+#define HECC_CANRML		0x1C	/* Remote message lost */
+#define HECC_CANRFP		0x20	/* Remote frame pending */
+#define HECC_CANGAM		0x24	/* SECC only:Global acceptance mask */
+#define HECC_CANMC		0x28	/* Master control */
+#define HECC_CANBTC		0x2C	/* Bit timing configuration */
+#define HECC_CANES		0x30	/* Error and status */
+#define HECC_CANTEC		0x34	/* Transmit error counter */
+#define HECC_CANREC		0x38	/* Receive error counter */
+#define HECC_CANGIF0		0x3C	/* Global interrupt flag 0 */
+#define HECC_CANGIM		0x40	/* Global interrupt mask */
+#define HECC_CANGIF1		0x44	/* Global interrupt flag 1 */
+#define HECC_CANMIM		0x48	/* Mailbox interrupt mask */
+#define HECC_CANMIL		0x4C	/* Mailbox interrupt level */
+#define HECC_CANOPC		0x50	/* Overwrite protection control */
+#define HECC_CANTIOC		0x54	/* Transmit I/O control */
+#define HECC_CANRIOC		0x58	/* Receive I/O control */
+#define HECC_CANLNT		0x5C	/* HECC only: Local network time */
+#define HECC_CANTOC		0x60	/* HECC only: Time-out control */
+#define HECC_CANTOS		0x64	/* HECC only: Time-out status */
+#define HECC_CANTIOCE		0x68	/* SCC only:Enhanced TX I/O control */
+#define HECC_CANRIOCE		0x6C	/* SCC only:Enhanced RX I/O control */
+
+/* SCC only:Local acceptance registers */
+#define HECC_CANLAM0		(priv-&gt;scc_ram_offset + 0x0)
+#define HECC_CANLAM3		(priv-&gt;scc_ram_offset + 0xC)
+
+/* HECC only */
+#define HECC_CANLAM(mbxno)	(priv-&gt;hecc_ram_offset + ((mbxno) * 4))
+#define HECC_CANMOTS(mbxno)	(priv-&gt;hecc_ram_offset + ((mbxno) * 4) + 0x80)
+#define HECC_CANMOTO(mbxno)	(priv-&gt;hecc_ram_offset + ((mbxno) * 4) + 0x100)
+
+/* Mailbox registers */
+#define HECC_CANMID(mbxno)	(priv-&gt;mbox_offset + ((mbxno) * 0x10))
+#define HECC_CANMCF(mbxno)	(priv-&gt;mbox_offset + ((mbxno) * 0x10) + 0x4)
+#define HECC_CANMDL(mbxno)	(priv-&gt;mbox_offset + ((mbxno) * 0x10) + 0x8)
+#define HECC_CANMDH(mbxno)	(priv-&gt;mbox_offset + ((mbxno) * 0x10) + 0xC)
+
+#define HECC_SET_REG		0xFFFFFFFF
+#define HECC_CANID_MASK		0x3FF	/* 18 bits mask for extended id's */
+
+#define HECC_CANMC_SCM		BIT(13)	/* SCC compat mode */
+#define HECC_CANMC_CCR		BIT(12)	/* Change config request */
+#define HECC_CANMC_PDR		BIT(11)	/* Local Power down - for sleep mode */
+#define HECC_CANMC_ABO		BIT(7)	/* Auto Bus On */
+#define HECC_CANMC_STM		BIT(6)	/* Self test mode - loopback */
+#define HECC_CANMC_SRES		BIT(5)	/* Software reset */
+
+#define HECC_CANTIOC_EN		BIT(3)	/* Enable CAN TX I/O pin */
+#define HECC_CANRIOC_EN		BIT(3)	/* Enable CAN RX I/O pin */
+
+#define HECC_CANMID_IDE		BIT(31)	/* Extended frame format */
+#define HECC_CANMID_AME		BIT(30)	/* Acceptance mask enable */
+#define HECC_CANMID_AAM		BIT(29)	/* Auto answer mode */
+
+#define HECC_CANES_FE		BIT(24)	/* form error */
+#define HECC_CANES_BE		BIT(23)	/* bit error */
+#define HECC_CANES_SA1		BIT(22)	/* stuck at dominant error */
+#define HECC_CANES_CRCE		BIT(21)	/* CRC error */
+#define HECC_CANES_SE		BIT(20)	/* stuff bit error */
+#define HECC_CANES_ACKE		BIT(19)	/* ack error */
+#define HECC_CANES_BO		BIT(18)	/* Bus off status */
+#define HECC_CANES_EP		BIT(17)	/* Error passive status */
+#define HECC_CANES_EW		BIT(16)	/* Error warning status */
+#define HECC_CANES_SMA		BIT(5)	/* suspend mode ack */
+#define HECC_CANES_CCE		BIT(4)	/* Change config enabled */
+#define HECC_CANES_PDA		BIT(3)	/* Power down mode ack */
+
+#define HECC_CANBTC_SAM		BIT(7)	/* sample points */
+
+#define HECC_BUS_ERROR		(HECC_CANES_FE | HECC_CANES_BE |\
+				HECC_CANES_CRCE | HECC_CANES_SE |\
+				HECC_CANES_ACKE)
+
+#define HECC_CANMCF_RTR		BIT(4)	/* Remote xmit request */
+
+#define HECC_CANGIF_MAIF	BIT(17)	/* Message alarm interrupt */
+#define HECC_CANGIF_TCOIF	BIT(16) /* Timer counter overflow int */
+#define HECC_CANGIF_GMIF	BIT(15)	/* Global mailbox interrupt */
+#define HECC_CANGIF_AAIF	BIT(14)	/* Abort ack interrupt */
+#define HECC_CANGIF_WDIF	BIT(13)	/* Write denied interrupt */
+#define HECC_CANGIF_WUIF	BIT(12)	/* Wake up interrupt */
+#define HECC_CANGIF_RMLIF	BIT(11)	/* Receive message lost interrupt */
+#define HECC_CANGIF_BOIF	BIT(10)	/* Bus off interrupt */
+#define HECC_CANGIF_EPIF	BIT(9)	/* Error passive interrupt */
+#define HECC_CANGIF_WLIF	BIT(8)	/* Warning level interrupt */
+#define HECC_CANGIF_MBOX_MASK	0x1F	/* Mailbox number mask */
+#define HECC_CANGIM_I1EN	BIT(1)	/* Int line 1 enable */
+#define HECC_CANGIM_I0EN	BIT(0)	/* Int line 0 enable */
+#define HECC_CANGIM_DEF_MASK	0x700	/* only busoff/warning/passive */
+#define HECC_CANGIM_SIL		BIT(2)	/* system interrupts to int line 1 */
+
+/* CAN Bittiming constants as per HECC specs */
+static struct can_bittiming_const ti_hecc_bittiming_const = {
+	.name = DRV_NAME,
+	.tseg1_min = 1,
+	.tseg1_max = 16,
+	.tseg2_min = 1,
+	.tseg2_max = 8,
+	.sjw_max = 4,
+	.brp_min = 1,
+	.brp_max = 256,
+	.brp_inc = 1,
+};
+
+struct ti_hecc_priv {
+	struct can_priv can;	/* MUST be first member/field */
+	struct napi_struct napi;
+	struct net_device *ndev;
+	struct clk *clk;
+	void __iomem *base;
+	u32 scc_ram_offset;
+	u32 hecc_ram_offset;
+	u32 mbox_offset;
+	u32 int_line;
+	u32 tx_mbxno;
+	u32 prio;
+	u32 stop_xmit;
+	DECLARE_BITMAP(tx_free_mbx, TI_HECC_MAX_TX_MBOX);
+	spinlock_t tx_lock;	/* Protects tx_mbxno &amp; tx_free_mbx bitmap */
+
+};
+
+static inline
+void hecc_write(struct ti_hecc_priv *priv, int reg, u32 val)
+{
+	__raw_writel(val, priv-&gt;base + reg);
+}
+
+static inline u32 hecc_read(struct ti_hecc_priv *priv, int reg)
+{
+	return __raw_readl(priv-&gt;base + reg);
+}
+
+static inline
+void hecc_set_bit(struct ti_hecc_priv *priv, int reg, unsigned bit)
+{
+	hecc_write(priv, reg, (hecc_read(priv, reg) | bit));
+}
+
+static inline
+void hecc_clear_bit(struct ti_hecc_priv *priv, int reg, unsigned bit)
+{
+	hecc_write(priv, reg, (hecc_read(priv, reg) &amp; ~bit));
+}
+
+static inline
+u32 hecc_get_bit(struct ti_hecc_priv *priv, int reg, int bit)
+{
+	return (hecc_read(priv, reg) &amp; bit) ? 1 : 0;
+}
+
+static int ti_hecc_get_state(const struct net_device *ndev,
+	enum can_state *state)
+{
+	struct ti_hecc_priv *priv = netdev_priv(ndev);
+	*state = priv-&gt;can.state;
+	return 0;
+}
+
+static int ti_hecc_set_bittiming(struct net_device *ndev)
+{
+	/* NOTE: TI HECC module requires bittimings to be programmed only in
+	 * initialization mode - this is handled only in ti_hecc_reset() in
+	 * this driver and hence this function is dummy. The can bittiming
+	 * structure should be populated before hand (via ip utility)
+	 */
+	return 0;
+}
+
+static int ti_hecc_set_btc(struct ti_hecc_priv *priv)
+{
+	struct can_bittiming *bit_timing = &amp;priv-&gt;can.bittiming;
+	u32 can_btc = 0;
+
+	can_btc = ((bit_timing-&gt;phase_seg2 - 1) &amp; 0x7);
+	can_btc |= (((bit_timing-&gt;phase_seg1 + bit_timing-&gt;prop_seg - 1)
+			&amp; 0xF) &lt;&lt; 3);
+	if ((bit_timing-&gt;brp &gt; 4) &amp;&amp;
+		(priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_3_SAMPLES))
+			can_btc |= HECC_CANBTC_SAM;
+
+	can_btc |= (((bit_timing-&gt;sjw - 1) &amp; 0x3) &lt;&lt; 8);
+	can_btc |= (((bit_timing-&gt;brp - 1) &amp; 0xFF) &lt;&lt; 16);
+
+	/* ERM being set to 0 by default meaning resync at falling edge */
+
+	hecc_write(priv, HECC_CANBTC, can_btc);
+	dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;setting CANBTC=%#x\n&quot;, can_btc);
+
+	return 0;
+}
+
+static void ti_hecc_reset(struct net_device *ndev)
+{
+#define HECC_CCE_WAIT_COUNT     100
+	u32 cnt;
+	struct ti_hecc_priv *priv = netdev_priv(ndev);
+
+	dev_dbg(ndev-&gt;dev.parent, &quot;resetting hecc ...\n&quot;);
+	hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_SRES);
+
+	/* Set change control request and wait till enabled */
+	hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
+
+	/* INFO: It has been observed that at times CCE bit may not be
+	 * set and hw seems to be ok even if this bit is not set so
+	 * timing out with a timing of 1ms to respect the specs
+	 */
+	cnt = HECC_CCE_WAIT_COUNT;
+	while (!hecc_get_bit(priv, HECC_CANES, HECC_CANES_CCE) &amp;&amp; (0 != cnt)) {
+		--cnt;
+		udelay(10);
+	}
+
+	/* Note: On HECC, BTC can be programmed only in initialization mode, so
+	 * it is expected that the can bittiming parameters are set via ip
+	 * utility before the device is opened
+	 */
+	ti_hecc_set_btc(priv);
+
+	/* Clear CCR (and CANMC register) and wait for CCE = 0 enable */
+	hecc_write(priv, HECC_CANMC, 0);
+
+	/* INFO: CAN net stack handles bus off and hence disabling auto-bus-on
+	 * hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_ABO);
+	 */
+
+	/* INFO: It has been observed that at times CCE bit may not be
+	 * set and hw seems to be ok even if this bit is not set so
+	 */
+	cnt = HECC_CCE_WAIT_COUNT;
+	while (hecc_get_bit(priv, HECC_CANES, HECC_CANES_CCE) &amp;&amp; (0 != cnt)) {
+		--cnt;
+		udelay(10);
+	}
+
+	/* Enable TX and RX I/O Control pins */
+	hecc_write(priv, HECC_CANTIOC, HECC_CANTIOC_EN);
+	hecc_write(priv, HECC_CANRIOC, HECC_CANRIOC_EN);
+
+	/* Clear registers for clean operation */
+	hecc_write(priv, HECC_CANTA, HECC_SET_REG);
+	hecc_write(priv, HECC_CANRMP, HECC_SET_REG);
+	hecc_write(priv, HECC_CANGIF0, HECC_SET_REG);
+	hecc_write(priv, HECC_CANGIF1, HECC_SET_REG);
+	hecc_write(priv, HECC_CANME, 0);
+	hecc_write(priv, HECC_CANMD, 0);
+
+	/* SCC compat mode NOT supported (and not needed too) */
+	hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_SCM);
+}
+
+/**
+ * ti_hecc_start: Starts HECC module
+ *
+ * If CAN state is not stopped, reset the module, init bit timings
+ * and start the device for operation
+ */
+static void ti_hecc_start(struct net_device *ndev)
+{
+	struct ti_hecc_priv *priv = netdev_priv(ndev);
+	int cnt, mbxno;
+
+	/* put HECC in initialization mode and set btc */
+	ti_hecc_reset(ndev);
+	priv-&gt;tx_mbxno = TI_HECC_MAX_TX_MBOX - 1;
+	priv-&gt;prio = MAX_TX_PRIO;
+	bitmap_zero(priv-&gt;tx_free_mbx, TI_HECC_MAX_TX_MBOX);
+
+	/* Enable local and global acceptance mask registers */
+	hecc_write(priv, HECC_CANGAM, HECC_SET_REG);
+	hecc_write(priv, HECC_CANLAM0, HECC_SET_REG);
+	hecc_write(priv, HECC_CANLAM3, HECC_SET_REG);
+
+	/* Prepare configured mailboxes to receive messages */
+	for (cnt = 0; cnt &lt; TI_HECC_MAX_RX_MBOX; cnt++) {
+		mbxno = (HECC_MAX_MAILBOXES - 1 - cnt);
+		hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
+		hecc_write(priv, HECC_CANMID(mbxno), HECC_CANMID_AME);
+		hecc_write(priv, HECC_CANLAM(mbxno), HECC_SET_REG);
+		hecc_set_bit(priv, HECC_CANMD, (1 &lt;&lt; mbxno));
+		hecc_set_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
+		hecc_set_bit(priv, HECC_CANMIM, (1 &lt;&lt; mbxno));
+	}
+
+	/* Prevent message over-write &amp; Enable interrupts */
+	hecc_write(priv, HECC_CANTRS, 0);
+	hecc_write(priv, HECC_CANOPC, HECC_SET_REG);
+	if (priv-&gt;int_line) {
+		hecc_write(priv, HECC_CANMIL, HECC_SET_REG);
+		hecc_write(priv, HECC_CANGIM, (HECC_CANGIM_DEF_MASK |
+			HECC_CANGIM_I1EN | HECC_CANGIM_SIL));
+	} else {
+		hecc_write(priv, HECC_CANMIL, 0);
+		hecc_write(priv, HECC_CANGIM,
+			(HECC_CANGIM_DEF_MASK | HECC_CANGIM_I0EN));
+	}
+	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
+}
+
+static void ti_hecc_stop(struct net_device *ndev)
+{
+	struct ti_hecc_priv *priv = netdev_priv(ndev);
+
+	/* Disable interrupts and disable mailboxes */
+	hecc_write(priv, HECC_CANGIM, 0);
+	hecc_write(priv, HECC_CANMIM, 0);
+	hecc_write(priv, HECC_CANME, 0);
+	priv-&gt;can.state = CAN_STATE_STOPPED;
+}
+
+static int ti_hecc_do_set_mode(struct net_device *ndev, enum can_mode mode)
+{
+	struct ti_hecc_priv *priv = netdev_priv(ndev);
+	int ret = 0;
+
+	switch (mode) {
+	case CAN_MODE_START:
+		dev_info(priv-&gt;ndev-&gt;dev.parent, &quot;device (re)starting\n&quot;);
+		++priv-&gt;can.can_stats.restarts;
+		ti_hecc_start(ndev);
+		if (netif_queue_stopped(ndev))
+			netif_wake_queue(ndev);
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	return ret;
+}
+
+/**
+ * ti_hecc_xmit: HECC Transmit
+ *
+ * The transmit mailboxes start from 0 to TI_HECC_MAX_TX_MBOX. In HECC the
+ * priority of the mailbox for tranmission depends upon the setting of priority
+ * field in mailbox registers. The mailbox with highest value in priority field
+ * is transmitted first. Only when two mailboxes have the same value in
+ * priority field the highest numbered mailbox is transmitted first.
+ *
+ * To utilize the HECC priority feature as described above we start with the
+ * highest numbered mailbox with highest priority level and move on to the next
+ * mailbox with the same priority level and so on. Once we loop through all the
+ * transmit mailboxes we choose the next priority level (lower) and so on
+ * untill we reach the lowest priority level on the lowest numbered mailbox
+ * when we stop transmission untill all mailboxes are transmitted and then
+ * restart at highest numbered mailbox with highest priority.
+ *
+ * To keep track of next transmit mailbox priv-&gt;tx_mbxno is used along with
+ * priv-&gt;prio for priority. priv-&gt;stop_xmit helps sync transmit complete
+ * interrupt when we re-start the queue if it was stopped after the mailbox
+ * priority roll-over.
+ */
+static int ti_hecc_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct ti_hecc_priv *priv = netdev_priv(ndev);
+	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
+	u32 mbxno = 0;
+	u32 data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;priv-&gt;tx_lock, flags);
+	mbxno = priv-&gt;tx_mbxno;
+	set_bit(mbxno, priv-&gt;tx_free_mbx);
+	spin_unlock_irqrestore(&amp;priv-&gt;tx_lock, flags);
+
+	/* Prepare mailbox for transmission */
+	hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
+	data = cf-&gt;can_dlc &amp; 0xF;
+	if (cf-&gt;can_id &amp; CAN_RTR_FLAG) /* Remote transmission request */
+		data |= HECC_CANMCF_RTR;
+	data |= ((priv-&gt;prio &amp; 0x3F) &lt;&lt; 8); /* set tx priority level */
+	hecc_write(priv, HECC_CANMCF(mbxno), data);
+
+	if (cf-&gt;can_id &amp; CAN_EFF_FLAG) /* Extended frame format */
+		data = ((cf-&gt;can_id &amp; CAN_EFF_MASK) | HECC_CANMID_IDE);
+	else /* Standard frame format */
+		data = ((cf-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; 18);
+
+	hecc_write(priv, HECC_CANMID(mbxno), data);
+	data = (cf-&gt;data[0] &lt;&lt; 24) | (cf-&gt;data[1] &lt;&lt; 16) |
+			(cf-&gt;data[2] &lt;&lt; 8) | cf-&gt;data[3];
+	hecc_write(priv, HECC_CANMDL(mbxno), data);
+	if (cf-&gt;can_dlc &gt; 4) {
+		data = (cf-&gt;data[4] &lt;&lt; 24) | (cf-&gt;data[5] &lt;&lt; 16) |
+			(cf-&gt;data[6] &lt;&lt; 8) | cf-&gt;data[7];
+		hecc_write(priv, HECC_CANMDH(mbxno), data);
+	}
+	can_put_echo_skb(skb, ndev, mbxno);
+
+	/* check if next mailbox is free - if not hold queue */
+	spin_lock_irqsave(&amp;priv-&gt;tx_lock, flags);
+	if (priv-&gt;tx_mbxno)
+		--priv-&gt;tx_mbxno;
+	else {
+		priv-&gt;tx_mbxno = (TI_HECC_MAX_TX_MBOX - 1);
+		if (priv-&gt;prio)
+			--priv-&gt;prio;
+		else {
+			priv-&gt;stop_xmit = 1;
+			priv-&gt;prio = MAX_TX_PRIO;
+		}
+	}
+
+	/* Stop the queue if next transmit mailbox is not free or if there
+	 * is a wrap over in priority and queue should be stopped
+	 */
+	if (test_bit(priv-&gt;tx_mbxno, priv-&gt;tx_free_mbx) || priv-&gt;stop_xmit)
+		netif_stop_queue(priv-&gt;ndev);
+	spin_unlock_irqrestore(&amp;priv-&gt;tx_lock, flags);
+
+	/* Enable interrupt for mbox and start transmission */
+	hecc_clear_bit(priv, HECC_CANMD, (1 &lt;&lt; mbxno));
+	hecc_set_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
+	hecc_set_bit(priv, HECC_CANMIM, (1 &lt;&lt; mbxno));
+	hecc_set_bit(priv, HECC_CANTRS, (1 &lt;&lt; mbxno));
+	ndev-&gt;trans_start = jiffies;
+
+	return NETDEV_TX_OK;
+}
+
+static int ti_hecc_rx_pkt(struct ti_hecc_priv *priv, int mbxno)
+{
+	struct net_device_stats *stats = &amp;priv-&gt;ndev-&gt;stats;
+	struct can_frame *cf;
+	struct sk_buff *skb;
+	u32 data;
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (!skb) {
+		if (printk_ratelimit())
+			dev_err(priv-&gt;ndev-&gt;dev.parent,
+				&quot;dev_alloc_skb() failed\n&quot;);
+		return -ENOMEM;
+	}
+	skb-&gt;dev = priv-&gt;ndev;
+	skb-&gt;protocol = htons(ETH_P_CAN);
+	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
+
+	cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
+	memset(cf, 0, sizeof(struct can_frame));
+	data = hecc_read(priv, HECC_CANMID(mbxno));
+	if (data &amp; HECC_CANMID_IDE)
+		cf-&gt;can_id = (data &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
+	else
+		cf-&gt;can_id = ((data &gt;&gt; 18) &amp; CAN_SFF_MASK);
+	data = hecc_read(priv, HECC_CANMCF(mbxno));
+	if (data &amp; HECC_CANMCF_RTR)
+		cf-&gt;can_id |= CAN_RTR_FLAG;
+	cf-&gt;can_dlc = data &amp; 0xF;
+	data = hecc_read(priv, HECC_CANMDL(mbxno));
+	/* The below statements are for readability sake */
+	cf-&gt;data[0] = ((data &amp; 0xFF000000) &gt;&gt; 24);
+	cf-&gt;data[1] = ((data &amp; 0xFF0000) &gt;&gt; 16);
+	cf-&gt;data[2] = ((data &amp; 0xFF00) &gt;&gt; 8);
+	cf-&gt;data[3] = (data &amp; 0xFF);
+	if (cf-&gt;can_dlc &gt; 4) {
+		data = hecc_read(priv, HECC_CANMDH(mbxno));
+		cf-&gt;data[4] = ((data &amp; 0xFF000000) &gt;&gt; 24);
+		cf-&gt;data[5] = ((data &amp; 0xFF0000) &gt;&gt; 16);
+		cf-&gt;data[6] = ((data &amp; 0xFF00) &gt;&gt; 8);
+		cf-&gt;data[7] = (data &amp; 0xFF);
+	}
+
+	/* prepare mailbox for next receive */
+	hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
+	hecc_write(priv, HECC_CANMID(mbxno), HECC_CANMID_AME);
+	hecc_write(priv, HECC_CANLAM(mbxno), HECC_SET_REG);
+	hecc_set_bit(priv, HECC_CANMD, (1 &lt;&lt; mbxno));
+	hecc_set_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
+
+	stats-&gt;rx_bytes += cf-&gt;can_dlc;
+	netif_receive_skb(skb);
+	stats-&gt;rx_packets++;
+	priv-&gt;ndev-&gt;last_rx = jiffies;
+
+	return 0;
+}
+
+/**
+ * ti_hecc_rx_poll - HECC receive pkts
+ *
+ * The receive mailboxes start from highest numbered mailbox till last xmit
+ * mailbox. On CAN frame reception the hardware places the data into highest
+ * numbered mailbox that matches the CAN ID filter. Since all receive mailboxes
+ * have same filtering (ALL CAN frames) we process higher numbered mailboxes
+ * first and so on to ensure packet order.
+ */
+static int ti_hecc_rx_poll(struct napi_struct *napi, int quota)
+{
+	struct net_device *ndev = napi-&gt;dev;
+	struct ti_hecc_priv *priv = netdev_priv(ndev);
+	u32 num_pkts = 0;
+	u32 mbxno, mbx_mask;
+	unsigned long pending_pkts;
+
+	if (!netif_running(ndev))
+		return 0;
+
+	pending_pkts = hecc_read(priv, HECC_CANRMP);
+	mbx_mask = BIT(HECC_MAX_MAILBOXES - 1); /* highest numbered mailbox */
+	mbxno = (HECC_MAX_MAILBOXES - 1);
+	while (pending_pkts &amp;&amp; (num_pkts &lt; quota)) {
+		if (mbx_mask &amp; pending_pkts) {
+			if (ti_hecc_rx_pkt(priv, mbxno) &lt; 0)
+				return num_pkts;
+			clear_bit(mbxno, &amp;pending_pkts);
+			hecc_set_bit(priv, HECC_CANRMP, (1 &lt;&lt; mbxno));
+			++num_pkts;
+		}
+		mbx_mask = (mbx_mask &gt;&gt; 1);
+		--mbxno;
+	}
+
+	/* Enable packet interrupt if all pkts are handled */
+	if (0 == hecc_read(priv, HECC_CANRMP)) {
+		napi_complete(napi);
+		/* Re-enable RX mailbox interrupts */
+		mbxno = hecc_read(priv, HECC_CANMIM);
+		mbxno |= (~((1 &lt;&lt; TI_HECC_MAX_TX_MBOX) - 1));
+		hecc_write(priv, HECC_CANMIM, mbxno);
+	}
+
+	return num_pkts;
+}
+
+static int
+ti_hecc_error(struct net_device *ndev, int int_status, int err_status)
+{
+	struct ti_hecc_priv *priv = netdev_priv(ndev);
+	struct net_device_stats *stats = &amp;ndev-&gt;stats;
+	struct can_frame *cf;
+	struct sk_buff *skb;
+
+	/* propogate the error condition to the can stack */
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (!skb) {
+		if (printk_ratelimit())
+			dev_err(priv-&gt;ndev-&gt;dev.parent,
+				&quot;dev_alloc_skb() failed in err processing\n&quot;);
+		return -ENOMEM;
+	}
+	skb-&gt;dev = ndev;
+	skb-&gt;protocol = htons(ETH_P_CAN);
+	cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
+	memset(cf, 0, sizeof(struct can_frame));
+	cf-&gt;can_id = CAN_ERR_FLAG;
+	cf-&gt;can_dlc = CAN_ERR_DLC;
+
+	if (int_status &amp; HECC_CANGIF_WLIF) { /* warning level int */
+		if (0 == (int_status &amp; HECC_CANGIF_BOIF)) {
+			priv-&gt;can.state = CAN_STATE_ERROR_WARNING;
+			++priv-&gt;can.can_stats.error_warning;
+			cf-&gt;can_id |= CAN_ERR_CRTL;
+			if (hecc_read(priv, HECC_CANTEC) &gt; 96)
+				cf-&gt;data[1] |= CAN_ERR_CRTL_TX_WARNING;
+			if (hecc_read(priv, HECC_CANREC) &gt; 96)
+				cf-&gt;data[1] |= CAN_ERR_CRTL_RX_WARNING;
+		}
+		hecc_set_bit(priv, HECC_CANES, HECC_CANES_EW);
+		dev_dbg(priv-&gt;ndev-&gt;dev.parent, &quot;Error Warning interrupt\n&quot;);
+		hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
+	}
+
+	if (int_status &amp; HECC_CANGIF_EPIF) { /* error passive int */
+		if (0 == (int_status &amp; HECC_CANGIF_BOIF)) {
+			priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
+			++priv-&gt;can.can_stats.error_passive;
+			cf-&gt;can_id |= CAN_ERR_CRTL;
+			if (hecc_read(priv, HECC_CANTEC) &gt; 127)
+				cf-&gt;data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
+			if (hecc_read(priv, HECC_CANREC) &gt; 127)
+				cf-&gt;data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
+		}
+		hecc_set_bit(priv, HECC_CANES, HECC_CANES_EP);
+		dev_dbg(priv-&gt;ndev-&gt;dev.parent, &quot;Error passive interrupt\n&quot;);
+		hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
+	}
+
+	/* Need to check busoff condition in error status register too to
+	 * ensure warning interrupts don't hog the system
+	 */
+	if ((int_status &amp; HECC_CANGIF_BOIF) || (err_status &amp; HECC_CANES_BO)) {
+		priv-&gt;can.state = CAN_STATE_BUS_OFF;
+		cf-&gt;can_id |= CAN_ERR_BUSOFF;
+		hecc_set_bit(priv, HECC_CANES, HECC_CANES_BO);
+		hecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);
+		can_bus_off(ndev);
+		/* Disable all interrupts in bus-off to avoid int hog */
+		hecc_write(priv, HECC_CANGIM, 0);
+	}
+
+	if (err_status &amp; HECC_BUS_ERROR) {
+		++priv-&gt;can.can_stats.bus_error;
+		cf-&gt;can_id |= (CAN_ERR_BUSERROR | CAN_ERR_PROT);
+		cf-&gt;data[2] |= CAN_ERR_PROT_UNSPEC;
+		if (err_status &amp; HECC_CANES_FE) {
+			hecc_set_bit(priv, HECC_CANES, HECC_CANES_FE);
+			cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
+		}
+		if (err_status &amp; HECC_CANES_BE) {
+			hecc_set_bit(priv, HECC_CANES, HECC_CANES_BE);
+			cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
+		}
+		if (err_status &amp; HECC_CANES_SE) {
+			hecc_set_bit(priv, HECC_CANES, HECC_CANES_SE);
+			cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
+		}
+		if (err_status &amp; HECC_CANES_CRCE) {
+			hecc_set_bit(priv, HECC_CANES, HECC_CANES_CRCE);
+			cf-&gt;data[2] |= (CAN_ERR_PROT_LOC_CRC_SEQ |
+					CAN_ERR_PROT_LOC_CRC_DEL);
+		}
+		if (err_status &amp; HECC_CANES_ACKE) {
+			hecc_set_bit(priv, HECC_CANES, HECC_CANES_ACKE);
+			cf-&gt;data[2] |= (CAN_ERR_PROT_LOC_ACK |
+					CAN_ERR_PROT_LOC_ACK_DEL);
+		}
+	}
+
+	netif_receive_skb(skb);
+	ndev-&gt;last_rx = jiffies;
+	stats-&gt;rx_packets++;
+	stats-&gt;rx_bytes += cf-&gt;can_dlc;
+	return 0;
+}
+
+
+/**
+ * ti_hecc_interrupt: TI HECC interrupt routine
+ *
+ * Handles HECC interrupts - disables interrupt if receive pkts that will
+ * be enabled when rx pkts are complete (napi_complete is done)
+ */
+static irqreturn_t ti_hecc_interrupt(int irq, void *dev_id)
+{
+	struct net_device *ndev = (struct net_device *)dev_id;
+	struct ti_hecc_priv *priv = netdev_priv(ndev);
+	struct net_device_stats *stats = &amp;ndev-&gt;stats;
+	u32 mbxno, int_status, err_status;
+	unsigned long flags, ack, canta_ack;
+
+	if (priv-&gt;int_line)
+		int_status = hecc_read(priv, HECC_CANGIF1);
+	else
+		int_status = hecc_read(priv, HECC_CANGIF0);
+
+	if (0 == int_status)
+		return IRQ_NONE;
+
+	err_status = hecc_read(priv, HECC_CANES);
+	if (err_status &amp; (HECC_BUS_ERROR | HECC_CANES_BO |
+		HECC_CANES_EP | HECC_CANES_EW))
+			ti_hecc_error(ndev, int_status, err_status);
+
+	/* Handle mailbox interrupt */
+	if (int_status &amp; HECC_CANGIF_GMIF) {
+		canta_ack = ack = hecc_read(priv, HECC_CANTA);
+		while (ack) {
+			mbxno = find_first_bit(&amp;ack, HECC_MAX_MAILBOXES);
+			if (mbxno == HECC_MAX_MAILBOXES) {
+				break;
+			} else {
+				clear_bit(mbxno, &amp;ack);
+				hecc_clear_bit(priv, HECC_CANME, (1 &lt;&lt; mbxno));
+				hecc_clear_bit(priv, HECC_CANMIM, (1 &lt;&lt; mbxno));
+				stats-&gt;tx_bytes =
+					(hecc_read(priv, HECC_CANMCF(mbxno)) &amp;
+					0xF);
+				can_get_echo_skb(ndev, mbxno);
+				spin_lock_irqsave(&amp;priv-&gt;tx_lock, flags);
+				clear_bit(mbxno, priv-&gt;tx_free_mbx);
+				spin_unlock_irqrestore(&amp;priv-&gt;tx_lock, flags);
+				stats-&gt;tx_packets++;
+			}
+		}
+		hecc_write(priv, HECC_CANTA, canta_ack);
+		if (priv-&gt;stop_xmit) {
+			ack = hecc_read(priv, HECC_CANME);
+			if ((ack &amp; ((1 &lt;&lt; TI_HECC_MAX_TX_MBOX) - 1)) == 0)
+				if (netif_queue_stopped(ndev)) {
+					priv-&gt;stop_xmit = 0;
+					netif_wake_queue(ndev);
+				}
+		} else {
+			spin_lock_irqsave(&amp;priv-&gt;tx_lock, flags);
+			if (!test_bit(priv-&gt;tx_mbxno, priv-&gt;tx_free_mbx))
+				if (netif_queue_stopped(ndev))
+					netif_wake_queue(ndev);
+			spin_unlock_irqrestore(&amp;priv-&gt;tx_lock, flags);
+		}
+
+		/* Disable RX mailbox interrupts and let NAPI reenable them */
+		if (hecc_read(priv, HECC_CANRMP)) {
+			ack = hecc_read(priv, HECC_CANMIM);
+			ack &amp;= ((1 &lt;&lt; TI_HECC_MAX_TX_MBOX) - 1);
+			hecc_write(priv, HECC_CANMIM, ack);
+			napi_schedule(&amp;priv-&gt;napi);
+		}
+	}
+
+	/* clear all interrupt conditions - read back to avoid spurious ints */
+	if (priv-&gt;int_line) {
+		hecc_write(priv, HECC_CANGIF1, HECC_SET_REG);
+		int_status = hecc_read(priv, HECC_CANGIF1);
+	} else {
+		hecc_write(priv, HECC_CANGIF0, HECC_SET_REG);
+		int_status = hecc_read(priv, HECC_CANGIF0);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int ti_hecc_open(struct net_device *ndev)
+{
+	struct ti_hecc_priv *priv = netdev_priv(ndev);
+	int err;
+
+	err = request_irq(ndev-&gt;irq, ti_hecc_interrupt, IRQF_DISABLED,
+				ndev-&gt;name, ndev);
+	if (err) {
+		dev_err(ndev-&gt;dev.parent, &quot;error requesting interrupt\n&quot;);
+		return err;
+	}
+
+	/* Open common can device */
+	err = open_candev(ndev);
+	if (err) {
+		dev_err(ndev-&gt;dev.parent, &quot;open_candev() failed %08X\n&quot;, err);
+		free_irq(ndev-&gt;irq, ndev);
+		return err;
+	}
+
+	/* Initialize device and start net queue */
+	spin_lock_init(&amp;priv-&gt;tx_lock);
+
+	clk_enable(priv-&gt;clk);
+	ti_hecc_start(ndev);
+	napi_enable(&amp;priv-&gt;napi);
+	netif_start_queue(ndev);
+
+	dev_info(ndev-&gt;dev.parent, &quot;device open\n&quot;);
+	return 0;
+}
+
+static int ti_hecc_close(struct net_device *ndev)
+{
+	struct ti_hecc_priv *priv = netdev_priv(ndev);
+
+	netif_stop_queue(ndev);
+	napi_disable(&amp;priv-&gt;napi);
+	ti_hecc_stop(ndev);
+	free_irq(ndev-&gt;irq, ndev);
+	clk_disable(priv-&gt;clk);
+	close_candev(ndev);
+	dev_info(ndev-&gt;dev.parent, &quot;device stopped\n&quot;);
+
+	return 0;
+}
+
+static const struct net_device_ops ti_hecc_netdev_ops = {
+	.ndo_open		= ti_hecc_open,
+	.ndo_stop		= ti_hecc_close,
+	.ndo_start_xmit		= ti_hecc_xmit,
+};
+
+static int ti_hecc_probe(struct platform_device *pdev)
+{
+	struct net_device *ndev = (struct net_device *)0;
+	struct ti_hecc_priv *priv;
+	struct ti_hecc_platform_data *pdata;
+	struct resource *mem, *irq;
+	void __iomem *addr;
+	int err;
+
+	dev_dbg(&amp;pdev-&gt;dev, &quot; probing devices...\n&quot;);
+	pdata = pdev-&gt;dev.platform_data;
+	if (!pdata) {
+		dev_err(&amp;pdev-&gt;dev, &quot;No platform data - exiting\n&quot;);
+		return -ENODEV;
+	}
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem) {
+		dev_err(&amp;pdev-&gt;dev, &quot;no mem resources???\n&quot;);
+		err = -ENODEV;
+		goto probe_exit;
+	}
+	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!irq) {
+		dev_err(&amp;pdev-&gt;dev, &quot;no irq resourc???\n&quot;);
+		err = -ENODEV;
+		goto probe_exit;
+	}
+	if (!request_mem_region(mem-&gt;start, resource_size(mem), pdev-&gt;name)) {
+		dev_err(&amp;pdev-&gt;dev, &quot;HECC region already claimed\n&quot;);
+		err = -EBUSY;
+		goto probe_exit;
+	}
+	addr = ioremap(mem-&gt;start, resource_size(mem));
+	if (!addr) {
+		dev_err(&amp;pdev-&gt;dev, &quot;ioremap failed\n&quot;);
+		err = -ENOMEM;
+		goto probe_exit_free_region;
+	}
+
+	ndev = alloc_candev(sizeof(struct ti_hecc_priv));
+	if (!ndev) {
+		dev_err(&amp;pdev-&gt;dev, &quot;alloc_candev failed\n&quot;);
+		err = -ENOMEM;
+		goto probe_exit_iounmap;
+	}
+
+	priv = netdev_priv(ndev);
+	priv-&gt;ndev = ndev;
+	priv-&gt;base = addr;
+	priv-&gt;scc_ram_offset = pdata-&gt;scc_ram_offset;
+	priv-&gt;hecc_ram_offset = pdata-&gt;hecc_ram_offset;
+	priv-&gt;mbox_offset = pdata-&gt;mbox_offset;
+	priv-&gt;int_line = pdata-&gt;int_line;
+
+	priv-&gt;can.bittiming_const = &amp;ti_hecc_bittiming_const;
+	priv-&gt;can.do_set_bittiming = ti_hecc_set_bittiming;
+	priv-&gt;can.do_set_mode = ti_hecc_do_set_mode;
+	priv-&gt;can.do_get_state = ti_hecc_get_state;
+
+	ndev-&gt;irq = irq-&gt;start;
+	ndev-&gt;flags |= IFF_ECHO;
+	platform_set_drvdata(pdev, ndev);
+	SET_NETDEV_DEV(ndev, &amp;pdev-&gt;dev);
+	ndev-&gt;netdev_ops = &amp;ti_hecc_netdev_ops;
+
+	/* Note: clk name would change using hecc_vbusp_ck temporarily */
+	priv-&gt;clk = clk_get(&amp;pdev-&gt;dev, &quot;hecc_vbusp_ck&quot;);
+	if (IS_ERR(priv-&gt;clk)) {
+		dev_err(&amp;pdev-&gt;dev, &quot;no clock available\n&quot;);
+		err = PTR_ERR(priv-&gt;clk);
+		priv-&gt;clk = NULL;
+		goto probe_exit_candev;
+	}
+	priv-&gt;can.clock.freq = clk_get_rate(priv-&gt;clk);
+	netif_napi_add(ndev, &amp;priv-&gt;napi, ti_hecc_rx_poll,
+			TI_HECC_DEF_NAPI_WEIGHT);
+
+	err = register_candev(ndev);
+	if (err) {
+		dev_err(&amp;pdev-&gt;dev, &quot;register_candev() failed\n&quot;);
+		err = -ENODEV;
+		goto probe_exit_clk;
+	}
+	dev_info(&amp;pdev-&gt;dev, &quot;device registered (reg_base=%p, irq=%u)\n&quot;,
+		priv-&gt;base, (u32) ndev-&gt;irq);
+
+	return 0;
+
+probe_exit_clk:
+	clk_put(priv-&gt;clk);
+probe_exit_candev:
+	free_candev(ndev);
+probe_exit_iounmap:
+	iounmap(addr);
+probe_exit_free_region:
+	release_mem_region(mem-&gt;start, resource_size(mem));
+probe_exit:
+	dev_err(ndev-&gt;dev.parent, &quot;probe error = %08X\n&quot;, err);
+	return err;
+}
+
+static int __devexit ti_hecc_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct ti_hecc_priv *priv = netdev_priv(ndev);
+
+	clk_put(priv-&gt;clk);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	iounmap(priv-&gt;base);
+	release_mem_region(res-&gt;start, resource_size(res));
+	unregister_candev(ndev);
+	free_candev(ndev);
+	platform_set_drvdata(pdev, NULL);
+	dev_info(ndev-&gt;dev.parent, &quot;driver removed\n&quot;);
+
+	return 0;
+}
+
+/* TI HECC netdevice driver: platform driver structure */
+static struct platform_driver ti_hecc_driver = {
+	.driver = {
+		.name    = DRV_NAME,
+		.owner   = THIS_MODULE,
+	},
+	.probe = ti_hecc_probe,
+	.remove = __devexit_p(ti_hecc_remove),
+};
+
+static int __init ti_hecc_init_driver(void)
+{
+	printk(KERN_INFO DRV_DESC &quot;\n&quot;);
+	return platform_driver_register(&amp;ti_hecc_driver);
+}
+module_init(ti_hecc_init_driver);
+
+static void __exit ti_hecc_exit_driver(void)
+{
+	printk(KERN_INFO DRV_DESC &quot; :Exit\n&quot;);
+	platform_driver_unregister(&amp;ti_hecc_driver);
+}
+module_exit(ti_hecc_exit_driver);
+
+MODULE_AUTHOR(&quot;Anant Gole &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">anantgole at ti.com</A>&gt;&quot;);
+MODULE_LICENSE(&quot;GPL v2&quot;);
+MODULE_DESCRIPTION(DRV_DESC);
diff --git a/include/linux/can/platform/ti_hecc.h b/include/linux/can/platform/ti_hecc.h
new file mode 100644
index 0000000..9164c67
--- /dev/null
+++ b/include/linux/can/platform/ti_hecc.h
@@ -0,0 +1,40 @@
+/*
+ * TI HECC (High End CAN Controller) driver platform header
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated - <A HREF="http://www.ti.com/">http://www.ti.com/</A>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed as is WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/**
+ * struct hecc_platform_data - HECC Platform Data
+ *
+ * @scc_hecc_offset:	mostly 0 - should really never change
+ * @scc_ram_offset:	SCC RAM offset
+ * @hecc_ram_offset:	HECC RAM offset
+ * @mbox_offset:	Mailbox RAM offset
+ * @int_line:		Interrupt line to use - 0 or 1
+ * @version:		version for future use
+ *
+ * Platform data structure to get all platform specific settings.
+ * this structure also accounts the fact that the IP may have different
+ * RAM and mailbox offsets for different SOC's
+ */
+struct ti_hecc_platform_data {
+	u32 scc_hecc_offset;
+	u32 scc_ram_offset;
+	u32 hecc_ram_offset;
+	u32 mbox_offset;
+	u32 int_line;
+	u32 version;
+};
+
+
-- 
1.6.2.4


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002963.html">(ATTicket:560142) Re: Comments on at91_can.c
</A></li>
	<LI>Next message: <A HREF="002965.html">[PATCH V2] net-next-2.6:can: add TI CAN (HECC) driver
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2964">[ date ]</a>
              <a href="thread.html#2964">[ thread ]</a>
              <a href="subject.html#2964">[ subject ]</a>
              <a href="author.html#2964">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
