<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH v3] ems_usb: CAN/USB driver for EMS CPC-USB/ARM7 CAN	interfaces
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20v3%5D%20ems_usb%3A%20CAN/USB%20driver%20for%20EMS%20CPC-USB/ARM7%20CAN%0A%09interfaces&In-Reply-To=%3C4AA8B309.2020602%40grandegger.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003029.html">
   <LINK REL="Next"  HREF="003037.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH v3] ems_usb: CAN/USB driver for EMS CPC-USB/ARM7 CAN	interfaces</H1>
    <B>Wolfgang Grandegger</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20v3%5D%20ems_usb%3A%20CAN/USB%20driver%20for%20EMS%20CPC-USB/ARM7%20CAN%0A%09interfaces&In-Reply-To=%3C4AA8B309.2020602%40grandegger.com%3E"
       TITLE="[PATCH v3] ems_usb: CAN/USB driver for EMS CPC-USB/ARM7 CAN	interfaces">wg at grandegger.com
       </A><BR>
    <I>Thu Sep 10 10:04:25 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003029.html">[PATCH v3] ems_usb: CAN/USB driver for EMS CPC-USB/ARM7 CAN interfaces
</A></li>
        <LI>Next message: <A HREF="003037.html">[PATCH v3] ems_usb: CAN/USB driver for EMS CPC-USB/ARM7 CAN	interfaces
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3034">[ date ]</a>
              <a href="thread.html#3034">[ thread ]</a>
              <a href="subject.html#3034">[ subject ]</a>
              <a href="author.html#3034">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Sebastian,

I still have the problems with the &quot;DOS endings&quot;. After a &quot;dos2unix&quot; on 
the extracted patch, checkpatch.pl is happy. Could someone else please 
check if this is *my* private problem (I replaced my laptop recently). 
The white-space issues are gone and coding style now locks (almost) 
good. There are still a few issues, though.

On 09/09/2009 06:19 PM, Sebastian Haas wrote:
&gt;<i> This patch adds support for the CAN/USB interface CPC-USB/ARM7 from EMS
</I>&gt;<i> Dr. Thomas Wuensche.
</I>&gt;<i>
</I>&gt;<i> Signed-off-by: Sebastian Haas&lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">haas at ems-wuensche.com</A>&gt;
</I>&gt;<i>
</I>&gt;<i>   Makefile                    |    1
</I>&gt;<i>   drivers/net/can/Kconfig     |    7
</I>&gt;<i>   drivers/net/can/Makefile    |    1
</I>&gt;<i>   drivers/net/can/ems_usb.c   | 1152 ++++++++++++++++++++++++++++++++++++++++++++
</I>&gt;<i>   include/linux/can/dev.h     |    2
</I>&gt;<i>   include/socketcan/can/dev.h |    2
</I>&gt;<i>   6 files changed, 1163 insertions(+), 2 deletions(-)
</I>&gt;<i>
</I>&gt;<i> Index: include/linux/can/dev.h
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- include/linux/can/dev.h	(Revision 1048)
</I>&gt;<i> +++ include/linux/can/dev.h	(Arbeitskopie)
</I>&gt;<i> @@ -32,7 +32,7 @@
</I>&gt;<i>   /*
</I>&gt;<i>    * CAN common private data
</I>&gt;<i>    */
</I>&gt;<i> -#define CAN_ECHO_SKB_MAX  4
</I>&gt;<i> +#define CAN_ECHO_SKB_MAX  10
</I>
Hm, this affects all drivers. What is the benefit for the EMS UBS device 
increasing this value?

&gt;<i>   struct can_priv {
</I>&gt;<i>   #if LINUX_VERSION_CODE&lt;  KERNEL_VERSION(2,6,23)
</I>&gt;<i> Index: include/socketcan/can/dev.h
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- include/socketcan/can/dev.h	(Revision 1048)
</I>&gt;<i> +++ include/socketcan/can/dev.h	(Arbeitskopie)
</I>&gt;<i> @@ -32,7 +32,7 @@
</I>&gt;<i>   /*
</I>&gt;<i>    * CAN common private data
</I>&gt;<i>    */
</I>&gt;<i> -#define CAN_ECHO_SKB_MAX  4
</I>&gt;<i> +#define CAN_ECHO_SKB_MAX  10
</I>&gt;<i>
</I>&gt;<i>   struct can_priv {
</I>&gt;<i>   #if LINUX_VERSION_CODE&lt;  KERNEL_VERSION(2,6,23)
</I>&gt;<i> Index: Makefile
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- Makefile	(Revision 1048)
</I>&gt;<i> +++ Makefile	(Arbeitskopie)
</I>&gt;<i> @@ -19,6 +19,7 @@
</I>&gt;<i>   export CONFIG_CAN_PEAK_PCI=m
</I>&gt;<i>   export CONFIG_CAN_KVASER_PCI=m
</I>&gt;<i>   export CONFIG_CAN_EMS_PCI=m
</I>&gt;<i> +export CONFIG_CAN_EMS_USB=m
</I>&gt;<i>   export CONFIG_CAN_EMS_PCMCIA=m
</I>&gt;<i>   export CONFIG_CAN_EMS_104M=m
</I>&gt;<i>   export CONFIG_CAN_ESD_PCI=m
</I>&gt;<i> Index: drivers/net/can/Kconfig
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- drivers/net/can/Kconfig	(Revision 1048)
</I>&gt;<i> +++ drivers/net/can/Kconfig	(Arbeitskopie)
</I>&gt;<i> @@ -127,6 +127,13 @@
</I>&gt;<i>   	  OpenFirmware bindings, e.g. if you have a PowerPC based system
</I>&gt;<i>   	  you may want to enable this option.
</I>&gt;<i>
</I>&gt;<i> +config CAN_EMS_USB
</I>&gt;<i> +	tristate &quot;EMS CPC-USB/ARM7&quot;
</I>&gt;<i> +	depends on USB&amp;&amp;  CAN_DEV
</I>&gt;<i> +	---help---
</I>&gt;<i> +	  This driver is for the one channel CAN/USB interface CPC-USB
</I>&gt;<i> +	  from EMS Dr. Thomas Wuensche (<A HREF="http://www.ems-wuensche.com">http://www.ems-wuensche.com</A>).
</I>&gt;<i> +
</I>&gt;<i>   config CAN_EMS_PCI
</I>&gt;<i>   	tristate &quot;EMS CPC-PCI, CPC-PCIe and CPC-104P Card&quot;
</I>&gt;<i>   	depends on PCI&amp;&amp;  CAN_SJA1000
</I>&gt;<i> Index: drivers/net/can/Makefile
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- drivers/net/can/Makefile	(Revision 1048)
</I>&gt;<i> +++ drivers/net/can/Makefile	(Arbeitskopie)
</I>&gt;<i> @@ -49,6 +49,7 @@
</I>&gt;<i>   obj-$(CONFIG_CAN_MSCAN_OLD)	+= old/mscan/
</I>&gt;<i>   obj-$(CONFIG_CAN_CCAN_OLD)	+= old/ccan/
</I>&gt;<i>   obj-$(CONFIG_CAN_MCP251X)	+= mcp251x.o
</I>&gt;<i> +obj-$(CONFIG_CAN_EMS_USB)	+= ems_usb.o
</I>&gt;<i>
</I>&gt;<i>   ifeq ($(CONFIG_CAN_DEBUG_DEVICES),y)
</I>&gt;<i>   	EXTRA_CFLAGS += -DDEBUG
</I>&gt;<i> Index: drivers/net/can/ems_usb.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- drivers/net/can/ems_usb.c	(Revision 0)
</I>&gt;<i> +++ drivers/net/can/ems_usb.c	(Revision 0)
</I>&gt;<i> @@ -0,0 +1,1152 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * CAN driver for EMS Dr. Thomas Wuensche CPC-USB/ARM7
</I>&gt;<i> + *
</I>&gt;<i> + * Copyright (C) 2004-2009 EMS Dr. Thomas Wuensche
</I>&gt;<i> + *
</I>&gt;<i> + * This program is free software; you can redistribute it and/or modify it
</I>&gt;<i> + * under the terms of the GNU General Public License as published
</I>&gt;<i> + * by the Free Software Foundation; version 2 of the License.
</I>&gt;<i> + *
</I>&gt;<i> + * This program is distributed in the hope that it will be useful, but
</I>&gt;<i> + * WITHOUT ANY WARRANTY; without even the implied warranty of
</I>&gt;<i> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
</I>&gt;<i> + * General Public License for more details.
</I>&gt;<i> + *
</I>&gt;<i> + * You should have received a copy of the GNU General Public License along
</I>&gt;<i> + * with this program; if not, write to the Free Software Foundation, Inc.,
</I>&gt;<i> + * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
</I>&gt;<i> + */
</I>&gt;<i> +#include&lt;linux/init.h&gt;
</I>&gt;<i> +#include&lt;linux/signal.h&gt;
</I>&gt;<i> +#include&lt;linux/slab.h&gt;
</I>&gt;<i> +#include&lt;linux/module.h&gt;
</I>&gt;<i> +#include&lt;linux/netdevice.h&gt;
</I>&gt;<i> +#include&lt;linux/usb.h&gt;
</I>&gt;<i> +#include&lt;asm/uaccess.h&gt;
</I>
Hm, do you really need uaccess.h?

&gt;<i> +#include&lt;socketcan/can.h&gt;
</I>&gt;<i> +#include&lt;socketcan/can/dev.h&gt;
</I>&gt;<i> +#include&lt;socketcan/can/error.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +MODULE_AUTHOR(&quot;Sebastian Haas&lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">haas at ems-wuensche.com</A>&gt;&quot;);
</I>&gt;<i> +MODULE_DESCRIPTION(&quot;CAN driver for EMS Dr. Thomas Wuensche CAN/USB interfaces&quot;);
</I>&gt;<i> +MODULE_LICENSE(&quot;GPL v2&quot;);
</I>&gt;<i> +
</I>&gt;<i> +/* Control-Values for CPC_Control() Command Subject Selection */
</I>&gt;<i> +#define CONTR_CAN_MESSAGE 0x04
</I>&gt;<i> +#define CONTR_CAN_STATE   0x0C
</I>&gt;<i> +#define CONTR_BUS_ERROR   0x1C
</I>&gt;<i> +
</I>&gt;<i> +/* Control Command Actions */
</I>&gt;<i> +#define CONTR_CONT_OFF 0
</I>&gt;<i> +#define CONTR_CONT_ON  1
</I>&gt;<i> +#define CONTR_SING_ON  2
</I>
Just for curiosity. What does &quot;SING&quot; stand for?

&gt;<i> +/* Messages from CPC to PC */
</I>&gt;<i> +#define CPC_MSG_TYPE_CAN_FRAME       1  /* CAN data frame */
</I>&gt;<i> +#define CPC_MSG_TYPE_RTR_FRAME       8  /* CAN remote frame */
</I>&gt;<i> +#define CPC_MSG_TYPE_CAN_FRAME_PRMS  12 /* Actual CAN parameters */
</I>
Typo? s/CAN_FRAME_PRMS/CAN_PARAMS/ ?

&gt;<i> +#define CPC_MSG_TYPE_CAN_STATE       14 /* CAN state message */
</I>&gt;<i> +#define CPC_MSG_TYPE_EXT_CAN_FRAME   16 /* Extended CAN data frame */
</I>&gt;<i> +#define CPC_MSG_TYPE_EXT_RTR_FRAME   17 /* Extended remote frame */
</I>&gt;<i> +#define CPC_MSG_TYPE_CONTROL         19 /* change interface behavior */
</I>&gt;<i> +#define CPC_MSG_TYPE_CONFIRM         20 /* command processed confirmation */
</I>&gt;<i> +#define CPC_MSG_TYPE_OVERRUN         21 /* overrun events */
</I>&gt;<i> +#define CPC_MSG_TYPE_CAN_FRAME_ERROR 23 /* detected bus errors */
</I>&gt;<i> +#define CPC_MSG_TYPE_ERR_COUNTER     25 /* RX/TX error counter */
</I>&gt;<i> +
</I>&gt;<i> +/* Messages from the PC to the CPC interface  */
</I>&gt;<i> +#define CPC_CMD_TYPE_CAN_FRAME     1   /* CAN data frame */
</I>&gt;<i> +#define CPC_CMD_TYPE_CONTROL       3   /* control of interface behavior */
</I>&gt;<i> +#define CPC_CMD_TYPE_CAN_PARAMS    6   /* set CAN parameters */
</I>&gt;<i> +#define CPC_CMD_TYPE_RTR_FRAME     13  /* CAN remote frame */
</I>&gt;<i> +#define CPC_CMD_TYPE_CAN_STATE     14  /* CAN state message */
</I>&gt;<i> +#define CPC_CMD_TYPE_EXT_CAN_FRAME 15  /* Extended CAN data frame */
</I>&gt;<i> +#define CPC_CMD_TYPE_EXT_RTR_FRAME 16  /* Extended CAN remote frame */
</I>&gt;<i> +#define CPC_CMD_TYPE_CAN_EXIT      200 /* exit the CAN */
</I>&gt;<i> +
</I>&gt;<i> +#define CPC_CMD_TYPE_INQ_ERR_COUNTER 25 /* request the CAN error counters */
</I>&gt;<i> +#define CPC_CMD_TYPE_CLEAR_MSG_QUEUE 8  /* clear CPC_MSG queue */
</I>&gt;<i> +#define CPC_CMD_TYPE_CLEAR_CMD_QUEUE 28 /* clear CPC_CMD queue */
</I>&gt;<i> +
</I>&gt;<i> +#define CPC_CC_TYPE_SJA1000 2 /* Philips basic CAN controller */
</I>&gt;<i> +
</I>&gt;<i> +#define CPC_CAN_ECODE_ERRFRAME 0x01 /* Ecode type */
</I>&gt;<i> +
</I>&gt;<i> +/* Overrun types */
</I>&gt;<i> +#define CPC_OVR_EVENT_CAN       0x01
</I>&gt;<i> +#define CPC_OVR_EVENT_CANSTATE  0x02
</I>&gt;<i> +#define CPC_OVR_EVENT_BUSERROR  0x04
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * If the CAN controller lost a message we indicate it with the highest bit
</I>&gt;<i> + * set in the count field.
</I>&gt;<i> + */
</I>&gt;<i> +#define CPC_OVR_HW 0x80
</I>&gt;<i> +
</I>&gt;<i> +/* Size of the &quot;struct ems_cpc_msg&quot; without the union */
</I>&gt;<i> +#define CPC_MSG_HEADER_LEN   11
</I>&gt;<i> +#define CPC_CAN_MSG_MIN_SIZE 5
</I>&gt;<i> +
</I>&gt;<i> +/* Define these values to match your devices */
</I>&gt;<i> +#define USB_CPCUSB_VENDOR_ID	0x12D6
</I>&gt;<i> +
</I>&gt;<i> +#define USB_CPCUSB_M16C_PRODUCT_ID 0x0888
</I>
Please remove because it's not yet used. OK for SVN.

&gt;<i> +#define USB_CPCUSB_ARM7_PRODUCT_ID 0x0444
</I>&gt;<i> +
</I>&gt;<i> +/* Mode register NXP LPC2119/SJA1000 CAN Controller */
</I>&gt;<i> +#define SJA1000_MOD_NORMAL 0x00
</I>&gt;<i> +#define SJA1000_MOD_RM     0x01
</I>&gt;<i> +
</I>&gt;<i> +/* ECC register NXP LPC2119/SJA1000 CAN Controller */
</I>&gt;<i> +#define SJA1000_ECC_SEG   0x1F
</I>&gt;<i> +#define SJA1000_ECC_DIR   0x20
</I>&gt;<i> +#define SJA1000_ECC_ERR   0x06
</I>&gt;<i> +#define SJA1000_ECC_BIT   0x00
</I>&gt;<i> +#define SJA1000_ECC_FORM  0x40
</I>&gt;<i> +#define SJA1000_ECC_STUFF 0x80
</I>&gt;<i> +#define SJA1000_ECC_MASK  0xc0
</I>&gt;<i> +
</I>&gt;<i> +/* Status register content */
</I>&gt;<i> +#define SJA1000_SR_BS 0x80
</I>&gt;<i> +#define SJA1000_SR_ES 0x40
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * CAN-Message representation in a CPC_MSG. Message object type is
</I>&gt;<i> + * CPC_MSG_TYPE_CAN_FRAME or CPC_MSG_TYPE_RTR_FRAME or
</I>&gt;<i> + * CPC_MSG_TYPE_EXT_CAN_FRAME or CPC_MSG_TYPE_EXT_RTR_FRAME.
</I>&gt;<i> + */
</I>&gt;<i> +struct cpc_can_msg {
</I>&gt;<i> +	u32 id;
</I>&gt;<i> +	u8 length;
</I>&gt;<i> +	u8 msg[8];
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/* Representation of the CAN parameters for the SJA1000 controller */
</I>&gt;<i> +struct cpc_sja1000_params {
</I>&gt;<i> +	u8 mode;
</I>&gt;<i> +	u8 acc_code0;
</I>&gt;<i> +	u8 acc_code1;
</I>&gt;<i> +	u8 acc_code2;
</I>&gt;<i> +	u8 acc_code3;
</I>&gt;<i> +	u8 acc_mask0;
</I>&gt;<i> +	u8 acc_mask1;
</I>&gt;<i> +	u8 acc_mask2;
</I>&gt;<i> +	u8 acc_mask3;
</I>&gt;<i> +	u8 btr0;
</I>&gt;<i> +	u8 btr1;
</I>&gt;<i> +	u8 outp_contr;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * Representation of the CAN parameters for the M16C controller in basic CAN
</I>&gt;<i> + * mode (means no full CAN)
</I>&gt;<i> + */
</I>&gt;<i> +struct cpc_m16c_basic_params {
</I>&gt;<i> +	u8 con0;
</I>&gt;<i> +	u8 con1;
</I>&gt;<i> +	u8 ctlr0;
</I>&gt;<i> +	u8 ctlr1;
</I>&gt;<i> +	u8 clk;
</I>&gt;<i> +	u8 acc_std_code0;
</I>&gt;<i> +	u8 acc_std_code1;
</I>&gt;<i> +	u8 acc_ext_code0;
</I>&gt;<i> +	u8 acc_ext_code1;
</I>&gt;<i> +	u8 acc_ext_code2;
</I>&gt;<i> +	u8 acc_ext_code3;
</I>&gt;<i> +	u8 acc_std_mask0;
</I>&gt;<i> +	u8 acc_std_mask1;
</I>&gt;<i> +	u8 acc_ext_mask0;
</I>&gt;<i> +	u8 acc_ext_mask1;
</I>&gt;<i> +	u8 acc_ext_mask2;
</I>&gt;<i> +	u8 acc_ext_mask3;
</I>&gt;<i> +};
</I>
Please remove as long as it's not used. OK for SVN.

&gt;<i> +/* CAN params message representation */
</I>&gt;<i> +struct cpc_can_params {
</I>&gt;<i> +	u8 cc_type;
</I>&gt;<i> +	union {
</I>&gt;<i> +		struct cpc_m16c_basic_params m16c_basic;
</I>
Please remove for the time being and add some comments why you use a 
union here. OK for SVN.

&gt;<i> +		struct cpc_sja1000_params sja1000;
</I>&gt;<i> +	} cc_params;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/* Structure for confirmed message handling */
</I>&gt;<i> +struct cpc_confirm {
</I>&gt;<i> +	u8 error; /* error code */
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/* Structure for overrun conditions */
</I>&gt;<i> +struct cpc_overrun {
</I>&gt;<i> +	u8 event;
</I>&gt;<i> +	u8 count;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/* SJA1000 CAN errors (compatible to NXP LPC2119) */
</I>&gt;<i> +struct cpc_sja1000_can_error {
</I>&gt;<i> +	u8 ecc;
</I>&gt;<i> +	u8 rxerr;
</I>&gt;<i> +	u8 txerr;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/* structure for CAN error conditions */
</I>&gt;<i> +struct cpc_can_error {
</I>&gt;<i> +	u8 ecode;
</I>&gt;<i> +	struct {
</I>&gt;<i> +		u8 cc_type;
</I>&gt;<i> +
</I>&gt;<i> +		union {
</I>&gt;<i> +			struct cpc_sja1000_can_error sja1000;
</I>&gt;<i> +		} regs;
</I>
Please describe why you use a union here.

&gt;<i> +	} cc;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * Structure containing RX/TX error counter. This structure is used to request
</I>&gt;<i> + * the values of the CAN controllers TX and RX error counter.
</I>&gt;<i> + */
</I>&gt;<i> +struct cpc_can_err_counter {
</I>&gt;<i> +	u8 rx;
</I>&gt;<i> +	u8 tx;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/* Main message type used between library and application */
</I>&gt;<i> +struct __attribute__ ((packed)) ems_cpc_msg {
</I>&gt;<i> +	u8 type; /* type of message */
</I>&gt;<i> +	u8 length; /* length of data within union 'msg' */
</I>&gt;<i> +	u8 msgid; /* confirmation handle */
</I>&gt;<i> +	u32 ts_sec; /* timestamp in seconds */
</I>&gt;<i> +	u32 ts_nsec; /* timestamp in nano seconds */
</I>
Comments are usually aligned.

&gt;<i> +
</I>&gt;<i> +	union {
</I>&gt;<i> +		u8 generic[64];
</I>&gt;<i> +		struct cpc_can_msg can_msg;
</I>&gt;<i> +		struct cpc_can_params can_params;
</I>&gt;<i> +		struct cpc_confirm confirmation;
</I>&gt;<i> +		struct cpc_overrun overrun;
</I>&gt;<i> +		struct cpc_can_error error;
</I>&gt;<i> +		struct cpc_can_err_counter err_counter;
</I>&gt;<i> +		u8 can_state;
</I>&gt;<i> +	} msg;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * Table of devices that work with this driver
</I>&gt;<i> + * NOTE: This driver supports only CPC-USB/ARM7 (LPC2119) yet.
</I>&gt;<i> + */
</I>&gt;<i> +static struct usb_device_id ems_usb_table[] = {
</I>&gt;<i> +	{USB_DEVICE(USB_CPCUSB_VENDOR_ID, USB_CPCUSB_ARM7_PRODUCT_ID)},
</I>&gt;<i> +	{} /* Terminating entry */
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +MODULE_DEVICE_TABLE(usb, ems_usb_table);
</I>&gt;<i> +
</I>&gt;<i> +#define RX_BUFFER_SIZE  64
</I>&gt;<i> +#define CPC_HEADER_SIZE 4
</I>&gt;<i> +
</I>&gt;<i> +#define MAX_RX_URBS 10
</I>&gt;<i> +#define MAX_TX_URBS CAN_ECHO_SKB_MAX
</I>&gt;<i> +
</I>&gt;<i> +struct ems_usb;
</I>&gt;<i> +
</I>&gt;<i> +struct ems_tx_urb_context {
</I>&gt;<i> +	struct ems_usb *dev;
</I>&gt;<i> +
</I>&gt;<i> +	u32 echo_index;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct ems_usb {
</I>&gt;<i> +	struct can_priv can; /* must be the first member */
</I>&gt;<i> +	int open_time;
</I>&gt;<i> +
</I>&gt;<i> +	struct sk_buff *echo_skb[MAX_TX_URBS];
</I>&gt;<i> +
</I>&gt;<i> +	struct usb_device *udev;
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +
</I>&gt;<i> +	atomic_t active_tx_urbs;
</I>&gt;<i> +	struct usb_anchor tx_submitted;
</I>&gt;<i> +	struct ems_tx_urb_context tx_contexts[MAX_TX_URBS];
</I>&gt;<i> +
</I>&gt;<i> +	struct usb_anchor rx_submitted;
</I>&gt;<i> +
</I>&gt;<i> +	struct urb *intr_urb;
</I>&gt;<i> +
</I>&gt;<i> +	u8 *tx_msg_buffer;
</I>&gt;<i> +
</I>&gt;<i> +	u8 intr_in_buffer[4];
</I>&gt;<i> +	unsigned int free_slots; /* Remember number of available slots */
</I>&gt;<i> +
</I>&gt;<i> +	struct ems_cpc_msg active_params; /* Active controller parameters */
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static void init_params_sja1000(struct ems_cpc_msg *msg, u8 btr0, u8 btr1,
</I>&gt;<i> +				u8 outp, u8 mod)
</I>&gt;<i> +{
</I>&gt;<i> +	struct cpc_sja1000_params *sja1000 =
</I>&gt;<i> +	&amp;msg-&gt;msg.can_params.cc_params.sja1000;
</I>
Use tabs for indention, please?

&gt;<i> +	msg-&gt;type = CPC_CMD_TYPE_CAN_PARAMS;
</I>&gt;<i> +	msg-&gt;length = sizeof(struct cpc_can_params);
</I>&gt;<i> +	msg-&gt;msgid = 0;
</I>&gt;<i> +
</I>&gt;<i> +	msg-&gt;msg.can_params.cc_type = CPC_CC_TYPE_SJA1000;
</I>&gt;<i> +
</I>&gt;<i> +	/* Acceptance filter open */
</I>&gt;<i> +	sja1000-&gt;acc_code0 = 0x00;
</I>&gt;<i> +	sja1000-&gt;acc_code1 = 0x00;
</I>&gt;<i> +	sja1000-&gt;acc_code2 = 0x00;
</I>&gt;<i> +	sja1000-&gt;acc_code3 = 0x00;
</I>&gt;<i> +
</I>&gt;<i> +	/* Acceptance filter open */
</I>&gt;<i> +	sja1000-&gt;acc_mask0 = 0xFF;
</I>&gt;<i> +	sja1000-&gt;acc_mask1 = 0xFF;
</I>&gt;<i> +	sja1000-&gt;acc_mask2 = 0xFF;
</I>&gt;<i> +	sja1000-&gt;acc_mask3 = 0xFF;
</I>&gt;<i> +
</I>&gt;<i> +	sja1000-&gt;btr0 = btr0;
</I>&gt;<i> +	sja1000-&gt;btr1 = btr1;
</I>&gt;<i> +
</I>&gt;<i> +	sja1000-&gt;outp_contr = outp;
</I>&gt;<i> +	sja1000-&gt;mode = mod;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void ems_usb_read_interrupt_callback(struct urb *urb)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ems_usb *dev = urb-&gt;context;
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	int retval;
</I>
s/retval/err/ ? In a mail to Oliver I explained why.

&gt;<i> +
</I>&gt;<i> +	netdev = dev-&gt;netdev;
</I>&gt;<i> +
</I>&gt;<i> +	if (!netif_device_present(netdev))
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	switch (urb-&gt;status) {
</I>&gt;<i> +	case 0:
</I>&gt;<i> +		dev-&gt;free_slots = dev-&gt;intr_in_buffer[1];
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	case -ECONNRESET: /* unlink */
</I>&gt;<i> +	case -ENOENT:
</I>&gt;<i> +	case -ESHUTDOWN:
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	default:
</I>&gt;<i> +		dev_info(ND2D(netdev), &quot;nonzero urb status %d\n&quot;, urb-&gt;status);
</I>
Is this a normal case. Also the message is not really meaningful. What 
did fail (as below)?

&gt;<i> +		break;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	retval = usb_submit_urb(urb, GFP_ATOMIC);
</I>&gt;<i> +
</I>&gt;<i> +	if (retval == -ENODEV)
</I>&gt;<i> +		netif_device_detach(netdev);
</I>&gt;<i> +	else if (retval)
</I>&gt;<i> +		dev_err(ND2D(netdev), &quot;failed resubmitting intr urb: %d\n&quot;,
</I>&gt;<i> +			retval);
</I>&gt;<i> +
</I>&gt;<i> +	return;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void ems_usb_rx_can_msg(struct ems_usb *dev, struct ems_cpc_msg *msg)
</I>&gt;<i> +{
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	int i;
</I>&gt;<i> +	struct net_device_stats *stats =&amp;dev-&gt;netdev-&gt;stats;
</I>&gt;<i> +
</I>&gt;<i> +	skb = dev_alloc_skb(sizeof(struct can_frame));
</I>&gt;<i> +	if (skb == NULL)
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	skb-&gt;dev = dev-&gt;netdev;
</I>&gt;<i> +	skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;<i> +
</I>&gt;<i> +	cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
</I>&gt;<i> +
</I>&gt;<i> +	cf-&gt;can_id = msg-&gt;msg.can_msg.id;
</I>&gt;<i> +	cf-&gt;can_dlc = clamp_t(u8, msg-&gt;msg.can_msg.length, 0, 8);
</I>
min_t might be more appropriate.

&gt;<i> +
</I>&gt;<i> +	if (msg-&gt;type == CPC_MSG_TYPE_EXT_CAN_FRAME
</I>&gt;<i> +	    || msg-&gt;type == CPC_MSG_TYPE_EXT_RTR_FRAME)
</I>&gt;<i> +		cf-&gt;can_id |= CAN_EFF_FLAG;
</I>&gt;<i> +
</I>&gt;<i> +	if (msg-&gt;type == CPC_MSG_TYPE_RTR_FRAME
</I>&gt;<i> +	    || msg-&gt;type == CPC_MSG_TYPE_EXT_RTR_FRAME) {
</I>&gt;<i> +		cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> +	} else {
</I>&gt;<i> +		for (i = 0; i&lt;  cf-&gt;can_dlc; i++)
</I>&gt;<i> +			cf-&gt;data[i] = msg-&gt;msg.can_msg.msg[i];
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	netif_rx(skb);
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;netdev-&gt;last_rx = jiffies;
</I>&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;<i> +	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void ems_usb_rx_err(struct ems_usb *dev, struct ems_cpc_msg *msg)
</I>&gt;<i> +{
</I>&gt;<i> +	struct can_frame *cf;
</I>&gt;<i> +	struct sk_buff *skb;
</I>&gt;<i> +	struct net_device_stats *stats =&amp;dev-&gt;netdev-&gt;stats;
</I>&gt;<i> +
</I>&gt;<i> +	skb = dev_alloc_skb(sizeof(struct can_frame));
</I>&gt;<i> +	if (skb == NULL)
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	skb-&gt;dev = dev-&gt;netdev;
</I>&gt;<i> +	skb-&gt;protocol = htons(ETH_P_CAN);
</I>&gt;<i> +
</I>&gt;<i> +	cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
</I>&gt;<i> +	memset(cf, 0, sizeof(struct can_frame));
</I>&gt;<i> +
</I>&gt;<i> +	cf-&gt;can_id = CAN_ERR_FLAG;
</I>&gt;<i> +	cf-&gt;can_dlc = CAN_ERR_DLC;
</I>&gt;<i> +
</I>&gt;<i> +	if (msg-&gt;type == CPC_MSG_TYPE_CAN_STATE) {
</I>&gt;<i> +		u8 state = msg-&gt;msg.can_state;
</I>&gt;<i> +
</I>&gt;<i> +		if (state&amp;  SJA1000_SR_BS) {
</I>&gt;<i> +			dev-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> +			cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> +
</I>&gt;<i> +			can_bus_off(dev-&gt;netdev);
</I>&gt;<i> +		} else if (state&amp;  SJA1000_SR_ES) {
</I>&gt;<i> +			dev-&gt;can.state = CAN_STATE_ERROR_WARNING;
</I>&gt;<i> +			dev-&gt;can.can_stats.error_warning++;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			dev-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +			dev-&gt;can.can_stats.error_passive++;
</I>&gt;<i> +		}
</I>&gt;<i> +	} else if (msg-&gt;type == CPC_MSG_TYPE_CAN_FRAME_ERROR) {
</I>&gt;<i> +		u8 ecc = msg-&gt;msg.error.cc.regs.sja1000.ecc;
</I>&gt;<i> +		u8 txerr = msg-&gt;msg.error.cc.regs.sja1000.txerr;
</I>&gt;<i> +		u8 rxerr = msg-&gt;msg.error.cc.regs.sja1000.rxerr;
</I>&gt;<i> +
</I>&gt;<i> +		/* bus error interrupt */
</I>&gt;<i> +		dev-&gt;can.can_stats.bus_error++;
</I>&gt;<i> +		stats-&gt;rx_errors++;
</I>&gt;<i> +
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
</I>&gt;<i> +
</I>&gt;<i> +		switch (ecc&amp;  SJA1000_ECC_MASK) {
</I>&gt;<i> +		case SJA1000_ECC_BIT:
</I>&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_BIT;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case SJA1000_ECC_FORM:
</I>&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case SJA1000_ECC_STUFF:
</I>&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;<i> +			break;
</I>&gt;<i> +		default:
</I>&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_UNSPEC;
</I>&gt;<i> +			cf-&gt;data[3] = ecc&amp;  SJA1000_ECC_SEG;
</I>&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		/* Error occured during transmission? */
</I>&gt;<i> +		if ((ecc&amp;  SJA1000_ECC_DIR) == 0)
</I>&gt;<i> +			cf-&gt;data[2] |= CAN_ERR_PROT_TX;
</I>&gt;<i> +
</I>&gt;<i> +		if (dev-&gt;can.state == CAN_STATE_ERROR_WARNING ||
</I>&gt;<i> +		    dev-&gt;can.state == CAN_STATE_ERROR_PASSIVE) {
</I>&gt;<i> +			cf-&gt;data[1] = (txerr&gt;  rxerr) ?
</I>
I still see this wired space issue. This seem to be a problem on my 
side. If I extract it, it looks good. I need to check. Sorry for the 
confusion.

&gt;<i> +			    CAN_ERR_CRTL_TX_PASSIVE : CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> +		}
</I>&gt;<i> +	} else if (msg-&gt;type == CPC_MSG_TYPE_OVERRUN) {
</I>&gt;<i> +		cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> +		cf-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
</I>&gt;<i> +
</I>&gt;<i> +		stats-&gt;rx_over_errors++;
</I>&gt;<i> +		stats-&gt;rx_errors++;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	netif_rx(skb);
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;netdev-&gt;last_rx = jiffies;
</I>&gt;<i> +	stats-&gt;rx_packets++;
</I>&gt;<i> +	stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * callback for bulk IN urb
</I>&gt;<i> + */
</I>&gt;<i> +static void ems_usb_read_bulk_callback(struct urb *urb)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ems_usb *dev = urb-&gt;context;
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	int retval;
</I>&gt;<i> +
</I>&gt;<i> +	netdev = dev-&gt;netdev;
</I>&gt;<i> +
</I>&gt;<i> +	if (!netif_device_present(netdev))
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	switch (urb-&gt;status) {
</I>&gt;<i> +	case 0: /* success */
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	case -ENOENT:
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	default:
</I>&gt;<i> +		dev_warn(ND2D(netdev), &quot;nonzero URB status %d\n&quot;, urb-&gt;status);
</I>&gt;<i> +		goto resubmit_urb;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (urb-&gt;actual_length&gt;  CPC_HEADER_SIZE) {
</I>&gt;<i> +		struct ems_cpc_msg *msg;
</I>&gt;<i> +		u8 *ibuf = urb-&gt;transfer_buffer;
</I>&gt;<i> +		u8 msg_count, again, start;
</I>&gt;<i> +
</I>&gt;<i> +		msg_count = ibuf[0]&amp;  ~0x80;
</I>&gt;<i> +		again = ibuf[0]&amp;  0x80;
</I>&gt;<i> +
</I>&gt;<i> +		start = CPC_HEADER_SIZE;
</I>&gt;<i> +
</I>&gt;<i> +		while (msg_count) {
</I>&gt;<i> +			msg = (struct ems_cpc_msg *)&amp;ibuf[start];
</I>&gt;<i> +
</I>&gt;<i> +			switch (msg-&gt;type) {
</I>&gt;<i> +			case CPC_MSG_TYPE_CAN_STATE:
</I>&gt;<i> +				/* Process CAN state changes */
</I>&gt;<i> +				ems_usb_rx_err(dev, msg);
</I>&gt;<i> +				break;
</I>&gt;<i> +
</I>&gt;<i> +			case CPC_MSG_TYPE_CAN_FRAME:
</I>&gt;<i> +			case CPC_MSG_TYPE_EXT_CAN_FRAME:
</I>&gt;<i> +			case CPC_MSG_TYPE_RTR_FRAME:
</I>&gt;<i> +			case CPC_MSG_TYPE_EXT_RTR_FRAME:
</I>&gt;<i> +				ems_usb_rx_can_msg(dev, msg);
</I>&gt;<i> +				break;
</I>&gt;<i> +
</I>&gt;<i> +			case CPC_MSG_TYPE_CAN_FRAME_ERROR:
</I>&gt;<i> +				/* Process errorframe */
</I>&gt;<i> +				ems_usb_rx_err(dev, msg);
</I>&gt;<i> +				break;
</I>&gt;<i> +
</I>&gt;<i> +			case CPC_MSG_TYPE_OVERRUN:
</I>&gt;<i> +				/* Message lost while receiving */
</I>&gt;<i> +				ems_usb_rx_err(dev, msg);
</I>&gt;<i> +				break;
</I>&gt;<i> +			}
</I>&gt;<i> +
</I>&gt;<i> +			start += CPC_MSG_HEADER_LEN + msg-&gt;length;
</I>&gt;<i> +			msg_count--;
</I>&gt;<i> +
</I>&gt;<i> +			if (start&gt;  urb-&gt;transfer_buffer_length) {
</I>&gt;<i> +				dev_err(ND2D(netdev), &quot;format error\n&quot;);
</I>&gt;<i> +				break;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +resubmit_urb:
</I>&gt;<i> +	usb_fill_bulk_urb(urb, dev-&gt;udev, usb_rcvbulkpipe(dev-&gt;udev, 2),
</I>&gt;<i> +			  urb-&gt;transfer_buffer, RX_BUFFER_SIZE,
</I>&gt;<i> +			  ems_usb_read_bulk_callback, dev);
</I>&gt;<i> +
</I>&gt;<i> +	retval = usb_submit_urb(urb, GFP_ATOMIC);
</I>&gt;<i> +
</I>&gt;<i> +	if (retval == -ENODEV)
</I>&gt;<i> +		netif_device_detach(netdev);
</I>&gt;<i> +	else if (retval)
</I>&gt;<i> +		dev_err(ND2D(netdev), &quot;failed resubmitting bulk urb: %d\n&quot;,
</I>&gt;<i> +			retval);
</I>&gt;<i> +
</I>&gt;<i> +	return;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * callback for bulk IN urb
</I>&gt;<i> + */
</I>&gt;<i> +static void ems_usb_write_bulk_callback(struct urb *urb)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ems_tx_urb_context *context = urb-&gt;context;
</I>&gt;<i> +	struct ems_usb *dev;
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +
</I>&gt;<i> +	if (!context)
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	dev = context-&gt;dev;
</I>&gt;<i> +	netdev = dev-&gt;netdev;
</I>&gt;<i> +
</I>&gt;<i> +	if (!netif_device_present(netdev))
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	if (urb-&gt;status)
</I>&gt;<i> +		dev_info(ND2D(netdev), &quot;%s: Tx status %d\n&quot;, netdev-&gt;name,
</I>&gt;<i> +			 urb-&gt;status);
</I>
Is this a normal case or does it signal a problem? dev_warn/dev_err?

&gt;<i> +	/* free up our allocated buffer */
</I>&gt;<i> +	usb_buffer_free(urb-&gt;dev, urb-&gt;transfer_buffer_length,
</I>&gt;<i> +			urb-&gt;transfer_buffer, urb-&gt;transfer_dma);
</I>&gt;<i> +
</I>&gt;<i> +	netdev-&gt;trans_start = jiffies;
</I>&gt;<i> +
</I>&gt;<i> +	/* transmission complete interrupt */
</I>&gt;<i> +	netdev-&gt;stats.tx_packets++;
</I>
Also increment stats-&gt;tx_bytes here.

&gt;<i> +
</I>&gt;<i> +	can_get_echo_skb(netdev, context-&gt;echo_index);
</I>&gt;<i> +
</I>&gt;<i> +	/* Release context */
</I>&gt;<i> +	context-&gt;echo_index = MAX_TX_URBS;
</I>&gt;<i> +
</I>&gt;<i> +	atomic_dec(&amp;dev-&gt;active_tx_urbs);
</I>&gt;<i> +
</I>&gt;<i> +	if (netif_queue_stopped(netdev))
</I>&gt;<i> +		netif_wake_queue(netdev);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * Send the given CPC command synchronously
</I>&gt;<i> + */
</I>&gt;<i> +static int ems_usb_command_msg(struct ems_usb *dev, struct ems_cpc_msg *msg)
</I>&gt;<i> +{
</I>&gt;<i> +	int actual_length;
</I>&gt;<i> +
</I>&gt;<i> +	/* Copy payload */
</I>&gt;<i> +	memcpy(&amp;dev-&gt;tx_msg_buffer[CPC_HEADER_SIZE], msg,
</I>&gt;<i> +	       msg-&gt;length + CPC_MSG_HEADER_LEN);
</I>&gt;<i> +
</I>&gt;<i> +	/* Clear header */
</I>&gt;<i> +	memset(&amp;dev-&gt;tx_msg_buffer[0], 0, CPC_HEADER_SIZE);
</I>&gt;<i> +
</I>&gt;<i> +	return usb_bulk_msg(dev-&gt;udev, usb_sndbulkpipe(dev-&gt;udev, 2),
</I>&gt;<i> +			&amp;dev-&gt;tx_msg_buffer[0],
</I>&gt;<i> +			    msg-&gt;length + CPC_MSG_HEADER_LEN + CPC_HEADER_SIZE,
</I>&gt;<i> +			&amp;actual_length, 1000);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * Change CAN controllers' mode register
</I>&gt;<i> + */
</I>&gt;<i> +static int ems_usb_write_mode(struct ems_usb *dev, u8 mode)
</I>&gt;<i> +{
</I>&gt;<i> +	dev-&gt;active_params.msg.can_params.cc_params.sja1000.mode = mode;
</I>&gt;<i> +
</I>&gt;<i> +	return ems_usb_command_msg(dev,&amp;dev-&gt;active_params);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * Send a CPC_Control command to change behaviour when interface receives a CAN
</I>&gt;<i> + * message, bus error or CAN state changed notifications.
</I>&gt;<i> + */
</I>&gt;<i> +static int ems_usb_control_cmd(struct ems_usb *dev, u8 val)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ems_cpc_msg cmd;
</I>&gt;<i> +
</I>&gt;<i> +	cmd.type = CPC_CMD_TYPE_CONTROL;
</I>&gt;<i> +	cmd.length = CPC_MSG_HEADER_LEN + 1;
</I>&gt;<i> +
</I>&gt;<i> +	cmd.msgid = 0;
</I>&gt;<i> +
</I>&gt;<i> +	cmd.msg.generic[0] = val;
</I>&gt;<i> +
</I>&gt;<i> +	return ems_usb_command_msg(dev,&amp;cmd);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * Start interface
</I>&gt;<i> + */
</I>&gt;<i> +static int ems_usb_start(struct ems_usb *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *netdev = dev-&gt;netdev;
</I>&gt;<i> +	int err, i;
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;intr_in_buffer[0] = 0;
</I>&gt;<i> +	dev-&gt;free_slots = 15;	/* initial size */
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i&lt;  MAX_RX_URBS; i++) {
</I>&gt;<i> +		struct urb *urb = NULL;
</I>&gt;<i> +		u8 *buf = NULL;
</I>&gt;<i> +
</I>&gt;<i> +		/* create a urb, and a buffer for it */
</I>&gt;<i> +		urb = usb_alloc_urb(0, GFP_ATOMIC);
</I>&gt;<i> +		if (!urb) {
</I>&gt;<i> +			dev_err(ND2D(netdev), &quot;No memory left for URBs\n&quot;);
</I>&gt;<i> +			return -ENOMEM;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		buf = usb_buffer_alloc(dev-&gt;udev, RX_BUFFER_SIZE, GFP_KERNEL,
</I>&gt;<i> +				&amp;urb-&gt;transfer_dma);
</I>&gt;<i> +		if (!buf) {
</I>&gt;<i> +			dev_err(ND2D(netdev),
</I>&gt;<i> +				&quot;No memory left for USB buffer\n&quot;);
</I>&gt;<i> +			usb_free_urb(urb);
</I>&gt;<i> +			return -ENOMEM;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		usb_fill_bulk_urb(urb, dev-&gt;udev, usb_rcvbulkpipe(dev-&gt;udev, 2),
</I>&gt;<i> +				  buf, RX_BUFFER_SIZE,
</I>&gt;<i> +				  ems_usb_read_bulk_callback, dev);
</I>&gt;<i> +		urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
</I>&gt;<i> +		usb_anchor_urb(urb,&amp;dev-&gt;rx_submitted);
</I>&gt;<i> +
</I>&gt;<i> +		err = usb_submit_urb(urb, GFP_KERNEL);
</I>&gt;<i> +		if (err) {
</I>&gt;<i> +			if (err == -ENODEV)
</I>&gt;<i> +				netif_device_detach(dev-&gt;netdev);
</I>&gt;<i> +
</I>&gt;<i> +			usb_unanchor_urb(urb);
</I>&gt;<i> +			usb_buffer_free(dev-&gt;udev, RX_BUFFER_SIZE, buf,
</I>&gt;<i> +					urb-&gt;transfer_dma);
</I>&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		/* Drop reference, USB core will take care of freeing it */
</I>&gt;<i> +		usb_free_urb(urb);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Do we submitted any URBs */
</I>
         /* Did we submit any URBS? */ ?

&gt;<i> +	if (i == 0) {
</I>&gt;<i> +		dev_warn(ND2D(netdev), &quot;couldn't setup read URBs\n&quot;);
</I>&gt;<i> +		return err;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Warn if we've couldn't transmit all the URBs */
</I>&gt;<i> +	if (i&lt;  MAX_RX_URBS)
</I>&gt;<i> +		dev_warn(ND2D(netdev), &quot;rx performance may be slow\n&quot;);
</I>&gt;<i> +
</I>&gt;<i> +	/* Setup and start interrupt URB */
</I>&gt;<i> +	usb_fill_int_urb(dev-&gt;intr_urb, dev-&gt;udev,
</I>&gt;<i> +			 usb_rcvintpipe(dev-&gt;udev, 1),
</I>&gt;<i> +			 dev-&gt;intr_in_buffer,
</I>&gt;<i> +			 sizeof(dev-&gt;intr_in_buffer),
</I>&gt;<i> +			 ems_usb_read_interrupt_callback, dev, 1);
</I>&gt;<i> +
</I>&gt;<i> +	err = usb_submit_urb(dev-&gt;intr_urb, GFP_KERNEL);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		if (err == -ENODEV)
</I>&gt;<i> +			netif_device_detach(dev-&gt;netdev);
</I>&gt;<i> +
</I>&gt;<i> +		dev_warn(ND2D(netdev), &quot;intr urb submit failed: %d\n&quot;, err);
</I>&gt;<i> +
</I>&gt;<i> +		return err;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* CPC-USB will transfer received message to host */
</I>&gt;<i> +	err = ems_usb_control_cmd(dev, CONTR_CAN_MESSAGE | CONTR_CONT_ON);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		goto failed;
</I>&gt;<i> +
</I>&gt;<i> +	/* CPC-USB will transfer CAN state changes to host */
</I>&gt;<i> +	err = ems_usb_control_cmd(dev, CONTR_CAN_STATE | CONTR_CONT_ON);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		goto failed;
</I>&gt;<i> +
</I>&gt;<i> +	/* CPC-USB will transfer bus errors to host */
</I>&gt;<i> +	err = ems_usb_control_cmd(dev, CONTR_BUS_ERROR | CONTR_CONT_ON);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		goto failed;
</I>&gt;<i> +
</I>&gt;<i> +	err = ems_usb_write_mode(dev, SJA1000_MOD_NORMAL);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		goto failed;
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +
</I>&gt;<i> +failed:
</I>&gt;<i> +	if (err == -ENODEV)
</I>&gt;<i> +		netif_device_detach(dev-&gt;netdev);
</I>&gt;<i> +
</I>&gt;<i> +	dev_warn(ND2D(netdev), &quot;couldn't submit control: %d\n&quot;, err);
</I>&gt;<i> +
</I>&gt;<i> +	return err;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void unlink_all_urbs(struct ems_usb *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	int i;
</I>&gt;<i> +
</I>&gt;<i> +	usb_unlink_urb(dev-&gt;intr_urb);
</I>&gt;<i> +
</I>&gt;<i> +	usb_kill_anchored_urbs(&amp;dev-&gt;rx_submitted);
</I>&gt;<i> +
</I>&gt;<i> +	usb_kill_anchored_urbs(&amp;dev-&gt;tx_submitted);
</I>&gt;<i> +	atomic_set(&amp;dev-&gt;active_tx_urbs, 0);
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i&lt;  MAX_TX_URBS; i++)
</I>&gt;<i> +		dev-&gt;tx_contexts[i].echo_index = MAX_TX_URBS;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ems_usb_open(struct net_device *netdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ems_usb *dev = netdev_priv(netdev);
</I>&gt;<i> +	int err;
</I>&gt;<i> +
</I>&gt;<i> +	err = ems_usb_write_mode(dev, SJA1000_MOD_RM);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		return err;
</I>&gt;<i> +
</I>&gt;<i> +	/* common open */
</I>&gt;<i> +	err = open_candev(netdev);
</I>&gt;<i> +	if (err)
</I>&gt;<i> +		return err;
</I>&gt;<i> +
</I>&gt;<i> +	/* finally start device */
</I>&gt;<i> +	err = ems_usb_start(dev);
</I>&gt;<i> +	if (err) {
</I>&gt;<i> +		if (err == -ENODEV)
</I>&gt;<i> +			netif_device_detach(dev-&gt;netdev);
</I>&gt;<i> +
</I>&gt;<i> +		dev_warn(ND2D(netdev), &quot;couldn't start device: %d\n&quot;, err);
</I>&gt;<i> +
</I>&gt;<i> +		close_candev(netdev);
</I>&gt;<i> +
</I>&gt;<i> +		return err;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;open_time = jiffies;
</I>&gt;<i> +
</I>&gt;<i> +	netif_start_queue(netdev);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ems_usb_start_xmit(struct sk_buff *skb, struct net_device *netdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ems_usb *dev = netdev_priv(netdev);
</I>&gt;<i> +	struct ems_tx_urb_context *context = NULL;
</I>&gt;<i> +	struct net_device_stats *stats =&amp;netdev-&gt;stats;
</I>&gt;<i> +	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> +	struct ems_cpc_msg *msg;
</I>&gt;<i> +	struct urb *urb;
</I>&gt;<i> +	u8 *buf;
</I>&gt;<i> +	int i, result;
</I>
s/result/err ?

&gt;<i> +	size_t size = CPC_HEADER_SIZE + CPC_MSG_HEADER_LEN
</I>&gt;<i> +	    + sizeof(struct cpc_can_msg);
</I>
Please use tabs for indention.

&gt;<i> +
</I>&gt;<i> +	/* create a urb, and a buffer for it, and copy the data to the urb */
</I>&gt;<i> +	urb = usb_alloc_urb(0, GFP_ATOMIC);
</I>&gt;<i> +	if (!urb) {
</I>&gt;<i> +		dev_err(ND2D(netdev), &quot;No memory left for URBs\n&quot;);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>
-ENOMEM is not a legal return value here. Use one of

<A HREF="http://lxr.linux.no/#linux+v2.6.30.6/include/linux/netdevice.h#L89">http://lxr.linux.no/#linux+v2.6.30.6/include/linux/netdevice.h#L89</A>

and handle the skb appropriately. Looking to other net-usb drivers, they 
seem to return NETDEV_TX_OK and drop the skb (dev_kfree_skb()) in case 
of errors.

&gt;<i> +	buf = usb_buffer_alloc(dev-&gt;udev, size, GFP_KERNEL,&amp;urb-&gt;transfer_dma);
</I>&gt;<i> +	if (!buf) {
</I>&gt;<i> +		dev_err(ND2D(netdev), &quot;No memory left for USB buffer\n&quot;);
</I>&gt;<i> +		usb_free_urb(urb);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>
Same here.

&gt;<i> +	msg = (struct ems_cpc_msg *)&amp;buf[CPC_HEADER_SIZE];
</I>&gt;<i> +
</I>&gt;<i> +	msg-&gt;msg.can_msg.id = cf-&gt;can_id&amp;  0x1FFFFFFFU;
</I>&gt;<i> +	msg-&gt;msg.can_msg.length = cf-&gt;can_dlc;
</I>&gt;<i> +
</I>&gt;<i> +	if (cf-&gt;can_id&amp;  CAN_RTR_FLAG) {
</I>&gt;<i> +		msg-&gt;type = cf-&gt;can_id&amp;  CAN_EFF_FLAG ?
</I>&gt;<i> +		    CPC_CMD_TYPE_EXT_RTR_FRAME : CPC_CMD_TYPE_RTR_FRAME;
</I>
Please use tabs for indention.

&gt;<i> +		msg-&gt;length = CPC_CAN_MSG_MIN_SIZE;
</I>&gt;<i> +	} else {
</I>&gt;<i> +		msg-&gt;type = cf-&gt;can_id&amp;  CAN_EFF_FLAG ?
</I>&gt;<i> +		    CPC_CMD_TYPE_EXT_CAN_FRAME : CPC_CMD_TYPE_CAN_FRAME;
</I>
Ditto.

&gt;<i> +		for (i = 0; i&lt;  cf-&gt;can_dlc; i++)
</I>&gt;<i> +			msg-&gt;msg.can_msg.msg[i] = cf-&gt;data[i];
</I>&gt;<i> +
</I>&gt;<i> +		msg-&gt;length = CPC_CAN_MSG_MIN_SIZE + cf-&gt;can_dlc;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i&lt;  MAX_TX_URBS; i++) {
</I>&gt;<i> +		if (dev-&gt;tx_contexts[i].echo_index == MAX_TX_URBS) {
</I>&gt;<i> +			context =&amp;dev-&gt;tx_contexts[i];
</I>&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * May never happen! When this happens we'd more URBs in flight as
</I>&gt;<i> +	 * allowed (MAX_TX_URBS).
</I>&gt;<i> +	 */
</I>&gt;<i> +	if (!context) {
</I>&gt;<i> +		usb_unanchor_urb(urb);
</I>&gt;<i> +		usb_buffer_free(dev-&gt;udev, size, buf, urb-&gt;transfer_dma);
</I>&gt;<i> +
</I>&gt;<i> +		dev_warn(ND2D(netdev), &quot;couldn't find free context\n&quot;);
</I>&gt;<i> +
</I>&gt;<i> +		return -EBUSY;
</I>&gt;<i> +	}
</I>
Ditto.

&gt;<i> +	context-&gt;dev = dev;
</I>&gt;<i> +	context-&gt;echo_index = i;
</I>&gt;<i> +
</I>&gt;<i> +	usb_fill_bulk_urb(urb, dev-&gt;udev, usb_sndbulkpipe(dev-&gt;udev, 2), buf,
</I>&gt;<i> +			  size, ems_usb_write_bulk_callback, context);
</I>&gt;<i> +	urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
</I>&gt;<i> +	usb_anchor_urb(urb,&amp;dev-&gt;tx_submitted);
</I>&gt;<i> +
</I>&gt;<i> +	can_put_echo_skb(skb, netdev, context-&gt;echo_index);
</I>&gt;<i> +
</I>&gt;<i> +	result = usb_submit_urb(urb, GFP_ATOMIC);
</I>&gt;<i> +	if (unlikely(result)) {
</I>&gt;<i> +		can_free_echo_skb(netdev, context-&gt;echo_index);
</I>
		dev_kfree_skb(skb); ?
		stats-&gt;tx_dropped++; ?
		
&gt;<i> +		usb_unanchor_urb(urb);
</I>&gt;<i> +		usb_buffer_free(dev-&gt;udev, size, buf, urb-&gt;transfer_dma);
</I>&gt;<i> +
</I>&gt;<i> +		if (result == -ENODEV) {
</I>&gt;<i> +			netif_device_detach(netdev);
</I>&gt;<i> +		} else {
</I>&gt;<i> +			dev_warn(ND2D(netdev), &quot;failed tx_urb %d\n&quot;, result);
</I>&gt;<i> +
</I>&gt;<i> +			stats-&gt;tx_errors++;
</I>
Hm, the queue was not stopped yet.

&gt;<i> +			netif_start_queue(netdev);
</I>&gt;<i> +		}
</I>&gt;<i> +	} else {
</I>&gt;<i> +		atomic_inc(&amp;dev-&gt;active_tx_urbs);
</I>&gt;<i> +
</I>&gt;<i> +		stats-&gt;tx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> +		netdev-&gt;trans_start = jiffies;
</I>&gt;<i> +
</I>&gt;<i> +		stats-&gt;tx_packets++;
</I>&gt;<i> +		stats-&gt;tx_bytes += skb-&gt;len;
</I>
Already done above, anyhow, please increment stats-&gt;tx_packets and 
stats-&gt;tx_bytes when TX request has completed.

&gt;<i> +		netdev-&gt;trans_start = jiffies;
</I>&gt;<i> +
</I>&gt;<i> +		/* Slow down tx path */
</I>&gt;<i> +		if (atomic_read(&amp;dev-&gt;active_tx_urbs)&gt;= MAX_TX_URBS ||
</I>&gt;<i> +		    dev-&gt;free_slots&lt;  5) {
</I>&gt;<i> +			netif_stop_queue(netdev);
</I>&gt;<i> +			return 0;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * Release our reference to this urb, the USB core will eventually free
</I>&gt;<i> +	 * it entirely.
</I>&gt;<i> +	 */
</I>&gt;<i> +	usb_free_urb(urb);
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>
	return NETDEV_TX_OK;

&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ems_usb_close(struct net_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ems_usb *priv = netdev_priv(dev);
</I>&gt;<i> +
</I>&gt;<i> +	netif_stop_queue(dev);
</I>&gt;<i> +
</I>&gt;<i> +	/* Stop polling */
</I>&gt;<i> +	unlink_all_urbs(priv);
</I>&gt;<i> +
</I>&gt;<i> +	/* Set CAN controller to reset mode */
</I>&gt;<i> +	if (ems_usb_write_mode(priv, SJA1000_MOD_RM))
</I>&gt;<i> +		dev_warn(ND2D(dev), &quot;couldn't stop device&quot;);
</I>&gt;<i> +
</I>&gt;<i> +	close_candev(dev);
</I>&gt;<i> +
</I>&gt;<i> +	priv-&gt;open_time = 0;
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE&gt;  KERNEL_VERSION(2,6,28)
</I>&gt;<i> +static const struct net_device_ops ems_usb_netdev_ops = {
</I>&gt;<i> +	.ndo_open = ems_usb_open,
</I>&gt;<i> +	.ndo_stop = ems_usb_close,
</I>&gt;<i> +	.ndo_start_xmit = ems_usb_start_xmit,
</I>&gt;<i> +};
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +static struct can_bittiming_const ems_usb_bittiming_const = {
</I>&gt;<i> +	.name = &quot;ems_usb&quot;,
</I>&gt;<i> +	.tseg1_min = 1,
</I>&gt;<i> +	.tseg1_max = 16,
</I>&gt;<i> +	.tseg2_min = 1,
</I>&gt;<i> +	.tseg2_max = 8,
</I>&gt;<i> +	.sjw_max = 4,
</I>&gt;<i> +	.brp_min = 1,
</I>&gt;<i> +	.brp_max = 64,
</I>&gt;<i> +	.brp_inc = 1,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int ems_usb_set_mode(struct net_device *dev, enum can_mode mode)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ems_usb *priv = netdev_priv(dev);
</I>&gt;<i> +
</I>&gt;<i> +	if (!priv-&gt;open_time)
</I>&gt;<i> +		return -EINVAL;
</I>&gt;<i> +
</I>&gt;<i> +	switch (mode) {
</I>&gt;<i> +	case CAN_MODE_START:
</I>&gt;<i> +		if (ems_usb_write_mode(priv, SJA1000_MOD_NORMAL))
</I>&gt;<i> +			dev_warn(ND2D(dev), &quot;couldn't start device&quot;);
</I>&gt;<i> +
</I>&gt;<i> +		if (netif_queue_stopped(dev))
</I>&gt;<i> +			netif_wake_queue(dev);
</I>&gt;<i> +		break;
</I>&gt;<i> +
</I>&gt;<i> +	default:
</I>&gt;<i> +		return -EOPNOTSUPP;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int ems_usb_set_bittiming(struct net_device *netdev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ems_usb *dev = netdev_priv(netdev);
</I>&gt;<i> +	struct can_bittiming *bt =&amp;dev-&gt;can.bittiming;
</I>&gt;<i> +	u8 btr0, btr1;
</I>&gt;<i> +
</I>&gt;<i> +	btr0 = ((bt-&gt;brp - 1)&amp;  0x3f) | (((bt-&gt;sjw - 1)&amp;  0x3)&lt;&lt;  6);
</I>&gt;<i> +	btr1 = ((bt-&gt;prop_seg + bt-&gt;phase_seg1 - 1)&amp;  0xf) |
</I>&gt;<i> +	    (((bt-&gt;phase_seg2 - 1)&amp;  0x7)&lt;&lt;  4);
</I>
Please use tabs for indention (like below).

&gt;<i> +	if (dev-&gt;can.ctrlmode&amp;  CAN_CTRLMODE_3_SAMPLES)
</I>&gt;<i> +		btr1 |= 0x80;
</I>&gt;<i> +
</I>&gt;<i> +	dev_info(ND2D(netdev), &quot;setting BTR0=0x%02x BTR1=0x%02x\n&quot;, btr0, btr1);
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;active_params.msg.can_params.cc_params.sja1000.btr0 = btr0;
</I>&gt;<i> +	dev-&gt;active_params.msg.can_params.cc_params.sja1000.btr1 = btr1;
</I>&gt;<i> +
</I>&gt;<i> +	return ems_usb_command_msg(dev,&amp;dev-&gt;active_params);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * probe function for new CPC-USB devices
</I>&gt;<i> + */
</I>&gt;<i> +static int ems_usb_probe(struct usb_interface *intf,
</I>&gt;<i> +			 const struct usb_device_id *id)
</I>&gt;<i> +{
</I>&gt;<i> +	struct net_device *netdev;
</I>&gt;<i> +	struct ems_usb *dev;
</I>&gt;<i> +	int i, err;
</I>&gt;<i> +
</I>&gt;<i> +	netdev = alloc_candev(sizeof(struct ems_usb));
</I>&gt;<i> +	if (!netdev) {
</I>&gt;<i> +		dev_err(ND2D(netdev), &quot;Out of memory&quot;);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	dev = netdev_priv(netdev);
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;udev = interface_to_usbdev(intf);
</I>&gt;<i> +	dev-&gt;netdev = netdev;
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;can.state = CAN_STATE_STOPPED;
</I>&gt;<i> +	dev-&gt;can.bittiming_const =&amp;ems_usb_bittiming_const;
</I>&gt;<i> +	dev-&gt;can.do_set_bittiming = ems_usb_set_bittiming;
</I>&gt;<i> +	dev-&gt;can.do_set_mode = ems_usb_set_mode;
</I>&gt;<i> +
</I>&gt;<i> +	netdev-&gt;flags |= IFF_ECHO; /* we support local echo */
</I>&gt;<i> +
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * The device actually uses a 16MHz clock to generate the CAN clock
</I>&gt;<i> +	 * but it expects SJA1000 bit settings based on 8MHz (is internally
</I>&gt;<i> +	 * converted).
</I>&gt;<i> +	 */
</I>&gt;<i> +	dev-&gt;can.clock.freq = 8000000;
</I>
Please define a macro for that value.

&gt;<i> +
</I>&gt;<i> +#if LINUX_VERSION_CODE&gt;  KERNEL_VERSION(2,6,28)
</I>&gt;<i> +	netdev-&gt;netdev_ops =&amp;ems_usb_netdev_ops;
</I>&gt;<i> +#else
</I>&gt;<i> +	netdev-&gt;open = ems_usb_open;
</I>&gt;<i> +	netdev-&gt;stop = ems_usb_close;
</I>&gt;<i> +	netdev-&gt;hard_start_xmit = ems_usb_start_xmit;
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +	netdev-&gt;flags |= IFF_ECHO; /* we support local echo */
</I>&gt;<i> +
</I>&gt;<i> +	init_usb_anchor(&amp;dev-&gt;rx_submitted);
</I>&gt;<i> +
</I>&gt;<i> +	init_usb_anchor(&amp;dev-&gt;tx_submitted);
</I>&gt;<i> +	atomic_set(&amp;dev-&gt;active_tx_urbs, 0);
</I>&gt;<i> +
</I>&gt;<i> +	for (i = 0; i&lt;  MAX_TX_URBS; i++)
</I>&gt;<i> +		dev-&gt;tx_contexts[i].echo_index = MAX_TX_URBS;
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;intr_urb = usb_alloc_urb(0, GFP_KERNEL);
</I>&gt;<i> +	if (!dev-&gt;intr_urb) {
</I>&gt;<i> +		dev_err(ND2D(netdev), &quot;Out of memory&quot;);
</I>&gt;<i> +		free_candev(netdev);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	dev-&gt;tx_msg_buffer = kzalloc(CPC_HEADER_SIZE +
</I>&gt;<i> +				     sizeof(struct ems_cpc_msg), GFP_KERNEL);
</I>&gt;<i> +	if (!dev-&gt;tx_msg_buffer) {
</I>&gt;<i> +		dev_err(ND2D(netdev), &quot;Out of memory&quot;);
</I>
Please use a more specific message. What failed?

&gt;<i> +		free_candev(netdev);
</I>&gt;<i> +		usb_free_urb(dev-&gt;intr_urb);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	usb_set_intfdata(intf, dev);
</I>&gt;<i> +
</I>&gt;<i> +	SET_NETDEV_DEV(netdev,&amp;intf-&gt;dev);
</I>&gt;<i> +
</I>&gt;<i> +	init_params_sja1000(&amp;dev-&gt;active_params, 0, 0, 0xDA, SJA1000_MOD_RM);
</I>
Why do you pass arguments for btr0/1 etc.? You could code it directly 
into init_params_sja1000. Using a #define for 0xda would be nice as well.

&gt;<i> +	err = ems_usb_command_msg(dev,&amp;dev-&gt;active_params);
</I>&gt;<i> +
</I>
Remove empty line?

&gt;<i> +	if (err) {
</I>&gt;<i> +		dev_err(ND2D(netdev), &quot;couldn't initialize controller: %d\n&quot;,
</I>&gt;<i> +			err);
</I>&gt;<i> +		return err;
</I>
Cleanup is missing: free_candev(), usb_free_urb(), etc.

&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return register_candev(netdev);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * called by the usb core when the device is removed from the system
</I>&gt;<i> + */
</I>&gt;<i> +static void ems_usb_disconnect(struct usb_interface *intf)
</I>&gt;<i> +{
</I>&gt;<i> +	struct ems_usb *dev = usb_get_intfdata(intf);
</I>&gt;<i> +
</I>&gt;<i> +	usb_set_intfdata(intf, NULL);
</I>&gt;<i> +
</I>&gt;<i> +	if (dev) {
</I>&gt;<i> +		unregister_netdev(dev-&gt;netdev);
</I>&gt;<i> +		free_candev(dev-&gt;netdev);
</I>&gt;<i> +
</I>&gt;<i> +		unlink_all_urbs(dev);
</I>&gt;<i> +
</I>&gt;<i> +		usb_free_urb(dev-&gt;intr_urb);
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/* usb specific object needed to register this driver with the usb subsystem */
</I>&gt;<i> +static struct usb_driver ems_usb_driver = {
</I>&gt;<i> +	.name = &quot;ems_usb&quot;,
</I>&gt;<i> +	.probe = ems_usb_probe,
</I>&gt;<i> +	.disconnect = ems_usb_disconnect,
</I>&gt;<i> +	.id_table = ems_usb_table,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static int __init ems_usb_init(void)
</I>&gt;<i> +{
</I>&gt;<i> +	int result;
</I>
s/result/err/

&gt;<i> +
</I>&gt;<i> +	printk(KERN_INFO &quot;CPC-USB kernel driver loaded\n&quot;);
</I>&gt;<i> +
</I>&gt;<i> +	/* register this driver with the USB subsystem */
</I>&gt;<i> +	result = usb_register(&amp;ems_usb_driver);
</I>&gt;<i> +
</I>&gt;<i> +	if (result) {
</I>&gt;<i> +		err(&quot;usb_register failed. Error number %d\n&quot;, result);
</I>&gt;<i> +		return result;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void __exit ems_usb_exit(void)
</I>&gt;<i> +{
</I>&gt;<i> +	/* deregister this driver with the USB subsystem */
</I>&gt;<i> +	usb_deregister(&amp;ems_usb_driver);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +module_init(ems_usb_init);
</I>&gt;<i> +module_exit(ems_usb_exit);
</I>
Wolfgang.

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003029.html">[PATCH v3] ems_usb: CAN/USB driver for EMS CPC-USB/ARM7 CAN interfaces
</A></li>
	<LI>Next message: <A HREF="003037.html">[PATCH v3] ems_usb: CAN/USB driver for EMS CPC-USB/ARM7 CAN	interfaces
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3034">[ date ]</a>
              <a href="thread.html#3034">[ thread ]</a>
              <a href="subject.html#3034">[ subject ]</a>
              <a href="author.html#3034">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
