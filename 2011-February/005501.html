<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [PATCH net-next-2.6 v6 1/1] can: c_can: Added support for Bosch	C_CAN controller
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2011-February/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20net-next-2.6%20v6%201/1%5D%20can%3A%20c_can%3A%20Added%20support%20for%20Bosch%0A%09C_CAN%20controller&In-Reply-To=%3CD5ECB3C7A6F99444980976A8C6D896384DEE36615D%40EAPEX1MAIL1.st.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005500.html">
   <LINK REL="Next"  HREF="005510.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[PATCH net-next-2.6 v6 1/1] can: c_can: Added support for Bosch	C_CAN controller</H1>
    <B>Bhupesh SHARMA</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BPATCH%20net-next-2.6%20v6%201/1%5D%20can%3A%20c_can%3A%20Added%20support%20for%20Bosch%0A%09C_CAN%20controller&In-Reply-To=%3CD5ECB3C7A6F99444980976A8C6D896384DEE36615D%40EAPEX1MAIL1.st.com%3E"
       TITLE="[PATCH net-next-2.6 v6 1/1] can: c_can: Added support for Bosch	C_CAN controller">bhupesh.sharma at st.com
       </A><BR>
    <I>Wed Feb  9 11:54:48 CET 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="005500.html">[PATCH net-next-2.6 v6 1/1] can: c_can: Added support for Bosch	C_CAN	controller
</A></li>
        <LI>Next message: <A HREF="005510.html">[PATCH net-next-2.6 v6 1/1] can: c_can: Added support for Bosch	C_CAN controller
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5501">[ date ]</a>
              <a href="thread.html#5501">[ thread ]</a>
              <a href="subject.html#5501">[ subject ]</a>
              <a href="author.html#5501">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Marc,

Thanks for your review comments.
Please see my comments inline:

&gt;<i> -----Original Message-----
</I>&gt;<i> From: Marc Kleine-Budde [mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">mkl at pengutronix.de</A>]
</I>&gt;<i> Sent: Wednesday, February 09, 2011 2:57 PM
</I>&gt;<i> To: Bhupesh SHARMA
</I>&gt;<i> Cc: <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">socketcan-core at lists.berlios.de</A>; <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">netdev at vger.kernel.org</A>
</I>&gt;<i> Subject: Re: [PATCH net-next-2.6 v6 1/1] can: c_can: Added support for
</I>&gt;<i> Bosch C_CAN controller
</I>&gt;<i>
</I>&gt;<i> On 02/09/2011 06:03 AM, Bhupesh Sharma wrote:
</I>&gt;<i> &gt; Bosch C_CAN controller is a full-CAN implementation which is
</I>&gt;<i> compliant
</I>&gt;<i> &gt; to CAN protocol version 2.0 part A and B. Bosch C_CAN user manual can
</I>&gt;<i> &gt; be obtained from:
</I>&gt;<i> &gt; <A HREF="http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/">http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/</A>
</I>&gt;<i> &gt; c_can/users_manual_c_can.pdf
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; This patch adds the support for this controller.
</I>&gt;<i> &gt; The following are the design choices made while writing the
</I>&gt;<i> controller
</I>&gt;<i> &gt; driver:
</I>&gt;<i> &gt; 1. Interface Register set IF1 has be used only in the current design.
</I>&gt;<i> &gt; 2. Out of the 32 Message objects available, 16 are kept aside for RX
</I>&gt;<i> &gt;    purposes and the rest for TX purposes.
</I>&gt;<i> &gt; 3. NAPI implementation is such that both the TX and RX paths function
</I>&gt;<i> &gt;    in polling mode.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Signed-off-by: Bhupesh Sharma &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">bhupesh.sharma at st.com</A>&gt;
</I>&gt;<i>
</I>&gt;<i> The driver looks quite good, some comments inline, most of them
</I>&gt;<i> nitpicking and or style related.
</I>&gt;<i>
</I>&gt;<i> Have a look at the netif_stop_queue(). In the at91 driver there are two
</I>&gt;<i> possibilities that to stop the queue. First the next tx mailbox is
</I>&gt;<i> still in use, second we have a wrap around. But your hardware is a bit
</I>&gt;<i> different. Anyways a second look doesn't harm.
</I>
As the Tx/Rx path of my driver are based on at91 driver, I have earlier
gone through the possibility of stopping the tx queue in the two cases as
you mentioned above :)

As per at91 specs, MRDY=0 signifies:
&quot;Mailbox data registers cannot be read/written by the software application&quot;

But, after reading the Bosch C_CAN specs Transmission Request Register(TxRqst)'s
bits if set to 1, signify that the transmission of this Message Object is
requested and is not yet done. If you agree we can add a check against the same here.
Please do go through the Bosch C_CAN specs for details:
<A HREF="http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/">http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/</A>
c_can/users_manual_c_can.pdf

&gt;<i> &gt; ---
</I>&gt;<i> &gt; Changes since V5:
</I>&gt;<i> &gt; 1. Seperated the state change and bus error handling paths.
</I>&gt;<i> &gt; 2. Added logic to write LEC value to 0x7 from CPU to check for
</I>&gt;<i> updates
</I>&gt;<i> &gt;    later.
</I>&gt;<i> &gt; 3. Corrected the ERROR_WARNING handling logic to correctly send error
</I>&gt;<i> &gt;    frames on the bus.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;  drivers/net/can/Kconfig                |    2 +
</I>&gt;<i> &gt;  drivers/net/can/Makefile               |    1 +
</I>&gt;<i> &gt;  drivers/net/can/c_can/Kconfig          |   15 +
</I>&gt;<i> &gt;  drivers/net/can/c_can/Makefile         |    8 +
</I>&gt;<i> &gt;  drivers/net/can/c_can/c_can.c          |  993
</I>&gt;<i> ++++++++++++++++++++++++++++++++
</I>&gt;<i> &gt;  drivers/net/can/c_can/c_can.h          |  230 ++++++++
</I>&gt;<i> &gt;  drivers/net/can/c_can/c_can_platform.c |  207 +++++++
</I>&gt;<i> &gt;  7 files changed, 1456 insertions(+), 0 deletions(-)  create mode
</I>&gt;<i> &gt; 100644 drivers/net/can/c_can/Kconfig  create mode 100644
</I>&gt;<i> &gt; drivers/net/can/c_can/Makefile  create mode 100644
</I>&gt;<i> &gt; drivers/net/can/c_can/c_can.c  create mode 100644
</I>&gt;<i> &gt; drivers/net/can/c_can/c_can.h  create mode 100644
</I>&gt;<i> &gt; drivers/net/can/c_can/c_can_platform.c
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig index
</I>&gt;<i> &gt; 5dec456..1d699e3 100644
</I>&gt;<i> &gt; --- a/drivers/net/can/Kconfig
</I>&gt;<i> &gt; +++ b/drivers/net/can/Kconfig
</I>&gt;<i> &gt; @@ -115,6 +115,8 @@ source &quot;drivers/net/can/mscan/Kconfig&quot;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;  source &quot;drivers/net/can/sja1000/Kconfig&quot;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; +source &quot;drivers/net/can/c_can/Kconfig&quot;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt;  source &quot;drivers/net/can/usb/Kconfig&quot;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;  source &quot;drivers/net/can/softing/Kconfig&quot;
</I>&gt;<i> &gt; diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
</I>&gt;<i> index
</I>&gt;<i> &gt; 53c82a7..24ebfe8 100644
</I>&gt;<i> &gt; --- a/drivers/net/can/Makefile
</I>&gt;<i> &gt; +++ b/drivers/net/can/Makefile
</I>&gt;<i> &gt; @@ -13,6 +13,7 @@ obj-y                             += softing/
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;  obj-$(CONFIG_CAN_SJA1000)  += sja1000/
</I>&gt;<i> &gt;  obj-$(CONFIG_CAN_MSCAN)            += mscan/
</I>&gt;<i> &gt; +obj-$(CONFIG_CAN_C_CAN)            += c_can/
</I>&gt;<i> &gt;  obj-$(CONFIG_CAN_AT91)             += at91_can.o
</I>&gt;<i> &gt;  obj-$(CONFIG_CAN_TI_HECC)  += ti_hecc.o
</I>&gt;<i> &gt;  obj-$(CONFIG_CAN_MCP251X)  += mcp251x.o
</I>&gt;<i> &gt; diff --git a/drivers/net/can/c_can/Kconfig
</I>&gt;<i> &gt; b/drivers/net/can/c_can/Kconfig new file mode 100644 index
</I>&gt;<i> &gt; 0000000..ffb9773
</I>&gt;<i> &gt; --- /dev/null
</I>&gt;<i> &gt; +++ b/drivers/net/can/c_can/Kconfig
</I>&gt;<i> &gt; @@ -0,0 +1,15 @@
</I>&gt;<i> &gt; +menuconfig CAN_C_CAN
</I>&gt;<i> &gt; +   tristate &quot;Bosch C_CAN devices&quot;
</I>&gt;<i> &gt; +   depends on CAN_DEV &amp;&amp; HAS_IOMEM
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +if CAN_C_CAN
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +config CAN_C_CAN_PLATFORM
</I>&gt;<i> &gt; +   tristate &quot;Generic Platform Bus based C_CAN driver&quot;
</I>&gt;<i> &gt; +   ---help---
</I>&gt;<i> &gt; +     This driver adds support for the C_CAN chips connected to
</I>&gt;<i> &gt; +     the &quot;platform bus&quot; (Linux abstraction for directly to the
</I>&gt;<i> &gt; +     processor attached devices) which can be found on various
</I>&gt;<i> &gt; +     boards from ST Microelectronics (<A HREF="http://www.st.com">http://www.st.com</A>)
</I>&gt;<i> &gt; +     like the SPEAr1310 and SPEAr320 evaluation boards.
</I>&gt;<i> &gt; +endif
</I>&gt;<i> &gt; diff --git a/drivers/net/can/c_can/Makefile
</I>&gt;<i> &gt; b/drivers/net/can/c_can/Makefile new file mode 100644 index
</I>&gt;<i> &gt; 0000000..9273f6d
</I>&gt;<i> &gt; --- /dev/null
</I>&gt;<i> &gt; +++ b/drivers/net/can/c_can/Makefile
</I>&gt;<i> &gt; @@ -0,0 +1,8 @@
</I>&gt;<i> &gt; +#
</I>&gt;<i> &gt; +#  Makefile for the Bosch C_CAN controller drivers.
</I>&gt;<i> &gt; +#
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +obj-$(CONFIG_CAN_C_CAN) += c_can.o
</I>&gt;<i> &gt; +obj-$(CONFIG_CAN_C_CAN_PLATFORM) += c_can_platform.o
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +ccflags-$(CONFIG_CAN_DEBUG_DEVICES) := -DDEBUG
</I>&gt;<i> &gt; diff --git a/drivers/net/can/c_can/c_can.c
</I>&gt;<i> &gt; b/drivers/net/can/c_can/c_can.c new file mode 100644 index
</I>&gt;<i> &gt; 0000000..7ef4aa9
</I>&gt;<i> &gt; --- /dev/null
</I>&gt;<i> &gt; +++ b/drivers/net/can/c_can/c_can.c
</I>&gt;<i> &gt; @@ -0,0 +1,993 @@
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * CAN bus driver for Bosch C_CAN controller
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Copyright (C) 2010 ST Microelectronics
</I>&gt;<i> &gt; + * Bhupesh Sharma &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">bhupesh.sharma at st.com</A>&gt;
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Borrowed heavily from the C_CAN driver originally written by:
</I>&gt;<i> &gt; + * Copyright (C) 2007
</I>&gt;<i> &gt; + * - Sascha Hauer, Marc Kleine-Budde, Pengutronix
</I>&gt;<i> &gt; +&lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">s.hauer at pengutronix.de</A>&gt;
</I>&gt;<i> &gt; + * - Simon Kallweit, intefo AG &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">simon.kallweit at intefo.ch</A>&gt;
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * TX and RX NAPI implementation has been borrowed from at91 CAN
</I>&gt;<i> &gt; +driver
</I>&gt;<i> &gt; + * written by:
</I>&gt;<i> &gt; + * Copyright
</I>&gt;<i> &gt; + * (C) 2007 by Hans J. Koch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">hjk at hansjkoch.de</A>&gt;
</I>&gt;<i> &gt; + * (C) 2008, 2009 by Marc Kleine-Budde &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">kernel at pengutronix.de</A>&gt;
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Bosch C_CAN controller is compliant to CAN protocol version 2.0
</I>&gt;<i> part A and B.
</I>&gt;<i> &gt; + * Bosch C_CAN user manual can be obtained from:
</I>&gt;<i> &gt; + *
</I>&gt;<i> <A HREF="http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/">http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/</A>
</I>&gt;<i> &gt; + * users_manual_c_can.pdf
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * This file is licensed under the terms of the GNU General Public
</I>&gt;<i> &gt; + * License version 2. This program is licensed &quot;as is&quot; without any
</I>&gt;<i> &gt; + * warranty of any kind, whether express or implied.
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#include &lt;linux/kernel.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/version.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/module.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/interrupt.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/delay.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/if_arp.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/if_ether.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/list.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/delay.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/io.h&gt;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#include &lt;linux/can.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/can/dev.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/can/error.h&gt;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#include &quot;c_can.h&quot;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static struct can_bittiming_const c_can_bittiming_const = {
</I>&gt;<i> &gt; +   .name = KBUILD_MODNAME,
</I>&gt;<i> &gt; +   .tseg1_min = 2,         /* Time segment 1 = prop_seg + phase_seg1
</I>&gt;<i> */
</I>&gt;<i> &gt; +   .tseg1_max = 16,
</I>&gt;<i> &gt; +   .tseg2_min = 1,         /* Time segment 2 = phase_seg2 */
</I>&gt;<i> &gt; +   .tseg2_max = 8,
</I>&gt;<i> &gt; +   .sjw_max = 4,
</I>&gt;<i> &gt; +   .brp_min = 1,
</I>&gt;<i> &gt; +   .brp_max = 1024,        /* 6-bit BRP field + 4-bit BRPE field*/
</I>&gt;<i> &gt; +   .brp_inc = 1,
</I>&gt;<i> &gt; +};
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static inline int get_tx_next_msg_obj(const struct c_can_priv *priv)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   return (priv-&gt;tx_next &amp; C_CAN_NEXT_MSG_OBJ_MASK) +
</I>&gt;<i> &gt; +                   C_CAN_MSG_OBJ_TX_FIRST;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static inline int get_tx_echo_msg_obj(const struct c_can_priv *priv)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   return (priv-&gt;tx_echo &amp; C_CAN_NEXT_MSG_OBJ_MASK) +
</I>&gt;<i> &gt; +                   C_CAN_MSG_OBJ_TX_FIRST;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static u32 c_can_read_reg32(struct c_can_priv *priv, void *reg) {
</I>&gt;<i> &gt; +   u32 val = priv-&gt;read_reg(priv, reg);
</I>&gt;<i> &gt; +   val |= ((u32) priv-&gt;read_reg(priv, reg + 2)) &lt;&lt; 16;
</I>&gt;<i> &gt; +   return val;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void c_can_enable_all_interrupts(struct c_can_priv *priv,
</I>&gt;<i> &gt; +                                           int enable)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   unsigned int cntrl_save = priv-&gt;read_reg(priv,
</I>&gt;<i> &gt; +                                           &amp;priv-&gt;regs-&gt;control);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   if (enable)
</I>&gt;<i> &gt; +           cntrl_save |= (CONTROL_SIE | CONTROL_EIE | CONTROL_IE);
</I>&gt;<i> &gt; +   else
</I>&gt;<i> &gt; +           cntrl_save &amp;= ~(CONTROL_EIE | CONTROL_IE | CONTROL_SIE);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control, cntrl_save); }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static inline int c_can_check_busy_status(struct c_can_priv *priv,
</I>&gt;<i> &gt; +int iface) {
</I>&gt;<i> &gt; +   int count = MIN_TIMEOUT_VALUE;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   while (count &amp;&amp; priv-&gt;read_reg(priv,
</I>&gt;<i> &gt; +                           &amp;priv-&gt;regs-&gt;ifregs[iface].com_req) &amp;
</I>&gt;<i> &gt; +                           IF_COMR_BUSY) {
</I>&gt;<i> &gt; +           count--;
</I>&gt;<i> &gt; +           udelay(1);
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return count;
</I>&gt;<i>
</I>&gt;<i> it's an unusual return value...maybe return 0 on success and -EBUSY
</I>&gt;<i> otherwise?
</I>
Hmm.. this will add the checking MIN_TIMEOUT_VALUE against 0 here,
instead of &quot;c_can_object_get&quot; and &quot;c_can_object_put&quot; routines.
If you persist we can add the same in V7 though.. :)

&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static inline void c_can_object_get(struct net_device *dev,
</I>&gt;<i> &gt; +                                   int iface, int objno, int mask)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   int ret;
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /*
</I>&gt;<i> &gt; +    * As per specs, after writting the message object number in the
</I>&gt;<i> &gt; +    * IF command request register the transfer b/w interface
</I>&gt;<i> &gt; +    * register and message RAM must be complete in 6 CAN-CLK
</I>&gt;<i> &gt; +    * period.
</I>&gt;<i> &gt; +    */
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].com_mask,
</I>&gt;<i> &gt; +                   IFX_WRITE_LOW_16BIT(mask));
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].com_req,
</I>&gt;<i> &gt; +                   IFX_WRITE_LOW_16BIT(objno));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   ret = c_can_check_busy_status(priv, iface);
</I>&gt;<i> &gt; +   if (!ret)
</I>&gt;<i> &gt; +           netdev_err(dev, &quot;timed out in object get\n&quot;); }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static inline void c_can_object_put(struct net_device *dev,
</I>&gt;<i> &gt; +                                   int iface, int objno, int mask)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   int ret;
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /*
</I>&gt;<i> &gt; +    * As per specs, after writting the message object number in the
</I>&gt;<i> &gt; +    * IF command request register the transfer b/w interface
</I>&gt;<i> &gt; +    * register and message RAM must be complete in 6 CAN-CLK
</I>&gt;<i> &gt; +    * period.
</I>&gt;<i> &gt; +    */
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].com_mask,
</I>&gt;<i> &gt; +                   (IF_COMM_WR | IFX_WRITE_LOW_16BIT(mask)));
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].com_req,
</I>&gt;<i> &gt; +                   IFX_WRITE_LOW_16BIT(objno));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   ret = c_can_check_busy_status(priv, iface);
</I>&gt;<i> &gt; +   if (!ret)
</I>&gt;<i> &gt; +           netdev_err(dev, &quot;timed out in object put\n&quot;); }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void c_can_write_msg_object(struct net_device *dev,
</I>&gt;<i> &gt; +                   int iface, struct can_frame *frame, int objno) {
</I>&gt;<i> &gt; +   int i;
</I>&gt;<i> &gt; +   u16 flags = 0;
</I>&gt;<i> &gt; +   unsigned int id;
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   if (!(frame-&gt;can_id &amp; CAN_RTR_FLAG))
</I>&gt;<i> &gt; +           flags |= IF_ARB_TRANSMIT;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   if (frame-&gt;can_id &amp; CAN_EFF_FLAG) {
</I>&gt;<i> &gt; +           id = frame-&gt;can_id &amp; CAN_EFF_MASK;
</I>&gt;<i> &gt; +           flags |= IF_ARB_MSGXTD;
</I>&gt;<i> &gt; +   } else
</I>&gt;<i> &gt; +           id = ((frame-&gt;can_id &amp; CAN_SFF_MASK) &lt;&lt; 18);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   flags |= IF_ARB_MSGVAL;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].arb1,
</I>&gt;<i> &gt; +                           IFX_WRITE_LOW_16BIT(id));
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].arb2, flags |
</I>&gt;<i> &gt; +                           IFX_WRITE_HIGH_16BIT(id));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   for (i = 0; i &lt; frame-&gt;can_dlc; i += 2) {
</I>&gt;<i> &gt; +           priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].data[i /
</I>&gt;<i> 2],
</I>&gt;<i> &gt; +                           frame-&gt;data[i] | (frame-&gt;data[i + 1] &lt;&lt; 8));
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* enable interrupt for this message object */
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].msg_cntrl,
</I>&gt;<i> &gt; +                   IF_MCONT_TXIE | IF_MCONT_TXRQST | IF_MCONT_EOB |
</I>&gt;<i> &gt; +                   (frame-&gt;can_dlc &amp; 0xf));
</I>&gt;<i>                                         ^^^^^
</I>&gt;<i>
</I>&gt;<i> the masking should not be needed, as you're using
</I>&gt;<i> can_dropped_invalid_skb()
</I>
Ok.

&gt;<i> &gt; +   c_can_object_put(dev, iface, objno, IF_COMM_ALL); }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static inline void c_can_mark_rx_msg_obj(struct net_device *dev,
</I>&gt;<i> &gt; +                                           int iface, int ctrl_mask,
</I>&gt;<i> &gt; +                                           int obj)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].msg_cntrl,
</I>&gt;<i> &gt; +                   ctrl_mask &amp; ~(IF_MCONT_MSGLST | IF_MCONT_INTPND));
</I>&gt;<i> &gt; +   c_can_object_put(dev, iface, obj, IF_COMM_CONTROL);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static inline void c_can_activate_all_lower_rx_msg_obj(struct
</I>&gt;<i> net_device *dev,
</I>&gt;<i> &gt; +                                           int iface,
</I>&gt;<i> &gt; +                                           int ctrl_mask)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   int i;
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   for (i = C_CAN_MSG_OBJ_RX_FIRST; i &lt;= C_CAN_MSG_RX_LOW_LAST; i++)
</I>&gt;<i> {
</I>&gt;<i> &gt; +           priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].msg_cntrl,
</I>&gt;<i> &gt; +                           ctrl_mask &amp; ~(IF_MCONT_MSGLST |
</I>&gt;<i> &gt; +                                   IF_MCONT_INTPND | IF_MCONT_NEWDAT));
</I>&gt;<i> &gt; +           c_can_object_put(dev, iface, i, IF_COMM_CONTROL);
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static inline void c_can_activate_rx_msg_obj(struct net_device *dev,
</I>&gt;<i> &gt; +                                           int iface, int ctrl_mask,
</I>&gt;<i> &gt; +                                           int obj)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].msg_cntrl,
</I>&gt;<i> &gt; +                   ctrl_mask &amp; ~(IF_MCONT_MSGLST |
</I>&gt;<i> &gt; +                           IF_MCONT_INTPND | IF_MCONT_NEWDAT));
</I>&gt;<i> &gt; +   c_can_object_put(dev, iface, obj, IF_COMM_CONTROL); }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void c_can_handle_lost_msg_obj(struct net_device *dev,
</I>&gt;<i> &gt; +                                   int iface, int objno)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +   struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> &gt; +   struct sk_buff *skb;
</I>&gt;<i> &gt; +   struct can_frame *frame;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   netdev_err(dev, &quot;msg lost in buffer %d\n&quot;, objno);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   c_can_object_get(dev, iface, objno, IF_COMM_ALL &amp;
</I>&gt;<i> ~IF_COMM_TXRQST);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].msg_cntrl,
</I>&gt;<i> &gt; +                   IF_MCONT_CLR_MSGLST);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   c_can_object_put(dev, 0, objno, IF_COMM_CONTROL);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* create an error msg */
</I>&gt;<i> &gt; +   skb = alloc_can_err_skb(dev, &amp;frame);
</I>&gt;<i> &gt; +   if (unlikely(!skb))
</I>&gt;<i> &gt; +           return;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   frame-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> &gt; +   frame-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
</I>&gt;<i> &gt; +   stats-&gt;rx_errors++;
</I>&gt;<i> &gt; +   stats-&gt;rx_over_errors++;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   netif_receive_skb(skb);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int c_can_read_msg_object(struct net_device *dev, int iface,
</I>&gt;<i> &gt; +int ctrl) {
</I>&gt;<i> &gt; +   u16 flags, data;
</I>&gt;<i> &gt; +   int i;
</I>&gt;<i> &gt; +   unsigned int val;
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +   struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> &gt; +   struct sk_buff *skb;
</I>&gt;<i> &gt; +   struct can_frame *frame;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   skb = alloc_can_skb(dev, &amp;frame);
</I>&gt;<i> &gt; +   if (!skb) {
</I>&gt;<i> &gt; +           stats-&gt;rx_dropped++;
</I>&gt;<i> &gt; +           return -ENOMEM;
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   frame-&gt;can_dlc = get_can_dlc(ctrl &amp; 0x0F);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   for (i = 0; i &lt; frame-&gt;can_dlc; i += 2) {
</I>&gt;<i> &gt; +           data = priv-&gt;read_reg(priv,
</I>&gt;<i> &gt; +                           &amp;priv-&gt;regs-&gt;ifregs[iface].data[i / 2]);
</I>&gt;<i> &gt; +           frame-&gt;data[i] = data;
</I>&gt;<i> &gt; +           frame-&gt;data[i + 1] = data &gt;&gt; 8;
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   flags = priv-&gt;read_reg(priv, &amp;priv-&gt;regs-
</I>&gt;<i> &gt;ifregs[iface].arb2);
</I>&gt;<i> &gt; +   val = priv-&gt;read_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].arb1) |
</I>&gt;<i> &gt; +           (flags &lt;&lt; 16);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   if (flags &amp; IF_ARB_MSGXTD)
</I>&gt;<i> &gt; +           frame-&gt;can_id = (val &amp; CAN_EFF_MASK) | CAN_EFF_FLAG;
</I>&gt;<i> &gt; +   else
</I>&gt;<i> &gt; +           frame-&gt;can_id = (val &gt;&gt; 18) &amp; CAN_SFF_MASK;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   if (flags &amp; IF_ARB_TRANSMIT)
</I>&gt;<i> &gt; +           frame-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i>
</I>&gt;<i> Can you please only copy the data to the frame if the rtr flag isn't
</I>&gt;<i> set. Not all driver do this yet, but we've agreed to do so.
</I>
Ok.

&gt;<i> &gt; +
</I>&gt;<i> &gt; +   netif_receive_skb(skb);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   stats-&gt;rx_packets++;
</I>&gt;<i> &gt; +   stats-&gt;rx_bytes += frame-&gt;can_dlc;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void c_can_setup_receive_object(struct net_device *dev, int
</I>&gt;<i> iface,
</I>&gt;<i> &gt; +                                   int objno, unsigned int mask,
</I>&gt;<i> &gt; +                                   unsigned int id, unsigned int mcont) {
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].mask1,
</I>&gt;<i> &gt; +                   IFX_WRITE_LOW_16BIT(mask));
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].mask2,
</I>&gt;<i> &gt; +                   IFX_WRITE_HIGH_16BIT(mask));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].arb1,
</I>&gt;<i> &gt; +                   IFX_WRITE_LOW_16BIT(id));
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].arb2,
</I>&gt;<i> &gt; +                   (IF_ARB_MSGVAL | IFX_WRITE_HIGH_16BIT(id)));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].msg_cntrl,
</I>&gt;<i> mcont);
</I>&gt;<i> &gt; +   c_can_object_put(dev, iface, objno, IF_COMM_ALL &amp;
</I>&gt;<i> ~IF_COMM_TXRQST);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   netdev_dbg(dev, &quot;obj no:%d, msgval:0x%08x\n&quot;, objno,
</I>&gt;<i> &gt; +                   c_can_read_reg32(priv, &amp;priv-&gt;regs-&gt;msgval1)); }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void c_can_inval_msg_object(struct net_device *dev, int
</I>&gt;<i> iface,
</I>&gt;<i> &gt; +int objno) {
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].arb1, 0);
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].arb2, 0);
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;ifregs[iface].msg_cntrl, 0);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   c_can_object_put(dev, iface, objno, IF_COMM_ARB |
</I>&gt;<i> IF_COMM_CONTROL);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   netdev_dbg(dev, &quot;obj no:%d, msgval:0x%08x\n&quot;, objno,
</I>&gt;<i> &gt; +                   c_can_read_reg32(priv, &amp;priv-&gt;regs-&gt;msgval1)); }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static netdev_tx_t c_can_start_xmit(struct sk_buff *skb,
</I>&gt;<i> &gt; +                                   struct net_device *dev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   u32 msg_obj_no;
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +   struct can_frame *frame = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   if (can_dropped_invalid_skb(dev, skb))
</I>&gt;<i> &gt; +           return NETDEV_TX_OK;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   msg_obj_no = get_tx_next_msg_obj(priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* prepare message object for transmission */
</I>&gt;<i> &gt; +   c_can_write_msg_object(dev, 0, frame, msg_obj_no);
</I>&gt;<i> &gt; +   can_put_echo_skb(skb, dev, msg_obj_no - C_CAN_MSG_OBJ_TX_FIRST);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   priv-&gt;tx_next++;
</I>&gt;<i> &gt; +   if ((priv-&gt;tx_next &amp; C_CAN_NEXT_MSG_OBJ_MASK) == 0)
</I>&gt;<i> &gt; +           netif_stop_queue(dev);
</I>&gt;<i>
</I>&gt;<i> It it possible, that the &quot;tx_next&quot; object isn't available, yet?
</I>&gt;<i> Understanding your code right. It's not possible, because you have a
</I>&gt;<i> wrap around (which is handled above) first.
</I>
Please see explanation above.

&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return NETDEV_TX_OK;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int c_can_set_bittiming(struct net_device *dev) {
</I>&gt;<i> &gt; +   unsigned int reg_btr, reg_brpe, ctrl_save;
</I>&gt;<i> &gt; +   u8 brp, brpe, sjw, tseg1, tseg2;
</I>&gt;<i> &gt; +   u32 ten_bit_brp;
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +   const struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* c_can provides a 6-bit brp and 4-bit brpe fields */
</I>&gt;<i> &gt; +   ten_bit_brp = bt-&gt;brp - 1;
</I>&gt;<i> &gt; +   brp = ten_bit_brp &amp; BTR_BRP_MASK;
</I>&gt;<i> &gt; +   brpe = ten_bit_brp &gt;&gt; 6;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   sjw = bt-&gt;sjw - 1;
</I>&gt;<i> &gt; +   tseg1 = bt-&gt;prop_seg + bt-&gt;phase_seg1 - 1;
</I>&gt;<i> &gt; +   tseg2 = bt-&gt;phase_seg2 - 1;
</I>&gt;<i> &gt; +   reg_btr = brp | (sjw &lt;&lt; BTR_SJW_SHIFT) | (tseg1 &lt;&lt;
</I>&gt;<i> BTR_TSEG1_SHIFT) |
</I>&gt;<i> &gt; +                   (tseg2 &lt;&lt; BTR_TSEG2_SHIFT);
</I>&gt;<i> &gt; +   reg_brpe = brpe &amp; BRP_EXT_BRPE_MASK;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   netdev_info(dev,
</I>&gt;<i> &gt; +           &quot;setting BTR=%04x BRPE=%04x\n&quot;, reg_btr, reg_brpe);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   ctrl_save = priv-&gt;read_reg(priv, &amp;priv-&gt;regs-&gt;control);
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control,
</I>&gt;<i> &gt; +                   ctrl_save | CONTROL_CCE | CONTROL_INIT);
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;btr, reg_btr);
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;brp_ext, reg_brpe);
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control, ctrl_save);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * Configure C_CAN message objects for Tx and Rx purposes:
</I>&gt;<i> &gt; + * C_CAN provides a total of 32 message objects that can be
</I>&gt;<i> &gt; +configured
</I>&gt;<i> &gt; + * either for Tx or Rx purposes. Here the first 16 message objects
</I>&gt;<i> &gt; +are used as
</I>&gt;<i> &gt; + * a reception FIFO. The end of reception FIFO is signified by the
</I>&gt;<i> &gt; +EoB bit
</I>&gt;<i> &gt; + * being SET. The remaining 16 message objects are kept aside for Tx
</I>&gt;<i> purposes.
</I>&gt;<i> &gt; + * See user guide document for further details on configuring
</I>&gt;<i> message
</I>&gt;<i> &gt; + * objects.
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +static void c_can_configure_msg_objects(struct net_device *dev) {
</I>&gt;<i> &gt; +   int i;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* first invalidate all message objects */
</I>&gt;<i> &gt; +   for (i = C_CAN_MSG_OBJ_RX_FIRST; i &lt;= C_CAN_NO_OF_OBJECTS; i++)
</I>&gt;<i> &gt; +           c_can_inval_msg_object(dev, 0, i);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* setup receive message objects */
</I>&gt;<i> &gt; +   for (i = C_CAN_MSG_OBJ_RX_FIRST; i &lt; C_CAN_MSG_OBJ_RX_LAST; i++)
</I>&gt;<i> &gt; +           c_can_setup_receive_object(dev, 0, i, 0, 0,
</I>&gt;<i> &gt; +                   (IF_MCONT_RXIE | IF_MCONT_UMASK) &amp; ~IF_MCONT_EOB);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   c_can_setup_receive_object(dev, 0, C_CAN_MSG_OBJ_RX_LAST, 0, 0,
</I>&gt;<i> &gt; +                   IF_MCONT_EOB | IF_MCONT_RXIE | IF_MCONT_UMASK); }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * Configure C_CAN chip:
</I>&gt;<i> &gt; + * - enable/disable auto-retransmission
</I>&gt;<i> &gt; + * - set operating mode
</I>&gt;<i> &gt; + * - configure message objects
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +static void c_can_chip_config(struct net_device *dev) {
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_ONE_SHOT)
</I>&gt;<i> &gt; +           /* disable automatic retransmission */
</I>&gt;<i> &gt; +           priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control,
</I>&gt;<i> &gt; +                           CONTROL_DISABLE_AR);
</I>&gt;<i> &gt; +   else
</I>&gt;<i> &gt; +           /* enable automatic retransmission */
</I>&gt;<i> &gt; +           priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control,
</I>&gt;<i> &gt; +                           CONTROL_ENABLE_AR);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   if (priv-&gt;can.ctrlmode &amp; (CAN_CTRLMODE_LISTENONLY &amp;
</I>&gt;<i> &gt; +                                   CAN_CTRLMODE_LOOPBACK)) {
</I>&gt;<i> &gt; +           /* loopback + silent mode : useful for hot self-test */
</I>&gt;<i> &gt; +           priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control, CONTROL_EIE |
</I>&gt;<i> &gt; +                           CONTROL_SIE | CONTROL_IE | CONTROL_TEST);
</I>&gt;<i> &gt; +           priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;test,
</I>&gt;<i> &gt; +                           TEST_LBACK | TEST_SILENT);
</I>&gt;<i> &gt; +   } else if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LOOPBACK) {
</I>&gt;<i> &gt; +           /* loopback mode : useful for self-test function */
</I>&gt;<i> &gt; +           priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control, CONTROL_EIE |
</I>&gt;<i> &gt; +                           CONTROL_SIE | CONTROL_IE | CONTROL_TEST);
</I>&gt;<i> &gt; +           priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;test, TEST_LBACK);
</I>&gt;<i> &gt; +   } else if (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_LISTENONLY) {
</I>&gt;<i> &gt; +           /* silent mode : bus-monitoring mode */
</I>&gt;<i> &gt; +           priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control, CONTROL_EIE |
</I>&gt;<i> &gt; +                           CONTROL_SIE | CONTROL_IE | CONTROL_TEST);
</I>&gt;<i> &gt; +           priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;test, TEST_SILENT);
</I>&gt;<i> &gt; +   } else
</I>&gt;<i> &gt; +           /* normal mode*/
</I>&gt;<i> &gt; +           priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;control,
</I>&gt;<i> &gt; +                           CONTROL_EIE | CONTROL_SIE | CONTROL_IE);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* configure message objects */
</I>&gt;<i> &gt; +   c_can_configure_msg_objects(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* set a `lec` value so that we can check for updates later */
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;status, LEC_UNUSED); }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void c_can_start(struct net_device *dev) {
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* enable status change, error and module interrupts */
</I>&gt;<i> &gt; +   c_can_enable_all_interrupts(priv, ENABLE_ALL_INTERRUPTS);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* basic c_can configuration */
</I>&gt;<i> &gt; +   c_can_chip_config(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* reset tx helper pointers */
</I>&gt;<i> &gt; +   priv-&gt;tx_next = priv-&gt;tx_echo = 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void c_can_stop(struct net_device *dev) {
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* disable all interrupts */
</I>&gt;<i> &gt; +   c_can_enable_all_interrupts(priv, DISABLE_ALL_INTERRUPTS);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* set the state as STOPPED */
</I>&gt;<i> &gt; +   priv-&gt;can.state = CAN_STATE_STOPPED; }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int c_can_set_mode(struct net_device *dev, enum can_mode
</I>&gt;<i> mode)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   switch (mode) {
</I>&gt;<i> &gt; +   case CAN_MODE_START:
</I>&gt;<i> &gt; +           c_can_start(dev);
</I>&gt;<i> &gt; +           netif_wake_queue(dev);
</I>&gt;<i> &gt; +           break;
</I>&gt;<i> &gt; +   default:
</I>&gt;<i> &gt; +           return -EOPNOTSUPP;
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int c_can_get_berr_counter(const struct net_device *dev,
</I>&gt;<i> &gt; +                                   struct can_berr_counter *bec)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   unsigned int reg_err_counter;
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   reg_err_counter = priv-&gt;read_reg(priv, &amp;priv-&gt;regs-&gt;err_cnt);
</I>&gt;<i> &gt; +   bec-&gt;rxerr = (reg_err_counter &amp; ERR_CNT_REC_MASK) &gt;&gt;
</I>&gt;<i> &gt; +                           ERR_CNT_REC_SHIFT;
</I>&gt;<i> &gt; +   bec-&gt;txerr = reg_err_counter &amp; ERR_CNT_TEC_MASK;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * theory of operation:
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * priv-&gt;tx_echo holds the number of the oldest can_frame put for
</I>&gt;<i> &gt; + * transmission into the hardware, but not yet ACKed by the CAN tx
</I>&gt;<i> &gt; + * complete IRQ.
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * We iterate from priv-&gt;tx_echo to priv-&gt;tx_next and check if the
</I>&gt;<i> &gt; + * packet has been transmitted, echo it back to the CAN framework.
</I>&gt;<i> &gt; + * If we discover a not yet transmitted package, stop looking for
</I>&gt;<i> more.
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +static void c_can_do_tx(struct net_device *dev) {
</I>&gt;<i> &gt; +   u32 val;
</I>&gt;<i> &gt; +   u32 msg_obj_no;
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +   struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   for (/* nix */; (priv-&gt;tx_next - priv-&gt;tx_echo) &gt; 0; priv-
</I>&gt;<i> &gt;tx_echo++) {
</I>&gt;<i> &gt; +           msg_obj_no = get_tx_echo_msg_obj(priv);
</I>&gt;<i> &gt; +           c_can_inval_msg_object(dev, 0, msg_obj_no);
</I>&gt;<i> &gt; +           val = c_can_read_reg32(priv, &amp;priv-&gt;regs-&gt;txrqst1);
</I>&gt;<i> &gt; +           if (!(val &amp; (1 &lt;&lt; msg_obj_no))) {
</I>&gt;<i> &gt; +                   can_get_echo_skb(dev,
</I>&gt;<i> &gt; +                                   msg_obj_no - C_CAN_MSG_OBJ_TX_FIRST);
</I>&gt;<i> &gt; +                   stats-&gt;tx_bytes += priv-&gt;read_reg(priv,
</I>&gt;<i> &gt; +                                   &amp;priv-&gt;regs-&gt;ifregs[0].msg_cntrl)
</I>&gt;<i> &gt; +                                   &amp; IF_MCONT_DLC_MASK;
</I>&gt;<i> &gt; +                   stats-&gt;tx_packets++;
</I>&gt;<i> &gt; +           }
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* restart queue if wrap-up or if queue stalled on last pkt */
</I>&gt;<i> &gt; +   if (((priv-&gt;tx_next &amp; C_CAN_NEXT_MSG_OBJ_MASK) != 0) ||
</I>&gt;<i> &gt; +                   ((priv-&gt;tx_echo &amp; C_CAN_NEXT_MSG_OBJ_MASK) == 0))
</I>&gt;<i> &gt; +           netif_wake_queue(dev);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * theory of operation:
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * c_can core saves a received CAN message into the first free
</I>&gt;<i> &gt; +message
</I>&gt;<i> &gt; + * object it finds free (starting with the lowest). Bits NEWDAT and
</I>&gt;<i> &gt; + * INTPND are set for this message object indicating that a new
</I>&gt;<i> &gt; +message
</I>&gt;<i> &gt; + * has arrived. To work-around this issue, we keep two groups of
</I>&gt;<i> &gt; +message
</I>&gt;<i> &gt; + * objects whose partitioning is defined by C_CAN_MSG_OBJ_RX_SPLIT.
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * To ensure in-order frame reception we use the following
</I>&gt;<i> &gt; + * approach while re-activating a message object to receive further
</I>&gt;<i> &gt; + * frames:
</I>&gt;<i> &gt; + * - if the current message object number is lower than
</I>&gt;<i> &gt; + *   C_CAN_MSG_RX_LOW_LAST, do not clear the NEWDAT bit while
</I>&gt;<i> clearing
</I>&gt;<i> &gt; + *   the INTPND bit.
</I>&gt;<i> &gt; + * - if the current message object number is equal to
</I>&gt;<i> &gt; + *   C_CAN_MSG_RX_LOW_LAST then clear the NEWDAT bit of all lower
</I>&gt;<i> &gt; + *   receive message objects.
</I>&gt;<i> &gt; + * - if the current message object number is greater than
</I>&gt;<i> &gt; + *   C_CAN_MSG_RX_LOW_LAST then clear the NEWDAT bit of
</I>&gt;<i> &gt; + *   only this message object.
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +static int c_can_do_rx_poll(struct net_device *dev, int quota) {
</I>&gt;<i> &gt; +   u32 num_rx_pkts = 0;
</I>&gt;<i> &gt; +   unsigned int msg_obj, msg_ctrl_save;
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +   u32 val = c_can_read_reg32(priv, &amp;priv-&gt;regs-&gt;intpnd1);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   for (msg_obj = C_CAN_MSG_OBJ_RX_FIRST;
</I>&gt;<i> &gt; +                   msg_obj &lt;= C_CAN_MSG_OBJ_RX_LAST &amp;&amp; quota &gt; 0;
</I>&gt;<i> &gt; +                   val = c_can_read_reg32(priv, &amp;priv-&gt;regs-&gt;intpnd1),
</I>&gt;<i> &gt; +                   msg_obj++) {
</I>&gt;<i> &gt; +           /*
</I>&gt;<i> &gt; +            * as interrupt pending register's bit n-1 corresponds to
</I>&gt;<i> &gt; +            * message object n, we need to handle the same properly.
</I>&gt;<i> &gt; +            */
</I>&gt;<i> &gt; +           if (val &amp; (1 &lt;&lt; (msg_obj - 1))) {
</I>&gt;<i> &gt; +                   c_can_object_get(dev, 0, msg_obj, IF_COMM_ALL &amp;
</I>&gt;<i> &gt; +                                   ~IF_COMM_TXRQST);
</I>&gt;<i> &gt; +                   msg_ctrl_save = priv-&gt;read_reg(priv,
</I>&gt;<i> &gt; +                                   &amp;priv-&gt;regs-&gt;ifregs[0].msg_cntrl);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +                   if (msg_ctrl_save &amp; IF_MCONT_EOB)
</I>&gt;<i> &gt; +                           return num_rx_pkts;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +                   if (msg_ctrl_save &amp; IF_MCONT_MSGLST) {
</I>&gt;<i> &gt; +                           c_can_handle_lost_msg_obj(dev, 0, msg_obj);
</I>&gt;<i> &gt; +                           num_rx_pkts++;
</I>&gt;<i> &gt; +                           quota--;
</I>&gt;<i> &gt; +                           continue;
</I>&gt;<i> &gt; +                   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +                   if (!(msg_ctrl_save &amp; IF_MCONT_NEWDAT))
</I>&gt;<i> &gt; +                           continue;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +                   /* read the data from the message object */
</I>&gt;<i> &gt; +                   c_can_read_msg_object(dev, 0, msg_ctrl_save);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +                   if (msg_obj &lt; C_CAN_MSG_RX_LOW_LAST)
</I>&gt;<i> &gt; +                           c_can_mark_rx_msg_obj(dev, 0,
</I>&gt;<i> &gt; +                                           msg_ctrl_save, msg_obj);
</I>&gt;<i> &gt; +                   else if (msg_obj &gt; C_CAN_MSG_RX_LOW_LAST)
</I>&gt;<i> &gt; +                           /* activate this msg obj */
</I>&gt;<i> &gt; +                           c_can_activate_rx_msg_obj(dev, 0,
</I>&gt;<i> &gt; +                                           msg_ctrl_save, msg_obj);
</I>&gt;<i> &gt; +                   else if (msg_obj == C_CAN_MSG_RX_LOW_LAST)
</I>&gt;<i> &gt; +                           /* activate all lower message objects */
</I>&gt;<i> &gt; +                           c_can_activate_all_lower_rx_msg_obj(dev,
</I>&gt;<i> &gt; +                                           0, msg_ctrl_save);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +                   num_rx_pkts++;
</I>&gt;<i> &gt; +                   quota--;
</I>&gt;<i> &gt; +           }
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return num_rx_pkts;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static inline int c_can_has_and_handle_berr(struct c_can_priv *priv)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   return (priv-&gt;can.ctrlmode &amp; CAN_CTRLMODE_BERR_REPORTING) &amp;&amp;
</I>&gt;<i> &gt; +           (priv-&gt;current_status &amp; LEC_UNUSED); }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int c_can_handle_state_change(struct net_device *dev,
</I>&gt;<i> &gt; +                           enum c_can_bus_error_types error_type) {
</I>&gt;<i> &gt; +   unsigned int reg_err_counter;
</I>&gt;<i> &gt; +   unsigned int rx_err_passive;
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +   struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> &gt; +   struct can_frame *cf;
</I>&gt;<i> &gt; +   struct sk_buff *skb;
</I>&gt;<i> &gt; +   struct can_berr_counter bec;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* propogate the error condition to the CAN stack */
</I>&gt;<i> &gt; +   skb = alloc_can_err_skb(dev, &amp;cf);
</I>&gt;<i> &gt; +   if (unlikely(!skb))
</I>&gt;<i> &gt; +           return 0;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   c_can_get_berr_counter(dev, &amp;bec);
</I>&gt;<i> &gt; +   reg_err_counter = priv-&gt;read_reg(priv, &amp;priv-&gt;regs-&gt;err_cnt);
</I>&gt;<i> &gt; +   rx_err_passive = (reg_err_counter &amp; ERR_CNT_RP_MASK) &gt;&gt;
</I>&gt;<i> &gt; +                           ERR_CNT_RP_SHIFT;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   switch (error_type) {
</I>&gt;<i> &gt; +   case C_CAN_ERROR_WARNING:
</I>&gt;<i> &gt; +           /* error warning state */
</I>&gt;<i> &gt; +           priv-&gt;can.can_stats.error_warning++;
</I>&gt;<i> &gt; +           priv-&gt;can.state = CAN_STATE_ERROR_WARNING;
</I>&gt;<i> &gt; +           cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> &gt; +           cf-&gt;data[1] = (bec.txerr &gt; bec.rxerr) ?
</I>&gt;<i> &gt; +                   CAN_ERR_CRTL_TX_WARNING :
</I>&gt;<i> &gt; +                   CAN_ERR_CRTL_RX_WARNING;
</I>&gt;<i> &gt; +           cf-&gt;data[6] = bec.txerr;
</I>&gt;<i> &gt; +           cf-&gt;data[7] = bec.rxerr;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +           break;
</I>&gt;<i> &gt; +   case C_CAN_ERROR_PASSIVE:
</I>&gt;<i> &gt; +           /* error passive state */
</I>&gt;<i> &gt; +           priv-&gt;can.can_stats.error_passive++;
</I>&gt;<i> &gt; +           priv-&gt;can.state = CAN_STATE_ERROR_PASSIVE;
</I>&gt;<i> &gt; +           cf-&gt;can_id |= CAN_ERR_CRTL;
</I>&gt;<i> &gt; +           if (rx_err_passive)
</I>&gt;<i> &gt; +                   cf-&gt;data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
</I>&gt;<i> &gt; +           if (bec.txerr &gt; 127)
</I>&gt;<i> &gt; +                   cf-&gt;data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +           cf-&gt;data[6] = bec.txerr;
</I>&gt;<i> &gt; +           cf-&gt;data[7] = bec.rxerr;
</I>&gt;<i> &gt; +           break;
</I>&gt;<i> &gt; +   case C_CAN_BUS_OFF:
</I>&gt;<i> &gt; +           /* bus-off state */
</I>&gt;<i> &gt; +           priv-&gt;can.state = CAN_STATE_BUS_OFF;
</I>&gt;<i> &gt; +           cf-&gt;can_id |= CAN_ERR_BUSOFF;
</I>&gt;<i> &gt; +           /*
</I>&gt;<i> &gt; +            * disable all interrupts in bus-off mode to ensure that
</I>&gt;<i> &gt; +            * the CPU is not hogged down
</I>&gt;<i> &gt; +            */
</I>&gt;<i> &gt; +           c_can_enable_all_interrupts(priv, DISABLE_ALL_INTERRUPTS);
</I>&gt;<i> &gt; +           can_bus_off(dev);
</I>&gt;<i> &gt; +           break;
</I>&gt;<i> &gt; +   default:
</I>&gt;<i> &gt; +           break;
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   netif_receive_skb(skb);
</I>&gt;<i> &gt; +   stats-&gt;rx_packets++;
</I>&gt;<i> &gt; +   stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return 1;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int c_can_handle_bus_err(struct net_device *dev,
</I>&gt;<i> &gt; +                           enum c_can_lec_type lec_type)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +   struct net_device_stats *stats = &amp;dev-&gt;stats;
</I>&gt;<i> &gt; +   struct can_frame *cf;
</I>&gt;<i> &gt; +   struct sk_buff *skb;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /*
</I>&gt;<i> &gt; +    * early exit if no lec update or no error.
</I>&gt;<i> &gt; +    * no lec update means that no CAN bus event has been detected
</I>&gt;<i> &gt; +    * since CPU wrote 0x7 value to status reg.
</I>&gt;<i> &gt; +    */
</I>&gt;<i> &gt; +   if (lec_type == LEC_UNUSED || lec_type == LEC_NO_ERROR)
</I>&gt;<i> &gt; +           return 0;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* propogate the error condition to the CAN stack */
</I>&gt;<i> &gt; +   skb = alloc_can_err_skb(dev, &amp;cf);
</I>&gt;<i> &gt; +   if (unlikely(!skb))
</I>&gt;<i> &gt; +           return 0;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /*
</I>&gt;<i> &gt; +    * check for 'last error code' which tells us the
</I>&gt;<i> &gt; +    * type of the last error to occur on the CAN bus
</I>&gt;<i> &gt; +    */
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* common for all type of bus errors */
</I>&gt;<i> &gt; +   priv-&gt;can.can_stats.bus_error++;
</I>&gt;<i> &gt; +   stats-&gt;rx_errors++;
</I>&gt;<i> &gt; +   cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
</I>&gt;<i> &gt; +   cf-&gt;data[2] |= CAN_ERR_PROT_UNSPEC;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   switch (lec_type) {
</I>&gt;<i> &gt; +   case LEC_STUFF_ERROR:
</I>&gt;<i> &gt; +           netdev_dbg(dev, &quot;stuff error\n&quot;);
</I>&gt;<i> &gt; +           cf-&gt;data[2] |= CAN_ERR_PROT_STUFF;
</I>&gt;<i> &gt; +           break;
</I>&gt;<i> &gt; +   case LEC_FORM_ERROR:
</I>&gt;<i> &gt; +           netdev_dbg(dev, &quot;form error\n&quot;);
</I>&gt;<i> &gt; +           cf-&gt;data[2] |= CAN_ERR_PROT_FORM;
</I>&gt;<i> &gt; +           break;
</I>&gt;<i> &gt; +   case LEC_ACK_ERROR:
</I>&gt;<i> &gt; +           netdev_dbg(dev, &quot;ack error\n&quot;);
</I>&gt;<i> &gt; +           cf-&gt;data[2] |= (CAN_ERR_PROT_LOC_ACK |
</I>&gt;<i> &gt; +                           CAN_ERR_PROT_LOC_ACK_DEL);
</I>&gt;<i> &gt; +           break;
</I>&gt;<i> &gt; +   case LEC_BIT1_ERROR:
</I>&gt;<i> &gt; +           netdev_dbg(dev, &quot;bit1 error\n&quot;);
</I>&gt;<i> &gt; +           cf-&gt;data[2] |= CAN_ERR_PROT_BIT1;
</I>&gt;<i> &gt; +           break;
</I>&gt;<i> &gt; +   case LEC_BIT0_ERROR:
</I>&gt;<i> &gt; +           netdev_dbg(dev, &quot;bit0 error\n&quot;);
</I>&gt;<i> &gt; +           cf-&gt;data[2] |= CAN_ERR_PROT_BIT0;
</I>&gt;<i> &gt; +           break;
</I>&gt;<i> &gt; +   case LEC_CRC_ERROR:
</I>&gt;<i> &gt; +           netdev_dbg(dev, &quot;CRC error\n&quot;);
</I>&gt;<i> &gt; +           cf-&gt;data[2] |= (CAN_ERR_PROT_LOC_CRC_SEQ |
</I>&gt;<i> &gt; +                           CAN_ERR_PROT_LOC_CRC_DEL);
</I>&gt;<i> &gt; +           break;
</I>&gt;<i> &gt; +   default:
</I>&gt;<i> &gt; +           break;
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* set a `lec` value so that we can check for updates later */
</I>&gt;<i> &gt; +   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;status, LEC_UNUSED);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   netif_receive_skb(skb);
</I>&gt;<i> &gt; +   stats-&gt;rx_packets++;
</I>&gt;<i> &gt; +   stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return 1;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int c_can_poll(struct napi_struct *napi, int quota) {
</I>&gt;<i> &gt; +   u16 irqstatus;
</I>&gt;<i> &gt; +   int lec_type = 0;
</I>&gt;<i> &gt; +   int work_done = 0;
</I>&gt;<i> &gt; +   struct net_device *dev = napi-&gt;dev;
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   irqstatus = priv-&gt;read_reg(priv, &amp;priv-&gt;regs-&gt;interrupt);
</I>&gt;<i> &gt; +   if (!irqstatus)
</I>&gt;<i> &gt; +           goto end;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* status events have the highest priority */
</I>&gt;<i> &gt; +   if (irqstatus == STATUS_INTERRUPT) {
</I>&gt;<i> &gt; +           priv-&gt;current_status = priv-&gt;read_reg(priv,
</I>&gt;<i> &gt; +                                   &amp;priv-&gt;regs-&gt;status);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +           /* handle Tx/Rx events */
</I>&gt;<i> &gt; +           if (priv-&gt;current_status &amp; STATUS_TXOK)
</I>&gt;<i> &gt; +                   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;status,
</I>&gt;<i> &gt; +                                   priv-&gt;current_status &amp; ~STATUS_TXOK);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +           if (priv-&gt;current_status &amp; STATUS_RXOK)
</I>&gt;<i> &gt; +                   priv-&gt;write_reg(priv, &amp;priv-&gt;regs-&gt;status,
</I>&gt;<i> &gt; +                                   priv-&gt;current_status &amp; ~STATUS_RXOK);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +           /* handle state changes */
</I>&gt;<i> &gt; +           if ((priv-&gt;current_status &amp; STATUS_EWARN) &amp;&amp;
</I>&gt;<i> &gt; +                           (!(priv-&gt;last_status &amp; STATUS_EWARN))) {
</I>&gt;<i> &gt; +                   netdev_dbg(dev, &quot;entered error warning state\n&quot;);
</I>&gt;<i> &gt; +                   work_done += c_can_handle_state_change(dev,
</I>&gt;<i> &gt; +                                           C_CAN_ERROR_WARNING);
</I>&gt;<i> &gt; +           }
</I>&gt;<i> &gt; +           if ((priv-&gt;current_status &amp; STATUS_EPASS) &amp;&amp;
</I>&gt;<i> &gt; +                           (!(priv-&gt;last_status &amp; STATUS_EPASS))) {
</I>&gt;<i> &gt; +                   netdev_dbg(dev, &quot;entered error passive state\n&quot;);
</I>&gt;<i> &gt; +                   work_done += c_can_handle_state_change(dev,
</I>&gt;<i> &gt; +                                           C_CAN_ERROR_PASSIVE);
</I>&gt;<i> &gt; +           }
</I>&gt;<i> &gt; +           if ((priv-&gt;current_status &amp; STATUS_BOFF) &amp;&amp;
</I>&gt;<i> &gt; +                           (!(priv-&gt;last_status &amp; STATUS_BOFF))) {
</I>&gt;<i> &gt; +                   netdev_dbg(dev, &quot;entered bus off state\n&quot;);
</I>&gt;<i> &gt; +                   work_done += c_can_handle_state_change(dev,
</I>&gt;<i> &gt; +                                           C_CAN_BUS_OFF);
</I>&gt;<i> &gt; +           }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +           /* handle bus recovery events */
</I>&gt;<i> &gt; +           if ((!(priv-&gt;current_status &amp; STATUS_BOFF)) &amp;&amp;
</I>&gt;<i> &gt; +                           (priv-&gt;last_status &amp; STATUS_BOFF)) {
</I>&gt;<i> &gt; +                   netdev_dbg(dev, &quot;left bus off state\n&quot;);
</I>&gt;<i> &gt; +                   priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> &gt; +           }
</I>&gt;<i> &gt; +           if ((!(priv-&gt;current_status &amp; STATUS_EPASS)) &amp;&amp;
</I>&gt;<i> &gt; +                           (priv-&gt;last_status &amp; STATUS_EPASS)) {
</I>&gt;<i> &gt; +                   netdev_dbg(dev, &quot;left error passive state\n&quot;);
</I>&gt;<i> &gt; +                   priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
</I>&gt;<i> &gt; +           }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +           priv-&gt;last_status = priv-&gt;current_status;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +           /* handle lec errors on the bus */
</I>&gt;<i> &gt; +           lec_type = c_can_has_and_handle_berr(priv);
</I>&gt;<i> &gt; +           if (lec_type)
</I>&gt;<i> &gt; +                   work_done += c_can_handle_bus_err(dev, lec_type);
</I>&gt;<i> &gt; +   } else if ((irqstatus &gt;= C_CAN_MSG_OBJ_RX_FIRST) &amp;&amp;
</I>&gt;<i> &gt; +                   (irqstatus &lt;= C_CAN_MSG_OBJ_RX_LAST)) {
</I>&gt;<i> &gt; +           /* handle events corresponding to receive message objects
</I>&gt;<i> */
</I>&gt;<i> &gt; +           work_done += c_can_do_rx_poll(dev, (quota - work_done));
</I>&gt;<i> &gt; +   } else if ((irqstatus &gt;= C_CAN_MSG_OBJ_TX_FIRST) &amp;&amp;
</I>&gt;<i> &gt; +                   (irqstatus &lt;= C_CAN_MSG_OBJ_TX_LAST)) {
</I>&gt;<i> &gt; +           /* handle events corresponding to transmit message objects
</I>&gt;<i> */
</I>&gt;<i> &gt; +           c_can_do_tx(dev);
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +end:
</I>&gt;<i> &gt; +   if (work_done &lt; quota) {
</I>&gt;<i> &gt; +           napi_complete(napi);
</I>&gt;<i> &gt; +           /* enable all IRQs */
</I>&gt;<i> &gt; +           c_can_enable_all_interrupts(priv, ENABLE_ALL_INTERRUPTS);
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return work_done;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static irqreturn_t c_can_isr(int irq, void *dev_id) {
</I>&gt;<i> &gt; +   u16 irqstatus;
</I>&gt;<i> &gt; +   struct net_device *dev = (struct net_device *)dev_id;
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   irqstatus = priv-&gt;read_reg(priv, &amp;priv-&gt;regs-&gt;interrupt);
</I>&gt;<i> &gt; +   if (!irqstatus)
</I>&gt;<i> &gt; +           return IRQ_NONE;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* disable all interrupts and schedule the NAPI */
</I>&gt;<i> &gt; +   c_can_enable_all_interrupts(priv, DISABLE_ALL_INTERRUPTS);
</I>&gt;<i> &gt; +   napi_schedule(&amp;priv-&gt;napi);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return IRQ_HANDLED;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int c_can_open(struct net_device *dev) {
</I>&gt;<i> &gt; +   int err;
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* open the can device */
</I>&gt;<i> &gt; +   err = open_candev(dev);
</I>&gt;<i> &gt; +   if (err) {
</I>&gt;<i> &gt; +           netdev_err(dev, &quot;failed to open can device\n&quot;);
</I>&gt;<i> &gt; +           return err;
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* register interrupt handler */
</I>&gt;<i> &gt; +   err = request_irq(dev-&gt;irq, &amp;c_can_isr, IRQF_SHARED, dev-&gt;name,
</I>&gt;<i> &gt; +                           dev);
</I>&gt;<i> &gt; +   if (err &lt; 0) {
</I>&gt;<i> &gt; +           netdev_err(dev, &quot;failed to request interrupt\n&quot;);
</I>&gt;<i> &gt; +           goto exit_irq_fail;
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* start the c_can controller */
</I>&gt;<i> &gt; +   c_can_start(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   napi_enable(&amp;priv-&gt;napi);
</I>&gt;<i> &gt; +   netif_start_queue(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return 0;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +exit_irq_fail:
</I>&gt;<i> &gt; +   close_candev(dev);
</I>&gt;<i> &gt; +   return err;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int c_can_close(struct net_device *dev) {
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   netif_stop_queue(dev);
</I>&gt;<i> &gt; +   napi_disable(&amp;priv-&gt;napi);
</I>&gt;<i> &gt; +   c_can_stop(dev);
</I>&gt;<i> &gt; +   free_irq(dev-&gt;irq, dev);
</I>&gt;<i> &gt; +   close_candev(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +struct net_device *alloc_c_can_dev(void) {
</I>&gt;<i> &gt; +   struct net_device *dev;
</I>&gt;<i> &gt; +   struct c_can_priv *priv;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   dev = alloc_candev(sizeof(struct c_can_priv),
</I>&gt;<i> C_CAN_MSG_OBJ_TX_NUM);
</I>&gt;<i> &gt; +   if (!dev)
</I>&gt;<i> &gt; +           return NULL;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   priv = netdev_priv(dev);
</I>&gt;<i> &gt; +   netif_napi_add(dev, &amp;priv-&gt;napi, c_can_poll, C_CAN_NAPI_WEIGHT);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   priv-&gt;dev = dev;
</I>&gt;<i> &gt; +   priv-&gt;can.bittiming_const = &amp;c_can_bittiming_const;
</I>&gt;<i> &gt; +   priv-&gt;can.do_set_bittiming = c_can_set_bittiming;
</I>&gt;<i>
</I>&gt;<i> Please move the set_bittiming to the _open() or the _start() function.
</I>&gt;<i> See b156fd0483c8f18b3cc544d9c400fe454458e16a. So we can get rid of the
</I>&gt;<i> can.do_set_bittiming sooner or later.
</I>
Ok. Will make this change in V7.

&gt;<i> &gt; +   priv-&gt;can.do_set_mode = c_can_set_mode;
</I>&gt;<i> &gt; +   priv-&gt;can.do_get_berr_counter = c_can_get_berr_counter;
</I>&gt;<i> &gt; +   priv-&gt;can.ctrlmode_supported = CAN_CTRLMODE_ONE_SHOT |
</I>&gt;<i> &gt; +                                   CAN_CTRLMODE_LOOPBACK |
</I>&gt;<i> &gt; +                                   CAN_CTRLMODE_LISTENONLY |
</I>&gt;<i> &gt; +                                   CAN_CTRLMODE_BERR_REPORTING;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return dev;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +EXPORT_SYMBOL_GPL(alloc_c_can_dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +void free_c_can_dev(struct net_device *dev) {
</I>&gt;<i> &gt; +   free_candev(dev);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +EXPORT_SYMBOL_GPL(free_c_can_dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static const struct net_device_ops c_can_netdev_ops = {
</I>&gt;<i> &gt; +   .ndo_open = c_can_open,
</I>&gt;<i> &gt; +   .ndo_stop = c_can_close,
</I>&gt;<i> &gt; +   .ndo_start_xmit = c_can_start_xmit,
</I>&gt;<i> &gt; +};
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +int register_c_can_dev(struct net_device *dev) {
</I>&gt;<i> &gt; +   dev-&gt;flags |= IFF_ECHO; /* we support local echo */
</I>&gt;<i> &gt; +   dev-&gt;netdev_ops = &amp;c_can_netdev_ops;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return register_candev(dev);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +EXPORT_SYMBOL_GPL(register_c_can_dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +void unregister_c_can_dev(struct net_device *dev) {
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* disable all interrupts */
</I>&gt;<i> &gt; +   c_can_enable_all_interrupts(priv, DISABLE_ALL_INTERRUPTS);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   unregister_candev(dev);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +EXPORT_SYMBOL_GPL(unregister_c_can_dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +MODULE_AUTHOR(&quot;Bhupesh Sharma &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">bhupesh.sharma at st.com</A>&gt;&quot;);
</I>&gt;<i> &gt; +MODULE_LICENSE(&quot;GPL v2&quot;); MODULE_DESCRIPTION(&quot;CAN bus driver for
</I>&gt;<i> &gt; +Bosch C_CAN controller&quot;);
</I>&gt;<i> &gt; diff --git a/drivers/net/can/c_can/c_can.h
</I>&gt;<i> &gt; b/drivers/net/can/c_can/c_can.h new file mode 100644 index
</I>&gt;<i> &gt; 0000000..bd094e6
</I>&gt;<i> &gt; --- /dev/null
</I>&gt;<i> &gt; +++ b/drivers/net/can/c_can/c_can.h
</I>&gt;<i> &gt; @@ -0,0 +1,230 @@
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * CAN bus driver for Bosch C_CAN controller
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Copyright (C) 2010 ST Microelectronics
</I>&gt;<i> &gt; + * Bhupesh Sharma &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">bhupesh.sharma at st.com</A>&gt;
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Borrowed heavily from the C_CAN driver originally written by:
</I>&gt;<i> &gt; + * Copyright (C) 2007
</I>&gt;<i> &gt; + * - Sascha Hauer, Marc Kleine-Budde, Pengutronix
</I>&gt;<i> &gt; +&lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">s.hauer at pengutronix.de</A>&gt;
</I>&gt;<i> &gt; + * - Simon Kallweit, intefo AG &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">simon.kallweit at intefo.ch</A>&gt;
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Bosch C_CAN controller is compliant to CAN protocol version 2.0
</I>&gt;<i> part A and B.
</I>&gt;<i> &gt; + * Bosch C_CAN user manual can be obtained from:
</I>&gt;<i> &gt; + *
</I>&gt;<i> <A HREF="http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/">http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/</A>
</I>&gt;<i> &gt; + * users_manual_c_can.pdf
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * This file is licensed under the terms of the GNU General Public
</I>&gt;<i> &gt; + * License version 2. This program is licensed &quot;as is&quot; without any
</I>&gt;<i> &gt; + * warranty of any kind, whether express or implied.
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#ifndef C_CAN_H
</I>&gt;<i> &gt; +#define C_CAN_H
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* control register */
</I>&gt;<i> &gt; +#define CONTROL_TEST               BIT(7)
</I>&gt;<i> &gt; +#define CONTROL_CCE                BIT(6)
</I>&gt;<i> &gt; +#define CONTROL_DISABLE_AR BIT(5)
</I>&gt;<i> &gt; +#define CONTROL_ENABLE_AR  (0 &lt;&lt; 5)
</I>&gt;<i> &gt; +#define CONTROL_EIE                BIT(3)
</I>&gt;<i> &gt; +#define CONTROL_SIE                BIT(2)
</I>&gt;<i> &gt; +#define CONTROL_IE         BIT(1)
</I>&gt;<i> &gt; +#define CONTROL_INIT               BIT(0)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* test register */
</I>&gt;<i> &gt; +#define TEST_RX                    BIT(7)
</I>&gt;<i> &gt; +#define TEST_TX1           BIT(6)
</I>&gt;<i> &gt; +#define TEST_TX2           BIT(5)
</I>&gt;<i> &gt; +#define TEST_LBACK         BIT(4)
</I>&gt;<i> &gt; +#define TEST_SILENT                BIT(3)
</I>&gt;<i> &gt; +#define TEST_BASIC         BIT(2)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* status register */
</I>&gt;<i> &gt; +#define STATUS_BOFF                BIT(7)
</I>&gt;<i> &gt; +#define STATUS_EWARN               BIT(6)
</I>&gt;<i> &gt; +#define STATUS_EPASS               BIT(5)
</I>&gt;<i> &gt; +#define STATUS_RXOK                BIT(4)
</I>&gt;<i> &gt; +#define STATUS_TXOK                BIT(3)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* error counter register */
</I>&gt;<i> &gt; +#define ERR_CNT_TEC_MASK   0xff
</I>&gt;<i> &gt; +#define ERR_CNT_TEC_SHIFT  0
</I>&gt;<i> &gt; +#define ERR_CNT_REC_SHIFT  8
</I>&gt;<i> &gt; +#define ERR_CNT_REC_MASK   (0x7f &lt;&lt; ERR_CNT_REC_SHIFT)
</I>&gt;<i> &gt; +#define ERR_CNT_RP_SHIFT   15
</I>&gt;<i> &gt; +#define ERR_CNT_RP_MASK            (0x1 &lt;&lt; ERR_CNT_RP_SHIFT)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* bit-timing register */
</I>&gt;<i> &gt; +#define BTR_BRP_MASK               0x3f
</I>&gt;<i> &gt; +#define BTR_BRP_SHIFT              0
</I>&gt;<i> &gt; +#define BTR_SJW_SHIFT              6
</I>&gt;<i> &gt; +#define BTR_SJW_MASK               (0x3 &lt;&lt; BTR_SJW_SHIFT)
</I>&gt;<i> &gt; +#define BTR_TSEG1_SHIFT            8
</I>&gt;<i> &gt; +#define BTR_TSEG1_MASK             (0xf &lt;&lt; BTR_TSEG1_SHIFT)
</I>&gt;<i> &gt; +#define BTR_TSEG2_SHIFT            12
</I>&gt;<i> &gt; +#define BTR_TSEG2_MASK             (0x7 &lt;&lt; BTR_TSEG2_SHIFT)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* brp extension register */
</I>&gt;<i> &gt; +#define BRP_EXT_BRPE_MASK  0x0f
</I>&gt;<i> &gt; +#define BRP_EXT_BRPE_SHIFT 0
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* IFx command request */
</I>&gt;<i> &gt; +#define IF_COMR_BUSY               BIT(15)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* IFx command mask */
</I>&gt;<i> &gt; +#define IF_COMM_WR         BIT(7)
</I>&gt;<i> &gt; +#define IF_COMM_MASK               BIT(6)
</I>&gt;<i> &gt; +#define IF_COMM_ARB                BIT(5)
</I>&gt;<i> &gt; +#define IF_COMM_CONTROL            BIT(4)
</I>&gt;<i> &gt; +#define IF_COMM_CLR_INT_PND        BIT(3)
</I>&gt;<i> &gt; +#define IF_COMM_TXRQST             BIT(2)
</I>&gt;<i> &gt; +#define IF_COMM_DATAA              BIT(1)
</I>&gt;<i> &gt; +#define IF_COMM_DATAB              BIT(0)
</I>&gt;<i> &gt; +#define IF_COMM_ALL                (IF_COMM_MASK | IF_COMM_ARB | \
</I>&gt;<i> &gt; +                           IF_COMM_CONTROL | IF_COMM_TXRQST | \
</I>&gt;<i> &gt; +                           IF_COMM_DATAA | IF_COMM_DATAB)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* IFx arbitration */
</I>&gt;<i> &gt; +#define IF_ARB_MSGVAL              BIT(15)
</I>&gt;<i> &gt; +#define IF_ARB_MSGXTD              BIT(14)
</I>&gt;<i> &gt; +#define IF_ARB_TRANSMIT            BIT(13)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* IFx message control */
</I>&gt;<i> &gt; +#define IF_MCONT_NEWDAT            BIT(15)
</I>&gt;<i> &gt; +#define IF_MCONT_MSGLST            BIT(14)
</I>&gt;<i> &gt; +#define IF_MCONT_CLR_MSGLST        (0 &lt;&lt; 14)
</I>&gt;<i> &gt; +#define IF_MCONT_INTPND            BIT(13)
</I>&gt;<i> &gt; +#define IF_MCONT_UMASK             BIT(12)
</I>&gt;<i> &gt; +#define IF_MCONT_TXIE              BIT(11)
</I>&gt;<i> &gt; +#define IF_MCONT_RXIE              BIT(10)
</I>&gt;<i> &gt; +#define IF_MCONT_RMTEN             BIT(9)
</I>&gt;<i> &gt; +#define IF_MCONT_TXRQST            BIT(8)
</I>&gt;<i> &gt; +#define IF_MCONT_EOB               BIT(7)
</I>&gt;<i> &gt; +#define IF_MCONT_DLC_MASK  0xf
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * IFx register masks:
</I>&gt;<i> &gt; + * allow easy operation on 16-bit registers when the
</I>&gt;<i> &gt; + * argument is 32-bit instead
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +#define IFX_WRITE_LOW_16BIT(x)     ((x) &amp; 0xFFFF)
</I>&gt;<i> &gt; +#define IFX_WRITE_HIGH_16BIT(x)    (((x) &amp; 0xFFFF0000) &gt;&gt; 16)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* message object split */
</I>&gt;<i> &gt; +#define C_CAN_NO_OF_OBJECTS        32
</I>&gt;<i> &gt; +#define C_CAN_MSG_OBJ_RX_NUM       16
</I>&gt;<i> &gt; +#define C_CAN_MSG_OBJ_TX_NUM       16
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#define C_CAN_MSG_OBJ_RX_FIRST     1
</I>&gt;<i> &gt; +#define C_CAN_MSG_OBJ_RX_LAST      (C_CAN_MSG_OBJ_RX_FIRST + \
</I>&gt;<i> &gt; +                           C_CAN_MSG_OBJ_RX_NUM - 1)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#define C_CAN_MSG_OBJ_TX_FIRST     (C_CAN_MSG_OBJ_RX_LAST + 1)
</I>&gt;<i> &gt; +#define C_CAN_MSG_OBJ_TX_LAST      (C_CAN_MSG_OBJ_TX_FIRST + \
</I>&gt;<i> &gt; +                           C_CAN_MSG_OBJ_TX_NUM - 1)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#define C_CAN_MSG_OBJ_RX_SPLIT     9
</I>&gt;<i> &gt; +#define C_CAN_MSG_RX_LOW_LAST      (C_CAN_MSG_OBJ_RX_SPLIT - 1)
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#define C_CAN_NEXT_MSG_OBJ_MASK    (C_CAN_MSG_OBJ_TX_NUM - 1)
</I>&gt;<i> &gt; +#define RECEIVE_OBJECT_BITS        0x0000ffff
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* status interrupt */
</I>&gt;<i> &gt; +#define STATUS_INTERRUPT   0x8000
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* global interrupt masks */
</I>&gt;<i> &gt; +#define ENABLE_ALL_INTERRUPTS      1
</I>&gt;<i> &gt; +#define DISABLE_ALL_INTERRUPTS     0
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* minimum timeout for checking BUSY status */
</I>&gt;<i> &gt; +#define MIN_TIMEOUT_VALUE  6
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* napi related */
</I>&gt;<i> &gt; +#define C_CAN_NAPI_WEIGHT  C_CAN_MSG_OBJ_RX_NUM
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* c_can IF registers */
</I>&gt;<i> &gt; +struct c_can_if_regs {
</I>&gt;<i> &gt; +   u16 com_req;
</I>&gt;<i> &gt; +   u16 com_mask;
</I>&gt;<i> &gt; +   u16 mask1;
</I>&gt;<i> &gt; +   u16 mask2;
</I>&gt;<i> &gt; +   u16 arb1;
</I>&gt;<i> &gt; +   u16 arb2;
</I>&gt;<i> &gt; +   u16 msg_cntrl;
</I>&gt;<i> &gt; +   u16 data[4];
</I>&gt;<i> &gt; +   u16 _reserved[13];
</I>&gt;<i> &gt; +};
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* c_can hardware registers */
</I>&gt;<i> &gt; +struct c_can_regs {
</I>&gt;<i> &gt; +   u16 control;
</I>&gt;<i> &gt; +   u16 status;
</I>&gt;<i> &gt; +   u16 err_cnt;
</I>&gt;<i> &gt; +   u16 btr;
</I>&gt;<i> &gt; +   u16 interrupt;
</I>&gt;<i> &gt; +   u16 test;
</I>&gt;<i> &gt; +   u16 brp_ext;
</I>&gt;<i> &gt; +   u16 _reserved1;
</I>&gt;<i> &gt; +   struct c_can_if_regs ifregs[2]; /* [0] = IF1 and [1] = IF2 */
</I>&gt;<i> &gt; +   u16 _reserved2[8];
</I>&gt;<i> &gt; +   u16 txrqst1;
</I>&gt;<i> &gt; +   u16 txrqst2;
</I>&gt;<i> &gt; +   u16 _reserved3[6];
</I>&gt;<i> &gt; +   u16 newdat1;
</I>&gt;<i> &gt; +   u16 newdat2;
</I>&gt;<i> &gt; +   u16 _reserved4[6];
</I>&gt;<i> &gt; +   u16 intpnd1;
</I>&gt;<i> &gt; +   u16 intpnd2;
</I>&gt;<i> &gt; +   u16 _reserved5[6];
</I>&gt;<i> &gt; +   u16 msgval1;
</I>&gt;<i> &gt; +   u16 msgval2;
</I>&gt;<i> &gt; +   u16 _reserved6[6];
</I>&gt;<i> &gt; +};
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* c_can lec values */
</I>&gt;<i> &gt; +enum c_can_lec_type {
</I>&gt;<i> &gt; +   LEC_NO_ERROR = 0,
</I>&gt;<i> &gt; +   LEC_STUFF_ERROR,
</I>&gt;<i> &gt; +   LEC_FORM_ERROR,
</I>&gt;<i> &gt; +   LEC_ACK_ERROR,
</I>&gt;<i> &gt; +   LEC_BIT1_ERROR,
</I>&gt;<i> &gt; +   LEC_BIT0_ERROR,
</I>&gt;<i> &gt; +   LEC_CRC_ERROR,
</I>&gt;<i> &gt; +   LEC_UNUSED,
</I>&gt;<i> &gt; +};
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * c_can error types:
</I>&gt;<i> &gt; + * Bus errors (BUS_OFF, ERROR_WARNING, ERROR_PASSIVE) are supported
</I>&gt;<i> &gt; +*/ enum c_can_bus_error_types {
</I>&gt;<i> &gt; +   C_CAN_NO_ERROR = 0,
</I>&gt;<i> &gt; +   C_CAN_BUS_OFF,
</I>&gt;<i> &gt; +   C_CAN_ERROR_WARNING,
</I>&gt;<i> &gt; +   C_CAN_ERROR_PASSIVE,
</I>&gt;<i> &gt; +};
</I>&gt;<i>
</I>&gt;<i> nitpick: are the defines, enums and structs needed in more than one c
</I>&gt;<i> file? If not, please move them into the c-file where they are used.
</I>
Well most of the strcuts/defines are useful in both `c_can.c` and
`c_can_platform.c`, but I will explore how to separate the rest in
the respective c-files. But inititally we agreed to a *sja1000* like
approach and hence this placement in h-file.

&gt;<i> &gt; +
</I>&gt;<i> &gt; +/* c_can private data structure */
</I>&gt;<i> &gt; +struct c_can_priv {
</I>&gt;<i> &gt; +   struct can_priv can;    /* must be the first member */
</I>&gt;<i> &gt; +   struct napi_struct napi;
</I>&gt;<i> &gt; +   struct net_device *dev;
</I>&gt;<i> &gt; +   int tx_object;
</I>&gt;<i> &gt; +   int current_status;
</I>&gt;<i> &gt; +   int last_status;
</I>&gt;<i> &gt; +   u16 (*read_reg) (struct c_can_priv *priv, void *reg);
</I>&gt;<i> &gt; +   void (*write_reg) (struct c_can_priv *priv, void *reg, u16 val);
</I>&gt;<i> &gt; +   struct c_can_regs __iomem *regs;
</I>&gt;<i> &gt; +   unsigned long irq_flags; /* for request_irq() */
</I>&gt;<i> &gt; +   unsigned int tx_next;
</I>&gt;<i> &gt; +   unsigned int tx_echo;
</I>&gt;<i> &gt; +   void *priv;             /* for board-specific data */
</I>&gt;<i> &gt; +};
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +struct net_device *alloc_c_can_dev(void); void free_c_can_dev(struct
</I>&gt;<i> &gt; +net_device *dev); int register_c_can_dev(struct net_device *dev);
</I>&gt;<i> &gt; +void unregister_c_can_dev(struct net_device *dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#endif /* C_CAN_H */
</I>&gt;<i> &gt; diff --git a/drivers/net/can/c_can/c_can_platform.c
</I>&gt;<i> &gt; b/drivers/net/can/c_can/c_can_platform.c
</I>&gt;<i> &gt; new file mode 100644
</I>&gt;<i> &gt; index 0000000..0fc314e
</I>&gt;<i> &gt; --- /dev/null
</I>&gt;<i> &gt; +++ b/drivers/net/can/c_can/c_can_platform.c
</I>&gt;<i> &gt; @@ -0,0 +1,207 @@
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * Platform CAN bus driver for Bosch C_CAN controller
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Copyright (C) 2010 ST Microelectronics
</I>&gt;<i> &gt; + * Bhupesh Sharma &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">bhupesh.sharma at st.com</A>&gt;
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Borrowed heavily from the C_CAN driver originally written by:
</I>&gt;<i> &gt; + * Copyright (C) 2007
</I>&gt;<i> &gt; + * - Sascha Hauer, Marc Kleine-Budde, Pengutronix
</I>&gt;<i> &gt; +&lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">s.hauer at pengutronix.de</A>&gt;
</I>&gt;<i> &gt; + * - Simon Kallweit, intefo AG &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">simon.kallweit at intefo.ch</A>&gt;
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Bosch C_CAN controller is compliant to CAN protocol version 2.0
</I>&gt;<i> part A and B.
</I>&gt;<i> &gt; + * Bosch C_CAN user manual can be obtained from:
</I>&gt;<i> &gt; + *
</I>&gt;<i> <A HREF="http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/">http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/</A>
</I>&gt;<i> &gt; + * users_manual_c_can.pdf
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * This file is licensed under the terms of the GNU General Public
</I>&gt;<i> &gt; + * License version 2. This program is licensed &quot;as is&quot; without any
</I>&gt;<i> &gt; + * warranty of any kind, whether express or implied.
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#include &lt;linux/kernel.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/version.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/module.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/interrupt.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/delay.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/netdevice.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/if_arp.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/if_ether.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/list.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/delay.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/io.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/platform_device.h&gt;
</I>&gt;<i> &gt; +#include &lt;linux/clk.h&gt;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#include &lt;linux/can/dev.h&gt;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +#include &quot;c_can.h&quot;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * 16-bit c_can registers can be arranged differently in the memory
</I>&gt;<i> &gt; + * architecture of different implementations. For example: 16-bit
</I>&gt;<i> &gt; + * registers can be aligned to a 16-bit boundary or 32-bit boundary
</I>&gt;<i> etc.
</I>&gt;<i> &gt; + * Handle the same by providing a common read/write interface.
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +static u16 c_can_plat_read_reg_aligned_to_16bit(struct c_can_priv
</I>&gt;<i> *priv,
</I>&gt;<i> &gt; +                                           void *reg)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   return readw(reg);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void c_can_plat_write_reg_aligned_to_16bit(struct c_can_priv
</I>&gt;<i> *priv,
</I>&gt;<i> &gt; +                                           void *reg, u16 val)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   writew(val, reg);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static u16 c_can_plat_read_reg_aligned_to_32bit(struct c_can_priv
</I>&gt;<i> *priv,
</I>&gt;<i> &gt; +                                           void *reg)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   return readw(reg + (long)reg - (long)priv-&gt;regs); }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void c_can_plat_write_reg_aligned_to_32bit(struct c_can_priv
</I>&gt;<i> *priv,
</I>&gt;<i> &gt; +                                           void *reg, u16 val)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   writew(val, reg + (long)reg - (long)priv-&gt;regs); }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int __devinit c_can_plat_probe(struct platform_device *pdev)
</I>&gt;<i> {
</I>&gt;<i> &gt; +   int ret;
</I>&gt;<i> &gt; +   void __iomem *addr;
</I>&gt;<i> &gt; +   struct net_device *dev;
</I>&gt;<i> &gt; +   struct c_can_priv *priv;
</I>&gt;<i> &gt; +   struct resource *mem, *irq;
</I>&gt;<i> &gt; +   struct clk *clk;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* get the appropriate clk */
</I>&gt;<i> &gt; +   clk = clk_get(&amp;pdev-&gt;dev, NULL);
</I>&gt;<i> &gt; +   if (IS_ERR(clk)) {
</I>&gt;<i> &gt; +           dev_err(&amp;pdev-&gt;dev, &quot;no clock defined\n&quot;);
</I>&gt;<i> &gt; +           ret = -ENODEV;
</I>&gt;<i> &gt; +           goto exit;
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* get the platform data */
</I>&gt;<i> &gt; +   mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;<i> &gt; +   irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
</I>&gt;<i> &gt; +   if (!mem || (irq &lt;= 0)) {
</I>&gt;<i> &gt; +           ret = -ENODEV;
</I>&gt;<i> &gt; +           goto exit_free_clk;
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   if (!request_mem_region(mem-&gt;start, resource_size(mem),
</I>&gt;<i> &gt; +                           KBUILD_MODNAME)) {
</I>&gt;<i> &gt; +           dev_err(&amp;pdev-&gt;dev, &quot;resource unavailable\n&quot;);
</I>&gt;<i> &gt; +           ret = -ENODEV;
</I>&gt;<i> &gt; +           goto exit_free_clk;
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   addr = ioremap(mem-&gt;start, resource_size(mem));
</I>&gt;<i> &gt; +   if (!addr) {
</I>&gt;<i> &gt; +           dev_err(&amp;pdev-&gt;dev, &quot;failed to map can port\n&quot;);
</I>&gt;<i> &gt; +           ret = -ENOMEM;
</I>&gt;<i> &gt; +           goto exit_release_mem;
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   /* allocate the c_can device */
</I>&gt;<i> &gt; +   dev = alloc_c_can_dev();
</I>&gt;<i> &gt; +   if (!dev) {
</I>&gt;<i> &gt; +           ret = -ENOMEM;
</I>&gt;<i> &gt; +           goto exit_iounmap;
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   priv = netdev_priv(dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   dev-&gt;irq = irq-&gt;start;
</I>&gt;<i> &gt; +   priv-&gt;regs = addr;
</I>&gt;<i> &gt; +   priv-&gt;can.clock.freq = clk_get_rate(clk);
</I>&gt;<i> &gt; +   priv-&gt;priv = clk;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   switch (mem-&gt;flags &amp; IORESOURCE_MEM_TYPE_MASK) {
</I>&gt;<i> &gt; +   case IORESOURCE_MEM_32BIT:
</I>&gt;<i> &gt; +           priv-&gt;read_reg = c_can_plat_read_reg_aligned_to_32bit;
</I>&gt;<i> &gt; +           priv-&gt;write_reg = c_can_plat_write_reg_aligned_to_32bit;
</I>&gt;<i> &gt; +           break;
</I>&gt;<i> &gt; +   case IORESOURCE_MEM_16BIT:
</I>&gt;<i> &gt; +   default:
</I>&gt;<i> &gt; +           priv-&gt;read_reg = c_can_plat_read_reg_aligned_to_16bit;
</I>&gt;<i> &gt; +           priv-&gt;write_reg = c_can_plat_write_reg_aligned_to_16bit;
</I>&gt;<i> &gt; +           break;
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   platform_set_drvdata(pdev, dev);
</I>&gt;<i> &gt; +   SET_NETDEV_DEV(dev, &amp;pdev-&gt;dev);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   ret = register_c_can_dev(dev);
</I>&gt;<i> &gt; +   if (ret) {
</I>&gt;<i> &gt; +           dev_err(&amp;pdev-&gt;dev, &quot;registering %s failed (err=%d)\n&quot;,
</I>&gt;<i> &gt; +                   KBUILD_MODNAME, ret);
</I>&gt;<i> &gt; +           goto exit_free_device;
</I>&gt;<i> &gt; +   }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   dev_info(&amp;pdev-&gt;dev, &quot;%s device registered (regs=%p, irq=%d)\n&quot;,
</I>&gt;<i> &gt; +            KBUILD_MODNAME, priv-&gt;regs, dev-&gt;irq);
</I>&gt;<i> &gt; +   return 0;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +exit_free_device:
</I>&gt;<i> &gt; +   platform_set_drvdata(pdev, NULL);
</I>&gt;<i> &gt; +   free_c_can_dev(dev);
</I>&gt;<i> &gt; +exit_iounmap:
</I>&gt;<i> &gt; +   iounmap(addr);
</I>&gt;<i> &gt; +exit_release_mem:
</I>&gt;<i> &gt; +   release_mem_region(mem-&gt;start, resource_size(mem));
</I>&gt;<i> &gt; +exit_free_clk:
</I>&gt;<i> &gt; +   clk_put(clk);
</I>&gt;<i> &gt; +exit:
</I>&gt;<i> &gt; +   dev_err(&amp;pdev-&gt;dev, &quot;probe failed\n&quot;);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return ret;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int __devexit c_can_plat_remove(struct platform_device *pdev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +   struct net_device *dev = platform_get_drvdata(pdev);
</I>&gt;<i> &gt; +   struct c_can_priv *priv = netdev_priv(dev);
</I>&gt;<i> &gt; +   struct resource *mem;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   unregister_c_can_dev(dev);
</I>&gt;<i> &gt; +   platform_set_drvdata(pdev, NULL);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   free_c_can_dev(dev);
</I>&gt;<i> &gt; +   iounmap(priv-&gt;regs);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
</I>&gt;<i> &gt; +   release_mem_region(mem-&gt;start, resource_size(mem));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   clk_put(priv-&gt;priv);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +   return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static struct platform_driver c_can_plat_driver = {
</I>&gt;<i> &gt; +   .driver = {
</I>&gt;<i> &gt; +           .name = KBUILD_MODNAME,
</I>&gt;<i> &gt; +           .owner = THIS_MODULE,
</I>&gt;<i> &gt; +   },
</I>&gt;<i> &gt; +   .probe = c_can_plat_probe,
</I>&gt;<i> &gt; +   .remove = __devexit_p(c_can_plat_remove), };
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int __init c_can_plat_init(void) {
</I>&gt;<i> &gt; +   return platform_driver_register(&amp;c_can_plat_driver);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +module_init(c_can_plat_init);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static void __exit c_can_plat_exit(void) {
</I>&gt;<i> &gt; +   platform_driver_unregister(&amp;c_can_plat_driver);
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +module_exit(c_can_plat_exit);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +MODULE_AUTHOR(&quot;Bhupesh Sharma &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">bhupesh.sharma at st.com</A>&gt;&quot;);
</I>&gt;<i> &gt; +MODULE_LICENSE(&quot;GPL v2&quot;); MODULE_DESCRIPTION(&quot;Platform CAN bus
</I>&gt;<i> driver
</I>&gt;<i> &gt; +for Bosch C_CAN controller&quot;);
</I>&gt;<i>
</I>&gt;<i> regards, Marc
</I>
Regards,
Bhupesh

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005500.html">[PATCH net-next-2.6 v6 1/1] can: c_can: Added support for Bosch	C_CAN	controller
</A></li>
	<LI>Next message: <A HREF="005510.html">[PATCH net-next-2.6 v6 1/1] can: c_can: Added support for Bosch	C_CAN controller
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5501">[ date ]</a>
              <a href="thread.html#5501">[ thread ]</a>
              <a href="subject.html#5501">[ subject ]</a>
              <a href="author.html#5501">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
