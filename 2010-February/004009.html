<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [RFC v1] can: add support for Janz CAN board
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-core/2010-February/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BRFC%20v1%5D%20can%3A%20add%20support%20for%20Janz%20CAN%20board&In-Reply-To=%3C4B7311DE.7070403%40grandegger.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004010.html">
   <LINK REL="Next"  HREF="004012.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[RFC v1] can: add support for Janz CAN board</H1>
    <B>Wolfgang Grandegger</B> 
    <A HREF="mailto:socketcan-core%40lists.berlios.de?Subject=Re%3A%20%5BRFC%20v1%5D%20can%3A%20add%20support%20for%20Janz%20CAN%20board&In-Reply-To=%3C4B7311DE.7070403%40grandegger.com%3E"
       TITLE="[RFC v1] can: add support for Janz CAN board">wg at grandegger.com
       </A><BR>
    <I>Wed Feb 10 21:06:54 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="004010.html">[RFC v1] can: add support for Janz CAN board
</A></li>
        <LI>Next message: <A HREF="004012.html">[RFC v1] can: add support for Janz CAN board
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4009">[ date ]</a>
              <a href="thread.html#4009">[ thread ]</a>
              <a href="subject.html#4009">[ subject ]</a>
              <a href="author.html#4009">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Ira W. Snyder wrote:
&gt;<i> Hello all,
</I>&gt;<i> 
</I>&gt;<i> I posted last week asking about a driver for boards running on a PLX
</I>&gt;<i> chip. It turns out that these are passive boards. I have been looking
</I>&gt;<i> for a driver for the Janz CMOD-IO board CAN interfaces.
</I>&gt;<i> 
</I>&gt;<i> I finally found the datasheets and took the time to write a driver. This
</I>&gt;<i> board is an intelligent CAN interface: it has onboard microprocessors to
</I>&gt;<i> help process CAN traffic.
</I>&gt;<i> 
</I>&gt;<i> This is a very rough first try at a CAN driver. I'm sure it still has
</I>&gt;<i> problems, and I would appreciate if you can take a look and help me add
</I>&gt;<i> what is needed. I'm am not extremely knowledgeable about the CAN bus.
</I>&gt;<i> 
</I>&gt;<i> The things that are known to be wrong:
</I>&gt;<i> 
</I>&gt;<i> - bus-on / bus-off handling
</I>&gt;<i> 
</I>&gt;<i> I did this straight in the network device open()/stop() methods. I don't
</I>&gt;<i> handle the condition where we get too many bus errors and the bus goes
</I>&gt;<i> into bus-off state. What should I be doing here?
</I>&gt;<i> 
</I>&gt;<i> - state changes, bit timing, etc.
</I>&gt;<i> 
</I>&gt;<i> I'm not at all sure how this is supposed to work. Perhaps someone that
</I>&gt;<i> knows CAN bus better that I do can help.
</I>&gt;<i> 
</I>&gt;<i> - CAN bus termination
</I>&gt;<i> 
</I>&gt;<i> This board supports optionally terminating the CAN bus. In order to test
</I>&gt;<i> this driver, I connected both CAN modules on a single board together. To
</I>&gt;<i> get this to work, I needed to turn on termination on both modules.
</I>&gt;<i> 
</I>&gt;<i> Is this wrong? Is there a way to enable/disable termination via the &quot;ip&quot;
</I>&gt;<i> tool?
</I>&gt;<i> 
</I>&gt;<i> - module probing
</I>&gt;<i> 
</I>&gt;<i> This board is really a MODULbus carrier board, into which plugs 4
</I>&gt;<i> daughterboards. These can be CAN modules, or others. On my board, I have
</I>&gt;<i> 2x CAN modules and 1x TTL GPIO module. I need support for both of these
</I>&gt;<i> for my application. For the time being, I *did not* add support for the
</I>&gt;<i> TTL module. That will come once the CAN part is finished.
</I>&gt;<i> 
</I>&gt;<i> Also, there is no way I am aware of to determine what type of board is
</I>&gt;<i> plugged into which MODULbus slot on the carrier board. My CAN modules
</I>&gt;<i> support identification, but the TTL module does not.
</I>&gt;<i> 
</I>&gt;<i> I hard-coded the module layout into the driver itself. This is
</I>&gt;<i> sufficient for my purposes, but probably is not sufficient for mainline
</I>&gt;<i> Linux :'(. Any ideas or suggestions?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Any review will be much appreciated!
</I>
Will do a quick review...

You are using way to much dev_dbg() messages. OK for debugging, but you
should remove most of them for the final version.

&gt;<i> --------------------- cut here ----------------------
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * Janz PCI CAN Driver
</I>&gt;<i>  *
</I>&gt;<i>  * Copyright (c) 2010 Ira W. Snyder &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">iws at ovro.caltech.edu</A>&gt;
</I>&gt;<i>  *
</I>&gt;<i>  * This file is licensed under the terms of the GNU General Public License
</I>&gt;<i>  * version 2. This program is licensed &quot;as is&quot; without any warranty of any
</I>&gt;<i>  * kind, whether express or implied.
</I>&gt;<i>  */
</I>&gt;<i> 
</I>&gt;<i> #define DEBUG 1
</I>
You can enable DEBUG with the Kconfig option CONFIG_CAN_DEBUG_DEVICES.


&gt;<i> #include &lt;linux/kernel.h&gt;
</I>&gt;<i> #include &lt;linux/module.h&gt;
</I>&gt;<i> #include &lt;linux/init.h&gt;
</I>&gt;<i> #include &lt;linux/pci.h&gt;
</I>&gt;<i> #include &lt;linux/interrupt.h&gt;
</I>&gt;<i> #include &lt;linux/delay.h&gt;
</I>&gt;<i> 
</I>&gt;<i> #include &lt;linux/netdevice.h&gt;
</I>&gt;<i> #include &lt;linux/can.h&gt;
</I>&gt;<i> #include &lt;linux/can/dev.h&gt;
</I>&gt;<i> #include &lt;linux/can/error.h&gt;
</I>&gt;<i> 
</I>&gt;<i> static const char drv_name[] = &quot;janz&quot;;
</I>&gt;<i> 
</I>&gt;<i> /* PLX bridge chip onboard registers */
</I>&gt;<i> #define JANZ_OB_INT_STAT	0x1		/* read  access */
</I>&gt;<i> #define JANZ_OB_INT_DISABLE	0x1		/* write access */
</I>&gt;<i> #define JANZ_OB_MBUS_NUM	0x3		/* read  access */
</I>&gt;<i> #define JANZ_OB_INT_ENABLE	0x3		/* write access */
</I>&gt;<i> #define JANZ_OB_RESET_ASSERT	0x5		/* write access */
</I>&gt;<i> #define JANZ_OB_RESET_DEASSERT	0x7		/* write access */
</I>&gt;<i> #define JANZ_OB_EEP		0x9		/* rw access */
</I>&gt;<i> #define JANZ_OB_ENID		0xb		/* write access */
</I>&gt;<i> /* the DPM has 64k of memory, organized into 256x 256 byte pages */
</I>&gt;<i> #define DPM_NUM_PAGES		256
</I>&gt;<i> #define DPM_PAGE_SIZE		256
</I>&gt;<i> #define DPM_PAGE_ADDR(p)	((p) * DPM_PAGE_SIZE)
</I>&gt;<i> 
</I>&gt;<i> /* Janz &quot;old-style&quot; host interface control registers */
</I>&gt;<i> #define MSYNC_PEER		0x00		/* ICAN only */
</I>&gt;<i> #define MSYNC_LOCL		0x01		/* host only */
</I>&gt;<i> #define TARGET_RUNNING		0x02
</I>&gt;<i> 
</I>&gt;<i> /* Janz &quot;new-style&quot; host interface queue page numbers */
</I>&gt;<i> #define QUEUE_TOHOST		5
</I>&gt;<i> #define QUEUE_FROMHOST_MID	6
</I>&gt;<i> #define QUEUE_FROMHOST_HIGH	7
</I>&gt;<i> #define QUEUE_FROMHOST_LOW	8
</I>&gt;<i> 
</I>&gt;<i> /* Janz &quot;new-style&quot; and &quot;fast&quot; host interface descriptor flags */
</I>&gt;<i> #define DESC_VALID		0x80
</I>&gt;<i> #define DESC_WRAP		0x40
</I>&gt;<i> #define DESC_INTERRUPT		0x20
</I>&gt;<i> #define DESC_IVALID		0x10
</I>&gt;<i> #define DESC_LEN(len)		(len)
</I>&gt;<i> 
</I>&gt;<i> /* Janz Firmware Messages */
</I>&gt;<i> #define MSG_CONNECTI		0x02
</I>&gt;<i> #define MSG_DISCONNECT		0x03
</I>&gt;<i> #define MSG_IDVERS		0x04
</I>&gt;<i> #define MSG_MSGLOST		0x05
</I>&gt;<i> #define MSG_NEWHOSTIF		0x08
</I>&gt;<i> #define MSG_SETAFILMASK		0x10
</I>&gt;<i> #define MSG_INITFDPMQUEUE	0x11
</I>&gt;<i> #define MSG_HWCONF		0x12
</I>&gt;<i> #define MSG_FMSGLOST		0x15
</I>&gt;<i> #define MSG_CEVTIND		0x37
</I>&gt;<i> #define MSG_CBTRREQ		0x41
</I>&gt;<i> #define MSG_COFFREQ		0x42
</I>&gt;<i> #define MSG_CONREQ		0x43
</I>&gt;<i> 
</I>&gt;<i> /* Number of buffers for use in the &quot;new-style&quot; host interface */
</I>&gt;<i> #define JANZ_NEW_BUFFERS 16
</I>&gt;<i> 
</I>&gt;<i> /* Number of buffers for use in the &quot;fast&quot; host interface */
</I>&gt;<i> #define JANZ_FAST_BUFFERS 256
</I>&gt;<i> 
</I>&gt;<i> /* Maximum number of buffers on a CMOD-IO carrier board */
</I>&gt;<i> #define JANZ_MAX_MODULES 4
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * This is a terrible solution to an ugly problem
</I>&gt;<i>  *
</I>&gt;<i>  * The Janz CMOD-IO carrier board supports both MODULbus and MODULbus+
</I>&gt;<i>  * modules, however, only MODULbus+ modules are required to have a serial
</I>&gt;<i>  * EEPROM onboard for automatic identification.
</I>&gt;<i>  *
</I>&gt;<i>  * This means that it is impossible to detect which modules are actually
</I>&gt;<i>  * present on any one CMOD-IO board.
</I>&gt;<i>  *
</I>&gt;<i>  * I chose the solution that the user will have to change the defines below
</I>&gt;<i>  * to match their actual hardware. There isn't really anything else I can do.
</I>&gt;<i>  * This is sufficient for my purposes: all boards I own have the same
</I>&gt;<i>  * configuration.
</I>&gt;<i>  *
</I>&gt;<i>  * Janz's character driver does this setup via string module parameters,
</I>&gt;<i>  * which are fairly ugly to parse inside the kernel.
</I>&gt;<i>  */
</I>&gt;<i> 
</I>&gt;<i> /* Module Types */
</I>&gt;<i> #define JANZ_MODULE_NONE	0
</I>&gt;<i> #define JANZ_MODULE_TTL		1
</I>&gt;<i> #define JANZ_MODULE_ICAN3	2
</I>&gt;<i> 
</I>&gt;<i> /* Modules Present */
</I>&gt;<i> static const int janz_modules_present[JANZ_MAX_MODULES] = {
</I>&gt;<i> 	JANZ_MODULE_ICAN3,
</I>&gt;<i> 	JANZ_MODULE_ICAN3,
</I>&gt;<i> 	JANZ_MODULE_NONE,
</I>&gt;<i> 	JANZ_MODULE_TTL,
</I>&gt;<i> };
</I>
This could be specified via module parameter, e.g.

 insmod janz_pci.ko modues=ican3,ican3,,ttl

&gt;<i> struct janz_module {
</I>&gt;<i> 
</I>&gt;<i> 	/* must be the first member */
</I>&gt;<i> 	struct can_priv can;
</I>&gt;<i> 
</I>&gt;<i> 	/* CAN network device */
</I>&gt;<i> 	struct net_device *ndev;
</I>&gt;<i> 	struct napi_struct napi;
</I>&gt;<i> 
</I>&gt;<i> 	/* parent PCI device */
</I>&gt;<i> 	struct janz_device *parent;
</I>&gt;<i> 
</I>&gt;<i> 	/* module number */
</I>&gt;<i> 	unsigned int num;
</I>&gt;<i> 
</I>&gt;<i> 	/* base address of registers */
</I>&gt;<i> 	void __iomem *regs;
</I>&gt;<i> 
</I>&gt;<i> 	/* old and new style host interface */
</I>&gt;<i> 	unsigned int iftype;
</I>&gt;<i> 	spinlock_t lock;
</I>&gt;<i> 
</I>&gt;<i> 	/* new host interface */
</I>&gt;<i> 	unsigned int rx_int;
</I>&gt;<i> 	unsigned int rx_num;
</I>&gt;<i> 	unsigned int tx_num;
</I>&gt;<i> 
</I>&gt;<i> 	/* fast host interface */
</I>&gt;<i> 	unsigned int fastrx_start;
</I>&gt;<i> 	unsigned int fastrx_int;
</I>&gt;<i> 	unsigned int fastrx_num;
</I>&gt;<i> 	unsigned int fasttx_start;
</I>&gt;<i> 	unsigned int fasttx_num;
</I>&gt;<i> 
</I>&gt;<i> 	/* first free DPM page */
</I>&gt;<i> 	unsigned int free_page;
</I>&gt;<i> 
</I>&gt;<i> 	/* interrupt handling */
</I>&gt;<i> 	struct work_struct work;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> struct janz_device {
</I>&gt;<i> 	struct device *dev;
</I>&gt;<i> 	struct pci_dev *pdev;
</I>&gt;<i> 
</I>&gt;<i> 	void __iomem *control_regs;
</I>&gt;<i> 	void __iomem *modulbus_regs;
</I>&gt;<i> 	void __iomem *onboard_regs;
</I>&gt;<i> 
</I>&gt;<i> 	/* hex switch position */
</I>&gt;<i> 	u8 hex;
</I>
Not a good name, I think.

&gt;<i> 
</I>&gt;<i> 	struct janz_module *modules[JANZ_MAX_MODULES];
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> struct janz_msg {
</I>&gt;<i> 	u8 control;
</I>&gt;<i> 	u8 spec;
</I>&gt;<i> 	__le16 len;
</I>&gt;<i> 	u8 data[252];
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> struct janz_new_desc {
</I>&gt;<i> 	u8 control;
</I>&gt;<i> 	u8 pointer;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> struct janz_fast_desc {
</I>&gt;<i> 	u8 control;
</I>&gt;<i> 	u8 command;
</I>&gt;<i> 	u8 data[14];
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> /* Dual Ported Memory (DPM) Access                                            */
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>
This comment sytel is not OK according to the coding style.

&gt;<i> /*
</I>&gt;<i>  * The DPM has a fixed size of 64K byte, organized into 256x 256 byte pages
</I>&gt;<i>  *
</I>&gt;<i>  * You have a 0x200 byte view into DPM memory, split into two windows:
</I>&gt;<i>  *
</I>&gt;<i>  * 0x0000 - 0x00ff: DPM memory page
</I>&gt;<i>  * 0x0100 - 0x01ff: DPM control registers
</I>&gt;<i>  *
</I>&gt;<i>  * You can switch the page shown in the first window by using the control
</I>&gt;<i>  * registers. They also have other uses, not described here.
</I>&gt;<i>  */
</I>&gt;<i> 
</I>&gt;<i> static u8 janz_dpm_read8(struct janz_module *mod, unsigned int addr)
</I>&gt;<i> {
</I>&gt;<i> 	/* the DPM pages are only 256 bytes long */
</I>&gt;<i> 	BUG_ON(addr &gt;= DPM_PAGE_SIZE);
</I>&gt;<i> 	return ioread8(mod-&gt;regs + addr);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void janz_dpm_write8(struct janz_module *mod, unsigned int addr, u8 val)
</I>&gt;<i> {
</I>&gt;<i> 	/* the DPM pages are only 256 bytes long */
</I>&gt;<i> 	BUG_ON(addr &gt;= DPM_PAGE_SIZE);
</I>&gt;<i> 	iowrite8(val, mod-&gt;regs + addr);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> /* DPM Register Access                                                        */
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> 
</I>&gt;<i> /* write to the window basic address register */
</I>&gt;<i> static void janz_set_page(struct janz_module *mod, unsigned int page)
</I>&gt;<i> {
</I>&gt;<i> 	/* the DPM only has 256 pages */
</I>&gt;<i> 	BUG_ON(page &gt;= 256);
</I>&gt;<i> 	iowrite8(page, mod-&gt;regs + 0x100);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /* clear a MODULbus interrupt */
</I>&gt;<i> static void janz_clr_int(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	ioread8(mod-&gt;regs + 0x102);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> /* generate a MODULbus interrupt */
</I>&gt;<i> static void janz_set_int(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	iowrite8(0x01, mod-&gt;regs + 0x102);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> #if 0
</I>&gt;<i> /* generate a hardware reset on the ICAN3 */
</I>&gt;<i> static void janz_set_hwreset(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	iowrite8(0x01, mod-&gt;regs + 0x104);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /* generate a TPU interrupt on the ICAN3 */
</I>&gt;<i> static void janz_set_tpuint(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	iowrite8(0x01, mod-&gt;regs + 0x106);
</I>&gt;<i> }
</I>&gt;<i> #endif
</I>
I do not find these single line function really useful. Use a macro
definitions, inline functions or even better a structure to define your
register layout, e.g.:

	iwrite8(0x01, &amp;mod-&gt;regs-&gt;tpuint);

&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> /* Onboard Registers                                                          */
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> 
</I>&gt;<i> static void janz_disable_interrupts(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>
Here and in other similar cases you should insert an empty line.

&gt;<i> 	iowrite8(1 &lt;&lt; mod-&gt;num, priv-&gt;onboard_regs + JANZ_OB_INT_DISABLE);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void janz_enable_interrupts(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	iowrite8(1 &lt;&lt; mod-&gt;num, priv-&gt;onboard_regs + JANZ_OB_INT_ENABLE);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> #if 0
</I>&gt;<i> 
</I>&gt;<i> static inline void eep(struct janz_device *priv, u8 eck, u8 edio)
</I>&gt;<i> {
</I>&gt;<i> 	u8 d = ((eck &lt;&lt; 1) | (edio &amp; 1)) ^ 0x03;
</I>&gt;<i> 	iowrite8(d, priv-&gt;onboard_regs + JANZ_OB_EEP);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static inline void selhi(struct janz_device *priv, unsigned int mod)
</I>&gt;<i> {
</I>&gt;<i> 	iowrite8(1 &lt;&lt; mod, priv-&gt;onboard_regs + JANZ_OB_ENID);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static inline void selnone(struct janz_device *priv)
</I>&gt;<i> {
</I>&gt;<i> 	iowrite8(0x00, priv-&gt;onboard_regs + JANZ_OB_ENID);
</I>&gt;<i> }
</I>
Ditto

&gt;<i> /*
</I>&gt;<i>  * Read a MODULbus+ EEPROM on a module
</I>&gt;<i>  *
</I>&gt;<i>  * This requires generating waveforms in software, which is pretty
</I>&gt;<i>  * uncomfortable and unfriendly. For reasons stated above, this
</I>&gt;<i>  * is a useless feature anyway, since it doesn't work on non-MODULbus+
</I>&gt;<i>  * modules
</I>&gt;<i>  */
</I>&gt;<i> static void janz_read_module_id(struct janz_device *priv, unsigned int mod)
</I>&gt;<i> {
</I>&gt;<i> 	int i, cell;
</I>&gt;<i> 	u16 val;
</I>&gt;<i> 	u8 bit;
</I>&gt;<i> 
</I>&gt;<i> 	/
</I>
That made me think that it does not compile yet.

&gt;<i> 	/*
</I>&gt;<i> 	 * This requires that you generate EEPROM waveforms in software, making
</I>&gt;<i> 	 * it pretty much impractical. You need to use the ENID register to
</I>&gt;<i> 	 * enable the module id lines, and then use the EEP register to
</I>&gt;<i> 	 * generate the waveforms for the EEPROM. Painful.
</I>&gt;<i> 	 */
</I>&gt;<i> 
</I>&gt;<i> 	/* put the bus in an idle state */
</I>&gt;<i> 	selnone(priv);
</I>&gt;<i> 	eep(priv, 0, 1);
</I>&gt;<i> 
</I>&gt;<i> 	/* Chip Select the correct module */
</I>&gt;<i> 	selhi(priv, mod);
</I>&gt;<i> 
</I>&gt;<i> 	/* generate the start bit (data == 1) */
</I>&gt;<i> 	eep(priv, 1, 1);
</I>&gt;<i> 	eep(priv, 0, 1);
</I>&gt;<i> 
</I>&gt;<i> 	/* opcode 10 */
</I>&gt;<i> 	eep(priv, 1, 1);
</I>&gt;<i> 	eep(priv, 0, 1);
</I>&gt;<i> 
</I>&gt;<i> 	eep(priv, 1, 0);
</I>&gt;<i> 	eep(priv, 0, 0);
</I>&gt;<i> 
</I>&gt;<i> 	/* 6 address bits, all 0 */
</I>&gt;<i> 	eep(priv, 1, 0);
</I>&gt;<i> 	eep(priv, 0, 0);
</I>&gt;<i> 
</I>&gt;<i> 	eep(priv, 1, 0);
</I>&gt;<i> 	eep(priv, 0, 0);
</I>&gt;<i> 
</I>&gt;<i> 	eep(priv, 1, 0);
</I>&gt;<i> 	eep(priv, 0, 0);
</I>&gt;<i> 
</I>&gt;<i> 	eep(priv, 1, 0);
</I>&gt;<i> 	eep(priv, 0, 0);
</I>&gt;<i> 
</I>&gt;<i> 	eep(priv, 1, 0);
</I>&gt;<i> 	eep(priv, 0, 0);
</I>&gt;<i> 
</I>&gt;<i> 	eep(priv, 1, 0);
</I>&gt;<i> 	eep(priv, 0, 0);
</I>
This code could be shortend a lot by using some helper function and for
loops.

&gt;<i> 	/* tri-state the data line */
</I>&gt;<i> 	eep(priv, 0, 1);
</I>&gt;<i> 
</I>&gt;<i> 	for (cell = 0; cell &lt; 64; cell++) {
</I>&gt;<i> 
</I>&gt;<i> 		/* read 16 bits at a time */
</I>&gt;<i> 		val = 0;
</I>&gt;<i> 		for (i = 0; i &lt; 16; i++) {
</I>&gt;<i> 			eep(priv, 1, 1);
</I>&gt;<i> 			eep(priv, 0, 1);
</I>&gt;<i> 			bit = (ioread8(priv-&gt;onboard_regs + JANZ_OB_EEP) &amp; 0x01) ^ 0x01;
</I>&gt;<i> 			val |= (bit &lt;&lt; (15 - i));
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;%s: DATA16 CELL %d -&gt; %.4x\n&quot;, __func__, cell, val);
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* de-assert chip select, reset the data and clock lines */
</I>&gt;<i> 	selnone(priv);
</I>&gt;<i> 	eep(priv, 1, 1);
</I>&gt;<i> }
</I>&gt;<i> #endif
</I>&gt;<i> 
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> /* Janz &quot;old-style&quot; host interface                                            */
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * Get the MSYNC bits from the &quot;old-style&quot; interface control
</I>&gt;<i>  * registers
</I>&gt;<i>  */
</I>&gt;<i> static void janz_get_msync(struct janz_module *mod, u8 *locl, u8 *peer)
</I>&gt;<i> {
</I>&gt;<i> 	janz_set_page(mod, 0);
</I>&gt;<i> 	*peer = janz_dpm_read8(mod, MSYNC_PEER);
</I>&gt;<i> 	*locl = janz_dpm_read8(mod, MSYNC_LOCL);
</I>
I fould the following more readable and transparent:

	*perr = ioread8(&amp;mod-&gt;dpm_regs-&gt;mysnc_peer);

&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * Recieve a message from the Janz &quot;old-style&quot; firmware interface
</I>&gt;<i>  *
</I>&gt;<i>  * @priv: device private data
</I>&gt;<i>  * @mod: MODULbus module number
</I>&gt;<i>  * @msg: message buffer storage
</I>&gt;<i>  * @return: 0 on success, -ENOMEM when no message exists
</I>&gt;<i>  */
</I>&gt;<i> static int janz_old_recv_msg(struct janz_module *mod, struct janz_msg *msg)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	u8 locl, peer, xord;
</I>&gt;<i> 	unsigned int mbox;
</I>&gt;<i> 
</I>&gt;<i> 	/* get the MSYNC registers */
</I>&gt;<i> 	janz_get_msync(mod, &amp;locl, &amp;peer);
</I>&gt;<i> 	xord = locl ^ peer;
</I>&gt;<i> 
</I>&gt;<i> 	if ((xord &amp; 0x03) == 0x00) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;no mbox for reading\n&quot;);
</I>&gt;<i> 		return -ENOMEM;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* find the first free mbox to read */
</I>&gt;<i> 	if ((xord &amp; 0x03) == 0x03)
</I>&gt;<i> 		mbox = (xord &amp; 0x04) ? 0 : 1;
</I>&gt;<i> 	else
</I>&gt;<i> 		mbox = (xord &amp; 0x01) ? 0 : 1;
</I>&gt;<i> 
</I>&gt;<i> 	/* copy the message */
</I>&gt;<i> 	janz_set_page(mod, mbox + 1);
</I>&gt;<i> 	memcpy_fromio(msg, mod-&gt;regs, sizeof(*msg));
</I>&gt;<i> 
</I>&gt;<i> 	/*
</I>&gt;<i> 	 * notify the firmware that the read buffer is available
</I>&gt;<i> 	 * for it to fill again
</I>&gt;<i> 	 */
</I>&gt;<i> 	locl ^= (1 &lt;&lt; mbox);
</I>&gt;<i> 
</I>&gt;<i> 	janz_set_page(mod, 0);
</I>&gt;<i> 	janz_dpm_write8(mod, MSYNC_LOCL, locl);
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * Send a message through the &quot;old-style&quot; firmware interface
</I>&gt;<i>  *
</I>&gt;<i>  * @priv: device private data
</I>&gt;<i>  * @mod: MODULbus module number
</I>&gt;<i>  * @msg: message buffer storage
</I>&gt;<i>  * @return: 0 on success, -ENOMEM when no free space exists
</I>&gt;<i>  */
</I>
Either use doc books style documentation consistantly or drop it.

&gt;<i> static int janz_old_send_msg(struct janz_module *mod, struct janz_msg *msg)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	u8 locl, peer, xord;
</I>&gt;<i> 	unsigned int mbox;
</I>&gt;<i> 
</I>&gt;<i> 	/* get the MSYNC registers */
</I>&gt;<i> 	janz_get_msync(mod, &amp;locl, &amp;peer);
</I>&gt;<i> 	xord = locl ^ peer;
</I>&gt;<i> 
</I>&gt;<i> 	if ((xord &amp; 0x30) == 0x30) {
</I>&gt;<i> 		dev_err(priv-&gt;dev, &quot;no mbox for writing\n&quot;);
</I>&gt;<i> 		return -ENOMEM;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* calculate a free mbox to use */
</I>&gt;<i> 	mbox = (xord &amp; 0x10) ? 1 : 0;
</I>&gt;<i> 
</I>&gt;<i> 	/* copy the message to the DPM */
</I>&gt;<i> 	janz_set_page(mod, mbox + 3);
</I>&gt;<i> 	memcpy_toio(mod-&gt;regs, msg, sizeof(*msg));
</I>&gt;<i> 
</I>&gt;<i> 	locl ^= (mbox == 0) ? 0x10 : 0x20;
</I>&gt;<i> 	locl |= (mbox == 0) ? 0x00 : 0x40;
</I>&gt;<i> 
</I>&gt;<i> 	janz_set_page(mod, 0);
</I>&gt;<i> 	janz_dpm_write8(mod, MSYNC_LOCL, locl);
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> /* Janz &quot;new-style&quot; Host Interface Setup                                      */
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> 
</I>&gt;<i> static void janz_init_new_host_interface(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	struct janz_new_desc desc;
</I>&gt;<i> 	unsigned long flags;
</I>&gt;<i> 	void __iomem *dst;
</I>&gt;<i> 	int i;
</I>&gt;<i> 
</I>&gt;<i> 	spin_lock_irqsave(&amp;mod-&gt;lock, flags);
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: starting at page %d\n&quot;, __func__, mod-&gt;free_page);
</I>&gt;<i> 
</I>&gt;<i> 	/* setup the internal datastructures for RX */
</I>&gt;<i> 	mod-&gt;rx_num = 0;
</I>&gt;<i> 	mod-&gt;rx_int = 0;
</I>&gt;<i> 
</I>&gt;<i> 	/* tohost queue descriptors are in page 5 */
</I>&gt;<i> 	janz_set_page(mod, 5);
</I>&gt;<i> 	dst = mod-&gt;regs;
</I>&gt;<i> 
</I>&gt;<i> 	/* initialize the tohost (rx) queue descriptors: pages 9-24 */
</I>&gt;<i> 	for (i = 0; i &lt; JANZ_NEW_BUFFERS; i++) {
</I>&gt;<i> 		desc.control = DESC_INTERRUPT | DESC_LEN(1); /* I L=1 */
</I>&gt;<i> 		desc.pointer = mod-&gt;free_page;
</I>&gt;<i> 
</I>&gt;<i> 		/* set wrap flag on last buffer */
</I>&gt;<i> 		if (i == JANZ_NEW_BUFFERS - 1)
</I>&gt;<i> 			desc.control |= DESC_WRAP;
</I>&gt;<i> 
</I>&gt;<i> 		memcpy_toio(dst, &amp;desc, sizeof(desc));
</I>&gt;<i> 		dst += sizeof(desc);
</I>&gt;<i> 		mod-&gt;free_page++;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* fromhost (tx) mid queue descriptors are in page 6 */
</I>&gt;<i> 	janz_set_page(mod, 6);
</I>&gt;<i> 	dst = mod-&gt;regs;
</I>&gt;<i> 
</I>&gt;<i> 	/* setup the internal datastructures for TX */
</I>&gt;<i> 	mod-&gt;tx_num = 0;
</I>&gt;<i> 
</I>&gt;<i> 	/* initialize the fromhost mid queue descriptors: pages 25-40 */
</I>&gt;<i> 	for (i = 0; i &lt; JANZ_NEW_BUFFERS; i++) {
</I>&gt;<i> 		desc.control = DESC_VALID | DESC_LEN(1); /* V L=1 */
</I>&gt;<i> 		desc.pointer = mod-&gt;free_page;
</I>&gt;<i> 
</I>&gt;<i> 		/* set wrap flag on last buffer */
</I>&gt;<i> 		if (i == JANZ_NEW_BUFFERS - 1)
</I>&gt;<i> 			desc.control |= DESC_WRAP;
</I>&gt;<i> 
</I>&gt;<i> 		memcpy_toio(dst, &amp;desc, sizeof(desc));
</I>&gt;<i> 		dst += sizeof(desc);
</I>&gt;<i> 		mod-&gt;free_page++;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* fromhost hi queue descriptors are in page 7 */
</I>&gt;<i> 	janz_set_page(mod, 7);
</I>&gt;<i> 	dst = mod-&gt;regs;
</I>&gt;<i> 
</I>&gt;<i> 	/* initialize only a single buffer in the fromhost hi queue (unused) */
</I>&gt;<i> 	desc.control = DESC_VALID | DESC_WRAP | DESC_LEN(1); /* VW L=1 */
</I>&gt;<i> 	desc.pointer = mod-&gt;free_page;
</I>&gt;<i> 	memcpy_toio(dst, &amp;desc, sizeof(desc));
</I>&gt;<i> 	mod-&gt;free_page++;
</I>&gt;<i> 
</I>&gt;<i> 	/* fromhost low queue descriptors are in page 8 */
</I>&gt;<i> 	janz_set_page(mod, 8);
</I>&gt;<i> 	dst = mod-&gt;regs;
</I>&gt;<i> 
</I>&gt;<i> 	/* initialize only a single buffer in the fromhost low queue (unused) */
</I>&gt;<i> 	desc.control = DESC_VALID | DESC_WRAP | DESC_LEN(1); /* VW L=1 */
</I>&gt;<i> 	desc.pointer = mod-&gt;free_page;
</I>&gt;<i> 	memcpy_toio(dst, &amp;desc, sizeof(desc));
</I>&gt;<i> 	mod-&gt;free_page++;
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: next free page %d\n&quot;, __func__, mod-&gt;free_page);
</I>&gt;<i> 	spin_unlock_irqrestore(&amp;mod-&gt;lock, flags);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> /* Janz Fast Host Interface Setup                                             */
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> 
</I>&gt;<i> static void janz_init_fast_host_interface(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	struct janz_fast_desc desc;
</I>&gt;<i> 	unsigned long flags;
</I>&gt;<i> 	unsigned int addr;
</I>&gt;<i> 	void __iomem *dst;
</I>&gt;<i> 	int i;
</I>&gt;<i> 
</I>&gt;<i> 	spin_lock_irqsave(&amp;mod-&gt;lock, flags);
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: starting at page %d\n&quot;, __func__, mod-&gt;free_page);
</I>&gt;<i> 
</I>&gt;<i> 	/* save the start recv page */
</I>&gt;<i> 	mod-&gt;fastrx_start = mod-&gt;free_page;
</I>&gt;<i> 	mod-&gt;fastrx_num   = 0;
</I>&gt;<i> 	mod-&gt;fastrx_int   = 0;
</I>&gt;<i> 
</I>&gt;<i> 	/* build a single fast tohost queue descriptor */
</I>&gt;<i> 	memset(&amp;desc, 0, sizeof(desc));
</I>&gt;<i> 	desc.control = 0x00;
</I>&gt;<i> 	desc.command = 1;
</I>&gt;<i> 
</I>&gt;<i> 	/* build the tohost queue descriptor ring in memory */
</I>&gt;<i> 	addr = 0;
</I>&gt;<i> 	for (i = 0; i &lt; JANZ_FAST_BUFFERS; i++) {
</I>&gt;<i> 
</I>&gt;<i> 		/* set the wrap bit on the last buffer */
</I>&gt;<i> 		if (i == JANZ_FAST_BUFFERS - 1)
</I>&gt;<i> 			desc.control |= DESC_WRAP;
</I>&gt;<i> 
</I>&gt;<i> 		/* switch to the correct page */
</I>&gt;<i> 		janz_set_page(mod, mod-&gt;free_page);
</I>&gt;<i> 
</I>&gt;<i> 		/* copy the descriptor to the DPM */
</I>&gt;<i> 		dst = mod-&gt;regs + addr;
</I>&gt;<i> 		memcpy_toio(dst, &amp;desc, sizeof(desc));
</I>&gt;<i> 		addr += sizeof(desc);
</I>&gt;<i> 
</I>&gt;<i> 		/* move to the next page if necessary */
</I>&gt;<i> 		if (addr &gt;= 256) {
</I>&gt;<i> 			addr = 0;
</I>&gt;<i> 			mod-&gt;free_page++;
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* make sure we page-align the next queue */
</I>&gt;<i> 	if (addr != 0)
</I>&gt;<i> 		mod-&gt;free_page++;
</I>&gt;<i> 
</I>&gt;<i> 	/* save the start xmit page */
</I>&gt;<i> 	mod-&gt;fasttx_start = mod-&gt;free_page;
</I>&gt;<i> 	mod-&gt;fasttx_num   = 0;
</I>&gt;<i> 
</I>&gt;<i> 	/* build a single fast fromhost queue descriptor */
</I>&gt;<i> 	memset(&amp;desc, 0, sizeof(desc));
</I>&gt;<i> 	desc.control = DESC_VALID;
</I>&gt;<i> 	desc.command = 1;
</I>&gt;<i> 
</I>&gt;<i> 	/* build the fromhost queue descriptor ring in memory */
</I>&gt;<i> 	addr = 0;
</I>&gt;<i> 	for (i = 0; i &lt; JANZ_FAST_BUFFERS; i++) {
</I>&gt;<i> 
</I>&gt;<i> 		/* set the wrap bit on the last buffer */
</I>&gt;<i> 		if (i == JANZ_FAST_BUFFERS - 1)
</I>&gt;<i> 			desc.control |= DESC_WRAP;
</I>&gt;<i> 
</I>&gt;<i> 		/* switch to the correct page */
</I>&gt;<i> 		janz_set_page(mod, mod-&gt;free_page);
</I>&gt;<i> 
</I>&gt;<i> 		/* copy the descriptor to the DPM */
</I>&gt;<i> 		dst = mod-&gt;regs + addr;
</I>&gt;<i> 		memcpy_toio(dst, &amp;desc, sizeof(desc));
</I>&gt;<i> 		addr += sizeof(desc);
</I>&gt;<i> 
</I>&gt;<i> 		/* move to the next page if necessary */
</I>&gt;<i> 		if (addr &gt;= 256) {
</I>&gt;<i> 			addr = 0;
</I>&gt;<i> 			mod-&gt;free_page++;
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: next free page %d\n&quot;, __func__, mod-&gt;free_page);
</I>&gt;<i> 	spin_unlock_irqrestore(&amp;mod-&gt;lock, flags);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> /* Janz &quot;new-style&quot; Host Interface Message Helpers                            */
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * LOCKING: must hold mod-&gt;lock
</I>&gt;<i>  */
</I>&gt;<i> static int janz_new_send_msg(struct janz_module *mod, struct janz_msg *msg)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_new_desc desc;
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	void __iomem *desc_addr = mod-&gt;regs + (mod-&gt;tx_num * sizeof(desc));
</I>&gt;<i> 
</I>&gt;<i> 	/* switch to the fromhost mid queue, and read the buffer descriptor */
</I>&gt;<i> 	janz_set_page(mod, 6);
</I>&gt;<i> 	memcpy_fromio(&amp;desc, desc_addr, sizeof(desc));
</I>&gt;<i> 
</I>&gt;<i> 	if (!(desc.control &amp; DESC_VALID)) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;%s: no free buffers\n&quot;, __func__);
</I>&gt;<i> 		return -ENOMEM;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* switch to the data page, copy the data */
</I>&gt;<i> 	janz_set_page(mod, desc.pointer);
</I>&gt;<i> 	memcpy_toio(mod-&gt;regs, msg, sizeof(*msg));
</I>&gt;<i> 
</I>&gt;<i> 	/* switch back to the descriptor, set the valid bit, write it back */
</I>&gt;<i> 	janz_set_page(mod, 6);
</I>&gt;<i> 	desc.control ^= DESC_VALID;
</I>&gt;<i> 	memcpy_toio(desc_addr, &amp;desc, sizeof(desc));
</I>&gt;<i> 
</I>&gt;<i> 	/* update the tx number */
</I>&gt;<i> 	mod-&gt;tx_num = (desc.control &amp; DESC_WRAP) ? 0 : (mod-&gt;tx_num + 1);
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: update TX num -&gt; %d\n&quot;, __func__, mod-&gt;tx_num);
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * LOCKING: must hold mod-&gt;lock
</I>&gt;<i>  */
</I>&gt;<i> static int janz_new_recv_msg(struct janz_module *mod, struct janz_msg *msg)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_new_desc desc;
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	void __iomem *desc_addr = mod-&gt;regs + (mod-&gt;rx_num * sizeof(desc));
</I>&gt;<i> 
</I>&gt;<i> 	/* switch to the tohost queue, and read the buffer descriptor */
</I>&gt;<i> 	janz_set_page(mod, 5);
</I>&gt;<i> 	memcpy_fromio(&amp;desc, desc_addr, sizeof(desc));
</I>&gt;<i> 
</I>&gt;<i> 	if (!(desc.control &amp; DESC_VALID)) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;%s: no buffers to recv\n&quot;, __func__);
</I>&gt;<i> 		return -ENOMEM;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* switch to the data page, copy the data */
</I>&gt;<i> 	janz_set_page(mod, desc.pointer);
</I>&gt;<i> 	memcpy_fromio(msg, mod-&gt;regs, sizeof(*msg));
</I>&gt;<i> 
</I>&gt;<i> 	/* switch back to the descriptor, toggle the valid bit, write it back */
</I>&gt;<i> 	janz_set_page(mod, 5);
</I>&gt;<i> 	desc.control ^= DESC_VALID;
</I>&gt;<i> 	memcpy_toio(desc_addr, &amp;desc, sizeof(desc));
</I>&gt;<i> 
</I>&gt;<i> 	/* update the rx number */
</I>&gt;<i> 	mod-&gt;rx_num = (desc.control &amp; DESC_WRAP) ? 0 : (mod-&gt;rx_num + 1);
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: update RX num -&gt; %d\n&quot;, __func__, mod-&gt;rx_num);
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> /* Message Send / Recv Helpers                                                */
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> 
</I>&gt;<i> static int janz_send_msg(struct janz_module *mod, struct janz_msg *msg)
</I>&gt;<i> {
</I>&gt;<i> 	unsigned long flags;
</I>&gt;<i> 	int ret;
</I>&gt;<i> 
</I>&gt;<i> 	spin_lock_irqsave(&amp;mod-&gt;lock, flags);
</I>&gt;<i> 
</I>&gt;<i> 	if (mod-&gt;iftype == 0)
</I>&gt;<i> 		ret = janz_old_send_msg(mod, msg);
</I>&gt;<i> 	else
</I>&gt;<i> 		ret = janz_new_send_msg(mod, msg);
</I>&gt;<i> 
</I>&gt;<i> 	spin_unlock_irqrestore(&amp;mod-&gt;lock, flags);
</I>&gt;<i> 	return ret;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static int janz_recv_msg(struct janz_module *mod, struct janz_msg *msg)
</I>&gt;<i> {
</I>&gt;<i> 	unsigned long flags;
</I>&gt;<i> 	int ret;
</I>&gt;<i> 
</I>&gt;<i> 	spin_lock_irqsave(&amp;mod-&gt;lock, flags);
</I>&gt;<i> 
</I>&gt;<i> 	if (mod-&gt;iftype == 0)
</I>&gt;<i> 		ret = janz_old_recv_msg(mod, msg);
</I>&gt;<i> 	else
</I>&gt;<i> 		ret = janz_new_recv_msg(mod, msg);
</I>&gt;<i> 
</I>&gt;<i> 	spin_unlock_irqrestore(&amp;mod-&gt;lock, flags);
</I>&gt;<i> 	return ret;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> /* Quick Pre-constructed Messages                                             */
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> 
</I>&gt;<i> static int janz_msg_connect(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	struct janz_msg msg;
</I>&gt;<i> 	int ret;
</I>&gt;<i> 
</I>&gt;<i> 	memset(&amp;msg, 0, sizeof(msg));
</I>&gt;<i> 	msg.control = 0x00;
</I>&gt;<i> 	msg.spec    = MSG_CONNECTI;
</I>&gt;<i> 	msg.len     = cpu_to_le16(0);
</I>&gt;<i> 
</I>&gt;<i> 	ret = janz_send_msg(mod, &amp;msg);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;unable to send CONNECT message\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static int janz_msg_disconnect(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	struct janz_msg msg;
</I>&gt;<i> 	int ret;
</I>&gt;<i> 
</I>&gt;<i> 	memset(&amp;msg, 0, sizeof(msg));
</I>&gt;<i> 	msg.control = 0x00;
</I>&gt;<i> 	msg.spec    = MSG_DISCONNECT;
</I>&gt;<i> 	msg.len     = cpu_to_le16(0);
</I>&gt;<i> 
</I>&gt;<i> 	ret = janz_send_msg(mod, &amp;msg);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;unable to send DISCONNECT message\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>
I see duplicated code above.

&gt;<i> static int janz_msg_newhostif(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	struct janz_msg msg;
</I>&gt;<i> 	int ret;
</I>&gt;<i> 
</I>&gt;<i> 	memset(&amp;msg, 0, sizeof(msg));
</I>&gt;<i> 	msg.control = 0x00;
</I>&gt;<i> 	msg.spec    = MSG_NEWHOSTIF;
</I>&gt;<i> 	msg.len     = cpu_to_le16(0);
</I>&gt;<i> 
</I>&gt;<i> 	/* If we're not using the old interface, switching seems bogus */
</I>&gt;<i> 	WARN_ON(mod-&gt;iftype != 0);
</I>&gt;<i> 
</I>&gt;<i> 	ret = janz_send_msg(mod, &amp;msg);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;unable to send NEWHOSTIF message\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* mark the module as using the new host interface */
</I>&gt;<i> 	mod-&gt;iftype = 1;
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static int janz_msg_fasthostif(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	struct janz_msg msg;
</I>&gt;<i> 	unsigned int addr;
</I>&gt;<i> 	int ret;
</I>&gt;<i> 
</I>&gt;<i> 	memset(&amp;msg, 0, sizeof(msg));
</I>&gt;<i> 	msg.control = 0x00;
</I>&gt;<i> 	msg.spec    = MSG_INITFDPMQUEUE;
</I>&gt;<i> 	msg.len     = cpu_to_le16(8);
</I>&gt;<i> 
</I>&gt;<i> 	/* write the tohost queue start address */
</I>&gt;<i> 	addr = DPM_PAGE_ADDR(mod-&gt;fastrx_start);
</I>&gt;<i> 	msg.data[0] = addr &amp; 0xff;
</I>&gt;<i> 	msg.data[1] = (addr &gt;&gt; 8) &amp; 0xff;
</I>&gt;<i> 	msg.data[2] = (addr &gt;&gt; 16) &amp; 0xff;
</I>&gt;<i> 	msg.data[3] = (addr &gt;&gt; 24) &amp; 0xff;
</I>&gt;<i> 
</I>&gt;<i> 	/* write the fromhost queue start address */
</I>&gt;<i> 	addr = DPM_PAGE_ADDR(mod-&gt;fasttx_start);
</I>&gt;<i> 	msg.data[4] = addr &amp; 0xff;
</I>&gt;<i> 	msg.data[5] = (addr &gt;&gt; 8) &amp; 0xff;
</I>&gt;<i> 	msg.data[6] = (addr &gt;&gt; 16) &amp; 0xff;
</I>&gt;<i> 	msg.data[7] = (addr &gt;&gt; 24) &amp; 0xff;
</I>&gt;<i> 
</I>&gt;<i> 	/* If we're not using the new interface yet, we cannot do this */
</I>&gt;<i> 	WARN_ON(mod-&gt;iftype != 1);
</I>&gt;<i> 
</I>&gt;<i> 	ret = janz_send_msg(mod, &amp;msg);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;unable to send FASTHOSTIF message\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * Setup the CAN filter to either accept or reject all
</I>&gt;<i>  * messages from the CAN bus.
</I>&gt;<i>  */
</I>&gt;<i> static int janz_set_id_filter(struct janz_module *mod, bool accept)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	struct janz_msg msg;
</I>&gt;<i> 	int ret;
</I>&gt;<i> 
</I>&gt;<i> 	/* Standard Frame Format */
</I>&gt;<i> 	memset(&amp;msg, 0, sizeof(msg));
</I>&gt;<i> 	msg.control = 0x00;
</I>&gt;<i> 	msg.spec    = MSG_SETAFILMASK;
</I>&gt;<i> 	msg.len     = cpu_to_le16(5);
</I>&gt;<i> 	msg.data[0] = 0x00; /* IDLo LSB */
</I>&gt;<i> 	msg.data[1] = 0x00; /* IDLo MSB */
</I>&gt;<i> 	msg.data[2] = 0xff; /* IDHi LSB */
</I>&gt;<i> 	msg.data[3] = 0x07; /* IDHi MSB */
</I>&gt;<i> 
</I>&gt;<i> 	/* accept all frames for fast host if, or reject all frames */
</I>&gt;<i> 	msg.data[4] = accept ? 0x02 : 0x00;
</I>&gt;<i> 
</I>&gt;<i> 	ret = janz_send_msg(mod, &amp;msg);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;unable to send SETAFILMASK message\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* Extended Frame Format */
</I>&gt;<i> 	memset(&amp;msg, 0, sizeof(msg));
</I>&gt;<i> 	msg.control = 0x00;
</I>&gt;<i> 	msg.spec    = MSG_SETAFILMASK;
</I>&gt;<i> 	msg.len     = cpu_to_le16(13);
</I>&gt;<i> 	msg.data[0] = 0;    /* MUX = 0 */
</I>&gt;<i> 	msg.data[1] = 0x00; /* IDLo LSB */
</I>&gt;<i> 	msg.data[2] = 0x00;
</I>&gt;<i> 	msg.data[3] = 0x00;
</I>&gt;<i> 	msg.data[4] = 0x20; /* IDLo MSB */
</I>&gt;<i> 	msg.data[5] = 0xff; /* IDHi LSB */
</I>&gt;<i> 	msg.data[6] = 0xff;
</I>&gt;<i> 	msg.data[7] = 0xff;
</I>&gt;<i> 	msg.data[8] = 0x3f; /* IDHi MSB */
</I>&gt;<i> 
</I>&gt;<i> 	/* accept all frames for fast host if, or reject all frames */
</I>&gt;<i> 	msg.data[9] = accept ? 0x02 : 0x00;
</I>&gt;<i> 
</I>&gt;<i> 	ret = janz_send_msg(mod, &amp;msg);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;unable to send SETAFILMASK message\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * Bring the CAN bus online or offline
</I>&gt;<i>  */
</I>&gt;<i> static int janz_set_bus_state(struct janz_module *mod, bool on)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	struct janz_msg msg;
</I>&gt;<i> 	int ret;
</I>&gt;<i> 
</I>&gt;<i> 	memset(&amp;msg, 0, sizeof(msg));
</I>&gt;<i> 	msg.control = 0x00;
</I>&gt;<i> 	msg.spec    = on ? MSG_CONREQ : MSG_COFFREQ;
</I>&gt;<i> 	msg.len     = cpu_to_le16(0);
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: %s request: spec %.2x\n&quot;, __func__, on ? &quot;on&quot; : &quot;off&quot;, msg.spec);
</I>&gt;<i> 	ret = janz_send_msg(mod, &amp;msg);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;unable to send CONREQ/COFFREQ message\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>
Other controllers use the name reset/init mode and normal mode-

&gt;<i> 
</I>&gt;<i> static int janz_set_termination(struct janz_module *mod, bool on)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	struct janz_msg msg;
</I>&gt;<i> 	int ret;
</I>&gt;<i> 
</I>&gt;<i> 	memset(&amp;msg, 0, sizeof(msg));
</I>&gt;<i> 	msg.control = 0x00;
</I>&gt;<i> 	msg.spec    = MSG_HWCONF;
</I>&gt;<i> 	msg.len     = cpu_to_le16(2);
</I>&gt;<i> 	msg.data[0] = 0x00;
</I>&gt;<i> 	msg.data[1] = on ? 0x01 : 0x00;
</I>&gt;<i> 
</I>&gt;<i> 	ret = janz_send_msg(mod, &amp;msg);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;unable to send HWCONF message\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> /* Interrupt Handling                                                         */
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> 
</I>&gt;<i> static void janz_handle_idvers(struct janz_module *mod, struct janz_msg *msg)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: %s\n&quot;, __func__, msg-&gt;data);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void janz_handle_msglost(struct janz_module *mod, struct janz_msg *msg)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	char *queue;
</I>&gt;<i> 
</I>&gt;<i> 	if (msg-&gt;spec == MSG_MSGLOST)
</I>&gt;<i> 		queue = &quot;new&quot;;
</I>&gt;<i> 	else
</I>&gt;<i> 		queue = &quot;fast&quot;;
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: %s hostif: %d messages lost\n&quot;,
</I>&gt;<i> 			   __func__, queue, msg-&gt;data[0]);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void janz_handle_cevtind(struct janz_module *mod, struct janz_msg *msg)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	char *s;
</I>&gt;<i> 	int i;
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: message len: %d\n&quot;, __func__, le16_to_cpu(msg-&gt;len));
</I>&gt;<i> 	for (i = 0; i &lt; le16_to_cpu(msg-&gt;len); i++)
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;%s: data[%.2d] -&gt; %.2x\n&quot;, __func__, i, msg-&gt;data[i]);
</I>&gt;<i> 
</I>&gt;<i> 	switch (msg-&gt;data[0]) {
</I>&gt;<i> 	case 0x01:
</I>&gt;<i> 		s = &quot;error interrupt occurred&quot;;
</I>&gt;<i> 		break;
</I>&gt;<i> 	case 0x02:
</I>&gt;<i> 		s = &quot;overrun interrupt occurred&quot;;
</I>&gt;<i> 		break;
</I>&gt;<i> 	case 0x04:
</I>&gt;<i> 		s = &quot;interrupts lost&quot;;
</I>&gt;<i> 		break;
</I>&gt;<i> 	case 0x08:
</I>&gt;<i> 		s = &quot;send queue full&quot;;
</I>&gt;<i> 		break;
</I>&gt;<i> 	case 0x10:
</I>&gt;<i> 		s = &quot;CANbus bus-error&quot;;
</I>&gt;<i> 		break;
</I>&gt;<i> 	default:
</I>&gt;<i> 		s = &quot;unknown error&quot;;
</I>&gt;<i> 		break;
</I>&gt;<i> 	}
</I>
Does the Firmware provide more information on the cause of the error.


&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: %s\n&quot;, __func__, s);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void janz_handle_unknown(struct janz_module *mod, struct janz_msg *msg)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	u16 len;
</I>&gt;<i> 	int i;
</I>&gt;<i> 
</I>&gt;<i> 	len = le16_to_cpu(msg-&gt;len);
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: modno %d UNKNOWN spec 0x%.2x len %d\n&quot;,
</I>&gt;<i> 			   __func__, mod-&gt;num, msg-&gt;spec, len);
</I>&gt;<i> 	for (i = 0; i &lt; len; i++)
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;msg-&gt;data[%.2d] -&gt; 0x%.2x\n&quot;, i, msg-&gt;data[i]);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void janz_handle_message(struct janz_module *mod, struct janz_msg *msg)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: modno %d spec 0x%.2x len %d bytes\n&quot;, __func__,
</I>&gt;<i> 			   mod-&gt;num, msg-&gt;spec, le16_to_cpu(msg-&gt;len));
</I>&gt;<i> 
</I>&gt;<i> 	switch (msg-&gt;spec) {
</I>&gt;<i> 	case MSG_IDVERS:
</I>&gt;<i> 		janz_handle_idvers(mod, msg);
</I>&gt;<i> 		break;
</I>&gt;<i> 	case MSG_MSGLOST:
</I>&gt;<i> 	case MSG_FMSGLOST:
</I>&gt;<i> 		janz_handle_msglost(mod, msg);
</I>&gt;<i> 		break;
</I>&gt;<i> 	case MSG_CEVTIND:
</I>&gt;<i> 		janz_handle_cevtind(mod, msg);
</I>&gt;<i> 		break;
</I>&gt;<i> 	default:
</I>&gt;<i> 		janz_handle_unknown(mod, msg);
</I>&gt;<i> 		break;
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void janz_work(struct work_struct *work)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_module *mod = container_of(work, struct janz_module, work);
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	unsigned int handled = 0;
</I>&gt;<i> 	struct janz_msg msg;
</I>&gt;<i> 	int ret;
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: module number %d\n&quot;, __func__, mod-&gt;num);
</I>&gt;<i> 
</I>&gt;<i> 	/* process all communication messages */
</I>&gt;<i> 	while (true) {
</I>&gt;<i> 
</I>&gt;<i> 		ret = janz_recv_msg(mod, &amp;msg);
</I>&gt;<i> 		if (ret) {
</I>&gt;<i> 			dev_dbg(priv-&gt;dev, &quot;%s: no more messages\n&quot;, __func__);
</I>&gt;<i> 			break;
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i> 		janz_handle_message(mod, &amp;msg);
</I>&gt;<i> 		handled++;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: handled %d messages\n&quot;, __func__, handled);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * Handle a MODULbus interrupt
</I>&gt;<i>  *
</I>&gt;<i>  * Due to the way the firmware works, we must first go through all of the
</I>&gt;<i>  * buffers and unset their IVALID flag, then notify our NAPI poller or
</I>&gt;<i>  * work function to go ahead and process the message. The IVALID flag must
</I>&gt;<i>  * be unset before clearing the interrupt.
</I>&gt;<i>  *
</I>&gt;<i>  * Only after the message has been processed can the VALID flag be unset.
</I>&gt;<i>  */
</I>&gt;<i> static void janz_handle_interrupt(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	unsigned long flags;
</I>&gt;<i> 	void __iomem *addr;
</I>&gt;<i> 	u8 control;
</I>&gt;<i> 
</I>&gt;<i> 	spin_lock_irqsave(&amp;mod-&gt;lock, flags);
</I>&gt;<i> 
</I>&gt;<i> 	/*
</I>&gt;<i> 	 * If we're using the old-style host interface, we only need to
</I>&gt;<i> 	 * start the work function, since the fast host interface (and
</I>&gt;<i> 	 * therefore CAN frame reception) cannot be working yet
</I>&gt;<i> 	 */
</I>&gt;<i> 	if (mod-&gt;iftype == 0) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;%s: old style host interface\n&quot;, __func__);
</I>&gt;<i> 		schedule_work(&amp;mod-&gt;work);
</I>&gt;<i> 		goto out_unlock;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/*
</I>&gt;<i> 	 * Ok, at least the new-style host interface must be running, so we
</I>&gt;<i> 	 * need to go through it's buffers and unset all of their DESC_IVALID
</I>&gt;<i> 	 * bits before clearing the interrupt
</I>&gt;<i> 	 */
</I>&gt;<i> 	while (true) {
</I>&gt;<i> 
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;%s: modno %d new style host interface\n&quot;, __func__, mod-&gt;num);
</I>&gt;<i> 
</I>&gt;<i> 		/* check the new host interface tohost queue */
</I>&gt;<i> 		janz_set_page(mod, 5);
</I>&gt;<i> 		addr = mod-&gt;regs + (mod-&gt;rx_int * sizeof(struct janz_new_desc));
</I>&gt;<i> 		control = ioread8(addr);
</I>&gt;<i> 
</I>&gt;<i> 		/* check if we're finished with buffers */
</I>&gt;<i> 		if (!(control &amp; DESC_IVALID))
</I>&gt;<i> 			break;
</I>&gt;<i> 
</I>&gt;<i> 		/* write the control bits back with IVALID unset */
</I>&gt;<i> 		control &amp;= ~DESC_IVALID;
</I>&gt;<i> 		iowrite8(control, addr);
</I>&gt;<i> 
</I>&gt;<i> 		/*
</I>&gt;<i> 		 * update the interrupt handler's position and schedule
</I>&gt;<i> 		 * the work function to run at some point in the future
</I>&gt;<i> 		 */
</I>&gt;<i> 		mod-&gt;rx_int = (control &amp; DESC_WRAP) ? 0 : (mod-&gt;rx_int + 1);
</I>&gt;<i> 		schedule_work(&amp;mod-&gt;work);
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* Check the fast host interface for interrupts */
</I>&gt;<i> 	while (true) {
</I>&gt;<i> 
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;%s: modno %d fast interface\n&quot;, __func__, mod-&gt;num);
</I>&gt;<i> 
</I>&gt;<i> 		/* check the fast host interface */
</I>&gt;<i> 		janz_set_page(mod, mod-&gt;fastrx_start + (mod-&gt;fastrx_int / 16));
</I>&gt;<i> 		addr = mod-&gt;regs + ((mod-&gt;fastrx_int % 16) * sizeof(struct janz_fast_desc));
</I>&gt;<i> 		control = ioread8(addr);
</I>&gt;<i> 
</I>&gt;<i> 		/* check if we're finished with buffers */
</I>&gt;<i> 		if (!(control &amp; DESC_IVALID))
</I>&gt;<i> 			break;
</I>&gt;<i> 
</I>&gt;<i> 		/* write back the control bits with IVALID unset */
</I>&gt;<i> 		control &amp;= ~DESC_IVALID;
</I>&gt;<i> 		iowrite8(control, addr);
</I>&gt;<i> 
</I>&gt;<i> 		/*
</I>&gt;<i> 		 * update the interrupt handler's position and schedule
</I>&gt;<i> 		 * the NAPI poller to run at some point in the future
</I>&gt;<i> 		 */
</I>&gt;<i> 		mod-&gt;fastrx_int = (control &amp; DESC_WRAP) ? 0 : (mod-&gt;fastrx_int + 1);
</I>&gt;<i> 		napi_schedule(&amp;mod-&gt;napi);
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> out_unlock:
</I>&gt;<i> 	janz_clr_int(mod);
</I>&gt;<i> 	spin_unlock_irqrestore(&amp;mod-&gt;lock, flags);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static irqreturn_t janz_irq(int irq, void *dev_id)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = dev_id;
</I>&gt;<i> 	struct janz_module *mod;
</I>&gt;<i> 	u8 stat;
</I>&gt;<i> 	int i;
</I>&gt;<i> 
</I>&gt;<i> 	/*
</I>&gt;<i> 	 * The interrupt status register on this device reports interrupts
</I>&gt;<i> 	 * as zeroes instead of using ones like most other devices
</I>&gt;<i> 	 */
</I>&gt;<i> 	stat = ioread8(priv-&gt;onboard_regs + JANZ_OB_INT_STAT) &amp; 0x0f;
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;IRQ: enter stat 0x%.2x\n&quot;, stat);
</I>&gt;<i> 
</I>&gt;<i> 	if (stat == 0x0f) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;IRQ: none pending\n&quot;);
</I>&gt;<i> 		return IRQ_NONE;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* Figure out which module interrupted, and run its work function */
</I>&gt;<i> 	for (i = 0; i &lt; JANZ_MAX_MODULES; i++) {
</I>&gt;<i> 		mod = priv-&gt;modules[i];
</I>&gt;<i> 		if ((stat &amp; (1 &lt;&lt; i)) == 0x00) {
</I>&gt;<i> 			dev_dbg(priv-&gt;dev, &quot;IRQ: module %d\n&quot;, i);
</I>&gt;<i> 			janz_handle_interrupt(mod);
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	stat = ioread8(priv-&gt;onboard_regs + JANZ_OB_INT_STAT) &amp; 0x0f;
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;IRQ: exit stat 0x%.2x\n&quot;, stat);
</I>&gt;<i> 
</I>&gt;<i> 	return IRQ_HANDLED;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> /* TEST CODE                                                                  */
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * Initialize the data structure for a module
</I>&gt;<i>  */
</I>&gt;<i> static void janz_init_module(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	mod-&gt;iftype = 0;
</I>&gt;<i> 	mod-&gt;rx_int = 0;
</I>&gt;<i> 	mod-&gt;rx_num = 0;
</I>&gt;<i> 	mod-&gt;tx_num = 0;
</I>&gt;<i> 
</I>&gt;<i> 	mod-&gt;fastrx_start = 0;
</I>&gt;<i> 	mod-&gt;fastrx_int   = 0;
</I>&gt;<i> 	mod-&gt;fastrx_num   = 0;
</I>&gt;<i> 	mod-&gt;fasttx_start = 0;
</I>&gt;<i> 	mod-&gt;fasttx_num   = 0;
</I>
There is no need to set these values to zero.

&gt;<i> 	/* the first unallocated page in the DPM is 9 */
</I>&gt;<i> 	mod-&gt;free_page = 9;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * Reset an ICAN module to its power-on state
</I>&gt;<i>  *
</I>&gt;<i>  * CONTEXT: no network device registered
</I>&gt;<i>  * LOCKING: napi + work disabled
</I>&gt;<i>  */
</I>&gt;<i> static int janz_reset_module(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	u8 val = 1 &lt;&lt; mod-&gt;num;
</I>&gt;<i> 	unsigned long start;
</I>&gt;<i> 	u8 runold, runnew;
</I>&gt;<i> 
</I>&gt;<i> 	/* disable interrupts so no more work is scheduled */
</I>&gt;<i> 	janz_disable_interrupts(mod);
</I>&gt;<i> 
</I>&gt;<i> 	/* flush any pending work */
</I>&gt;<i> 	flush_scheduled_work();
</I>&gt;<i> 
</I>&gt;<i> 	/* re-initialize the software state */
</I>&gt;<i> 	janz_init_module(mod);
</I>&gt;<i> 
</I>&gt;<i> 	janz_set_page(mod, 0);
</I>&gt;<i> 	runold = janz_dpm_read8(mod, TARGET_RUNNING);
</I>&gt;<i> 
</I>&gt;<i> 	/* reset the module */
</I>&gt;<i> 	iowrite8(val, priv-&gt;onboard_regs + JANZ_OB_RESET_ASSERT);
</I>&gt;<i> 	iowrite8(val, priv-&gt;onboard_regs + JANZ_OB_RESET_DEASSERT);
</I>&gt;<i> 
</I>&gt;<i> 	/* wait until the module has finished resetting and is running */
</I>&gt;<i> 	start = jiffies;
</I>&gt;<i> 	do {
</I>&gt;<i> 		janz_set_page(mod, 0);
</I>&gt;<i> 		runnew = janz_dpm_read8(mod, TARGET_RUNNING);
</I>&gt;<i> 		if (runnew == (runold ^ 0xff)) {
</I>&gt;<i> 			dev_dbg(priv-&gt;dev, &quot;%s: success\n&quot;, __func__);
</I>&gt;<i> 			return 0;
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;%s: msleep(10)\n&quot;, __func__);
</I>&gt;<i> 		msleep(10);
</I>&gt;<i> 	} while (time_before(jiffies, start + HZ / 4));
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: timed out\n&quot;, __func__);
</I>&gt;<i> 	return -ETIMEDOUT;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void janz_shutdown_module(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	int ret;
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: disconnect and reset module\n&quot;, __func__);
</I>&gt;<i> 	janz_msg_disconnect(mod);
</I>&gt;<i> 	ret = janz_reset_module(mod);
</I>&gt;<i> 	if (ret)
</I>&gt;<i> 		dev_err(priv-&gt;dev, &quot;unable to reset module\n&quot;);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*
</I>&gt;<i>  * Startup an ICAN module, bringing it into fast mode
</I>&gt;<i>  */
</I>&gt;<i> static int janz_startup_module(struct janz_module *mod)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	int ret;
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: reset module\n&quot;, __func__);
</I>&gt;<i> 	ret = janz_reset_module(mod);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_err(priv-&gt;dev, &quot;unable to reset module\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* re-enable interrupts so we can send messages */
</I>&gt;<i> 	janz_enable_interrupts(mod);
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: connect and switch to new if\n&quot;, __func__);
</I>&gt;<i> 	ret = janz_msg_connect(mod);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_err(priv-&gt;dev, &quot;unable to connect to module\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	janz_init_new_host_interface(mod);
</I>&gt;<i> 	ret = janz_msg_newhostif(mod);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_err(priv-&gt;dev, &quot;unable to switch to new-style interface\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: enable termination\n&quot;, __func__);
</I>&gt;<i> 	ret = janz_set_termination(mod, true);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_err(priv-&gt;dev, &quot;unable to enable termination\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: start fast host if\n&quot;, __func__);
</I>&gt;<i> 	janz_init_fast_host_interface(mod);
</I>&gt;<i> 	ret = janz_msg_fasthostif(mod);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_err(priv-&gt;dev, &quot;unable to switch to fast host interface\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: set filter to accept everything\n&quot;, __func__);
</I>&gt;<i> 	ret = janz_set_id_filter(mod, true);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_err(priv-&gt;dev, &quot;unable to set acceptance filter\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> /* Janz to CAN Frame Conversion                                               */
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> 
</I>&gt;<i> static void janz_to_can(struct janz_module *mod, struct janz_fast_desc *desc,
</I>&gt;<i> 			struct can_frame *cf)
</I>
Better name?

&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 
</I>&gt;<i> 	if ((desc-&gt;command &amp; 0x0f) == 0) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;%s: old frame format\n&quot;, __func__);
</I>&gt;<i> 		if (desc-&gt;data[1] &amp; 0x10)
</I>&gt;<i> 			cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> 
</I>&gt;<i> 		cf-&gt;can_id |= desc-&gt;data[0] &lt;&lt; 3;
</I>&gt;<i> 		cf-&gt;can_id |= (desc-&gt;data[1] &amp; 0xe0) &gt;&gt; 5;
</I>&gt;<i> 		cf-&gt;can_dlc = desc-&gt;data[1] &amp; 0x0f;
</I>&gt;<i> 		memcpy(cf-&gt;data, &amp;desc-&gt;data[2], sizeof(cf-&gt;data));
</I>&gt;<i> 	} else {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;%s: new frame format\n&quot;, __func__);
</I>&gt;<i> 		cf-&gt;can_dlc = desc-&gt;data[0] &amp; 0x0f;
</I>&gt;<i> 		if (desc-&gt;data[0] &amp; 0x40)
</I>&gt;<i> 			cf-&gt;can_id |= CAN_RTR_FLAG;
</I>&gt;<i> 
</I>&gt;<i> 		if (desc-&gt;data[0] &amp; 0x80) {
</I>&gt;<i> 			cf-&gt;can_id |= CAN_EFF_FLAG;
</I>&gt;<i> 			cf-&gt;can_id |= desc-&gt;data[2] &lt;&lt; 21; /* 28-21 */
</I>&gt;<i> 			cf-&gt;can_id |= desc-&gt;data[3] &lt;&lt; 13; /* 20-13 */
</I>&gt;<i> 			cf-&gt;can_id |= desc-&gt;data[4] &lt;&lt; 5;  /* 12-5  */
</I>&gt;<i> 			cf-&gt;can_id |= (desc-&gt;data[5] &amp; 0xf8) &gt;&gt; 3;
</I>&gt;<i> 		} else {
</I>&gt;<i> 			cf-&gt;can_id |= desc-&gt;data[2] &lt;&lt; 3;  /* 10-3  */
</I>&gt;<i> 			cf-&gt;can_id |= desc-&gt;data[3] &gt;&gt; 5;  /* 2-0   */
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i> 		memcpy(cf-&gt;data, &amp;desc-&gt;data[6], sizeof(cf-&gt;data));
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void can_to_janz(struct janz_module *mod, struct can_frame *cf,
</I>&gt;<i> 			struct janz_fast_desc *desc)
</I>
Ditto.

&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 
</I>&gt;<i> 	/* clear out any stale data in the descriptor */
</I>&gt;<i> 	memset(desc-&gt;data, 0, sizeof(desc-&gt;data));
</I>&gt;<i> 
</I>&gt;<i> 	/* we always use the extended format, with the ECHO flag set */
</I>&gt;<i> 	desc-&gt;command = 1;
</I>&gt;<i> 	desc-&gt;data[0] |= cf-&gt;can_dlc;
</I>&gt;<i> 	desc-&gt;data[1] |= 0x10; /* echo */
</I>&gt;<i> 
</I>&gt;<i> 	if (cf-&gt;can_id &amp; CAN_RTR_FLAG)
</I>&gt;<i> 		desc-&gt;data[0] |= 0x40;
</I>&gt;<i> 
</I>&gt;<i> 	/* pack the id into the correct places */
</I>&gt;<i> 	if (cf-&gt;can_id &amp; CAN_EFF_FLAG) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;%s: extended frame\n&quot;, __func__);
</I>&gt;<i> 		desc-&gt;data[0] |= 0x80; /* extended id frame */
</I>&gt;<i> 		desc-&gt;data[2] = (cf-&gt;can_id &amp; 0x1fe00000) &gt;&gt; 21; /* 28-21 */
</I>&gt;<i> 		desc-&gt;data[3] = (cf-&gt;can_id &amp; 0x001fe000) &gt;&gt; 13; /* 20-13 */
</I>&gt;<i> 		desc-&gt;data[4] = (cf-&gt;can_id &amp; 0x00001fe0) &gt;&gt; 5;  /* 12-5  */
</I>&gt;<i> 		desc-&gt;data[5] = (cf-&gt;can_id &amp; 0x0000001f) &lt;&lt; 3;  /* 4-0   */
</I>&gt;<i> 	} else {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;%s: standard frame\n&quot;, __func__);
</I>&gt;<i> 		desc-&gt;data[2] = (cf-&gt;can_id &amp; 0x7F8) &gt;&gt; 3; /* bits 10-3 */
</I>&gt;<i> 		desc-&gt;data[3] = (cf-&gt;can_id &amp; 0x007) &lt;&lt; 5; /* bits 2-0  */
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* copy the data bits into the descriptor */
</I>&gt;<i> 	memcpy(&amp;desc-&gt;data[6], cf-&gt;data, sizeof(cf-&gt;data));
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> /* CAN Network Device                                                         */
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> 
</I>&gt;<i> static int janz_open(struct net_device *ndev)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_module *mod = netdev_priv(ndev);
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	int ret;
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: called\n&quot;, __func__);
</I>&gt;<i> 
</I>&gt;<i> 	/* bring the bus online */
</I>&gt;<i> 	ret = janz_set_bus_state(mod, true);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_err(priv-&gt;dev, &quot;unable to set bus-on\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* start up the network device */
</I>&gt;<i> 	napi_enable(&amp;mod-&gt;napi);
</I>&gt;<i> 	netif_start_queue(ndev);
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static int janz_stop(struct net_device *ndev)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_module *mod = netdev_priv(ndev);
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	int ret;
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: called\n&quot;, __func__);
</I>&gt;<i> 
</I>&gt;<i> 	/* stop the network device xmit routine */
</I>&gt;<i> 	netif_stop_queue(ndev);
</I>&gt;<i> 
</I>&gt;<i> 	/* bring the bus offline */
</I>&gt;<i> 	ret = janz_set_bus_state(mod, false);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_err(priv-&gt;dev, &quot;unable to set bus-off\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* stop receiving packets */
</I>&gt;<i> 	napi_disable(&amp;mod-&gt;napi);
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static int janz_xmit(struct sk_buff *skb, struct net_device *ndev)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_module *mod = netdev_priv(ndev);
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> 	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
</I>&gt;<i> 	struct janz_fast_desc desc;
</I>&gt;<i> 	void __iomem *desc_addr;
</I>&gt;<i> 	unsigned long flags;
</I>&gt;<i> 
</I>&gt;<i> 	spin_lock_irqsave(&amp;mod-&gt;lock, flags);
</I>&gt;<i> 
</I>&gt;<i> 	/* copy the control bits of the descriptor */
</I>&gt;<i> 	janz_set_page(mod, mod-&gt;fasttx_start + (mod-&gt;fasttx_num / 16));
</I>&gt;<i> 	desc_addr = mod-&gt;regs + ((mod-&gt;fasttx_num % 16) * sizeof(desc));
</I>&gt;<i> 	memset(&amp;desc, 0, sizeof(desc));
</I>&gt;<i> 	memcpy_fromio(&amp;desc, desc_addr, 1);
</I>&gt;<i> 
</I>&gt;<i> 	/* check that we can actually transmit */
</I>&gt;<i> 	if (!(desc.control &amp; DESC_VALID)) {
</I>&gt;<i> 		dev_err(priv-&gt;dev, &quot;%s: no buffers\n&quot;, __func__);
</I>&gt;<i> 		stats-&gt;tx_dropped++;
</I>&gt;<i> 		kfree_skb(skb);
</I>&gt;<i> 		goto out_unlock;
</I>
Not sure if you want to drop the skb. You could also return
NETDEV_TX_BUSY without freeing the packet.

&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* convert the CAN frame into Janz format */
</I>&gt;<i> 	can_to_janz(mod, cf, &amp;desc);
</I>&gt;<i> 
</I>&gt;<i> 	/*
</I>&gt;<i> 	 * the programming manual says that you must set the IVALID bit, then
</I>&gt;<i> 	 * interrupt, then set the valid bit. Quite weird, but it seems to be
</I>&gt;<i> 	 * required for this to work
</I>&gt;<i> 	 */
</I>&gt;<i> 	desc.control |= DESC_IVALID;
</I>&gt;<i> 	memcpy_toio(desc_addr, &amp;desc, sizeof(desc));
</I>&gt;<i> 	janz_set_int(mod);
</I>&gt;<i> 	desc.control ^= DESC_VALID;
</I>&gt;<i> 	memcpy_toio(desc_addr, &amp;desc, sizeof(desc));
</I>&gt;<i> 
</I>&gt;<i> 	/* update the next buffer pointer */
</I>&gt;<i> 	mod-&gt;fasttx_num = (desc.control &amp; DESC_WRAP) ? 0 : (mod-&gt;fasttx_num + 1);
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: update fast TX num -&gt; %d\n&quot;, __func__, mod-&gt;fasttx_num);
</I>&gt;<i> 
</I>&gt;<i> 	/* update statistics */
</I>&gt;<i> 	stats-&gt;tx_packets++;
</I>&gt;<i> 	stats-&gt;tx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> 	kfree_skb(skb);
</I>&gt;<i> 
</I>&gt;<i> out_unlock:
</I>&gt;<i> 	spin_unlock_irqrestore(&amp;mod-&gt;lock, flags);
</I>&gt;<i> 	return NETDEV_TX_OK;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static int janz_napi(struct napi_struct *napi, int quota)
</I>&gt;<i> {
</I>&gt;<i> 	struct net_device *ndev = napi-&gt;dev;
</I>&gt;<i> 	struct net_device_stats *stats = &amp;ndev-&gt;stats;
</I>&gt;<i> 	struct janz_module *mod = netdev_priv(ndev);
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	struct janz_fast_desc desc;
</I>&gt;<i> 	void __iomem *desc_addr;
</I>&gt;<i> 	struct can_frame *cf;
</I>&gt;<i> 	struct sk_buff *skb;
</I>&gt;<i> 	unsigned long flags;
</I>&gt;<i> 	int handled = 0;
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: modno %d called quota %d\n&quot;, __func__, mod-&gt;num, quota);
</I>&gt;<i> 	spin_lock_irqsave(&amp;mod-&gt;lock, flags);
</I>&gt;<i> 
</I>&gt;<i> 	while (handled &lt; quota) {
</I>&gt;<i> 
</I>&gt;<i> 		/* copy the whole descriptor */
</I>&gt;<i> 		janz_set_page(mod, mod-&gt;fastrx_start + (mod-&gt;fastrx_num / 16));
</I>&gt;<i> 		desc_addr = mod-&gt;regs + ((mod-&gt;fastrx_num % 16) * sizeof(desc));
</I>&gt;<i> 		memcpy_fromio(&amp;desc, desc_addr, sizeof(desc));
</I>&gt;<i> 
</I>&gt;<i> 		/* check that we actually have a CAN frame */
</I>&gt;<i> 		if (!(desc.control &amp; DESC_VALID)) {
</I>&gt;<i> 			dev_dbg(priv-&gt;dev, &quot;%s: no more frames\n&quot;, __func__);
</I>&gt;<i> 			break;
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i> 		/* allocate an skb */
</I>&gt;<i> 		skb = alloc_can_skb(ndev, &amp;cf);
</I>&gt;<i> 		if (unlikely(skb == NULL)) {
</I>&gt;<i> 			dev_dbg(priv-&gt;dev, &quot;%s: no more skbs\n&quot;, __func__);
</I>&gt;<i> 			stats-&gt;rx_dropped++;
</I>&gt;<i> 			goto err_noalloc;
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i> 		/* convert the Janz frame into CAN format */
</I>&gt;<i> 		janz_to_can(mod, &amp;desc, cf);
</I>&gt;<i> 
</I>&gt;<i> 		/* receive the skb, update statistics */
</I>&gt;<i> 		netif_receive_skb(skb);
</I>&gt;<i> 		stats-&gt;rx_packets++;
</I>&gt;<i> 		stats-&gt;rx_bytes += cf-&gt;can_dlc;
</I>&gt;<i> 		handled++;
</I>&gt;<i> 
</I>&gt;<i> err_noalloc:
</I>&gt;<i> 		/* toggle the valid bit and return the descriptor to the ring */
</I>&gt;<i> 		desc.control ^= DESC_VALID;
</I>&gt;<i> 		memcpy_toio(desc_addr, &amp;desc, 1);
</I>&gt;<i> 
</I>&gt;<i> 		/* update the next buffer pointer */
</I>&gt;<i> 		mod-&gt;fastrx_num = (desc.control &amp; DESC_WRAP) ? 0 : (mod-&gt;fastrx_num + 1);
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;%s: update fast RX num -&gt; %d\n&quot;, __func__, mod-&gt;fastrx_num);
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	if (handled &lt; quota)
</I>&gt;<i> 		napi_complete(napi);
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: modno %d handled %d CAN frames\n&quot;, __func__, mod-&gt;num, handled);
</I>&gt;<i> 	spin_unlock_irqrestore(&amp;mod-&gt;lock, flags);
</I>&gt;<i> 	return handled;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static const struct net_device_ops janz_netdev_ops = {
</I>&gt;<i> 	.ndo_open	= janz_open,
</I>&gt;<i> 	.ndo_stop	= janz_stop,
</I>&gt;<i> 	.ndo_start_xmit	= janz_xmit,
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> /* Low-level CAN Device                                                       */
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> 
</I>&gt;<i> struct janz_baud_entry {
</I>&gt;<i> 	u32 rate;
</I>&gt;<i> 	u8 btr0;
</I>&gt;<i> 	u8 btr1;
</I>&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> static struct janz_baud_entry janz_baud_table[] = {
</I>&gt;<i> #if 0
</I>&gt;<i> 	{1000000, 0x00, 0x23}, /* early sampling */
</I>&gt;<i> #endif
</I>&gt;<i> 	{1000000, 0x00, 0x14}, /* late sampling */
</I>&gt;<i> 	{500000,  0x00, 0x1c},
</I>&gt;<i> 	{250000,  0x01, 0x1c},
</I>&gt;<i> 	{125000,  0x03, 0x1c},
</I>&gt;<i> 	{100000,  0xc7, 0x34},
</I>&gt;<i> 	{50000,   0xcf, 0x34},
</I>&gt;<i> 	{20000,   0xcf, 0x7f},
</I>&gt;<i> };
</I>
You could use the calculated bittiming paramters for the SJA1000. Check
sja1000.c on how to do it.

&gt;<i> static int janz_set_bittiming(struct net_device *ndev)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_module *mod = netdev_priv(ndev);
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 	struct janz_baud_entry *entry = NULL;
</I>&gt;<i> 	struct janz_msg msg;
</I>&gt;<i> 	int i, ret;
</I>&gt;<i> 
</I>&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: called bitrate %d\n&quot;,
</I>&gt;<i> 			   __func__, mod-&gt;can.bittiming.bitrate);
</I>&gt;<i> 
</I>&gt;<i> 	for (i = 0; i &lt; ARRAY_SIZE(janz_baud_table); i++) {
</I>&gt;<i> 		if (mod-&gt;can.bittiming.bitrate == janz_baud_table[i].rate) {
</I>&gt;<i> 			entry = &amp;janz_baud_table[i];
</I>&gt;<i> 			break;
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	if (!entry) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;%s: no matching bittiming\n&quot;, __func__);
</I>&gt;<i> 		return -EINVAL;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	memset(&amp;msg, 0, sizeof(msg));
</I>&gt;<i> 	msg.spec    = MSG_CBTRREQ;
</I>&gt;<i> 	msg.len     = cpu_to_le16(4);
</I>&gt;<i> 	msg.data[0] = 0x00;
</I>&gt;<i> 	msg.data[1] = 0x00;
</I>&gt;<i> 	msg.data[2] = entry-&gt;btr0;
</I>&gt;<i> 	msg.data[3] = entry-&gt;btr1;
</I>&gt;<i> 
</I>&gt;<i> 	ret = janz_send_msg(mod, &amp;msg);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_dbg(priv-&gt;dev, &quot;unable to send CBTRREQ message\n&quot;);
</I>&gt;<i> 		return ret;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static int janz_set_mode(struct net_device *ndev, enum can_mode mode)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_module *mod = netdev_priv(ndev);
</I>&gt;<i> 	struct janz_device *priv = mod-&gt;parent;
</I>&gt;<i> 
</I>
This is called to restart to device after bus-off.


&gt;<i> 	dev_dbg(priv-&gt;dev, &quot;%s: called mode %d\n&quot;, __func__, mode);
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> /* PCI Subsystem                                                              */
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> 
</I>&gt;<i> static void janz_free_one(struct janz_device *priv, unsigned int modno)
</I>&gt;<i> {
</I>&gt;<i> 	struct net_device *ndev;
</I>&gt;<i> 	struct janz_module *mod;
</I>&gt;<i> 
</I>&gt;<i> 	mod = priv-&gt;modules[modno];
</I>&gt;<i> 	priv-&gt;modules[modno] = NULL;
</I>&gt;<i> 	ndev = mod-&gt;ndev;
</I>&gt;<i> 
</I>&gt;<i> 	unregister_netdev(ndev);
</I>&gt;<i> 	free_netdev(ndev);
</I>&gt;<i> 
</I>&gt;<i> 	janz_shutdown_module(mod);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> /* setup a single CAN module on the MODULbus carrier board */
</I>&gt;<i> static int janz_alloc_one(struct janz_device *priv, unsigned int modno)
</I>&gt;<i> {
</I>&gt;<i> 	struct net_device *ndev;
</I>&gt;<i> 	struct janz_module *mod;
</I>&gt;<i> 	int ret;
</I>&gt;<i> 
</I>&gt;<i> 	ndev = alloc_candev(sizeof(*mod), 16);
</I>&gt;<i> 	if (!ndev) {
</I>&gt;<i> 		dev_err(priv-&gt;dev, &quot;%s: unable to allocate CANdev\n&quot;, __func__);
</I>&gt;<i> 		ret = -ENOMEM;
</I>&gt;<i> 		goto out_return;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	mod = netdev_priv(ndev);
</I>&gt;<i> 	priv-&gt;modules[modno] = mod;
</I>&gt;<i> 
</I>&gt;<i> 	mod-&gt;ndev = ndev;
</I>&gt;<i> 	mod-&gt;parent = priv;
</I>&gt;<i> 	mod-&gt;num = modno;
</I>&gt;<i> 	mod-&gt;regs = priv-&gt;modulbus_regs + (0x200 * modno);
</I>&gt;<i> 	INIT_WORK(&amp;mod-&gt;work, janz_work);
</I>&gt;<i> 	spin_lock_init(&amp;mod-&gt;lock);
</I>&gt;<i> 
</I>&gt;<i> 	/* initialize the software state */
</I>&gt;<i> 	janz_init_module(mod);
</I>&gt;<i> 
</I>&gt;<i> 	ndev-&gt;netdev_ops = &amp;janz_netdev_ops;
</I>&gt;<i> 	ndev-&gt;irq = priv-&gt;pdev-&gt;irq;
</I>&gt;<i> 	ndev-&gt;flags |= IFF_ECHO;
</I>&gt;<i> 
</I>&gt;<i> 	mod-&gt;can.do_set_bittiming = &amp;janz_set_bittiming;
</I>&gt;<i> 	mod-&gt;can.do_set_mode = &amp;janz_set_mode;
</I>
Remove the two &quot;&amp;&quot; above.

&gt;<i> 	netif_napi_add(ndev, &amp;mod-&gt;napi, janz_napi, 16);
</I>&gt;<i> 	SET_NETDEV_DEV(ndev, &amp;priv-&gt;pdev-&gt;dev);
</I>&gt;<i> 
</I>&gt;<i> 	/* reset and initialize the CAN controller into fast mode */
</I>&gt;<i> 	ret = janz_startup_module(mod);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_err(priv-&gt;dev, &quot;%s: unable to start CANdev\n&quot;, __func__);
</I>&gt;<i> 		goto out_free_ndev;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* register with the Linux CAN layer */
</I>&gt;<i> 	ret = register_candev(ndev);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_err(priv-&gt;dev, &quot;%s: unable to register CANdev\n&quot;, __func__);
</I>&gt;<i> 		goto out_free_ndev;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	dev_info(priv-&gt;dev, &quot;module %d: registered CAN device\n&quot;, modno);
</I>&gt;<i> 	return 0;
</I>&gt;<i> 
</I>&gt;<i> out_free_ndev:
</I>&gt;<i> 	priv-&gt;modules[modno] = NULL;
</I>&gt;<i> 	free_netdev(ndev);
</I>&gt;<i> out_return:
</I>&gt;<i> 	return ret;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static int janz_probe_modules(struct janz_device *priv)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_module *mod;
</I>&gt;<i> 	int i;
</I>&gt;<i> 
</I>&gt;<i> 	for (i = 0; i &lt; ARRAY_SIZE(janz_modules_present); i++) {
</I>&gt;<i> 		mod = priv-&gt;modules[i];
</I>&gt;<i> 		switch (janz_modules_present[i]) {
</I>&gt;<i> 		case JANZ_MODULE_NONE:
</I>&gt;<i> 			dev_dbg(priv-&gt;dev, &quot;modno %d: NONE\n&quot;, i);
</I>&gt;<i> 			break;
</I>&gt;<i> 		case JANZ_MODULE_ICAN3:
</I>&gt;<i> 			dev_dbg(priv-&gt;dev, &quot;modno %d: ICAN3\n&quot;, i);
</I>&gt;<i> 			janz_alloc_one(priv, i);
</I>&gt;<i> 			break;
</I>&gt;<i> 		case JANZ_MODULE_TTL:
</I>&gt;<i> 			dev_dbg(priv-&gt;dev, &quot;modno %d: TTL\n&quot;, i);
</I>&gt;<i> 			break;
</I>&gt;<i> 		default:
</I>&gt;<i> 			dev_err(priv-&gt;dev, &quot;modno %d: UNKNOWN\n&quot;, i);
</I>&gt;<i> 			break;
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void janz_remove_modules(struct janz_device *priv)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_module *mod;
</I>&gt;<i> 	int i;
</I>&gt;<i> 
</I>&gt;<i> 	for (i = 0; i &lt; ARRAY_SIZE(janz_modules_present); i++) {
</I>&gt;<i> 		mod = priv-&gt;modules[i];
</I>&gt;<i> 		if (mod == NULL)
</I>&gt;<i> 			continue;
</I>&gt;<i> 
</I>&gt;<i> 		switch (janz_modules_present[i]) {
</I>&gt;<i> 		case JANZ_MODULE_NONE:
</I>&gt;<i> 			dev_dbg(priv-&gt;dev, &quot;modno %d: NONE\n&quot;, i);
</I>&gt;<i> 			break;
</I>&gt;<i> 		case JANZ_MODULE_ICAN3:
</I>&gt;<i> 			dev_dbg(priv-&gt;dev, &quot;modno %d: ICAN3\n&quot;, i);
</I>&gt;<i> 			janz_free_one(priv, i);
</I>&gt;<i> 			break;
</I>&gt;<i> 		case JANZ_MODULE_TTL:
</I>&gt;<i> 			dev_dbg(priv-&gt;dev, &quot;modno %d: TTL\n&quot;, i);
</I>&gt;<i> 			break;
</I>&gt;<i> 		default:
</I>&gt;<i> 			dev_err(priv-&gt;dev, &quot;modno %d: UNKNOWN\n&quot;, i);
</I>&gt;<i> 			break;
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static int janz_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv;
</I>&gt;<i> 	int ret;
</I>&gt;<i> 
</I>&gt;<i> 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
</I>&gt;<i> 	if (!priv) {
</I>&gt;<i> 		dev_err(&amp;dev-&gt;dev, &quot;unable to allocate private data\n&quot;);
</I>&gt;<i> 		ret = -ENOMEM;
</I>&gt;<i> 		goto out_return;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	pci_set_drvdata(dev, priv);
</I>&gt;<i> 	priv-&gt;dev = &amp;dev-&gt;dev;
</I>&gt;<i> 	priv-&gt;pdev = dev;
</I>&gt;<i> 
</I>&gt;<i> 	/* Hardware Initialization */
</I>&gt;<i> 	ret = pci_enable_device(dev);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_err(&amp;dev-&gt;dev, &quot;unable to enable device\n&quot;);
</I>&gt;<i> 		goto out_free_priv;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	pci_set_master(dev);
</I>&gt;<i> 	ret = pci_request_regions(dev, drv_name);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_err(&amp;dev-&gt;dev, &quot;unable to request regions\n&quot;);
</I>&gt;<i> 		goto out_pci_disable_device;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* Local Configuration Registers */
</I>&gt;<i> 	priv-&gt;control_regs = pci_ioremap_bar(dev, 0);
</I>&gt;<i> 	if (!priv-&gt;control_regs) {
</I>&gt;<i> 		dev_err(&amp;dev-&gt;dev, &quot;unable to remap control regs\n&quot;);
</I>&gt;<i> 		ret = -ENOMEM;
</I>&gt;<i> 		goto out_pci_release_regions;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* MODULbus memory space, big endian access */
</I>&gt;<i> 	priv-&gt;modulbus_regs = pci_ioremap_bar(dev, 3);
</I>&gt;<i> 	if (!priv-&gt;modulbus_regs) {
</I>&gt;<i> 		dev_err(&amp;dev-&gt;dev, &quot;unable to remap MODULbus regs\n&quot;);
</I>&gt;<i> 		ret = -ENOMEM;
</I>&gt;<i> 		goto out_unmap_control_regs;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* Onboard configuration registers */
</I>&gt;<i> 	priv-&gt;onboard_regs = pci_ioremap_bar(dev, 4);
</I>&gt;<i> 	if (!priv-&gt;onboard_regs) {
</I>&gt;<i> 		dev_err(&amp;dev-&gt;dev, &quot;unable to remap onboard regs\n&quot;);
</I>&gt;<i> 		ret = -ENOMEM;
</I>&gt;<i> 		goto out_unmap_modulbus_regs;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* Read the hex switch on the carrier board */
</I>&gt;<i> 	priv-&gt;hex = ioread8(priv-&gt;onboard_regs + JANZ_OB_MBUS_NUM);
</I>&gt;<i> 	dev_info(&amp;dev-&gt;dev, &quot;detected board with HEX switch %X\n&quot;, priv-&gt;hex);
</I>&gt;<i> 
</I>&gt;<i> 	/* Disable all interrupt lines, hookup the handler */
</I>&gt;<i> 	iowrite8(0xf, priv-&gt;onboard_regs + JANZ_OB_INT_DISABLE);
</I>&gt;<i> 	ret = request_irq(dev-&gt;irq, janz_irq, IRQF_SHARED, drv_name, priv);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_err(&amp;dev-&gt;dev, &quot;unable to register IRQ handler\n&quot;);
</I>&gt;<i> 		goto out_unmap_onboard_regs;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/* Probe all of the modules on the CMOD-IO carrier board */
</I>&gt;<i> 	ret = janz_probe_modules(priv);
</I>&gt;<i> 	if (ret) {
</I>&gt;<i> 		dev_err(&amp;dev-&gt;dev, &quot;unable to probe MODULbus modules\n&quot;);
</I>&gt;<i> 		goto out_free_irq;
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	return 0;
</I>&gt;<i> 
</I>&gt;<i> out_free_irq:
</I>&gt;<i> 	free_irq(dev-&gt;irq, priv);
</I>&gt;<i> out_unmap_onboard_regs:
</I>&gt;<i> 	iounmap(priv-&gt;onboard_regs);
</I>&gt;<i> out_unmap_modulbus_regs:
</I>&gt;<i> 	iounmap(priv-&gt;modulbus_regs);
</I>&gt;<i> out_unmap_control_regs:
</I>&gt;<i> 	iounmap(priv-&gt;control_regs);
</I>&gt;<i> out_pci_release_regions:
</I>&gt;<i> 	pci_release_regions(dev);
</I>&gt;<i> out_pci_disable_device:
</I>&gt;<i> 	pci_disable_device(dev);
</I>&gt;<i> out_free_priv:
</I>&gt;<i> 	kfree(priv);
</I>&gt;<i> out_return:
</I>&gt;<i> 	return ret;
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void janz_pci_remove(struct pci_dev *dev)
</I>&gt;<i> {
</I>&gt;<i> 	struct janz_device *priv = pci_get_drvdata(dev);
</I>&gt;<i> 
</I>&gt;<i> 	janz_remove_modules(priv);
</I>&gt;<i> 	free_irq(dev-&gt;irq, priv);
</I>&gt;<i> 	iounmap(priv-&gt;onboard_regs);
</I>&gt;<i> 	iounmap(priv-&gt;modulbus_regs);
</I>&gt;<i> 	iounmap(priv-&gt;control_regs);
</I>&gt;<i> 	pci_release_regions(dev);
</I>&gt;<i> 	pci_disable_device(dev);
</I>&gt;<i> 	kfree(priv);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> #define PCI_VENDOR_ID_JANZ		0x13c3
</I>&gt;<i> 
</I>&gt;<i> /* The list of devices that this module will support */
</I>&gt;<i> static struct pci_device_id janz_pci_ids[] = {
</I>
Please use DEFINE_PCI_DEVICE_TABLE() here.

&gt;<i> 	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030, PCI_VENDOR_ID_JANZ, 0x0101 },
</I>&gt;<i> 	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9050, PCI_VENDOR_ID_JANZ, 0x0100 },
</I>&gt;<i> 	{ 0, }
</I>&gt;<i> };
</I>&gt;<i> MODULE_DEVICE_TABLE(pci, janz_pci_ids);
</I>&gt;<i> 
</I>&gt;<i> static struct pci_driver janz_pci_driver = {
</I>&gt;<i> 	.name     = (char *)drv_name,
</I>&gt;<i> 	.id_table = janz_pci_ids,
</I>&gt;<i> 	.probe    = janz_pci_probe,
</I>&gt;<i> 	.remove   = janz_pci_remove,
</I>

You should also use __devinit where appropriate. See:
<A HREF="http://lxr.linux.no/#linux+v2.6.32/Documentation/PCI/pci.txt#L177">http://lxr.linux.no/#linux+v2.6.32/Documentation/PCI/pci.txt#L177</A>

&gt;<i> };
</I>&gt;<i> 
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> /* Module Init / Exit                                                         */
</I>&gt;<i> /*----------------------------------------------------------------------------*/
</I>&gt;<i> 
</I>&gt;<i> static int __init janz_init(void)
</I>&gt;<i> {
</I>&gt;<i> 	return pci_register_driver(&amp;janz_pci_driver);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> static void __exit janz_exit(void)
</I>&gt;<i> {
</I>&gt;<i> 	pci_unregister_driver(&amp;janz_pci_driver);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> MODULE_AUTHOR(&quot;Ira W. Snyder &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-core">iws at ovro.caltech.edu</A>&gt;&quot;);
</I>&gt;<i> MODULE_DESCRIPTION(&quot;Janz PCI CAN Driver&quot;);
</I>&gt;<i> MODULE_LICENSE(&quot;GPL&quot;);
</I>&gt;<i> 
</I>&gt;<i> module_init(janz_init);
</I>&gt;<i> module_exit(janz_exit);
</I>
Wolfgang.

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004010.html">[RFC v1] can: add support for Janz CAN board
</A></li>
	<LI>Next message: <A HREF="004012.html">[RFC v1] can: add support for Janz CAN board
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4009">[ date ]</a>
              <a href="thread.html#4009">[ thread ]</a>
              <a href="subject.html#4009">[ subject ]</a>
              <a href="author.html#4009">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-core">More information about the Socketcan-core
mailing list</a><br>
</body></html>
